extern void __VERIFIER_error() __attribute__ ((__noreturn__));
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};
struct module;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
typedef int __kernel_pid_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u32 __wsum;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef unsigned long ulong;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef unsigned int oom_flags_t;
typedef u64 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_6 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct __anonstruct_ldv_1022_9 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct_ldv_1037_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
union __anonunion_ldv_1038_8 {
   struct __anonstruct_ldv_1022_9 ldv_1022 ;
   struct __anonstruct_ldv_1037_10 ldv_1037 ;
};
struct desc_struct {
   union __anonunion_ldv_1038_8 ldv_1038 ;
};
typedef unsigned long pteval_t;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
typedef struct __anonstruct_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct arch_spinlock;
typedef u16 __ticket_t;
typedef u32 __ticketpair_t;
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
typedef struct arch_spinlock arch_spinlock_t;
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
typedef struct qrwlock arch_rwlock_t;
typedef void (*ctor_fn_t)(void);
struct device;
struct net_device;
struct file_operations;
struct completion;
struct pid;
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
struct timespec;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
union __anonunion_ldv_2998_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2998_20 ldv_2998 ;
};
struct cpumask {
   unsigned long bits[128U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct seq_operations;
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct_ldv_5289_25 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct_ldv_5295_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion_ldv_5296_24 {
   struct __anonstruct_ldv_5289_25 ldv_5289 ;
   struct __anonstruct_ldv_5295_26 ldv_5295 ;
};
union __anonunion_ldv_5305_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5296_24 ldv_5296 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5305_27 ldv_5305 ;
};
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
struct lwp_struct {
   u8 reserved[128U] ;
};
struct bndregs_struct {
   u64 bndregs[8U] ;
};
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
struct kmem_cache;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
typedef atomic64_t atomic_long_t;
struct lockdep_map;
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
typedef struct seqcount seqcount_t;
struct __anonstruct_seqlock_t_33 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_33 seqlock_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct user_namespace;
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
typedef struct __anonstruct_kuid_t_34 kuid_t;
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
typedef struct __anonstruct_kgid_t_35 kgid_t;
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
struct optimistic_spin_queue;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct tvec_base;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32 ) ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
struct pci_bus;
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct rb_root {
   struct rb_node *rb_node ;
};
struct vm_area_struct;
struct bio_vec;
struct notifier_block;
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
struct ctl_table;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_header;
struct ctl_dir;
typedef int proc_handler(struct ctl_table * , int , void * , size_t * , loff_t * );
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
struct __anonstruct_ldv_13760_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
union __anonunion_ldv_13762_128 {
   struct __anonstruct_ldv_13760_129 ldv_13760 ;
   struct callback_head rcu ;
};
struct ctl_table_set;
struct ctl_table_header {
   union __anonunion_ldv_13762_128 ldv_13762 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
struct cred;
struct inode;
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct __anonstruct_ldv_14006_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
struct __anonstruct_ldv_14010_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
union __anonunion_ldv_14011_135 {
   struct __anonstruct_ldv_14006_136 ldv_14006 ;
   struct __anonstruct_ldv_14010_137 ldv_14010 ;
};
struct uprobe;
struct return_instance;
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_14011_135 ldv_14011 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
struct xol_area;
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
union __anonunion_ldv_14120_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
union __anonunion_ldv_14126_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct_ldv_14136_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion_ldv_14138_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14136_144 ldv_14136 ;
   int units ;
};
struct __anonstruct_ldv_14140_142 {
   union __anonunion_ldv_14138_143 ldv_14138 ;
   atomic_t _count ;
};
union __anonunion_ldv_14142_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14140_142 ldv_14140 ;
   unsigned int active ;
};
struct __anonstruct_ldv_14143_139 {
   union __anonunion_ldv_14126_140 ldv_14126 ;
   union __anonunion_ldv_14142_141 ldv_14142 ;
};
struct __anonstruct_ldv_14150_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
struct slab;
union __anonunion_ldv_14155_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14150_146 ldv_14150 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
union __anonunion_ldv_14161_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 ldv_14120 ;
   struct __anonstruct_ldv_14143_139 ldv_14143 ;
   union __anonunion_ldv_14155_145 ldv_14155 ;
   union __anonunion_ldv_14161_147 ldv_14161 ;
   unsigned long debug_flags ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct kioctx_table;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long , unsigned long ,
                                      unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
union __anonunion_ldv_14524_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14524_153 ldv_14524 ;
};
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct dentry;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
struct kernfs_root;
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
struct kernfs_node;
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
struct kernfs_ops;
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
union __anonunion_ldv_14668_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14668_154 ldv_14668 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const * , umode_t ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const * ) ;
};
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t , loff_t ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock * ) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct bin_attribute;
struct attribute {
   char const *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t , size_t ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t , size_t ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const * , size_t ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject * ) ;
   void const *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (* const filter)(struct kset * , struct kobject * ) ;
   char const *(* const name)(struct kset * , struct kobject * ) ;
   int (* const uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const * , struct kernel_param const * ) ;
   int (*get)(char * , struct kernel_param const * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion_ldv_15343_155 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};
struct kernel_param {
   char const *name ;
   struct kernel_param_ops const *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15343_155 ldv_15343 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};
struct mod_arch_specific {
};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const * ,
                    size_t ) ;
   void (*setup)(struct module * , char const * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct tracepoint;
struct ftrace_event_call;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
struct mem_cgroup;
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct memcg_cache_params;
struct kmem_cache_node;
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
struct __anonstruct_ldv_15969_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
struct __anonstruct_ldv_15975_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
union __anonunion_ldv_15976_156 {
   struct __anonstruct_ldv_15969_157 ldv_15969 ;
   struct __anonstruct_ldv_15975_158 ldv_15975 ;
};
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_15976_156 ldv_15976 ;
};
struct qlcnic_dcb;
struct qlcnic_adapter;
struct ethtool_ringparam;
struct device_attribute;
struct ethtool_cmd;
struct qlcnic_host_tx_ring;
struct qlcnic_cmd_args;
struct ethtool_pauseparam;
struct ethtool_wolinfo;
struct qlcnic_info;
struct ethtool_dump;
struct qlcnic_host_sds_ring;
struct ethtool_channels;
struct ethtool_coalesce;
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct path;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct pinctrl;
struct pinctrl_state;
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct iommu_ops;
struct iommu_group;
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
struct device_type;
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};
struct class_attribute;
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device * ) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const * , size_t ) ;
};
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops const *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const * ,
                    size_t ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct acpi_device;
struct acpi_dev_node {
   struct acpi_device *companion ;
};
struct dma_coherent_mem;
struct cma;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
typedef unsigned short pci_bus_flags_t;
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_ats;
struct proc_dir_entry;
struct pci_driver;
union __anonunion_ldv_17957_162 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_17957_162 ldv_17957 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
struct pci_ops;
struct msi_chip;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int , int , int , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int , int , int , u32 ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool ) ;
   void (*resume)(struct pci_dev * ) ;
};
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id const * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
struct file_ra_state;
struct user_struct;
struct writeback_control;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long , void * , int , int ) ;
   char const *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const * , nodemask_t const * ,
                  unsigned long ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long , unsigned long ,
                      unsigned long ) ;
};
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t , dma_addr_t * , gfp_t , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t , void * , dma_addr_t , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t ,
               size_t , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t ,
                      size_t , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long , size_t ,
                          enum dma_data_direction , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t , size_t , enum dma_data_direction ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int , enum dma_data_direction ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int , enum dma_data_direction ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device * , dma_addr_t ) ;
   int (*dma_supported)(struct device * , u64 ) ;
   int (*set_dma_mask)(struct device * , u64 ) ;
   int is_phys ;
};
struct plist_head {
   struct list_head node_list ;
};
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
union __anonunion_data_163 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_163 data ;
   struct device *dev ;
};
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
union __anonunion_ldv_23400_164 {
   struct iovec const *iov ;
   struct bio_vec const *bvec ;
};
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_ldv_23400_164 ldv_23400 ;
   unsigned long nr_segs ;
};
typedef s32 dma_cookie_t;
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
typedef unsigned short __kernel_sa_family_t;
typedef __kernel_sa_family_t sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
struct __anonstruct_sync_serial_settings_166 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
typedef struct __anonstruct_sync_serial_settings_166 sync_serial_settings;
struct __anonstruct_te1_settings_167 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
typedef struct __anonstruct_te1_settings_167 te1_settings;
struct __anonstruct_raw_hdlc_proto_168 {
   unsigned short encoding ;
   unsigned short parity ;
};
typedef struct __anonstruct_raw_hdlc_proto_168 raw_hdlc_proto;
struct __anonstruct_fr_proto_169 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
typedef struct __anonstruct_fr_proto_169 fr_proto;
struct __anonstruct_fr_proto_pvc_170 {
   unsigned int dlci ;
};
typedef struct __anonstruct_fr_proto_pvc_170 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_171 {
   unsigned int dlci ;
   char master[16U] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_171 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_172 {
   unsigned int interval ;
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_172 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_173 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_173 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_174 {
   char ifrn_name[16U] ;
};
union __anonunion_ifr_ifru_175 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_174 ifr_ifrn ;
   union __anonunion_ifr_ifru_175 ifr_ifru ;
};
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct __anonstruct_ldv_24484_178 {
   spinlock_t lock ;
   unsigned int count ;
};
union __anonunion_ldv_24485_177 {
   struct __anonstruct_ldv_24484_178 ldv_24484 ;
};
struct lockref {
   union __anonunion_ldv_24485_177 ldv_24485 ;
};
struct nameidata;
struct vfsmount;
struct __anonstruct_ldv_24508_180 {
   u32 hash ;
   u32 len ;
};
union __anonunion_ldv_24510_179 {
   struct __anonstruct_ldv_24508_180 ldv_24508 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion_ldv_24510_179 ldv_24510 ;
   unsigned char const *name ;
};
struct dentry_operations;
union __anonunion_d_u_181 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_181 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int ) ;
   int (*d_hash)(struct dentry const * , struct qstr * ) ;
   int (*d_compare)(struct dentry const * , struct dentry const * , unsigned int ,
                    char const * , struct qstr const * ) ;
   int (*d_delete)(struct dentry const * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
struct __anonstruct_ldv_24871_183 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
union __anonunion_ldv_24873_182 {
   struct __anonstruct_ldv_24871_183 ldv_24871 ;
   struct callback_head callback_head ;
};
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_24873_182 ldv_24873 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct block_device;
struct io_context;
struct cgroup_subsys_state;
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
struct export_operations;
struct kiocb;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
struct __anonstruct_kprojid_t_185 {
   projid_t val ;
};
typedef struct __anonstruct_kprojid_t_185 kprojid_t;
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
union __anonunion_ldv_25670_186 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion_ldv_25670_186 ldv_25670 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int ) ;
   int (*read_file_info)(struct super_block * , int ) ;
   int (*write_file_info)(struct super_block * , int ) ;
   int (*free_file_info)(struct super_block * , int ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int , int , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int , int ) ;
   int (*quota_off)(struct super_block * , int ) ;
   int (*quota_sync)(struct super_block * , int ) ;
   int (*get_info)(struct super_block * , int , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int , int ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops const *ops[2U] ;
};
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t , unsigned int ,
                      unsigned int , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t , unsigned int ,
                    unsigned int , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t ) ;
   void (*invalidatepage)(struct page * , unsigned int , unsigned int ) ;
   int (*releasepage)(struct page * , gfp_t ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int , struct kiocb * , struct iov_iter * , loff_t ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long , int , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion_ldv_26085_189 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};
union __anonunion_ldv_26105_190 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock;
struct cdev;
union __anonunion_ldv_26122_191 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_26085_189 ldv_26085 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_26105_190 ldv_26105 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_26122_191 ldv_26122 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_192 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_192 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
struct files_struct;
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int ) ;
};
struct net;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_194 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_193 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_194 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_193 fl_u ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
struct dir_context {
   int (*actor)(void * , char const * , int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t , int ) ;
   ssize_t (*read)(struct file * , char * , size_t , loff_t * ) ;
   ssize_t (*write)(struct file * , char const * , size_t , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec const * , unsigned long ,
                       loff_t ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec const * , unsigned long ,
                        loff_t ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file * , unsigned int , unsigned long ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb * , int ) ;
   int (*fasync)(int , struct file * , int ) ;
   int (*lock)(struct file * , int , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int , size_t , loff_t * ,
                       int ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long , unsigned long ,
                                      unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file * , int , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t ,
                           unsigned int ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t ,
                          unsigned int ) ;
   int (*setlease)(struct file * , long , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int , loff_t , loff_t ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int ) ;
   struct posix_acl *(*get_acl)(struct inode * , int ) ;
   int (*readlink)(struct dentry * , char * , int ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t , bool ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t , dev_t ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const * , void const * , size_t , int ) ;
   ssize_t (*getxattr)(struct dentry * , char const * , void * , size_t ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t ) ;
   int (*removexattr)(struct dentry * , char const * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 , u64 ) ;
   int (*update_time)(struct inode * , struct timespec * , int ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int ,
                      umode_t , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int , char * , size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block * , int , char const * , size_t ,
                          loff_t ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t ) ;
   long (*nr_cached_objects)(struct super_block * , int ) ;
   long (*free_cached_objects)(struct super_block * , long , int ) ;
};
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int , char const * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
typedef unsigned long cputime_t;
struct __anonstruct_sigset_t_195 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_195 sigset_t;
struct siginfo;
typedef void __signalfn_t(int );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_197 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_198 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_199 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_200 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__sigfault_201 {
   void *_addr ;
   short _addr_lsb ;
};
struct __anonstruct__sigpoll_202 {
   long _band ;
   int _fd ;
};
struct __anonstruct__sigsys_203 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_196 {
   int _pad[28U] ;
   struct __anonstruct__kill_197 _kill ;
   struct __anonstruct__timer_198 _timer ;
   struct __anonstruct__rt_199 _rt ;
   struct __anonstruct__sigchld_200 _sigchld ;
   struct __anonstruct__sigfault_201 _sigfault ;
   struct __anonstruct__sigpoll_202 _sigpoll ;
   struct __anonstruct__sigsys_203 _sigsys ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_196 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
struct rt_mutex_waiter;
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
struct assoc_array_ptr;
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct key_type;
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};
union __anonunion_ldv_29084_206 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion_ldv_29092_207 {
   time_t expiry ;
   time_t revoked_at ;
};
struct __anonstruct_ldv_29105_209 {
   struct key_type *type ;
   char *description ;
};
union __anonunion_ldv_29106_208 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_29105_209 ldv_29105 ;
};
union __anonunion_type_data_210 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
union __anonunion_payload_212 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
union __anonunion_ldv_29121_211 {
   union __anonunion_payload_212 payload ;
   struct assoc_array keys ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_29084_206 ldv_29084 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_29092_207 ldv_29092 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_29106_208 ldv_29106 ;
   union __anonunion_type_data_210 type_data ;
   union __anonunion_ldv_29121_211 ldv_29121 ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct cfs_rq;
struct task_group;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct uts_namespace;
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
struct sched_class;
struct css_set;
struct compat_robust_list_head;
struct numa_group;
struct ftrace_ret_stack;
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
typedef s32 compat_long_t;
typedef u32 compat_uptr_t;
struct compat_robust_list {
   compat_uptr_t next ;
};
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
enum ldv_23789 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
typedef enum ldv_23789 socket_state;
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
struct proto_ops;
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int ) ;
   int (*connect)(struct socket * , struct sockaddr * , int , int ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket * , unsigned int , unsigned long ) ;
   int (*listen)(struct socket * , int ) ;
   int (*shutdown)(struct socket * , int ) ;
   int (*setsockopt)(struct socket * , int , int , char * , unsigned int ) ;
   int (*getsockopt)(struct socket * , int , int , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int , int , char * , unsigned int ) ;
   int (*compat_getsockopt)(struct socket * , int , int , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t , int ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock * , int ) ;
};
struct exception_table_entry {
   int insn ;
   int fixup ;
};
struct in6_addr;
struct sk_buff;
typedef u64 netdev_features_t;
struct nf_conntrack {
   atomic_t use ;
};
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
typedef unsigned int sk_buff_data_t;
struct __anonstruct_ldv_32751_231 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
union __anonunion_ldv_32752_230 {
   u64 v64 ;
   struct __anonstruct_ldv_32751_231 ldv_32751 ;
};
struct skb_mstamp {
   union __anonunion_ldv_32752_230 ldv_32752 ;
};
union __anonunion_ldv_32771_232 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
struct sec_path;
struct __anonstruct_ldv_32787_234 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
union __anonunion_ldv_32788_233 {
   __wsum csum ;
   struct __anonstruct_ldv_32787_234 ldv_32787 ;
};
union __anonunion_ldv_32827_235 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
union __anonunion_ldv_32833_236 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_ldv_32771_232 ldv_32771 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_32788_233 ldv_32788 ;
   __u32 priority ;
   unsigned char ignore_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   union __anonunion_ldv_32827_235 ldv_32827 ;
   __u32 secmark ;
   union __anonunion_ldv_32833_236 ldv_32833 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
struct dst_entry;
struct rtable;
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32 ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32 , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32 ) ;
   int (*get_sset_count)(struct net_device * , int ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const * , u8 const * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
union __anonunion_in6_u_239 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
struct in6_addr {
   union __anonunion_in6_u_239 in6_u ;
};
struct prot_inuse;
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
struct u64_stats_sync {
};
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
struct icmp_mib {
   unsigned long mibs[28U] ;
};
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
struct tcp_mib {
   unsigned long mibs[16U] ;
};
struct udp_mib {
   unsigned long mibs[8U] ;
};
struct linux_mib {
   unsigned long mibs[103U] ;
};
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
struct tcpm_hash_bucket;
struct ipv4_devconf;
struct fib_rules_ops;
struct fib_table;
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
struct inet_peer_base;
struct xt_table;
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
struct neighbour;
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const * ) ;
   unsigned int (*mtu)(struct dst_entry const * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32 ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const * , struct sk_buff * ,
                                     void const * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
struct ipv6_devconf;
struct rt6_info;
struct rt6_statistics;
struct fib6_table;
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
   u16 max_dsize ;
};
struct sctp_mib;
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
struct nlattr;
struct nf_logger;
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
struct ebt_table;
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
struct hlist_nulls_node;
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
struct ip_conntrack_stat;
struct nf_ct_event_notifier;
struct nf_exp_event_notifier;
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
struct nft_af_info;
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
struct net_generic;
struct netns_ipvs;
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
struct dsa_switch;
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
struct dsa_switch_driver;
struct mii_bus;
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int , int ) ;
   int (*phy_write)(struct dsa_switch * , int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8 ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device * , int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int , u8 ) ;
   void (*getpfccfg)(struct net_device * , int , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int , u8 ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8 ) ;
   void (*getbcncfg)(struct net_device * , int , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int , u32 ) ;
   void (*getbcnrp)(struct net_device * , int , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int , u8 ) ;
   u8 (*setapp)(struct net_device * , u8 , u16 , u8 ) ;
   u8 (*getapp)(struct net_device * , u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device * , int , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int , u8 ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8 ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
struct percpu_ref;
typedef void percpu_ref_func_t(struct percpu_ref * );
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
struct cgroup_root;
struct cgroup_subsys;
struct cgroup;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64 ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};
struct cgroup_taskset;
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
struct xfrm_policy;
struct xfrm_state;
struct request_sock;
struct mnt_namespace;
struct ipc_namespace;
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
struct netpoll_info;
struct phy_device;
struct wireless_dev;
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
typedef enum netdev_tx netdev_tx_t;
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
struct neigh_parms;
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short , void const * ,
                 void const * , unsigned int ) ;
   int (*parse)(struct sk_buff const * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour const * , struct hh_cache * , __be16 ) ;
   void (*cache_update)(struct hh_cache * , struct net_device const * , unsigned char const * ) ;
};
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
typedef enum rx_handler_result rx_handler_result_t;
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
struct Qdisc;
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device * , int , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int , int ) ;
   int (*ndo_set_vf_port)(struct net_device * , int , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16 , struct scatterlist * , unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16 , struct scatterlist * ,
                              unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff const * , u16 ,
                            u32 ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const * ,
                      u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32 , u32 , struct net_device * ,
                             u32 ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
};
struct __anonstruct_adj_list_250 {
   struct list_head upper ;
   struct list_head lower ;
};
struct __anonstruct_all_adj_list_251 {
   struct list_head upper ;
   struct list_head lower ;
};
struct iw_handler_def;
struct iw_public_data;
struct forwarding_accel_ops;
struct vlan_info;
struct tipc_bearer;
struct in_device;
struct dn_dev;
struct inet6_dev;
struct cpu_rmap;
struct pcpu_lstats;
struct pcpu_sw_netstats;
struct pcpu_dstats;
struct pcpu_vstats;
union __anonunion_ldv_42084_252 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
struct garp_port;
struct mrp_port;
struct rtnl_link_ops;
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_250 adj_list ;
   struct __anonstruct_all_adj_list_251 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct forwarding_accel_ops const *fwd_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_42084_252 ldv_42084 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
struct res_counter {
   unsigned long long usage ;
   unsigned long long max_usage ;
   unsigned long long limit ;
   unsigned long long soft_limit ;
   unsigned long long failcnt ;
   spinlock_t lock ;
   struct res_counter *parent ;
};
struct kioctx;
typedef int kiocb_cancel_fn(struct kiocb * );
union __anonunion_ki_obj_253 {
   void *user ;
   struct task_struct *tsk ;
};
struct eventfd_ctx;
struct kiocb {
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   kiocb_cancel_fn *ki_cancel ;
   void *private ;
   union __anonunion_ki_obj_253 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   size_t ki_nbytes ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
struct sock_filter_int {
   __u8 code ;
   unsigned char dst_reg : 4 ;
   unsigned char src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
union __anonunion_ldv_44129_254 {
   struct sock_filter insns[0U] ;
   struct sock_filter_int insnsi[0U] ;
   struct work_struct work ;
};
struct sk_filter {
   atomic_t refcnt ;
   unsigned char jited : 1 ;
   unsigned int len : 31 ;
   struct sock_fprog_kern *orig_prog ;
   struct callback_head rcu ;
   unsigned int (*bpf_func)(struct sk_buff const * , struct sock_filter_int const * ) ;
   union __anonunion_ldv_44129_254 ldv_44129 ;
};
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
struct nla_policy {
   u16 type ;
   u16 len ;
};
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device const * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device const * ) ;
   size_t (*get_xstats_size)(struct net_device const * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device const * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device const * , struct net_device const * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device const * , struct net_device const * ) ;
};
struct neigh_table;
struct neigh_parms {
   struct net *net ;
   struct net_device *dev ;
   struct neigh_parms *next ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[12U] ;
   unsigned long data_state[1U] ;
};
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
struct neigh_ops;
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
struct pneigh_entry {
   struct pneigh_entry *next ;
   struct net *net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
struct neigh_table {
   struct neigh_table *next ;
   int family ;
   int entry_size ;
   int key_len ;
   __u32 (*hash)(void const * , struct net_device const * , __u32 * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
struct dn_route;
union __anonunion_ldv_45622_259 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sock * , struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_ldv_45622_259 ldv_45622 ;
};
struct __anonstruct_socket_lock_t_260 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_socket_lock_t_260 socket_lock_t;
struct proto;
typedef __u32 __portpair;
typedef __u64 __addrpair;
struct __anonstruct_ldv_45857_262 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
union __anonunion_ldv_45858_261 {
   __addrpair skc_addrpair ;
   struct __anonstruct_ldv_45857_262 ldv_45857 ;
};
union __anonunion_ldv_45862_263 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
struct __anonstruct_ldv_45868_265 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
union __anonunion_ldv_45869_264 {
   __portpair skc_portpair ;
   struct __anonstruct_ldv_45868_265 ldv_45868 ;
};
union __anonunion_ldv_45878_266 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
union __anonunion_ldv_45887_267 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
struct sock_common {
   union __anonunion_ldv_45858_261 ldv_45858 ;
   union __anonunion_ldv_45862_263 ldv_45862 ;
   union __anonunion_ldv_45869_264 ldv_45869 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 4 ;
   int skc_bound_dev_if ;
   union __anonunion_ldv_45878_266 ldv_45878 ;
   struct proto *skc_prot ;
   struct net *skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_ldv_45887_267 ldv_45887 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
struct cg_proto;
struct __anonstruct_sk_backlog_268 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_268 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check_tx : 1 ;
   unsigned char sk_no_check_rx : 1 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   unsigned short sk_ack_backlog ;
   unsigned short sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   void *sk_protinfo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
struct request_sock_ops;
struct timewait_sock_ops;
struct inet_hashinfo;
struct raw_hashinfo;
struct udp_table;
union __anonunion_h_269 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
struct proto {
   void (*close)(struct sock * , long ) ;
   int (*connect)(struct sock * , struct sockaddr * , int ) ;
   int (*disconnect)(struct sock * , int ) ;
   struct sock *(*accept)(struct sock * , int , int * ) ;
   int (*ioctl)(struct sock * , int , unsigned long ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int ) ;
   int (*setsockopt)(struct sock * , int , int , char * , unsigned int ) ;
   int (*getsockopt)(struct sock * , int , int , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int , int , char * , unsigned int ) ;
   int (*compat_getsockopt)(struct sock * , int , int , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int , unsigned long ) ;
   int (*sendmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t ) ;
   int (*recvmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t , int ,
                  int , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int , size_t , int ) ;
   int (*bind)(struct sock * , struct sockaddr * , int ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*mtu_reduced)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short ) ;
   void (*clear_sk)(struct sock * , int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_269 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
struct cg_proto {
   struct res_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct sock * , struct request_sock * ) ;
};
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   unsigned long expires ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 secid ;
   u32 peer_secid ;
};
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};
struct qlcnic_pci_info;
struct qlcnic_hardware_context;
struct qlcnic_fw_dump;
struct crb_128M_2M_sub_block_map {
   unsigned int valid ;
   unsigned int start_128M ;
   unsigned int end_128M ;
   unsigned int start_2M ;
};
struct crb_128M_2M_block_map {
   struct crb_128M_2M_sub_block_map sub_block[16U] ;
};
struct qlcnic_intrpt_config {
   u8 type ;
   u8 enabled ;
   u16 id ;
   u32 src ;
};
struct qlc_83xx_fw_info {
   struct firmware const *fw ;
   char fw_file_name[20U] ;
};
struct qlc_83xx_reset_hdr;
struct qlc_83xx_reset {
   struct qlc_83xx_reset_hdr *hdr ;
   int seq_index ;
   int seq_error ;
   int array_index ;
   u32 array[16U] ;
   u8 *buff ;
   u8 *stop_offset ;
   u8 *start_offset ;
   u8 *init_offset ;
   u8 seq_end ;
   u8 template_end ;
};
struct qlc_83xx_idc {
   int (*state_entry)(struct qlcnic_adapter * ) ;
   u64 sec_counter ;
   u64 delay ;
   unsigned long status ;
   int err_code ;
   int collect_dump ;
   u8 curr_state ;
   u8 prev_state ;
   u8 vnic_state ;
   u8 vnic_wait_limit ;
   u8 quiesce_req ;
   u8 delay_reset ;
   char **name ;
};
struct qlcnic_dcb_ops {
   int (*query_hw_capability)(struct qlcnic_dcb * , char * ) ;
   int (*get_hw_capability)(struct qlcnic_dcb * ) ;
   int (*query_cee_param)(struct qlcnic_dcb * , char * , u8 ) ;
   void (*init_dcbnl_ops)(struct qlcnic_dcb * ) ;
   void (*aen_handler)(struct qlcnic_dcb * , void * ) ;
   int (*get_cee_cfg)(struct qlcnic_dcb * ) ;
   void (*get_info)(struct qlcnic_dcb * ) ;
   int (*attach)(struct qlcnic_dcb * ) ;
   void (*free)(struct qlcnic_dcb * ) ;
};
struct qlcnic_dcb_mbx_params;
struct qlcnic_dcb_cfg;
struct qlcnic_dcb {
   struct qlcnic_dcb_mbx_params *param ;
   struct qlcnic_adapter *adapter ;
   struct delayed_work aen_work ;
   struct workqueue_struct *wq ;
   struct qlcnic_dcb_ops *ops ;
   struct qlcnic_dcb_cfg *cfg ;
   unsigned long state ;
};
struct cmd_desc_type0 {
   u8 tcp_hdr_offset ;
   u8 ip_hdr_offset ;
   __le16 flags_opcode ;
   __le32 nfrags__length ;
   __le64 addr_buffer2 ;
   __le16 encap_descr ;
   __le16 mss ;
   u8 port_ctxid ;
   u8 hdr_length ;
   u8 outer_hdr_length ;
   u8 rsvd1 ;
   __le64 addr_buffer3 ;
   __le64 addr_buffer1 ;
   __le16 buffer_length[4U] ;
   __le64 addr_buffer4 ;
   u8 eth_addr[6U] ;
   __le16 vlan_TCI ;
};
struct rcv_desc {
   __le16 reference_handle ;
   __le16 reserved ;
   __le32 buffer_length ;
   __le64 addr_buffer ;
};
struct status_desc {
   __le64 status_desc_data[2U] ;
};
struct qlcnic_fdt {
   u32 valid ;
   u16 ver ;
   u16 len ;
   u16 cksum ;
   u16 unused ;
   u8 model[16U] ;
   u16 mfg_id ;
   u16 id ;
   u8 flag ;
   u8 erase_cmd ;
   u8 alt_erase_cmd ;
   u8 write_enable_cmd ;
   u8 write_enable_bits ;
   u8 write_statusreg_cmd ;
   u8 unprotected_sec_cmd ;
   u8 read_manuf_cmd ;
   u32 block_size ;
   u32 alt_block_size ;
   u32 flash_size ;
   u32 write_enable_data ;
   u8 readid_addr_len ;
   u8 write_disable_bits ;
   u8 read_dev_id_len ;
   u8 chip_erase_cmd ;
   u16 read_timeo ;
   u8 protected_sec_cmd ;
   u8 resvd[65U] ;
};
struct qlcnic_skb_frag {
   u64 dma ;
   u64 length ;
};
struct qlcnic_cmd_buffer {
   struct sk_buff *skb ;
   struct qlcnic_skb_frag frag_array[18U] ;
   u32 frag_count ;
};
struct qlcnic_rx_buffer {
   u16 ref_handle ;
   struct sk_buff *skb ;
   struct list_head list ;
   u64 dma ;
};
struct qlcnic_nic_intr_coalesce {
   u8 type ;
   u8 sts_ring_mask ;
   u16 rx_packets ;
   u16 rx_time_us ;
   u16 tx_packets ;
   u16 tx_time_us ;
   u16 flag ;
   u32 timer_out ;
};
struct qlcnic_fw_dump {
   u8 clr ;
   bool enable ;
   u32 size ;
   u32 cap_mask ;
   void *data ;
   void *tmpl_hdr ;
   dma_addr_t phys_addr ;
   void *dma_buffer ;
   bool use_pex_dma ;
   u32 tmpl_hdr_size ;
   u32 version ;
   u32 num_entries ;
   u32 offset ;
};
struct qlcnic_hardware_ops;
struct qlcnic_sriov;
struct qlcnic_mailbox;
struct qlcnic_hardware_context {
   void *pci_base0 ;
   void *ocm_win_crb ;
   unsigned long pci_len0 ;
   rwlock_t crb_lock ;
   struct mutex mem_lock ;
   u8 revision_id ;
   u8 pci_func ;
   u8 linkup ;
   u8 loopback_state ;
   u8 beacon_state ;
   u8 has_link_events ;
   u8 fw_type ;
   u8 physical_port ;
   u8 reset_context ;
   u8 msix_supported ;
   u8 max_mac_filters ;
   u8 mc_enabled ;
   u8 max_mc_count ;
   u8 diag_test ;
   u8 num_msix ;
   u8 nic_mode ;
   int diag_cnt ;
   u16 max_uc_count ;
   u16 port_type ;
   u16 board_type ;
   u16 supported_type ;
   u16 link_speed ;
   u16 link_duplex ;
   u16 link_autoneg ;
   u16 module_type ;
   u16 op_mode ;
   u16 switch_mode ;
   u16 max_tx_ques ;
   u16 max_rx_ques ;
   u16 max_mtu ;
   u32 msg_enable ;
   u16 total_nic_func ;
   u16 max_pci_func ;
   u32 max_vnic_func ;
   u32 total_pci_func ;
   u32 capabilities ;
   u32 extra_capability[3U] ;
   u32 temp ;
   u32 int_vec_bit ;
   u32 fw_hal_version ;
   u32 port_config ;
   struct qlcnic_hardware_ops *hw_ops ;
   struct qlcnic_nic_intr_coalesce coal ;
   struct qlcnic_fw_dump fw_dump ;
   struct qlcnic_fdt fdt ;
   struct qlc_83xx_reset reset ;
   struct qlc_83xx_idc idc ;
   struct qlc_83xx_fw_info *fw_info ;
   struct qlcnic_intrpt_config *intr_tbl ;
   struct qlcnic_sriov *sriov ;
   u32 *reg_tbl ;
   u32 *ext_reg_tbl ;
   u32 mbox_aen[5U] ;
   u32 mbox_reg[4U] ;
   struct qlcnic_mailbox *mailbox ;
   u8 extend_lb_time ;
   u8 phys_port_id[6U] ;
   u8 lb_mode ;
   u16 vxlan_port ;
   struct device *hwmon_dev ;
};
struct qlcnic_adapter_stats {
   u64 xmitcalled ;
   u64 xmitfinished ;
   u64 rxdropped ;
   u64 txdropped ;
   u64 csummed ;
   u64 rx_pkts ;
   u64 lro_pkts ;
   u64 rxbytes ;
   u64 txbytes ;
   u64 lrobytes ;
   u64 lso_frames ;
   u64 encap_lso_frames ;
   u64 encap_tx_csummed ;
   u64 encap_rx_csummed ;
   u64 xmit_on ;
   u64 xmit_off ;
   u64 skb_alloc_failure ;
   u64 null_rxbuf ;
   u64 rx_dma_map_error ;
   u64 tx_dma_map_error ;
   u64 spurious_intr ;
   u64 mac_filter_limit_overrun ;
};
struct qlcnic_host_rds_ring {
   void *crb_rcv_producer ;
   struct rcv_desc *desc_head ;
   struct qlcnic_rx_buffer *rx_buf_arr ;
   u32 num_desc ;
   u32 producer ;
   u32 dma_size ;
   u32 skb_size ;
   u32 flags ;
   struct list_head free_list ;
   spinlock_t lock ;
   dma_addr_t phys_addr ;
};
struct qlcnic_host_sds_ring {
   u32 consumer ;
   u32 num_desc ;
   void *crb_sts_consumer ;
   struct qlcnic_host_tx_ring *tx_ring ;
   struct status_desc *desc_head ;
   struct qlcnic_adapter *adapter ;
   struct napi_struct napi ;
   struct list_head free_list[3U] ;
   void *crb_intr_mask ;
   int irq ;
   dma_addr_t phys_addr ;
   char name[28U] ;
};
struct qlcnic_tx_queue_stats {
   u64 xmit_on ;
   u64 xmit_off ;
   u64 xmit_called ;
   u64 xmit_finished ;
   u64 tx_bytes ;
};
struct qlcnic_host_tx_ring {
   int irq ;
   void *crb_intr_mask ;
   char name[28U] ;
   u16 ctx_id ;
   u32 state ;
   u32 producer ;
   u32 sw_consumer ;
   u32 num_desc ;
   struct qlcnic_tx_queue_stats tx_stats ;
   void *crb_cmd_producer ;
   struct cmd_desc_type0 *desc_head ;
   struct qlcnic_adapter *adapter ;
   struct napi_struct napi ;
   struct qlcnic_cmd_buffer *cmd_buf_arr ;
   __le32 *hw_consumer ;
   dma_addr_t phys_addr ;
   dma_addr_t hw_cons_phys_addr ;
   struct netdev_queue *txq ;
   spinlock_t tx_clean_lock ;
};
struct qlcnic_recv_context {
   struct qlcnic_host_rds_ring *rds_rings ;
   struct qlcnic_host_sds_ring *sds_rings ;
   u32 state ;
   u16 context_id ;
   u16 virt_port ;
};
struct qlcnic_mac_vlan_list {
   struct list_head list ;
   uint8_t mac_addr[8U] ;
   u16 vlan_id ;
};
struct qlcnic_nic_req {
   __le64 qhdr ;
   __le64 req_hdr ;
   __le64 words[6U] ;
};
struct qlcnic_mac_req {
   u8 op ;
   u8 tag ;
   u8 mac_addr[6U] ;
};
struct qlcnic_vlan_req {
   __le16 vlan_id ;
   __le16 rsvd[3U] ;
};
struct qlcnic_ipaddr {
   __be32 ipv4 ;
   __be32 ipv6[4U] ;
};
struct qlcnic_filter {
   struct hlist_node fnode ;
   u8 faddr[6U] ;
   u16 vlan_id ;
   unsigned long ftime ;
};
struct qlcnic_filter_hash {
   struct hlist_head *fhead ;
   u8 fnum ;
   u16 fmax ;
   u16 fbucket_size ;
};
struct qlcnic_mbx_ops;
struct qlcnic_mailbox {
   struct workqueue_struct *work_q ;
   struct qlcnic_adapter *adapter ;
   struct qlcnic_mbx_ops *ops ;
   struct work_struct work ;
   struct completion completion ;
   struct list_head cmd_q ;
   unsigned long status ;
   spinlock_t queue_lock ;
   spinlock_t aen_lock ;
   atomic_t rsp_status ;
   u32 num_cmds ;
};
struct qlcnic_npar_info;
struct qlcnic_eswitch;
struct qlcnic_nic_template;
struct qlcnic_adapter {
   struct qlcnic_hardware_context *ahw ;
   struct qlcnic_recv_context *recv_ctx ;
   struct qlcnic_host_tx_ring *tx_ring ;
   struct net_device *netdev ;
   struct pci_dev *pdev ;
   unsigned long state ;
   u32 flags ;
   u16 num_txd ;
   u16 num_rxd ;
   u16 num_jumbo_rxd ;
   u16 max_rxd ;
   u16 max_jumbo_rxd ;
   u8 max_rds_rings ;
   u8 max_sds_rings ;
   u8 max_tx_rings ;
   u8 drv_tx_rings ;
   u8 drv_sds_rings ;
   u8 drv_tss_rings ;
   u8 drv_rss_rings ;
   u8 rx_csum ;
   u8 portnum ;
   u8 fw_wait_cnt ;
   u8 fw_fail_cnt ;
   u8 tx_timeo_cnt ;
   u8 need_fw_reset ;
   u8 reset_ctx_cnt ;
   u16 is_up ;
   u16 rx_pvid ;
   u16 tx_pvid ;
   u32 irq ;
   u32 heartbeat ;
   u8 dev_state ;
   u8 reset_ack_timeo ;
   u8 dev_init_timeo ;
   u8 mac_addr[6U] ;
   u64 dev_rst_time ;
   bool drv_mac_learn ;
   bool fdb_mac_learn ;
   bool rx_mac_learn ;
   unsigned long vlans[64U] ;
   u8 flash_mfg_id ;
   struct qlcnic_npar_info *npars ;
   struct qlcnic_eswitch *eswitch ;
   struct qlcnic_nic_template *nic_ops ;
   struct qlcnic_adapter_stats stats ;
   struct list_head mac_list ;
   void *tgt_mask_reg ;
   void *tgt_status_reg ;
   void *crb_int_state_reg ;
   void *isr_int_vec ;
   struct msix_entry *msix_entries ;
   struct workqueue_struct *qlcnic_wq ;
   struct delayed_work fw_work ;
   struct delayed_work idc_aen_work ;
   struct delayed_work mbx_poll_work ;
   struct qlcnic_dcb *dcb ;
   struct qlcnic_filter_hash fhash ;
   struct qlcnic_filter_hash rx_fhash ;
   struct list_head vf_mc_list ;
   spinlock_t mac_learn_lock ;
   spinlock_t rx_mac_learn_lock ;
   u32 file_prd_off ;
   u32 fw_version ;
   u32 offload_flags ;
   struct firmware const *fw ;
};
struct qlcnic_info {
   u16 pci_func ;
   u16 op_mode ;
   u16 phys_port ;
   u16 switch_mode ;
   u32 capabilities ;
   u8 max_mac_filters ;
   u16 max_mtu ;
   u16 max_tx_ques ;
   u16 max_rx_ques ;
   u16 min_tx_bw ;
   u16 max_tx_bw ;
   u32 op_type ;
   u16 max_bw_reg_offset ;
   u16 max_linkspeed_reg_offset ;
   u32 capability1 ;
   u32 capability2 ;
   u32 capability3 ;
   u16 max_tx_mac_filters ;
   u16 max_rx_mcast_mac_filters ;
   u16 max_rx_ucast_mac_filters ;
   u16 max_rx_ip_addr ;
   u16 max_rx_lro_flow ;
   u16 max_rx_status_rings ;
   u16 max_rx_buf_rings ;
   u16 max_tx_vlan_keys ;
   u8 total_pf ;
   u8 total_rss_engines ;
   u16 max_vports ;
   u16 linkstate_reg_offset ;
   u16 bit_offsets ;
   u16 max_local_ipv6_addrs ;
   u16 max_remote_ipv6_addrs ;
};
struct qlcnic_pci_info {
   u16 id ;
   u16 active ;
   u16 type ;
   u16 default_port ;
   u16 tx_min_bw ;
   u16 tx_max_bw ;
   u8 mac[6U] ;
   u16 func_count ;
};
struct qlcnic_npar_info {
   bool eswitch_status ;
   u16 pvid ;
   u16 min_bw ;
   u16 max_bw ;
   u8 phy_port ;
   u8 type ;
   u8 active ;
   u8 enable_pm ;
   u8 dest_npar ;
   u8 discard_tagged ;
   u8 mac_override ;
   u8 mac_anti_spoof ;
   u8 promisc_mode ;
   u8 offload_flags ;
   u8 pci_func ;
   u8 mac[6U] ;
};
struct qlcnic_eswitch {
   u8 port ;
   u8 active_vports ;
   u8 active_vlans ;
   u8 active_ucast_filters ;
   u8 max_ucast_filters ;
   u8 max_active_vlans ;
   u32 flags ;
};
struct _cdrp_cmd {
   u32 num ;
   u32 *arg ;
};
struct qlcnic_cmd_args {
   struct completion completion ;
   struct list_head list ;
   struct _cdrp_cmd req ;
   struct _cdrp_cmd rsp ;
   atomic_t rsp_status ;
   int pay_size ;
   u32 rsp_opcode ;
   u32 total_cmds ;
   u32 op_type ;
   u32 type ;
   u32 cmd_op ;
   u32 *hdr ;
   u32 *pay ;
   u8 func_num ;
};
struct qlcnic_nic_template {
   int (*config_bridged_mode)(struct qlcnic_adapter * , u32 ) ;
   int (*config_led)(struct qlcnic_adapter * , u32 , u32 ) ;
   int (*start_firmware)(struct qlcnic_adapter * ) ;
   int (*init_driver)(struct qlcnic_adapter * ) ;
   void (*request_reset)(struct qlcnic_adapter * , u32 ) ;
   void (*cancel_idc_work)(struct qlcnic_adapter * ) ;
   int (*napi_add)(struct qlcnic_adapter * , struct net_device * ) ;
   void (*napi_del)(struct qlcnic_adapter * ) ;
   void (*config_ipaddr)(struct qlcnic_adapter * , __be32 , int ) ;
   irqreturn_t (*clear_legacy_intr)(struct qlcnic_adapter * ) ;
   int (*shutdown)(struct pci_dev * ) ;
   int (*resume)(struct qlcnic_adapter * ) ;
};
struct qlcnic_mbx_ops {
   int (*enqueue_cmd)(struct qlcnic_adapter * , struct qlcnic_cmd_args * , unsigned long * ) ;
   void (*dequeue_cmd)(struct qlcnic_adapter * , struct qlcnic_cmd_args * ) ;
   void (*decode_resp)(struct qlcnic_adapter * , struct qlcnic_cmd_args * ) ;
   void (*encode_cmd)(struct qlcnic_adapter * , struct qlcnic_cmd_args * ) ;
   void (*nofity_fw)(struct qlcnic_adapter * , u8 ) ;
};
struct qlcnic_hardware_ops {
   void (*read_crb)(struct qlcnic_adapter * , char * , loff_t , size_t ) ;
   void (*write_crb)(struct qlcnic_adapter * , char * , loff_t , size_t ) ;
   int (*read_reg)(struct qlcnic_adapter * , ulong , int * ) ;
   int (*write_reg)(struct qlcnic_adapter * , ulong , u32 ) ;
   void (*get_ocm_win)(struct qlcnic_hardware_context * ) ;
   int (*get_mac_address)(struct qlcnic_adapter * , u8 * , u8 ) ;
   int (*setup_intr)(struct qlcnic_adapter * ) ;
   int (*alloc_mbx_args)(struct qlcnic_cmd_args * , struct qlcnic_adapter * , u32 ) ;
   int (*mbx_cmd)(struct qlcnic_adapter * , struct qlcnic_cmd_args * ) ;
   void (*get_func_no)(struct qlcnic_adapter * ) ;
   int (*api_lock)(struct qlcnic_adapter * ) ;
   void (*api_unlock)(struct qlcnic_adapter * ) ;
   void (*add_sysfs)(struct qlcnic_adapter * ) ;
   void (*remove_sysfs)(struct qlcnic_adapter * ) ;
   void (*process_lb_rcv_ring_diag)(struct qlcnic_host_sds_ring * ) ;
   int (*create_rx_ctx)(struct qlcnic_adapter * ) ;
   int (*create_tx_ctx)(struct qlcnic_adapter * , struct qlcnic_host_tx_ring * , int ) ;
   void (*del_rx_ctx)(struct qlcnic_adapter * ) ;
   void (*del_tx_ctx)(struct qlcnic_adapter * , struct qlcnic_host_tx_ring * ) ;
   int (*setup_link_event)(struct qlcnic_adapter * , int ) ;
   int (*get_nic_info)(struct qlcnic_adapter * , struct qlcnic_info * , u8 ) ;
   int (*get_pci_info)(struct qlcnic_adapter * , struct qlcnic_pci_info * ) ;
   int (*set_nic_info)(struct qlcnic_adapter * , struct qlcnic_info * ) ;
   int (*change_macvlan)(struct qlcnic_adapter * , u8 * , u16 , u8 ) ;
   void (*napi_enable)(struct qlcnic_adapter * ) ;
   void (*napi_disable)(struct qlcnic_adapter * ) ;
   int (*config_intr_coal)(struct qlcnic_adapter * , struct ethtool_coalesce * ) ;
   int (*config_rss)(struct qlcnic_adapter * , int ) ;
   int (*config_hw_lro)(struct qlcnic_adapter * , int ) ;
   int (*config_loopback)(struct qlcnic_adapter * , u8 ) ;
   int (*clear_loopback)(struct qlcnic_adapter * , u8 ) ;
   int (*config_promisc_mode)(struct qlcnic_adapter * , u32 ) ;
   void (*change_l2_filter)(struct qlcnic_adapter * , u64 * , u16 ) ;
   int (*get_board_info)(struct qlcnic_adapter * ) ;
   void (*set_mac_filter_count)(struct qlcnic_adapter * ) ;
   void (*free_mac_list)(struct qlcnic_adapter * ) ;
   int (*read_phys_port_id)(struct qlcnic_adapter * ) ;
   pci_ers_result_t (*io_error_detected)(struct pci_dev * , pci_channel_state_t ) ;
   pci_ers_result_t (*io_slot_reset)(struct pci_dev * ) ;
   void (*io_resume)(struct pci_dev * ) ;
   void (*get_beacon_state)(struct qlcnic_adapter * ) ;
   void (*enable_sds_intr)(struct qlcnic_adapter * , struct qlcnic_host_sds_ring * ) ;
   void (*disable_sds_intr)(struct qlcnic_adapter * , struct qlcnic_host_sds_ring * ) ;
   void (*enable_tx_intr)(struct qlcnic_adapter * , struct qlcnic_host_tx_ring * ) ;
   void (*disable_tx_intr)(struct qlcnic_adapter * , struct qlcnic_host_tx_ring * ) ;
   u32 (*get_saved_state)(void * , u32 ) ;
   void (*set_saved_state)(void * , u32 , u32 ) ;
   void (*cache_tmpl_hdr_values)(struct qlcnic_fw_dump * ) ;
   u32 (*get_cap_size)(void * , int ) ;
   void (*set_sys_info)(void * , int , u32 ) ;
   void (*store_cap_mask)(void * , u32 ) ;
};
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 optimistic_dad ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   void *sysctl ;
};
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   spinlock_t aca_lock ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
union __anonunion_ldv_52077_284 {
   __be32 a4 ;
   __be32 a6[4U] ;
};
struct inetpeer_addr_base {
   union __anonunion_ldv_52077_284 ldv_52077 ;
};
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
union __anonunion_ldv_52092_285 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
struct __anonstruct_ldv_52096_287 {
   atomic_t rid ;
};
union __anonunion_ldv_52099_286 {
   struct __anonstruct_ldv_52096_287 ldv_52096 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[15U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_ldv_52092_285 ldv_52092 ;
   union __anonunion_ldv_52099_286 ldv_52099 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   u32 flush_seq ;
   int total ;
};
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
};
struct qlcnic_ms_reg_ctrl {
   u32 ocm_window ;
   u32 control ;
   u32 hi ;
   u32 low ;
   u32 rd[4U] ;
   u32 wd[4U] ;
   u64 off ;
};
struct paravirt_callee_save {
   void *func ;
};
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
typedef int pao_T__;
typedef int pao_T_____0;
enum hrtimer_restart;
struct pci_sysdata {
   int domain ;
   int node ;
   struct acpi_device *companion ;
   void *iommu ;
};
struct netdev_notifier_info {
   struct net_device *dev ;
};
struct qlcnic_legacy_intr_set {
   u32 int_vec_bit ;
   u32 tgt_status_reg ;
   u32 tgt_mask_reg ;
   u32 pci_int_reg ;
};
struct qlcnic_esw_func_cfg {
   u16 vlan_id ;
   u8 op_mode ;
   u8 op_type ;
   u8 pci_func ;
   u8 host_vlan_tag ;
   u8 promisc_mode ;
   u8 discard_tagged ;
   u8 mac_override ;
   u8 mac_anti_spoof ;
   u8 offload_flags ;
   u8 reserved[5U] ;
};
struct qlcnic_board_info {
   unsigned short vendor ;
   unsigned short device ;
   unsigned short sub_vendor ;
   unsigned short sub_device ;
   char short_name[100U] ;
};
struct qlcnic_bc_payload {
   u64 payload[126U] ;
};
struct qlcnic_bc_hdr {
   u8 version ;
   unsigned char msg_type : 4 ;
   unsigned char rsvd1 : 3 ;
   unsigned char op_type : 1 ;
   u8 num_cmds ;
   u8 num_frags ;
   u8 frag_num ;
   u8 cmd_op ;
   u16 seq_id ;
   u64 rsvd3 ;
};
struct qlcnic_trans_list {
   spinlock_t lock ;
   struct list_head wait_list ;
   int count ;
};
enum qlcnic_trans_state {
    QLC_INIT = 0,
    QLC_WAIT_FOR_CHANNEL_FREE = 1,
    QLC_WAIT_FOR_RESP = 2,
    QLC_ABORT = 3,
    QLC_END = 4
} ;
struct qlcnic_vf_info;
struct qlcnic_bc_trans {
   u8 func_id ;
   u8 active ;
   u8 curr_rsp_frag ;
   u8 curr_req_frag ;
   u16 cmd_id ;
   u16 req_pay_size ;
   u16 rsp_pay_size ;
   u32 trans_id ;
   enum qlcnic_trans_state trans_state ;
   struct list_head list ;
   struct qlcnic_bc_hdr *req_hdr ;
   struct qlcnic_bc_hdr *rsp_hdr ;
   struct qlcnic_bc_payload *req_pay ;
   struct qlcnic_bc_payload *rsp_pay ;
   struct completion resp_cmpl ;
   struct qlcnic_vf_info *vf ;
};
struct qlcnic_resources {
   u16 num_tx_mac_filters ;
   u16 num_rx_ucast_mac_filters ;
   u16 num_rx_mcast_mac_filters ;
   u16 num_txvlan_keys ;
   u16 num_rx_queues ;
   u16 num_tx_queues ;
   u16 num_rx_buf_rings ;
   u16 num_rx_status_rings ;
   u16 num_destip ;
   u32 num_lro_flows_supported ;
   u16 max_local_ipv6_addrs ;
   u16 max_remote_ipv6_addrs ;
};
struct qlcnic_vport {
   u16 handle ;
   u16 max_tx_bw ;
   u16 min_tx_bw ;
   u16 pvid ;
   u8 vlan_mode ;
   u8 qos ;
   bool spoofchk ;
   u8 mac[6U] ;
};
struct qlcnic_vf_info {
   u8 pci_func ;
   u16 rx_ctx_id ;
   u16 tx_ctx_id ;
   u16 *sriov_vlans ;
   int num_vlan ;
   unsigned long state ;
   struct completion ch_free_cmpl ;
   struct work_struct trans_work ;
   struct work_struct flr_work ;
   struct mutex send_cmd_lock ;
   struct qlcnic_bc_trans *send_cmd ;
   struct qlcnic_bc_trans *flr_trans ;
   struct qlcnic_trans_list rcv_act ;
   struct qlcnic_trans_list rcv_pend ;
   struct qlcnic_adapter *adapter ;
   struct qlcnic_vport *vp ;
   spinlock_t vlan_list_lock ;
};
struct qlcnic_back_channel {
   u16 trans_counter ;
   struct workqueue_struct *bc_trans_wq ;
   struct workqueue_struct *bc_async_wq ;
   struct workqueue_struct *bc_flr_wq ;
   struct list_head async_list ;
};
struct qlcnic_sriov {
   u16 vp_handle ;
   u8 num_vfs ;
   u8 any_vlan ;
   u8 vlan_mode ;
   u16 num_allowed_vlans ;
   u16 *allowed_vlans ;
   u16 vlan ;
   struct qlcnic_resources ff_max ;
   struct qlcnic_back_channel bc ;
   struct qlcnic_vf_info *vf_info ;
};
struct in_ifaddr;
struct ipv4_devconf {
   void *sysctl ;
   int data[28U] ;
   unsigned long state[1U] ;
};
struct ip_mc_list;
struct in_device {
   struct net_device *dev ;
   atomic_t refcnt ;
   int dead ;
   struct in_ifaddr *ifa_list ;
   struct ip_mc_list *mc_list ;
   struct ip_mc_list **mc_hash ;
   int mc_count ;
   spinlock_t mc_tomb_lock ;
   struct ip_mc_list *mc_tomb ;
   unsigned long mr_v1_seen ;
   unsigned long mr_v2_seen ;
   unsigned long mr_maxdelay ;
   unsigned char mr_qrv ;
   unsigned char mr_gq_running ;
   unsigned char mr_ifc_count ;
   struct timer_list mr_gq_timer ;
   struct timer_list mr_ifc_timer ;
   struct neigh_parms *arp_parms ;
   struct ipv4_devconf cnf ;
   struct callback_head callback_head ;
};
struct in_ifaddr {
   struct hlist_node hash ;
   struct in_ifaddr *ifa_next ;
   struct in_device *ifa_dev ;
   struct callback_head callback_head ;
   __be32 ifa_local ;
   __be32 ifa_address ;
   __be32 ifa_mask ;
   __be32 ifa_broadcast ;
   unsigned char ifa_scope ;
   unsigned char ifa_prefixlen ;
   __u32 ifa_flags ;
   char ifa_label[16U] ;
   __u32 ifa_valid_lft ;
   __u32 ifa_preferred_lft ;
   unsigned long ifa_cstamp ;
   unsigned long ifa_tstamp ;
};
typedef int ldv_func_ret_type___2;
typedef int ldv_func_ret_type___3;
enum hrtimer_restart;
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
struct uni_table_desc {
   __le32 findex ;
   __le32 num_entries ;
   __le32 entry_size ;
   __le32 reserved[5U] ;
};
struct uni_data_desc {
   __le32 findex ;
   __le32 size ;
   __le32 reserved[5U] ;
};
struct qlcnic_flt_header {
   u16 version ;
   u16 len ;
   u16 checksum ;
   u16 reserved ;
};
struct qlcnic_flt_entry {
   u8 region ;
   u8 reserved0 ;
   u8 attrib ;
   u8 reserved1 ;
   u32 size ;
   u32 start_addr ;
   u32 end_addr ;
};
struct crb_addr_pair {
   u32 addr ;
   u32 data ;
};
enum hrtimer_restart;
struct qlcnic_mac_statistics {
   u64 mac_tx_frames ;
   u64 mac_tx_bytes ;
   u64 mac_tx_mcast_pkts ;
   u64 mac_tx_bcast_pkts ;
   u64 mac_tx_pause_cnt ;
   u64 mac_tx_ctrl_pkt ;
   u64 mac_tx_lt_64b_pkts ;
   u64 mac_tx_lt_127b_pkts ;
   u64 mac_tx_lt_255b_pkts ;
   u64 mac_tx_lt_511b_pkts ;
   u64 mac_tx_lt_1023b_pkts ;
   u64 mac_tx_lt_1518b_pkts ;
   u64 mac_tx_gt_1518b_pkts ;
   u64 rsvd1[3U] ;
   u64 mac_rx_frames ;
   u64 mac_rx_bytes ;
   u64 mac_rx_mcast_pkts ;
   u64 mac_rx_bcast_pkts ;
   u64 mac_rx_pause_cnt ;
   u64 mac_rx_ctrl_pkt ;
   u64 mac_rx_lt_64b_pkts ;
   u64 mac_rx_lt_127b_pkts ;
   u64 mac_rx_lt_255b_pkts ;
   u64 mac_rx_lt_511b_pkts ;
   u64 mac_rx_lt_1023b_pkts ;
   u64 mac_rx_lt_1518b_pkts ;
   u64 mac_rx_gt_1518b_pkts ;
   u64 rsvd2[3U] ;
   u64 mac_rx_length_error ;
   u64 mac_rx_length_small ;
   u64 mac_rx_length_large ;
   u64 mac_rx_jabber ;
   u64 mac_rx_dropped ;
   u64 mac_rx_crc_error ;
   u64 mac_align_error ;
};
struct __qlcnic_esw_statistics {
   u16 context_id ;
   u16 version ;
   u16 size ;
   u16 unused ;
   u64 unicast_frames ;
   u64 multicast_frames ;
   u64 broadcast_frames ;
   u64 dropped_frames ;
   u64 errors ;
   u64 local_frames ;
   u64 numbytes ;
   u64 rsvd[3U] ;
};
struct qlcnic_esw_statistics {
   struct __qlcnic_esw_statistics rx ;
   struct __qlcnic_esw_statistics tx ;
};
struct qlcnic_stats {
   char stat_string[32U] ;
   int sizeof_stat ;
   int stat_offset ;
};
enum hrtimer_restart;
struct qlcnic_mailbox_metadata {
   u32 cmd ;
   u32 in_args ;
   u32 out_args ;
};
struct qlcnic_hostrq_sds_ring {
   __le64 host_phys_addr ;
   __le32 ring_size ;
   __le16 msi_index ;
   __le16 rsvd ;
};
struct qlcnic_hostrq_rds_ring {
   __le64 host_phys_addr ;
   __le64 buff_size ;
   __le32 ring_size ;
   __le32 ring_kind ;
};
struct qlcnic_hostrq_rx_ctx {
   __le64 host_rsp_dma_addr ;
   __le32 capabilities[4U] ;
   __le32 host_int_crb_mode ;
   __le32 host_rds_crb_mode ;
   __le32 rds_ring_offset ;
   __le32 sds_ring_offset ;
   __le16 num_rds_rings ;
   __le16 num_sds_rings ;
   __le16 valid_field_offset ;
   u8 txrx_sds_binding ;
   u8 msix_handler ;
   u8 reserved[128U] ;
   char data[0U] ;
};
struct qlcnic_cardrsp_rds_ring {
   __le32 host_producer_crb ;
   __le32 rsvd1 ;
};
struct qlcnic_cardrsp_sds_ring {
   __le32 host_consumer_crb ;
   __le32 interrupt_crb ;
};
struct qlcnic_cardrsp_rx_ctx {
   __le32 rds_ring_offset ;
   __le32 sds_ring_offset ;
   __le32 host_ctx_state ;
   __le32 num_fn_per_port ;
   __le16 num_rds_rings ;
   __le16 num_sds_rings ;
   __le16 context_id ;
   u8 phys_port ;
   u8 virt_port ;
   u8 reserved[128U] ;
   char data[0U] ;
};
struct qlcnic_hostrq_cds_ring {
   __le64 host_phys_addr ;
   __le32 ring_size ;
   __le32 rsvd ;
};
struct qlcnic_hostrq_tx_ctx {
   __le64 host_rsp_dma_addr ;
   __le64 cmd_cons_dma_addr ;
   __le64 dummy_dma_addr ;
   __le32 capabilities[4U] ;
   __le32 host_int_crb_mode ;
   __le32 rsvd1 ;
   __le16 rsvd2 ;
   __le16 interrupt_ctl ;
   __le16 msi_index ;
   __le16 rsvd3 ;
   struct qlcnic_hostrq_cds_ring cds_ring ;
   u8 reserved[128U] ;
};
struct qlcnic_cardrsp_cds_ring {
   __le32 host_producer_crb ;
   __le32 interrupt_crb ;
};
struct qlcnic_cardrsp_tx_ctx {
   __le32 host_ctx_state ;
   __le16 context_id ;
   u8 phys_port ;
   u8 virt_port ;
   struct qlcnic_cardrsp_cds_ring cds_ring ;
   u8 reserved[128U] ;
};
struct qlcnic_info_le {
   __le16 pci_func ;
   __le16 op_mode ;
   __le16 phys_port ;
   __le16 switch_mode ;
   __le32 capabilities ;
   u8 max_mac_filters ;
   u8 reserved1 ;
   __le16 max_mtu ;
   __le16 max_tx_ques ;
   __le16 max_rx_ques ;
   __le16 min_tx_bw ;
   __le16 max_tx_bw ;
   __le32 op_type ;
   __le16 max_bw_reg_offset ;
   __le16 max_linkspeed_reg_offset ;
   __le32 capability1 ;
   __le32 capability2 ;
   __le32 capability3 ;
   __le16 max_tx_mac_filters ;
   __le16 max_rx_mcast_mac_filters ;
   __le16 max_rx_ucast_mac_filters ;
   __le16 max_rx_ip_addr ;
   __le16 max_rx_lro_flow ;
   __le16 max_rx_status_rings ;
   __le16 max_rx_buf_rings ;
   __le16 max_tx_vlan_keys ;
   u8 total_pf ;
   u8 total_rss_engines ;
   __le16 max_vports ;
   __le16 linkstate_reg_offset ;
   __le16 bit_offsets ;
   __le16 max_local_ipv6_addrs ;
   __le16 max_remote_ipv6_addrs ;
   u8 reserved2[56U] ;
};
struct qlcnic_pci_info_le {
   __le16 id ;
   __le16 active ;
   __le16 type ;
   __le16 default_port ;
   __le16 tx_min_bw ;
   __le16 tx_max_bw ;
   __le16 reserved1[2U] ;
   u8 mac[6U] ;
   __le16 func_count ;
   u8 reserved2[104U] ;
};
struct qlcnic_mac_statistics_le {
   __le64 mac_tx_frames ;
   __le64 mac_tx_bytes ;
   __le64 mac_tx_mcast_pkts ;
   __le64 mac_tx_bcast_pkts ;
   __le64 mac_tx_pause_cnt ;
   __le64 mac_tx_ctrl_pkt ;
   __le64 mac_tx_lt_64b_pkts ;
   __le64 mac_tx_lt_127b_pkts ;
   __le64 mac_tx_lt_255b_pkts ;
   __le64 mac_tx_lt_511b_pkts ;
   __le64 mac_tx_lt_1023b_pkts ;
   __le64 mac_tx_lt_1518b_pkts ;
   __le64 mac_tx_gt_1518b_pkts ;
   __le64 rsvd1[3U] ;
   __le64 mac_rx_frames ;
   __le64 mac_rx_bytes ;
   __le64 mac_rx_mcast_pkts ;
   __le64 mac_rx_bcast_pkts ;
   __le64 mac_rx_pause_cnt ;
   __le64 mac_rx_ctrl_pkt ;
   __le64 mac_rx_lt_64b_pkts ;
   __le64 mac_rx_lt_127b_pkts ;
   __le64 mac_rx_lt_255b_pkts ;
   __le64 mac_rx_lt_511b_pkts ;
   __le64 mac_rx_lt_1023b_pkts ;
   __le64 mac_rx_lt_1518b_pkts ;
   __le64 mac_rx_gt_1518b_pkts ;
   __le64 rsvd2[3U] ;
   __le64 mac_rx_length_error ;
   __le64 mac_rx_length_small ;
   __le64 mac_rx_length_large ;
   __le64 mac_rx_jabber ;
   __le64 mac_rx_dropped ;
   __le64 mac_rx_crc_error ;
   __le64 mac_align_error ;
};
struct qlcnic_esw_stats_le {
   __le16 context_id ;
   __le16 version ;
   __le16 size ;
   __le16 unused ;
   __le64 unicast_frames ;
   __le64 multicast_frames ;
   __le64 broadcast_frames ;
   __le64 dropped_frames ;
   __le64 errors ;
   __le64 local_frames ;
   __le64 numbytes ;
   __le64 rsvd[3U] ;
};
typedef __u16 __sum16;
enum hrtimer_restart;
struct skb_frag_struct;
typedef struct skb_frag_struct skb_frag_t;
struct __anonstruct_page_225 {
   struct page *p ;
};
struct skb_frag_struct {
   struct __anonstruct_page_225 page ;
   __u32 page_offset ;
   __u32 size ;
};
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
   ktime_t syststamp ;
};
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
typedef enum gro_result gro_result_t;
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
struct ipv6hdr {
   unsigned char priority : 4 ;
   unsigned char version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   unsigned char res1 : 4 ;
   unsigned char doff : 4 ;
   unsigned char fin : 1 ;
   unsigned char syn : 1 ;
   unsigned char rst : 1 ;
   unsigned char psh : 1 ;
   unsigned char ack : 1 ;
   unsigned char urg : 1 ;
   unsigned char ece : 1 ;
   unsigned char cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};
struct __anonstruct_ldv_51618_288 {
   u64 hdr ;
   u64 body[7U] ;
};
union __anonunion_ldv_51620_287 {
   struct __anonstruct_ldv_51618_288 ldv_51618 ;
   u64 words[8U] ;
};
struct qlcnic_fw_msg {
   union __anonunion_ldv_51620_287 ldv_51620 ;
};
typedef int ldv_func_ret_type;
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
enum hrtimer_restart;
struct qlcnic_pci_func_cfg {
   u16 func_type ;
   u16 min_bw ;
   u16 max_bw ;
   u16 port_num ;
   u8 pci_func ;
   u8 func_state ;
   u8 def_mac_addr[6U] ;
};
struct qlcnic_npar_func_cfg {
   u32 fw_capab ;
   u16 port_num ;
   u16 min_bw ;
   u16 max_bw ;
   u16 max_tx_queues ;
   u16 max_rx_queues ;
   u8 pci_func ;
   u8 op_mode ;
};
struct qlcnic_pm_func_cfg {
   u8 pci_func ;
   u8 action ;
   u8 dest_npar ;
   u8 reserved[5U] ;
};
struct sensor_device_attribute {
   struct device_attribute dev_attr ;
   int index ;
};
enum hrtimer_restart;
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
struct qlcnic_83xx_dump_template_hdr {
   u32 type ;
   u32 offset ;
   u32 size ;
   u32 cap_mask ;
   u32 num_entries ;
   u32 version ;
   u32 timestamp ;
   u32 checksum ;
   u32 drv_cap_mask ;
   u32 sys_info[3U] ;
   u32 saved_state[16U] ;
   u32 cap_sizes[8U] ;
   u32 ocm_wnd_reg[16U] ;
   u32 rsvd[0U] ;
};
struct qlcnic_82xx_dump_template_hdr {
   u32 type ;
   u32 offset ;
   u32 size ;
   u32 cap_mask ;
   u32 num_entries ;
   u32 version ;
   u32 timestamp ;
   u32 checksum ;
   u32 drv_cap_mask ;
   u32 sys_info[3U] ;
   u32 saved_state[16U] ;
   u32 cap_sizes[8U] ;
   u32 rsvd[7U] ;
   u32 capabilities ;
   u32 rsvd1[0U] ;
};
struct qlcnic_pex_dma_descriptor {
   u32 read_data_size ;
   u32 dma_desc_cmd ;
   u32 src_addr_low ;
   u32 src_addr_high ;
   u32 dma_bus_addr_low ;
   u32 dma_bus_addr_high ;
   u32 rsvd[6U] ;
};
struct qlcnic_common_entry_hdr {
   u32 type ;
   u32 offset ;
   u32 cap_size ;
   u8 mask ;
   u8 rsvd[2U] ;
   u8 flags ;
};
struct __crb {
   u32 addr ;
   u8 stride ;
   u8 rsvd1[3U] ;
   u32 data_size ;
   u32 no_ops ;
   u32 rsvd2[4U] ;
};
struct __ctrl {
   u32 addr ;
   u8 stride ;
   u8 index_a ;
   u16 timeout ;
   u32 data_size ;
   u32 no_ops ;
   u8 opcode ;
   u8 index_v ;
   u8 shl_val ;
   u8 shr_val ;
   u32 val1 ;
   u32 val2 ;
   u32 val3 ;
};
struct __cache {
   u32 addr ;
   u16 stride ;
   u16 init_tag_val ;
   u32 size ;
   u32 no_ops ;
   u32 ctrl_addr ;
   u32 ctrl_val ;
   u32 read_addr ;
   u8 read_addr_stride ;
   u8 read_addr_num ;
   u8 rsvd1[2U] ;
};
struct __ocm {
   u8 rsvd[8U] ;
   u32 size ;
   u32 no_ops ;
   u8 rsvd1[8U] ;
   u32 read_addr ;
   u32 read_addr_stride ;
};
struct __mem {
   u32 desc_card_addr ;
   u32 dma_desc_cmd ;
   u32 start_dma_cmd ;
   u32 rsvd[3U] ;
   u32 addr ;
   u32 size ;
};
struct __mux {
   u32 addr ;
   u8 rsvd[4U] ;
   u32 size ;
   u32 no_ops ;
   u32 val ;
   u32 val_stride ;
   u32 read_addr ;
   u8 rsvd2[4U] ;
};
struct __queue {
   u32 sel_addr ;
   u16 stride ;
   u8 rsvd[2U] ;
   u32 size ;
   u32 no_ops ;
   u8 rsvd2[8U] ;
   u32 read_addr ;
   u8 read_addr_stride ;
   u8 read_addr_cnt ;
   u8 rsvd3[2U] ;
};
struct __pollrd {
   u32 sel_addr ;
   u32 read_addr ;
   u32 sel_val ;
   u16 sel_val_stride ;
   u16 no_ops ;
   u32 poll_wait ;
   u32 poll_mask ;
   u32 data_size ;
   u8 rsvd[4U] ;
};
struct __mux2 {
   u32 sel_addr1 ;
   u32 sel_addr2 ;
   u32 sel_val1 ;
   u32 sel_val2 ;
   u32 no_ops ;
   u32 sel_val_mask ;
   u32 read_addr ;
   u8 sel_val_stride ;
   u8 data_size ;
   u8 rsvd[2U] ;
};
struct __pollrdmwr {
   u32 addr1 ;
   u32 addr2 ;
   u32 val1 ;
   u32 val2 ;
   u32 poll_wait ;
   u32 poll_mask ;
   u32 mod_mask ;
   u32 data_size ;
};
union __anonunion_region_289 {
   struct __crb crb ;
   struct __cache cache ;
   struct __ocm ocm ;
   struct __mem mem ;
   struct __mux mux ;
   struct __queue que ;
   struct __ctrl ctrl ;
   struct __pollrdmwr pollrdmwr ;
   struct __mux2 mux2 ;
   struct __pollrd pollrd ;
};
struct qlcnic_dump_entry {
   struct qlcnic_common_entry_hdr hdr ;
   union __anonunion_region_289 region ;
};
enum qlcnic_minidump_opcode {
    QLCNIC_DUMP_NOP = 0,
    QLCNIC_DUMP_READ_CRB = 1,
    QLCNIC_DUMP_READ_MUX = 2,
    QLCNIC_DUMP_QUEUE = 3,
    QLCNIC_DUMP_BRD_CONFIG = 4,
    QLCNIC_DUMP_READ_OCM = 6,
    QLCNIC_DUMP_PEG_REG = 7,
    QLCNIC_DUMP_L1_DTAG = 8,
    QLCNIC_DUMP_L1_ITAG = 9,
    QLCNIC_DUMP_L1_DATA = 11,
    QLCNIC_DUMP_L1_INST = 12,
    QLCNIC_DUMP_L2_DTAG = 21,
    QLCNIC_DUMP_L2_ITAG = 22,
    QLCNIC_DUMP_L2_DATA = 23,
    QLCNIC_DUMP_L2_INST = 24,
    QLCNIC_DUMP_POLL_RD = 35,
    QLCNIC_READ_MUX2 = 36,
    QLCNIC_READ_POLLRDMWR = 37,
    QLCNIC_DUMP_READ_ROM = 71,
    QLCNIC_DUMP_READ_MEM = 72,
    QLCNIC_DUMP_READ_CTRL = 98,
    QLCNIC_DUMP_TLHDR = 99,
    QLCNIC_DUMP_RDEND = 255
} ;
struct qlcnic_dump_operations {
   enum qlcnic_minidump_opcode opcode ;
   u32 (*handler)(struct qlcnic_adapter * , struct qlcnic_dump_entry * , __le32 * ) ;
};
enum hrtimer_restart;
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
struct qlcnic_sds_mbx {
   u32 phy_addr_low ;
   u32 phy_addr_high ;
   u32 rsvd1[4U] ;
   u16 sds_ring_size ;
   u16 rsvd2 ;
   u16 rsvd3[2U] ;
   u16 intrpt_id ;
   u8 intrpt_val ;
   u8 rsvd4 ;
   u32 rsvd5 ;
};
struct qlcnic_rds_mbx {
   u32 phy_addr_reg_low ;
   u32 phy_addr_reg_high ;
   u32 phy_addr_jmb_low ;
   u32 phy_addr_jmb_high ;
   u16 reg_ring_sz ;
   u16 reg_ring_len ;
   u16 jmb_ring_sz ;
   u16 jmb_ring_len ;
};
struct __host_producer_mbx {
   u32 reg_buf ;
   u32 jmb_buf ;
};
struct qlcnic_rcv_mbx_out {
   u8 rcv_num ;
   u8 sts_num ;
   u16 ctx_id ;
   u8 state ;
   u8 num_pci_func ;
   u8 phy_port ;
   u8 vport_id ;
   u32 host_csmr[8U] ;
   struct __host_producer_mbx host_prod[8U] ;
};
struct qlcnic_add_rings_mbx_out {
   u8 rcv_num ;
   u8 sts_num ;
   u16 ctx_id ;
   u32 host_csmr[8U] ;
   struct __host_producer_mbx host_prod[8U] ;
};
struct qlcnic_tx_mbx {
   u32 phys_addr_low ;
   u32 phys_addr_high ;
   u32 cnsmr_index_low ;
   u32 cnsmr_index_high ;
   u16 size ;
   u16 intr_id ;
   u8 src ;
   u8 rsvd[3U] ;
};
struct qlcnic_tx_mbx_out {
   u32 host_prod ;
   u16 ctx_id ;
   u8 state ;
   u8 rsvd ;
};
struct qlcnic_macvlan_mbx {
   u8 mac_addr0 ;
   u8 mac_addr1 ;
   u8 mac_addr2 ;
   u8 mac_addr3 ;
   u8 mac_addr4 ;
   u8 mac_addr5 ;
   u16 vlan ;
};
enum hrtimer_restart;
struct qlc_83xx_reset_hdr {
   u16 version ;
   u16 signature ;
   u16 size ;
   u16 entries ;
   u16 hdr_size ;
   u16 checksum ;
   u16 init_offset ;
   u16 start_offset ;
};
struct qlc_83xx_entry_hdr {
   u16 cmd ;
   u16 size ;
   u16 count ;
   u16 delay ;
};
struct qlc_83xx_poll {
   u32 mask ;
   u32 status ;
};
struct qlc_83xx_rmw {
   u32 mask ;
   u32 xor_value ;
   u32 or_value ;
   u8 shl ;
   u8 shr ;
   u8 index_a ;
   u8 rsvd ;
};
struct qlc_83xx_entry {
   u32 arg1 ;
   u32 arg2 ;
};
struct qlc_83xx_quad_entry {
   u32 dr_addr ;
   u32 dr_value ;
   u32 ar_addr ;
   u32 ar_value ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum qlcnic_vlan_operations {
    QLC_VLAN_ADD = 0,
    QLC_VLAN_DELETE = 1
} ;
struct qlcnic_async_work_list {
   struct list_head list ;
   struct work_struct work ;
   void *ptr ;
   struct qlcnic_cmd_args *cmd ;
};
enum hrtimer_restart;
struct qlcnic_sriov_cmd_handler {
   int (*fn)(struct qlcnic_bc_trans * , struct qlcnic_cmd_args * ) ;
};
struct qlcnic_sriov_fw_cmd_handler {
   u32 cmd ;
   int (*fn)(struct qlcnic_bc_trans * , struct qlcnic_cmd_args * ) ;
};
enum hrtimer_restart;
struct qlcnic_dcb_capability {
   bool tsa_capability ;
   bool ets_capability ;
   u8 max_num_tc ;
   u8 max_ets_tc ;
   u8 max_pfc_tc ;
   u8 dcb_capability ;
};
struct qlcnic_dcb_param {
   u32 hdr_prio_pfc_map[2U] ;
   u32 prio_pg_map[2U] ;
   u32 pg_bw_map[2U] ;
   u32 pg_tsa_map[2U] ;
   u32 app[8U] ;
};
struct qlcnic_dcb_mbx_params {
   struct qlcnic_dcb_param type[3U] ;
   u32 prio_tc_map ;
};
struct qlcnic_82xx_dcb_param_mbx_le {
   __le32 hdr_prio_pfc_map[2U] ;
   __le32 prio_pg_map[2U] ;
   __le32 pg_bw_map[2U] ;
   __le32 pg_tsa_map[2U] ;
   __le32 app[8U] ;
};
enum qlcnic_dcb_selector {
    QLC_SELECTOR_DEF = 0,
    QLC_SELECTOR_ETHER = 1,
    QLC_SELECTOR_TCP = 2,
    QLC_SELECTOR_UDP = 3
} ;
enum qlcnic_dcb_prio_type {
    QLC_PRIO_NONE = 0,
    QLC_PRIO_GROUP = 1,
    QLC_PRIO_LINK = 2
} ;
enum qlcnic_dcb_pfc_type {
    QLC_PFC_DISABLED = 0,
    QLC_PFC_FULL = 1,
    QLC_PFC_TX = 2,
    QLC_PFC_RX = 3
} ;
struct qlcnic_dcb_prio_cfg {
   bool valid ;
   enum qlcnic_dcb_pfc_type pfc_type ;
};
struct qlcnic_dcb_pg_cfg {
   bool valid ;
   u8 total_bw_percent ;
   u8 prio_count ;
   u8 tsa_type ;
};
struct qlcnic_dcb_tc_cfg {
   bool valid ;
   struct qlcnic_dcb_prio_cfg prio_cfg[8U] ;
   enum qlcnic_dcb_prio_type prio_type ;
   u8 link_percent ;
   u8 bwg_percent ;
   u8 up_tc_map ;
   u8 pgid ;
};
struct qlcnic_dcb_app {
   bool valid ;
   enum qlcnic_dcb_selector selector ;
   u16 protocol ;
   u8 priority ;
};
struct qlcnic_dcb_cee {
   struct qlcnic_dcb_tc_cfg tc_cfg[8U] ;
   struct qlcnic_dcb_pg_cfg pg_cfg[8U] ;
   struct qlcnic_dcb_app app[8U] ;
   bool tc_param_valid ;
   bool pfc_mode_enable ;
};
struct qlcnic_dcb_cfg {
   struct qlcnic_dcb_cee type[3U] ;
   struct qlcnic_dcb_capability capability ;
   u32 version ;
};
typedef struct page___0 *pgtable_t___0;
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14126_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14120_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) * (sizeof(unsigned long )) ))) ;
enum kobj_ns_type;
struct attribute___0 {
   char const *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const * ,
                    size_t ) ;
};
struct kobject___0 {
   char const *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0 const *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const *(*namespace)(struct kobject___0 *kobj ) ;
};
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
long ldv__builtin_expect(long exp , long c ) ;
void ldv_spin_lock(void) ;
void ldv_spin_unlock(void) ;
__inline static void set_bit(long nr , unsigned long volatile *addr )
{
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile *)addr)): "Ir" (nr): "memory");
  return;
}
}
__inline static void clear_bit(long nr , unsigned long volatile *addr )
{
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile *)addr)): "Ir" (nr));
  return;
}
}
__inline static int test_and_clear_bit(long nr , unsigned long volatile *addr )
{
  char c ;
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
  return ((int )((signed char )c) != 0);
}
}
__inline static int constant_test_bit(long nr , unsigned long const volatile *addr )
{
  {
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
extern int printk(char const * , ...) ;
extern int __printk_ratelimit(char const * ) ;
extern void dump_stack(void) ;
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
__inline static void list_add_tail(struct list_head *new , struct list_head *head )
{
  {
  __list_add(new, head->prev, head);
  return;
}
}
extern void list_del(struct list_head * ) ;
__inline static int list_empty(struct list_head const *head )
{
  {
  return ((unsigned long )((struct list_head const *)head->next) == (unsigned long )head);
}
}
__inline static void __hlist_del(struct hlist_node *n )
{
  struct hlist_node *next ;
  struct hlist_node **pprev ;
  {
  next = n->next;
  pprev = n->pprev;
  *pprev = next;
  if ((unsigned long )next != (unsigned long )((struct hlist_node *)0)) {
    next->pprev = pprev;
  } else {
  }
  return;
}
}
__inline static void hlist_del(struct hlist_node *n )
{
  {
  __hlist_del(n);
  n->next = (struct hlist_node *)-2401263026317557504L;
  n->pprev = (struct hlist_node **)-2401263026316508672L;
  return;
}
}
extern void __bad_percpu_size(void) ;
extern void warn_slowpath_null(char const * , int const ) ;
extern void *memcpy(void * , void const * , size_t ) ;
extern void *memset(void * , int , size_t ) ;
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
extern unsigned long _raw_write_lock_irqsave(rwlock_t * ) ;
extern void _raw_write_unlock_irqrestore(rwlock_t * , unsigned long ) ;
__inline static void ldv_spin_lock_bh_2(spinlock_t *lock )
{
  {
  _raw_spin_lock_bh(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void ldv_spin_unlock_bh_6(spinlock_t *lock )
{
  {
  _raw_spin_unlock_bh(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
extern void mutex_lock_nested(struct mutex * , unsigned int ) ;
extern void mutex_unlock(struct mutex * ) ;
extern unsigned long volatile jiffies ;
__inline static unsigned int readl(void const volatile *addr )
{
  unsigned int ret ;
  {
  __asm__ volatile ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile *)addr)): "memory");
  return (ret);
}
}
__inline static void writel(unsigned int val , void volatile *addr )
{
  {
  __asm__ volatile ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile *)addr)): "memory");
  return;
}
}
__inline static unsigned long readq(void const volatile *addr )
{
  unsigned long ret ;
  {
  __asm__ volatile ("movq %1,%0": "=r" (ret): "m" (*((unsigned long volatile *)addr)): "memory");
  return (ret);
}
}
__inline static void writeq(unsigned long val , void volatile *addr )
{
  {
  __asm__ volatile ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile *)addr)): "memory");
  return;
}
}
extern int cpu_number ;
extern void __bad_size_call_parameter(void) ;
extern void kfree(void const * ) ;
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t ) ;
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_33(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
void ldv_check_alloc_flags(gfp_t flags ) ;
extern void *malloc(size_t size ) ;
extern void *calloc(size_t nmemb , size_t size ) ;
extern int __VERIFIER_nondet_int(void) ;
extern unsigned long __VERIFIER_nondet_ulong(void) ;
extern void *__VERIFIER_nondet_pointer(void) ;
extern void __VERIFIER_assume(int expression ) ;
void *ldv_malloc(size_t size )
{
  void *p ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = malloc(size);
    p = tmp;
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
void *ldv_zalloc(size_t size )
{
  void *p ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = calloc(1UL, size);
    p = tmp;
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
int ldv_undef_int(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  return (tmp);
}
}
void *ldv_undef_ptr(void)
{
  void *tmp ;
  {
  tmp = __VERIFIER_nondet_pointer();
  return (tmp);
}
}
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp ;
  {
  tmp = __VERIFIER_nondet_ulong();
  return (tmp);
}
}
__inline static void ldv_error(void)
{
  {
  ERROR: ;
  __VERIFIER_error();
}
}
long ldv__builtin_expect(long exp , long c )
{
  {
  return (exp);
}
}
void ldv__builtin_trap(void)
{
  {
  ldv_error();
  return;
}
}
int LDV_IN_INTERRUPT = 1;
__inline static void *dev_get_drvdata(struct device const *dev )
{
  {
  return ((void *)dev->driver_data);
}
}
extern int dev_err(struct device const * , char const * , ...) ;
extern int dev_warn(struct device const * , char const * , ...) ;
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int , int , u32 * ) ;
__inline static int pci_read_config_dword(struct pci_dev const *dev , int where ,
                                          u32 *val )
{
  int tmp ;
  {
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
extern int pci_save_state(struct pci_dev * ) ;
extern int __pci_enable_wake(struct pci_dev * , pci_power_t , bool , bool ) ;
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable )
{
  int tmp ;
  {
  tmp = __pci_enable_wake(dev, state, 0, (int )enable);
  return (tmp);
}
}
__inline static void *pci_get_drvdata(struct pci_dev *pdev )
{
  void *tmp ;
  {
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  return (tmp);
}
}
extern void msleep(unsigned int ) ;
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t ) ;
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
extern struct sk_buff *skb_copy(struct sk_buff const * , gfp_t ) ;
struct sk_buff *ldv_skb_copy_26(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
extern int pskb_expand_head(struct sk_buff * , int , int , gfp_t ) ;
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int , gfp_t ) ;
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
__inline static void *netdev_priv(struct net_device const *dev )
{
  {
  return ((void *)dev + 3264U);
}
}
extern void __netif_schedule(struct Qdisc * ) ;
__inline static void netif_tx_wake_queue(struct netdev_queue *dev_queue )
{
  int tmp ;
  {
  tmp = test_and_clear_bit(0L, (unsigned long volatile *)(& dev_queue->state));
  if (tmp != 0) {
    __netif_schedule(dev_queue->qdisc);
  } else {
  }
  return;
}
}
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue )
{
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  {
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("include/linux/netdevice.h", 2212);
  } else {
  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
    return;
  } else {
  }
  set_bit(0L, (unsigned long volatile *)(& dev_queue->state));
  return;
}
}
__inline static bool netif_running(struct net_device const *dev )
{
  int tmp ;
  {
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& dev->state));
  return (tmp != 0);
}
}
extern void netif_device_detach(struct net_device * ) ;
extern void netif_device_attach(struct net_device * ) ;
__inline static void __netif_tx_lock_bh(struct netdev_queue *txq )
{
  int pscr_ret__ ;
  void const *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  {
  spin_lock_bh(& txq->_xmit_lock);
  __vpp_verify = (void const *)0;
  switch (4UL) {
  case 1UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
  goto ldv_42893;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_42893;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_42893;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_42893;
  default:
  __bad_percpu_size();
  }
  ldv_42893:
  pscr_ret__ = pfo_ret__;
  goto ldv_42899;
  case 2UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_42903;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_42903;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_42903;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_42903;
  default:
  __bad_percpu_size();
  }
  ldv_42903:
  pscr_ret__ = pfo_ret_____0;
  goto ldv_42899;
  case 4UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_42912;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_42912;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_42912;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_42912;
  default:
  __bad_percpu_size();
  }
  ldv_42912:
  pscr_ret__ = pfo_ret_____1;
  goto ldv_42899;
  case 8UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_42921;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_42921;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_42921;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_42921;
  default:
  __bad_percpu_size();
  }
  ldv_42921:
  pscr_ret__ = pfo_ret_____2;
  goto ldv_42899;
  default:
  __bad_size_call_parameter();
  goto ldv_42899;
  }
  ldv_42899:
  txq->xmit_lock_owner = pscr_ret__;
  return;
}
}
__inline static void __netif_tx_unlock_bh(struct netdev_queue *txq )
{
  {
  txq->xmit_lock_owner = -1;
  spin_unlock_bh(& txq->_xmit_lock);
  return;
}
}
extern int netdev_err(struct net_device const * , char const * , ...) ;
__inline static bool ether_addr_equal(u8 const *addr1 , u8 const *addr2 )
{
  u32 fold ;
  {
  fold = ((unsigned int )*((u32 const *)addr1) ^ (unsigned int )*((u32 const *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const *)addr2 + 4U)));
  return (fold == 0U);
}
}
int qlcnic_82xx_hw_read_wx_2M(struct qlcnic_adapter *adapter , ulong off , int *err ) ;
int qlcnic_82xx_hw_write_wx_2M(struct qlcnic_adapter *adapter , ulong off , u32 data ) ;
int qlcnic_82xx_config_hw_lro(struct qlcnic_adapter *adapter , int enable ) ;
int qlcnic_82xx_nic_set_promisc(struct qlcnic_adapter *adapter , u32 mode ) ;
void qlcnic_82xx_get_beacon_state(struct qlcnic_adapter *adapter ) ;
int qlcnic_82xx_config_intr_coalesce(struct qlcnic_adapter *adapter , struct ethtool_coalesce *ethcoal ) ;
int qlcnic_82xx_set_rx_coalesce(struct qlcnic_adapter *adapter ) ;
int qlcnic_82xx_config_rss(struct qlcnic_adapter *adapter , int enable ) ;
void qlcnic_82xx_config_ipaddr(struct qlcnic_adapter *adapter , __be32 ip , int cmd ) ;
int qlcnic_82xx_linkevent_request(struct qlcnic_adapter *adapter , int enable ) ;
int qlcnic_82xx_clear_lb_mode(struct qlcnic_adapter *adapter , u8 mode ) ;
int qlcnic_82xx_set_lb_mode(struct qlcnic_adapter *adapter , u8 mode ) ;
void qlcnic_82xx_write_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                           size_t size ) ;
void qlcnic_82xx_read_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                          size_t size ) ;
int qlcnic_82xx_sre_macaddr_change(struct qlcnic_adapter *adapter , u8 *addr , u16 vlan_id ,
                                   u8 op ) ;
int qlcnic_82xx_get_board_info(struct qlcnic_adapter *adapter ) ;
int qlcnic_82xx_config_led(struct qlcnic_adapter *adapter , u32 state , u32 rate ) ;
void qlcnic_82xx_get_func_no(struct qlcnic_adapter *adapter ) ;
int qlcnic_82xx_api_lock(struct qlcnic_adapter *adapter ) ;
void qlcnic_82xx_api_unlock(struct qlcnic_adapter *adapter ) ;
int qlcnic_82xx_shutdown(struct pci_dev *pdev ) ;
int qlcnic_82xx_resume(struct qlcnic_adapter *adapter ) ;
void qlcnic_clr_all_drv_state(struct qlcnic_adapter *adapter , u8 failed ) ;
void qlcnic_fw_poll_work(struct work_struct *work ) ;
int qlcnic_83xx_wrt_reg_indirect(struct qlcnic_adapter *adapter , ulong addr , u32 data ) ;
int qlcnic_ind_wr(struct qlcnic_adapter *adapter , u32 addr , u32 data ) ;
int qlcnic_ind_rd(struct qlcnic_adapter *adapter , u32 addr ) ;
void qlcnic_free_mbx_args(struct qlcnic_cmd_args *cmd ) ;
int qlcnic_pci_mem_write_2M(struct qlcnic_adapter *adapter , u64 off , u64 data ) ;
int qlcnic_pci_mem_read_2M(struct qlcnic_adapter *adapter , u64 off , u64 *data ) ;
int qlcnic_pcie_sem_lock(struct qlcnic_adapter *adapter , int sem , u32 id_reg ) ;
void qlcnic_pcie_sem_unlock(struct qlcnic_adapter *adapter , int sem ) ;
void qlcnic_prune_lb_filters(struct qlcnic_adapter *adapter ) ;
void qlcnic_delete_lb_filters(struct qlcnic_adapter *adapter ) ;
void qlcnic_schedule_work(struct qlcnic_adapter *adapter , void (*func)(struct work_struct * ) ,
                          int delay ) ;
int qlcnic_rom_fast_read(struct qlcnic_adapter *adapter , u32 addr , u32 *valp ) ;
void *qlcnic_get_ioaddr(struct qlcnic_hardware_context *ahw , u32 offset ) ;
void qlcnic_set_multi(struct net_device *netdev ) ;
int qlcnic_nic_add_mac(struct qlcnic_adapter *adapter , u8 const *addr , u16 vlan ) ;
int qlcnic_nic_del_mac(struct qlcnic_adapter *adapter , u8 const *addr ) ;
void qlcnic_82xx_free_mac_list(struct qlcnic_adapter *adapter ) ;
int qlcnic_82xx_read_phys_port_id(struct qlcnic_adapter *adapter ) ;
int qlcnic_fw_cmd_set_mtu(struct qlcnic_adapter *adapter , int mtu ) ;
int qlcnic_change_mtu(struct net_device *netdev , int mtu ) ;
netdev_features_t qlcnic_fix_features(struct net_device *netdev , netdev_features_t features ) ;
int qlcnic_set_features(struct net_device *netdev , netdev_features_t features ) ;
int qlcnic_config_bridged_mode(struct qlcnic_adapter *adapter , u32 enable ) ;
extern void qlcnic_update_cmd_producer(struct qlcnic_host_tx_ring * ) ;
void qlcnic_alloc_lb_filters_mem(struct qlcnic_adapter *adapter ) ;
void qlcnic_down(struct qlcnic_adapter *adapter , struct net_device *netdev ) ;
int qlcnic_up(struct qlcnic_adapter *adapter , struct net_device *netdev ) ;
void qlcnic_restore_indev_addr(struct net_device *netdev , unsigned long event ) ;
void qlcnic_sriov_vf_set_multi(struct net_device *netdev ) ;
__inline static u32 qlcnic_tx_avail(struct qlcnic_host_tx_ring *tx_ring )
{
  long tmp ;
  {
  tmp = ldv__builtin_expect(tx_ring->producer < tx_ring->sw_consumer, 1L);
  if (tmp != 0L) {
    return (tx_ring->sw_consumer - tx_ring->producer);
  } else {
    return ((tx_ring->sw_consumer + tx_ring->num_desc) - tx_ring->producer);
  }
}
}
__inline static int qlcnic_start_firmware(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = (*((adapter->nic_ops)->start_firmware))(adapter);
  return (tmp);
}
}
__inline static int qlcnic_get_mac_address(struct qlcnic_adapter *adapter , u8 *mac ,
                                           u8 function )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->get_mac_address))(adapter, mac, (int )function);
  return (tmp);
}
}
__inline static int qlcnic_alloc_mbx_args(struct qlcnic_cmd_args *mbx , struct qlcnic_adapter *adapter ,
                                          u32 arg )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->alloc_mbx_args))(mbx, adapter, arg);
  return (tmp);
}
}
__inline static int qlcnic_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  int tmp ;
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->mbx_cmd != (unsigned long )((int (*)(struct qlcnic_adapter * ,
                                                                                     struct qlcnic_cmd_args * ))0)) {
    tmp = (*(((adapter->ahw)->hw_ops)->mbx_cmd))(adapter, cmd);
    return (tmp);
  } else {
  }
  return (-5);
}
}
__inline static int qlcnic_sre_macaddr_change(struct qlcnic_adapter *adapter , u8 *addr ,
                                              u16 id , u8 cmd )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->change_macvlan))(adapter, addr, (int )id, (int )cmd);
  return (tmp);
}
}
__inline static int qlcnic_config_hw_lro(struct qlcnic_adapter *adapter , int enable )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->config_hw_lro))(adapter, enable);
  return (tmp);
}
}
__inline static int qlcnic_nic_set_promisc(struct qlcnic_adapter *adapter , u32 mode )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->config_promisc_mode))(adapter, mode);
  return (tmp);
}
}
__inline static void qlcnic_cancel_idc_work(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned long )(adapter->nic_ops)->cancel_idc_work != (unsigned long )((void (*)(struct qlcnic_adapter * ))0)) {
    (*((adapter->nic_ops)->cancel_idc_work))(adapter);
  } else {
  }
  return;
}
}
__inline static bool qlcnic_82xx_check(struct qlcnic_adapter *adapter )
{
  unsigned short device ;
  {
  device = (adapter->pdev)->device;
  return ((unsigned int )device == 32800U);
}
}
__inline static bool qlcnic_sriov_vf_check(struct qlcnic_adapter *adapter )
{
  unsigned short device ;
  bool status ;
  {
  device = (adapter->pdev)->device;
  status = (bool )((unsigned int )device == 33840U || (unsigned int )device == 33856U);
  return (status);
}
}
static struct crb_128M_2M_block_map crb_128M_2M_map[64U] =
  { {{{0U, 0U, 0U, 0U}}},
        {{{1U, 1048576U, 1056768U, 1179648U}, {1U, 1114112U, 1179648U, 1245184U}, {1U,
                                                                                1179648U,
                                                                                1187840U,
                                                                                1196032U},
       {1U, 1245184U, 1253376U, 1204224U}, {1U, 1310720U, 1318912U, 1212416U}, {1U,
                                                                                1376256U,
                                                                                1384448U,
                                                                                1220608U},
       {1U, 1441792U, 1507328U, 1114112U}, {1U, 1507328U, 1515520U, 1236992U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {1U, 1966080U, 1968128U, 1187840U}, {0U, 0U, 0U, 0U}}},
        {{{1U, 2097152U, 2162688U, 1572864U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{1U, 4194304U, 4198400U, 1478656U}}},
        {{{1U, 5242880U, 5308416U, 1310720U}}},
        {{{1U, 6291456U, 6356992U, 1835008U}}},
        {{{1U, 7340032U, 7356416U, 1802240U}}},
        {{{1U, 8388608U, 8396800U, 1507328U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 9371648U, 9379840U, 1515520U}}},
        {{{1U, 9437184U, 9445376U, 1523712U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 10420224U, 10428416U, 1531904U}}},
        {{{0U, 10485760U, 10493952U, 1540096U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 11468800U, 11476992U, 1548288U}}},
        {{{0U, 11534336U, 11542528U, 1556480U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {1U, 12517376U, 12525568U, 1564672U}}},
        {{{1U, 12582912U, 12599296U, 1916928U}}},
        {{{1U, 13631488U, 13647872U, 1720320U}}},
        {{{1U, 14680064U, 14696448U, 1703936U}}},
        {{{1U, 15728640U, 15732736U, 1458176U}}},
        {{{0U, 16777216U, 16793600U, 1736704U}}},
        {{{1U, 17825792U, 17829888U, 1441792U}}},
        {{{1U, 18874368U, 18878464U, 1445888U}}},
        {{{1U, 19922944U, 19927040U, 1449984U}}},
        {{{1U, 20971520U, 20975616U, 1454080U}}},
        {{{1U, 22020096U, 22024192U, 1462272U}}},
        {{{1U, 23068672U, 23072768U, 1466368U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{1U, 30408704U, 30474240U, 1638400U}}},
        {{{1U, 31457280U, 31461376U, 1482752U}}},
        {{{1U, 32505856U, 32571392U, 1376256U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{1U, 34603008U, 34611200U, 1179648U}, {1U, 34668544U, 34734080U, 1245184U},
       {1U, 34734080U, 34742272U, 1196032U}, {1U, 34799616U, 34807808U, 1204224U},
       {1U, 34865152U, 34873344U, 1212416U}, {1U, 34930688U, 34938880U, 1220608U},
       {1U, 34996224U, 35061760U, 1114112U}, {1U, 35061760U, 35069952U, 1236992U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U,
                                                                                0U,
                                                                                0U,
                                                                                0U},
       {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U}}},
        {{{1U, 35651584U, 35667968U, 1769472U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{1U, 41943040U, 41959424U, 1720320U}}},
        {{{1U, 42991616U, 42995712U, 1486848U}}},
        {{{1U, 44040192U, 44041216U, 1754112U}}},
        {{{1U, 45088768U, 45089792U, 1755136U}}},
        {{{1U, 46137344U, 46138368U, 1756160U}}},
        {{{1U, 47185920U, 47186944U, 1757184U}}},
        {{{1U, 48234496U, 48235520U, 1758208U}}},
        {{{1U, 49283072U, 49284096U, 1759232U}}},
        {{{1U, 50331648U, 50332672U, 1760256U}}},
        {{{0U, 51380224U, 51396608U, 1736704U}}},
        {{{1U, 52428800U, 52445184U, 1916928U}}},
        {{{1U, 53477376U, 53493760U, 1703936U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{1U, 55574528U, 55575552U, 1753088U}}},
        {{{1U, 56623104U, 56624128U, 1761280U}}},
        {{{1U, 57671680U, 57672704U, 1762304U}}},
        {{{1U, 58720256U, 58736640U, 1900544U}}},
        {{{1U, 59768832U, 59785216U, 1785856U}}},
        {{{1U, 60817408U, 60833792U, 1933312U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{0U, 0U, 0U, 0U}}},
        {{{1U, 63963136U, 63979520U, 1933312U}}},
        {{{1U, 65011712U, 65015808U, 1470464U}}},
        {{{1U, 66060288U, 66064384U, 1474560U}}}};
static unsigned int const crb_hub_agt[64U] =
  { 0U, 1907U, 661U, 677U,
        0U, 208U, 433U, 230U,
        224U, 225U, 226U, 227U,
        1056U, 1047U, 1057U, 843U,
        1029U, 832U, 833U, 834U,
        835U, 837U, 836U, 960U,
        961U, 962U, 963U, 0U,
        964U, 1040U, 0U, 209U,
        0U, 1907U, 1046U, 0U,
        0U, 0U, 0U, 0U,
        1047U, 0U, 137U, 1802U,
        1803U, 1804U, 141U, 142U,
        1807U, 1029U, 1056U, 1057U,
        0U, 136U, 145U, 1810U,
        1030U, 0U, 1816U, 409U,
        425U, 0U, 838U, 0U};
static void qlcnic_read_window_reg(u32 addr , void *bar0 , u32 *data )
{
  u32 dest ;
  void *val ;
  {
  dest = addr & 4294901760U;
  val = bar0 + 1245280UL;
  writel(dest, (void volatile *)val);
  readl((void const volatile *)val);
  val = bar0 + ((unsigned long )((unsigned short )addr) + 1966080UL);
  *data = readl((void const volatile *)val);
  return;
}
}
static void qlcnic_write_window_reg(u32 addr , void *bar0 , u32 data )
{
  u32 dest ;
  void *val ;
  {
  dest = addr & 4294901760U;
  val = bar0 + 1245280UL;
  writel(dest, (void volatile *)val);
  readl((void const volatile *)val);
  val = bar0 + ((unsigned long )((unsigned short )addr) + 1966080UL);
  writel(data, (void volatile *)val);
  readl((void const volatile *)val);
  return;
}
}
int qlcnic_pcie_sem_lock(struct qlcnic_adapter *adapter , int sem , u32 id_reg )
{
  int timeout ;
  int err ;
  int done ;
  {
  timeout = 0;
  err = 0;
  done = 0;
  goto ldv_52835;
  ldv_52834:
  done = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (unsigned long )((sem + 14336) * 8) + 101711872UL,
                                                 & err);
  if (done == 1) {
    goto ldv_52833;
  } else {
  }
  timeout = timeout + 1;
  if (timeout > 9999) {
    if (id_reg != 0U) {
      done = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )id_reg, & err);
      if (done != -1) {
        dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to acquire sem=%d lock held by=%d\n",
                sem, done);
      } else {
        dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to acquire sem=%d lock",
                sem);
      }
    } else {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to acquire sem=%d lock",
              sem);
    }
    return (-5);
  } else {
  }
  msleep(1U);
  ldv_52835: ;
  if (done == 0) {
    goto ldv_52834;
  } else {
  }
  ldv_52833: ;
  if (id_reg != 0U) {
    (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (ulong )id_reg, (u32 )adapter->portnum);
  } else {
  }
  return (0);
}
}
void qlcnic_pcie_sem_unlock(struct qlcnic_adapter *adapter , int sem )
{
  int err ;
  {
  err = 0;
  (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (unsigned long )(sem * 8 + 114692) + 101711872UL,
                                          & err);
  return;
}
}
int qlcnic_ind_rd(struct qlcnic_adapter *adapter , u32 addr )
{
  int err ;
  u32 data ;
  int tmp ;
  bool tmp___0 ;
  {
  err = 0;
  tmp___0 = qlcnic_82xx_check(adapter);
  if ((int )tmp___0) {
    qlcnic_read_window_reg(addr, (adapter->ahw)->pci_base0, & data);
  } else {
    tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )addr, & err);
    data = (u32 )tmp;
    if (err == -5) {
      return (err);
    } else {
    }
  }
  return ((int )data);
}
}
int qlcnic_ind_wr(struct qlcnic_adapter *adapter , u32 addr , u32 data )
{
  int ret ;
  bool tmp ;
  {
  ret = 0;
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    qlcnic_write_window_reg(addr, (adapter->ahw)->pci_base0, data);
  } else {
    ret = qlcnic_83xx_wrt_reg_indirect(adapter, (ulong )addr, data);
  }
  return (ret);
}
}
static int qlcnic_send_cmd_descs(struct qlcnic_adapter *adapter , struct cmd_desc_type0 *cmd_desc_arr ,
                                 int nr_desc )
{
  u32 i ;
  u32 producer ;
  struct qlcnic_cmd_buffer *pbuf ;
  struct cmd_desc_type0 *cmd_desc ;
  struct qlcnic_host_tx_ring *tx_ring ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  size_t __len ;
  void *__ret ;
  {
  i = 0U;
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& adapter->state));
  if (tmp == 0) {
    return (-5);
  } else {
  }
  tx_ring = adapter->tx_ring;
  __netif_tx_lock_bh(tx_ring->txq);
  producer = tx_ring->producer;
  tmp___2 = qlcnic_tx_avail(tx_ring);
  if ((u32 )nr_desc >= tmp___2) {
    netif_tx_stop_queue(tx_ring->txq);
    __asm__ volatile ("mfence": : : "memory");
    tmp___1 = qlcnic_tx_avail(tx_ring);
    if (tmp___1 > (u32 )nr_desc) {
      tmp___0 = qlcnic_tx_avail(tx_ring);
      if (tmp___0 > 10U) {
        netif_tx_wake_queue(tx_ring->txq);
      } else {
      }
    } else {
      adapter->stats.xmit_off = adapter->stats.xmit_off + 1ULL;
      __netif_tx_unlock_bh(tx_ring->txq);
      return (-16);
    }
  } else {
  }
  ldv_52866:
  cmd_desc = cmd_desc_arr + (unsigned long )i;
  pbuf = tx_ring->cmd_buf_arr + (unsigned long )producer;
  pbuf->skb = (struct sk_buff *)0;
  pbuf->frag_count = 0U;
  __len = 64UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)tx_ring->desc_head + (unsigned long )producer, (void const *)cmd_desc,
                     __len);
  } else {
    __ret = memcpy((void *)tx_ring->desc_head + (unsigned long )producer,
                             (void const *)cmd_desc, __len);
  }
  producer = (producer + 1U) & (tx_ring->num_desc - 1U);
  i = i + 1U;
  if ((u32 )nr_desc != i) {
    goto ldv_52866;
  } else {
  }
  tx_ring->producer = producer;
  qlcnic_update_cmd_producer(tx_ring);
  __netif_tx_unlock_bh(tx_ring->txq);
  return (0);
}
}
int qlcnic_82xx_sre_macaddr_change(struct qlcnic_adapter *adapter , u8 *addr , u16 vlan_id ,
                                   u8 op )
{
  struct qlcnic_nic_req req ;
  struct qlcnic_mac_req *mac_req ;
  struct qlcnic_vlan_req *vlan_req ;
  u64 word ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  {
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 167772160ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 1ULL;
  req.req_hdr = word;
  mac_req = (struct qlcnic_mac_req *)(& req.words);
  mac_req->op = op;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& mac_req->mac_addr), (void const *)addr, __len);
  } else {
    __ret = memcpy((void *)(& mac_req->mac_addr), (void const *)addr,
                             __len);
  }
  vlan_req = (struct qlcnic_vlan_req *)(& req.words) + 1U;
  vlan_req->vlan_id = vlan_id;
  tmp = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  return (tmp);
}
}
int qlcnic_nic_del_mac(struct qlcnic_adapter *adapter , u8 const *addr )
{
  struct qlcnic_mac_vlan_list *cur ;
  struct list_head *head ;
  int err ;
  struct list_head const *__mptr ;
  bool tmp ;
  {
  err = -22;
  head = adapter->mac_list.next;
  goto ldv_52891;
  ldv_52890:
  __mptr = (struct list_head const *)head;
  cur = (struct qlcnic_mac_vlan_list *)__mptr;
  tmp = ether_addr_equal(addr, (u8 const *)(& cur->mac_addr));
  if ((int )tmp) {
    err = qlcnic_sre_macaddr_change(adapter, (u8 *)(& cur->mac_addr), 0, 2);
    if (err != 0) {
      return (err);
    } else {
    }
    list_del(& cur->list);
    kfree((void const *)cur);
    return (err);
  } else {
  }
  head = head->next;
  ldv_52891: ;
  if ((unsigned long )(& adapter->mac_list) != (unsigned long )head) {
    goto ldv_52890;
  } else {
  }
  return (err);
}
}
int qlcnic_nic_add_mac(struct qlcnic_adapter *adapter , u8 const *addr , u16 vlan )
{
  struct qlcnic_mac_vlan_list *cur ;
  struct list_head *head ;
  struct list_head const *__mptr ;
  bool tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  {
  head = adapter->mac_list.next;
  goto ldv_52903;
  ldv_52902:
  __mptr = (struct list_head const *)head;
  cur = (struct qlcnic_mac_vlan_list *)__mptr;
  tmp = ether_addr_equal(addr, (u8 const *)(& cur->mac_addr));
  if ((int )tmp && (int )cur->vlan_id == (int )vlan) {
    return (0);
  } else {
  }
  head = head->next;
  ldv_52903: ;
  if ((unsigned long )(& adapter->mac_list) != (unsigned long )head) {
    goto ldv_52902;
  } else {
  }
  tmp___0 = kzalloc(32UL, 32U);
  cur = (struct qlcnic_mac_vlan_list *)tmp___0;
  if ((unsigned long )cur == (unsigned long )((struct qlcnic_mac_vlan_list *)0)) {
    return (-12);
  } else {
  }
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& cur->mac_addr), (void const *)addr, __len);
  } else {
    __ret = memcpy((void *)(& cur->mac_addr), (void const *)addr, __len);
  }
  tmp___1 = qlcnic_sre_macaddr_change(adapter, (u8 *)(& cur->mac_addr), (int )vlan,
                                      1);
  if (tmp___1 != 0) {
    kfree((void const *)cur);
    return (-5);
  } else {
  }
  cur->vlan_id = vlan;
  list_add_tail(& cur->list, & adapter->mac_list);
  return (0);
}
}
static void __qlcnic_set_multi(struct net_device *netdev , u16 vlan )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  struct netdev_hw_addr *ha ;
  u8 bcast_addr[6U] ;
  u32 mode ;
  int tmp___0 ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  bcast_addr[0] = 255U;
  bcast_addr[1] = 255U;
  bcast_addr[2] = 255U;
  bcast_addr[3] = 255U;
  bcast_addr[4] = 255U;
  bcast_addr[5] = 255U;
  mode = 0U;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    return;
  } else {
  }
  qlcnic_nic_add_mac(adapter, (u8 const *)(& adapter->mac_addr), (int )vlan);
  qlcnic_nic_add_mac(adapter, (u8 const *)(& bcast_addr), (int )vlan);
  if ((netdev->flags & 256U) != 0U) {
    if ((adapter->flags & 2048U) == 0U) {
      mode = 1U;
    } else {
    }
  } else
  if ((netdev->flags & 512U) != 0U || netdev->mc.count > (int )ahw->max_mc_count) {
    mode = 2U;
  } else
  if (netdev->mc.count != 0) {
    __mptr = (struct list_head const *)netdev->mc.list.next;
    ha = (struct netdev_hw_addr *)__mptr;
    goto ldv_52922;
    ldv_52921:
    qlcnic_nic_add_mac(adapter, (u8 const *)(& ha->addr), (int )vlan);
    __mptr___0 = (struct list_head const *)ha->list.next;
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_52922: ;
    if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->mc.list)) {
      goto ldv_52921;
    } else {
    }
  } else {
  }
  if (netdev->uc.count > (int )ahw->max_uc_count) {
    mode = 1U;
  } else
  if (netdev->uc.count != 0) {
    __mptr___1 = (struct list_head const *)netdev->uc.list.next;
    ha = (struct netdev_hw_addr *)__mptr___1;
    goto ldv_52929;
    ldv_52928:
    qlcnic_nic_add_mac(adapter, (u8 const *)(& ha->addr), (int )vlan);
    __mptr___2 = (struct list_head const *)ha->list.next;
    ha = (struct netdev_hw_addr *)__mptr___2;
    ldv_52929: ;
    if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->uc.list)) {
      goto ldv_52928;
    } else {
    }
  } else {
  }
  if (mode == 1U && ! adapter->fdb_mac_learn) {
    qlcnic_alloc_lb_filters_mem(adapter);
    adapter->drv_mac_learn = 1;
    if ((adapter->flags & 64U) != 0U) {
      adapter->rx_mac_learn = 1;
    } else {
    }
  } else {
    adapter->drv_mac_learn = 0;
    adapter->rx_mac_learn = 0;
  }
  qlcnic_nic_set_promisc(adapter, mode);
  return;
}
}
void qlcnic_set_multi(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    return;
  } else {
  }
  tmp___1 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___1) {
    qlcnic_sriov_vf_set_multi(netdev);
  } else {
    __qlcnic_set_multi(netdev, 0);
  }
  return;
}
}
int qlcnic_82xx_nic_set_promisc(struct qlcnic_adapter *adapter , u32 mode )
{
  struct qlcnic_nic_req req ;
  u64 word ;
  int tmp ;
  {
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 12ULL;
  req.req_hdr = word;
  req.words[0] = (unsigned long long )mode;
  tmp = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  return (tmp);
}
}
void qlcnic_82xx_free_mac_list(struct qlcnic_adapter *adapter )
{
  struct list_head *head ;
  struct qlcnic_mac_vlan_list *cur ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  head = & adapter->mac_list;
  goto ldv_52949;
  ldv_52948:
  __mptr = (struct list_head const *)head->next;
  cur = (struct qlcnic_mac_vlan_list *)__mptr;
  qlcnic_sre_macaddr_change(adapter, (u8 *)(& cur->mac_addr), 0, 2);
  list_del(& cur->list);
  kfree((void const *)cur);
  ldv_52949:
  tmp = list_empty((struct list_head const *)head);
  if (tmp == 0) {
    goto ldv_52948;
  } else {
  }
  return;
}
}
void qlcnic_prune_lb_filters(struct qlcnic_adapter *adapter )
{
  struct qlcnic_filter *tmp_fil ;
  struct hlist_node *n ;
  struct hlist_head *head ;
  int i ;
  unsigned long expires ;
  u8 cmd ;
  struct hlist_node *____ptr ;
  struct hlist_node const *__mptr ;
  struct qlcnic_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node const *__mptr___0 ;
  struct qlcnic_filter *tmp___0 ;
  struct hlist_node *____ptr___1 ;
  struct hlist_node const *__mptr___1 ;
  struct qlcnic_filter *tmp___1 ;
  struct hlist_node *____ptr___2 ;
  struct hlist_node const *__mptr___2 ;
  struct qlcnic_filter *tmp___2 ;
  {
  i = 0;
  goto ldv_52979;
  ldv_52978:
  head = adapter->fhash.fhead + (unsigned long )i;
  ____ptr = head->first;
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
    __mptr = (struct hlist_node const *)____ptr;
    tmp = (struct qlcnic_filter *)__mptr;
  } else {
    tmp = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp;
  goto ldv_52976;
  ldv_52975:
  cmd = (unsigned int )tmp_fil->vlan_id != 0U ? 4U : 2U;
  expires = tmp_fil->ftime + 20000UL;
  if ((long )(expires - (unsigned long )jiffies) < 0L) {
    qlcnic_sre_macaddr_change(adapter, (u8 *)(& tmp_fil->faddr), (int )tmp_fil->vlan_id,
                              (int )cmd);
    spin_lock_bh(& adapter->mac_learn_lock);
    adapter->fhash.fnum = (u8 )((int )adapter->fhash.fnum - 1);
    hlist_del(& tmp_fil->fnode);
    spin_unlock_bh(& adapter->mac_learn_lock);
    kfree((void const *)tmp_fil);
  } else {
  }
  ____ptr___0 = n;
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
    __mptr___0 = (struct hlist_node const *)____ptr___0;
    tmp___0 = (struct qlcnic_filter *)__mptr___0;
  } else {
    tmp___0 = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp___0;
  ldv_52976: ;
  if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
    n = tmp_fil->fnode.next;
    goto ldv_52975;
  } else {
  }
  i = i + 1;
  ldv_52979: ;
  if ((int )adapter->fhash.fbucket_size > i) {
    goto ldv_52978;
  } else {
  }
  i = 0;
  goto ldv_53000;
  ldv_52999:
  head = adapter->rx_fhash.fhead + (unsigned long )i;
  ____ptr___1 = head->first;
  if ((unsigned long )____ptr___1 != (unsigned long )((struct hlist_node *)0)) {
    __mptr___1 = (struct hlist_node const *)____ptr___1;
    tmp___1 = (struct qlcnic_filter *)__mptr___1;
  } else {
    tmp___1 = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp___1;
  goto ldv_52997;
  ldv_52996:
  expires = tmp_fil->ftime + 20000UL;
  if ((long )(expires - (unsigned long )jiffies) < 0L) {
    spin_lock_bh(& adapter->rx_mac_learn_lock);
    adapter->rx_fhash.fnum = (u8 )((int )adapter->rx_fhash.fnum - 1);
    hlist_del(& tmp_fil->fnode);
    spin_unlock_bh(& adapter->rx_mac_learn_lock);
    kfree((void const *)tmp_fil);
  } else {
  }
  ____ptr___2 = n;
  if ((unsigned long )____ptr___2 != (unsigned long )((struct hlist_node *)0)) {
    __mptr___2 = (struct hlist_node const *)____ptr___2;
    tmp___2 = (struct qlcnic_filter *)__mptr___2;
  } else {
    tmp___2 = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp___2;
  ldv_52997: ;
  if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
    n = tmp_fil->fnode.next;
    goto ldv_52996;
  } else {
  }
  i = i + 1;
  ldv_53000: ;
  if ((int )adapter->rx_fhash.fbucket_size > i) {
    goto ldv_52999;
  } else {
  }
  return;
}
}
void qlcnic_delete_lb_filters(struct qlcnic_adapter *adapter )
{
  struct qlcnic_filter *tmp_fil ;
  struct hlist_node *n ;
  struct hlist_head *head ;
  int i ;
  u8 cmd ;
  struct hlist_node *____ptr ;
  struct hlist_node const *__mptr ;
  struct qlcnic_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node const *__mptr___0 ;
  struct qlcnic_filter *tmp___0 ;
  {
  i = 0;
  goto ldv_53023;
  ldv_53022:
  head = adapter->fhash.fhead + (unsigned long )i;
  ____ptr = head->first;
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
    __mptr = (struct hlist_node const *)____ptr;
    tmp = (struct qlcnic_filter *)__mptr;
  } else {
    tmp = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp;
  goto ldv_53020;
  ldv_53019:
  cmd = (unsigned int )tmp_fil->vlan_id != 0U ? 4U : 2U;
  qlcnic_sre_macaddr_change(adapter, (u8 *)(& tmp_fil->faddr), (int )tmp_fil->vlan_id,
                            (int )cmd);
  spin_lock_bh(& adapter->mac_learn_lock);
  adapter->fhash.fnum = (u8 )((int )adapter->fhash.fnum - 1);
  hlist_del(& tmp_fil->fnode);
  spin_unlock_bh(& adapter->mac_learn_lock);
  kfree((void const *)tmp_fil);
  ____ptr___0 = n;
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
    __mptr___0 = (struct hlist_node const *)____ptr___0;
    tmp___0 = (struct qlcnic_filter *)__mptr___0;
  } else {
    tmp___0 = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp___0;
  ldv_53020: ;
  if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
    n = tmp_fil->fnode.next;
    goto ldv_53019;
  } else {
  }
  i = i + 1;
  ldv_53023: ;
  if ((int )adapter->fhash.fbucket_size > i) {
    goto ldv_53022;
  } else {
  }
  return;
}
}
static int qlcnic_set_fw_loopback(struct qlcnic_adapter *adapter , u8 flag )
{
  struct qlcnic_nic_req req ;
  int rv ;
  {
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  req.req_hdr = ((unsigned long long )adapter->portnum << 16) | 4294967315ULL;
  req.words[0] = (unsigned long long )flag;
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%sting loopback mode failed\n",
            (unsigned int )flag != 0U ? (char *)"Set" : (char *)"Reset");
  } else {
  }
  return (rv);
}
}
int qlcnic_82xx_set_lb_mode(struct qlcnic_adapter *adapter , u8 mode )
{
  int tmp ;
  int tmp___0 ;
  {
  tmp = qlcnic_set_fw_loopback(adapter, (int )mode);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  tmp___0 = qlcnic_nic_set_promisc(adapter, 1U);
  if (tmp___0 != 0) {
    qlcnic_set_fw_loopback(adapter, 0);
    return (-5);
  } else {
  }
  msleep(1000U);
  return (0);
}
}
int qlcnic_82xx_clear_lb_mode(struct qlcnic_adapter *adapter , u8 mode )
{
  struct net_device *netdev ;
  {
  netdev = adapter->netdev;
  mode = 0U;
  qlcnic_set_fw_loopback(adapter, 0);
  if ((netdev->flags & 256U) != 0U) {
    mode = 1U;
  } else
  if ((netdev->flags & 512U) != 0U) {
    mode = 2U;
  } else {
  }
  qlcnic_nic_set_promisc(adapter, (u32 )mode);
  msleep(1000U);
  return (0);
}
}
int qlcnic_82xx_read_phys_port_id(struct qlcnic_adapter *adapter )
{
  u8 mac[6U] ;
  int ret ;
  size_t __len ;
  void *__ret ;
  {
  ret = qlcnic_get_mac_address(adapter, (u8 *)(& mac), (int )(adapter->ahw)->physical_port);
  if (ret != 0) {
    return (ret);
  } else {
  }
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& (adapter->ahw)->phys_port_id), (void const *)(& mac),
                     __len);
  } else {
    __ret = memcpy((void *)(& (adapter->ahw)->phys_port_id), (void const *)(& mac),
                             __len);
  }
  adapter->flags = adapter->flags | 262144U;
  return (0);
}
}
int qlcnic_82xx_set_rx_coalesce(struct qlcnic_adapter *adapter )
{
  struct qlcnic_nic_req req ;
  int rv ;
  {
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  req.req_hdr = ((unsigned long long )adapter->portnum << 16) | 3ULL;
  req.words[0] = (unsigned long long )(adapter->ahw)->coal.flag << 32;
  req.words[2] = (unsigned long long )(adapter->ahw)->coal.rx_packets | ((unsigned long long )(adapter->ahw)->coal.rx_time_us << 16);
  req.words[5] = ((unsigned long long )(adapter->ahw)->coal.timer_out | ((unsigned long long )(adapter->ahw)->coal.type << 32)) | ((unsigned long long )(adapter->ahw)->coal.sts_ring_mask << 40);
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "Could not send interrupt coalescing parameters\n");
  } else {
  }
  return (rv);
}
}
int qlcnic_82xx_config_intr_coalesce(struct qlcnic_adapter *adapter , struct ethtool_coalesce *ethcoal )
{
  struct qlcnic_nic_intr_coalesce *coal ;
  int rv ;
  {
  coal = & (adapter->ahw)->coal;
  coal->flag = 4U;
  coal->rx_time_us = (u16 )ethcoal->rx_coalesce_usecs;
  coal->rx_packets = (u16 )ethcoal->rx_max_coalesced_frames;
  rv = qlcnic_82xx_set_rx_coalesce(adapter);
  if (rv != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "Failed to set Rx coalescing parametrs\n");
  } else {
  }
  return (rv);
}
}
int qlcnic_82xx_config_hw_lro(struct qlcnic_adapter *adapter , int enable )
{
  struct qlcnic_nic_req req ;
  u64 word ;
  int rv ;
  int tmp ;
  {
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& adapter->state));
  if (tmp == 0) {
    return (0);
  } else {
  }
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 24ULL;
  req.req_hdr = word;
  word = 0ULL;
  if (enable != 0) {
    word = 1ULL;
    if (((adapter->ahw)->extra_capability[0] & 8U) != 0U) {
      word = word | 514ULL;
    } else {
    }
  } else {
  }
  req.words[0] = word;
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "Could not send configure hw lro request\n");
  } else {
  }
  return (rv);
}
}
int qlcnic_config_bridged_mode(struct qlcnic_adapter *adapter , u32 enable )
{
  struct qlcnic_nic_req req ;
  u64 word ;
  int rv ;
  {
  if ((u32 )((adapter->flags & 16U) != 0U) == enable) {
    return (0);
  } else {
  }
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 23ULL;
  req.req_hdr = word;
  req.words[0] = (unsigned long long )enable;
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "Could not send configure bridge mode request\n");
  } else {
  }
  adapter->flags = adapter->flags ^ 16U;
  return (rv);
}
}
int qlcnic_82xx_config_rss(struct qlcnic_adapter *adapter , int enable )
{
  struct qlcnic_nic_req req ;
  u64 word ;
  int i ;
  int rv ;
  u64 key[5U] ;
  {
  key[0] = 0xbeac01fa6a42b73bULL;
  key[1] = 0x8030f20c77cb2da3ULL;
  key[2] = 0xae7b30b4d0ca2bcbULL;
  key[3] = 4873897208919303485ULL;
  key[4] = 2691761430505084634ULL;
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 1ULL;
  req.req_hdr = word;
  word = (((unsigned long long )enable & 1ULL) << 8) | 0x80070000000004f0ULL;
  req.words[0] = word;
  i = 0;
  goto ldv_53083;
  ldv_53082:
  req.words[i + 1] = key[i];
  i = i + 1;
  ldv_53083: ;
  if (i <= 4) {
    goto ldv_53082;
  } else {
  }
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "could not configure RSS\n");
  } else {
  }
  return (rv);
}
}
void qlcnic_82xx_config_ipaddr(struct qlcnic_adapter *adapter , __be32 ip , int cmd )
{
  struct qlcnic_nic_req req ;
  struct qlcnic_ipaddr *ipa ;
  u64 word ;
  int rv ;
  {
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 18ULL;
  req.req_hdr = word;
  req.words[0] = (unsigned long long )cmd;
  ipa = (struct qlcnic_ipaddr *)(& req.words) + 1U;
  ipa->ipv4 = ip;
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "could not notify %s IP 0x%x reuqest\n",
            cmd == 2 ? (char *)"Add" : (char *)"Remove", ip);
  } else {
  }
  return;
}
}
int qlcnic_82xx_linkevent_request(struct qlcnic_adapter *adapter , int enable )
{
  struct qlcnic_nic_req req ;
  u64 word ;
  int rv ;
  {
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 21ULL;
  req.req_hdr = word;
  req.words[0] = (unsigned long long )((enable << 8) | enable);
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "could not configure link notification\n");
  } else {
  }
  return (rv);
}
}
static int qlcnic_send_lro_cleanup(struct qlcnic_adapter *adapter )
{
  struct qlcnic_nic_req req ;
  u64 word ;
  int rv ;
  int tmp ;
  {
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& adapter->state));
  if (tmp == 0) {
    return (0);
  } else {
  }
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 288230376151711751ULL;
  req.req_hdr = word;
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "could not cleanup lro flows\n");
  } else {
  }
  return (rv);
}
}
int qlcnic_change_mtu(struct net_device *netdev , int mtu )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int rc ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  rc = 0;
  if (mtu <= 67 || mtu > 9600) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "%d bytes < mtu < %d bytes not supported\n",
            9600, 68);
    return (-22);
  } else {
  }
  rc = qlcnic_fw_cmd_set_mtu(adapter, mtu);
  if (rc == 0) {
    netdev->mtu = (unsigned int )mtu;
  } else {
  }
  return (rc);
}
}
static netdev_features_t qlcnic_process_flags(struct qlcnic_adapter *adapter , netdev_features_t features )
{
  u32 offload_flags ;
  {
  offload_flags = adapter->offload_flags;
  if ((int )offload_flags & 1) {
    features = features | 17179869202ULL;
    adapter->rx_csum = 1U;
    if (((adapter->ahw)->capabilities & 2U) != 0U) {
      if ((offload_flags & 2U) == 0U) {
        features = features & 0xfffffffffffeffffULL;
      } else {
        features = features | 65536ULL;
      }
      if ((offload_flags & 4U) == 0U) {
        features = features & 0xffffffffffefffffULL;
      } else {
        features = features | 1048576ULL;
      }
    } else {
    }
  } else {
    features = features & 0xfffffffbffffffedULL;
    if (((adapter->ahw)->capabilities & 2U) != 0U) {
      features = features & 0xffffffffffeeffffULL;
    } else {
    }
    adapter->rx_csum = 0U;
  }
  return (features);
}
}
netdev_features_t qlcnic_fix_features(struct net_device *netdev , netdev_features_t features )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  netdev_features_t changed ;
  bool tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_82xx_check(adapter);
  if ((int )tmp___0 && (adapter->flags & 64U) != 0U) {
    if ((adapter->flags & 131072U) != 0U) {
      features = qlcnic_process_flags(adapter, features);
    } else {
      changed = netdev->features ^ features;
      features = (changed & 17180983314ULL) ^ features;
    }
  } else {
  }
  if ((features & 17179869184ULL) == 0ULL) {
    features = features & 0xffffffffffff7fffULL;
  } else {
  }
  return (features);
}
}
int qlcnic_set_features(struct net_device *netdev , netdev_features_t features )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  netdev_features_t changed ;
  int hw_lro ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  changed = netdev->features ^ features;
  hw_lro = (features & 32768ULL) != 0ULL;
  if ((changed & 32768ULL) == 0ULL) {
    return (0);
  } else {
  }
  netdev->features = netdev->features ^ 32768ULL;
  tmp___0 = qlcnic_config_hw_lro(adapter, hw_lro);
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  if (hw_lro == 0) {
    tmp___2 = qlcnic_82xx_check(adapter);
    if ((int )tmp___2) {
      tmp___1 = qlcnic_send_lro_cleanup(adapter);
      if (tmp___1 != 0) {
        return (-5);
      } else {
      }
    } else {
    }
  } else {
  }
  return (0);
}
}
static int qlcnic_pci_get_crb_addr_2M(struct qlcnic_hardware_context *ahw , ulong off ,
                                      void **addr )
{
  struct crb_128M_2M_sub_block_map const *m ;
  {
  if (off > 167772159UL || off <= 100663295UL) {
    return (-22);
  } else {
  }
  off = off - 100663296UL;
  m = (struct crb_128M_2M_sub_block_map const *)(& crb_128M_2M_map[(off >> 20) & 63UL].sub_block) + ((off >> 16) & 15UL);
  if (((unsigned int )m->valid != 0U && (ulong )m->start_128M <= off) && (ulong )m->end_128M > off) {
    *addr = ahw->pci_base0 + ((unsigned long )m->start_2M + (off - (ulong )m->start_128M));
    return (0);
  } else {
  }
  *addr = ahw->pci_base0 + ((off & 65535UL) + 1966080UL);
  return (1);
}
}
static int qlcnic_pci_set_crbwindow_2M(struct qlcnic_adapter *adapter , ulong off )
{
  u32 window ;
  void *addr ;
  int tmp ;
  unsigned int tmp___0 ;
  {
  addr = (adapter->ahw)->pci_base0 + 1245280UL;
  off = off - 100663296UL;
  window = (u32 )(crb_hub_agt[(off >> 20) & 63UL] << 20) | ((u32 )off & 983040U);
  if (window == 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Invalid offset 0x%lx\n",
            off);
    return (-5);
  } else {
  }
  writel(window, (void volatile *)addr);
  tmp___0 = readl((void const volatile *)addr);
  if (tmp___0 != window) {
    tmp = __printk_ratelimit("qlcnic_pci_set_crbwindow_2M");
    if (tmp != 0) {
      dev_warn((struct device const *)(& (adapter->pdev)->dev), "failed to set CRB window to %d off 0x%lx\n",
               window, off);
    } else {
    }
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_82xx_hw_write_wx_2M(struct qlcnic_adapter *adapter , ulong off , u32 data )
{
  unsigned long flags ;
  int rv ;
  void *addr ;
  {
  addr = (void *)0;
  rv = qlcnic_pci_get_crb_addr_2M(adapter->ahw, off, & addr);
  if (rv == 0) {
    writel(data, (void volatile *)addr);
    return (0);
  } else {
  }
  if (rv > 0) {
    flags = _raw_write_lock_irqsave(& (adapter->ahw)->crb_lock);
    qlcnic_pcie_sem_lock(adapter, 7, 136323364U);
    rv = qlcnic_pci_set_crbwindow_2M(adapter, off);
    if (rv == 0) {
      writel(data, (void volatile *)addr);
    } else {
    }
    qlcnic_pcie_sem_unlock(adapter, 7);
    _raw_write_unlock_irqrestore(& (adapter->ahw)->crb_lock, flags);
    return (rv);
  } else {
  }
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: invalid offset: 0x%016lx\n",
          "qlcnic_82xx_hw_write_wx_2M", off);
  dump_stack();
  return (-5);
}
}
int qlcnic_82xx_hw_read_wx_2M(struct qlcnic_adapter *adapter , ulong off , int *err )
{
  unsigned long flags ;
  int rv ;
  u32 data ;
  void *addr ;
  unsigned int tmp ;
  int tmp___0 ;
  {
  data = 4294967295U;
  addr = (void *)0;
  rv = qlcnic_pci_get_crb_addr_2M(adapter->ahw, off, & addr);
  if (rv == 0) {
    tmp = readl((void const volatile *)addr);
    return ((int )tmp);
  } else {
  }
  if (rv > 0) {
    flags = _raw_write_lock_irqsave(& (adapter->ahw)->crb_lock);
    qlcnic_pcie_sem_lock(adapter, 7, 136323364U);
    tmp___0 = qlcnic_pci_set_crbwindow_2M(adapter, off);
    if (tmp___0 == 0) {
      data = readl((void const volatile *)addr);
    } else {
    }
    qlcnic_pcie_sem_unlock(adapter, 7);
    _raw_write_unlock_irqrestore(& (adapter->ahw)->crb_lock, flags);
    return ((int )data);
  } else {
  }
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: invalid offset: 0x%016lx\n",
          "qlcnic_82xx_hw_read_wx_2M", off);
  dump_stack();
  return (-1);
}
}
void *qlcnic_get_ioaddr(struct qlcnic_hardware_context *ahw , u32 offset )
{
  void *addr ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  {
  addr = (void *)0;
  tmp = qlcnic_pci_get_crb_addr_2M(ahw, (ulong )offset, & addr);
  __ret_warn_on = tmp != 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.o.c.prepared",
                       1389);
  } else {
  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (addr);
}
}
static int qlcnic_pci_mem_access_direct(struct qlcnic_adapter *adapter , u32 window ,
                                        u64 off , u64 *data , int op )
{
  void *addr ;
  u32 start ;
  unsigned long tmp ;
  {
  mutex_lock_nested(& (adapter->ahw)->mem_lock, 0U);
  writel(window, (void volatile *)(adapter->ahw)->ocm_win_crb);
  readl((void const volatile *)(adapter->ahw)->ocm_win_crb);
  start = (u32 )off + 786432U;
  addr = (adapter->ahw)->pci_base0 + (unsigned long )start;
  if (op == 0) {
    tmp = readq((void const volatile *)addr);
    *data = (u64 )tmp;
  } else {
    writeq((unsigned long )*data, (void volatile *)addr);
  }
  writel(0U, (void volatile *)(adapter->ahw)->ocm_win_crb);
  readl((void const volatile *)(adapter->ahw)->ocm_win_crb);
  mutex_unlock(& (adapter->ahw)->mem_lock);
  return (0);
}
}
static void qlcnic_pci_camqm_read_2M(struct qlcnic_adapter *adapter , u64 off , u64 *data )
{
  void *addr ;
  unsigned long tmp ;
  {
  addr = (adapter->ahw)->pci_base0 + ((unsigned long )off + 0xfffffffffb8ff800UL);
  mutex_lock_nested(& (adapter->ahw)->mem_lock, 0U);
  tmp = readq((void const volatile *)addr);
  *data = (u64 )tmp;
  mutex_unlock(& (adapter->ahw)->mem_lock);
  return;
}
}
static void qlcnic_pci_camqm_write_2M(struct qlcnic_adapter *adapter , u64 off , u64 data )
{
  void *addr ;
  {
  addr = (adapter->ahw)->pci_base0 + ((unsigned long )off + 0xfffffffffb8ff800UL);
  mutex_lock_nested(& (adapter->ahw)->mem_lock, 0U);
  writeq((unsigned long )data, (void volatile *)addr);
  mutex_unlock(& (adapter->ahw)->mem_lock);
  return;
}
}
static void qlcnic_set_ms_controls(struct qlcnic_adapter *adapter , u64 off , struct qlcnic_ms_reg_ctrl *ms )
{
  {
  ms->control = 1090519184U;
  ms->low = 1090519188U;
  ms->hi = 1090519192U;
  if ((off & 15ULL) != 0ULL) {
    ms->wd[0] = 1090519200U;
    ms->rd[0] = 1090519208U;
    ms->wd[1] = 1090519204U;
    ms->rd[1] = 1090519212U;
    ms->wd[2] = 1090519216U;
    ms->wd[3] = 1090519220U;
    ms->rd[2] = 1090519224U;
    ms->rd[3] = 1090519228U;
  } else {
    ms->wd[0] = 1090519216U;
    ms->rd[0] = 1090519224U;
    ms->wd[1] = 1090519220U;
    ms->rd[1] = 1090519228U;
    ms->wd[2] = 1090519200U;
    ms->wd[3] = 1090519204U;
    ms->rd[2] = 1090519208U;
    ms->rd[3] = 1090519212U;
  }
  ms->ocm_window = (u32 )off & 268173312U;
  ms->off = off & 262143ULL;
  return;
}
}
int qlcnic_pci_mem_write_2M(struct qlcnic_adapter *adapter , u64 off , u64 data )
{
  int j ;
  int ret ;
  u32 temp ;
  u32 off8 ;
  struct qlcnic_ms_reg_ctrl ms ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  ret = 0;
  if ((off & 7ULL) != 0ULL) {
    return (-5);
  } else {
  }
  memset((void *)(& ms), 0, 56UL);
  if ((off > 13019119614ULL || off <= 12884901887ULL) && off > 268435454ULL) {
    return (-5);
  } else {
  }
  qlcnic_set_ms_controls(adapter, off, & ms);
  if (off <= 8590983166ULL && off > 8589934591ULL) {
    tmp = qlcnic_pci_mem_access_direct(adapter, ms.ocm_window, ms.off, & data, 1);
    return (tmp);
  } else {
  }
  off8 = (u32 )off & 4294967280U;
  mutex_lock_nested(& (adapter->ahw)->mem_lock, 0U);
  qlcnic_ind_wr(adapter, ms.low, off8);
  qlcnic_ind_wr(adapter, ms.hi, 0U);
  qlcnic_ind_wr(adapter, ms.control, 2U);
  qlcnic_ind_wr(adapter, ms.control, 3U);
  j = 0;
  goto ldv_53220;
  ldv_53219:
  tmp___0 = qlcnic_ind_rd(adapter, ms.control);
  temp = (u32 )tmp___0;
  if ((temp & 8U) == 0U) {
    goto ldv_53218;
  } else {
  }
  j = j + 1;
  ldv_53220: ;
  if (j <= 999) {
    goto ldv_53219;
  } else {
  }
  ldv_53218: ;
  if (j > 999) {
    ret = -5;
    goto done;
  } else {
  }
  tmp___1 = qlcnic_ind_rd(adapter, ms.rd[0]);
  qlcnic_ind_wr(adapter, ms.wd[0], (u32 )tmp___1);
  tmp___2 = qlcnic_ind_rd(adapter, ms.rd[1]);
  qlcnic_ind_wr(adapter, ms.wd[1], (u32 )tmp___2);
  qlcnic_ind_wr(adapter, ms.wd[2], (u32 )data);
  qlcnic_ind_wr(adapter, ms.wd[3], (u32 )(data >> 32));
  qlcnic_ind_wr(adapter, ms.control, 6U);
  qlcnic_ind_wr(adapter, ms.control, 7U);
  j = 0;
  goto ldv_53224;
  ldv_53223:
  tmp___3 = qlcnic_ind_rd(adapter, ms.control);
  temp = (u32 )tmp___3;
  if ((temp & 8U) == 0U) {
    goto ldv_53222;
  } else {
  }
  j = j + 1;
  ldv_53224: ;
  if (j <= 999) {
    goto ldv_53223;
  } else {
  }
  ldv_53222: ;
  if (j > 999) {
    tmp___4 = __printk_ratelimit("qlcnic_pci_mem_write_2M");
    if (tmp___4 != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "failed to write through agent\n");
    } else {
    }
    ret = -5;
  } else {
    ret = 0;
  }
  done:
  mutex_unlock(& (adapter->ahw)->mem_lock);
  return (ret);
}
}
int qlcnic_pci_mem_read_2M(struct qlcnic_adapter *adapter , u64 off , u64 *data )
{
  int j ;
  int ret ;
  u32 temp ;
  u32 off8 ;
  u64 val ;
  struct qlcnic_ms_reg_ctrl ms ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  if ((off & 7ULL) != 0ULL) {
    return (-5);
  } else {
  }
  if ((off > 13019119614ULL || off <= 12884901887ULL) && off > 268435454ULL) {
    return (-5);
  } else {
  }
  memset((void *)(& ms), 0, 56UL);
  qlcnic_set_ms_controls(adapter, off, & ms);
  if (off <= 8590983166ULL && off > 8589934591ULL) {
    tmp = qlcnic_pci_mem_access_direct(adapter, ms.ocm_window, ms.off, data, 0);
    return (tmp);
  } else {
  }
  mutex_lock_nested(& (adapter->ahw)->mem_lock, 0U);
  off8 = (u32 )off & 4294967280U;
  qlcnic_ind_wr(adapter, ms.low, off8);
  qlcnic_ind_wr(adapter, ms.hi, 0U);
  qlcnic_ind_wr(adapter, ms.control, 2U);
  qlcnic_ind_wr(adapter, ms.control, 3U);
  j = 0;
  goto ldv_53239;
  ldv_53238:
  tmp___0 = qlcnic_ind_rd(adapter, ms.control);
  temp = (u32 )tmp___0;
  if ((temp & 8U) == 0U) {
    goto ldv_53237;
  } else {
  }
  j = j + 1;
  ldv_53239: ;
  if (j <= 999) {
    goto ldv_53238;
  } else {
  }
  ldv_53237: ;
  if (j > 999) {
    tmp___1 = __printk_ratelimit("qlcnic_pci_mem_read_2M");
    if (tmp___1 != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "failed to read through agent\n");
    } else {
    }
    ret = -5;
  } else {
    tmp___2 = qlcnic_ind_rd(adapter, ms.rd[3]);
    temp = (u32 )tmp___2;
    val = (unsigned long long )temp << 32;
    tmp___3 = qlcnic_ind_rd(adapter, ms.rd[2]);
    val = (u64 )tmp___3 | val;
    *data = val;
    ret = 0;
  }
  mutex_unlock(& (adapter->ahw)->mem_lock);
  return (ret);
}
}
int qlcnic_82xx_get_board_info(struct qlcnic_adapter *adapter )
{
  int offset ;
  int board_type ;
  int magic ;
  int err ;
  struct pci_dev *pdev ;
  int tmp ;
  int tmp___0 ;
  u32 gpio ;
  int tmp___1 ;
  {
  err = 0;
  pdev = adapter->pdev;
  offset = 16680;
  tmp = qlcnic_rom_fast_read(adapter, (u32 )offset, (u32 *)(& magic));
  if (tmp != 0) {
    return (-5);
  } else {
  }
  if (magic != 305419896) {
    dev_err((struct device const *)(& pdev->dev), "invalid board config, magic=%08x\n",
            magic);
    return (-5);
  } else {
  }
  offset = 16392;
  tmp___0 = qlcnic_rom_fast_read(adapter, (u32 )offset, (u32 *)(& board_type));
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  (adapter->ahw)->board_type = (u16 )board_type;
  if (board_type == 41) {
    tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 154140684UL, & err);
    gpio = (u32 )tmp___1;
    if (err == -5) {
      return (err);
    } else {
    }
    if ((gpio & 32768U) == 0U) {
      board_type = 128;
    } else {
    }
  } else {
  }
  switch (board_type) {
  case 34: ;
  case 40: ;
  case 49: ;
  case 35: ;
  case 37: ;
  case 38: ;
  case 42: ;
  case 43: ;
  case 50: ;
  case 39:
  (adapter->ahw)->port_type = 2U;
  goto ldv_53260;
  case 33: ;
  case 36: ;
  case 41:
  (adapter->ahw)->port_type = 1U;
  goto ldv_53260;
  case 128:
  (adapter->ahw)->port_type = (unsigned int )adapter->portnum <= 1U ? 2U : 1U;
  goto ldv_53260;
  default:
  dev_err((struct device const *)(& pdev->dev), "unknown board type %x\n", board_type);
  (adapter->ahw)->port_type = 2U;
  goto ldv_53260;
  }
  ldv_53260: ;
  return (0);
}
}
static int qlcnic_wol_supported(struct qlcnic_adapter *adapter )
{
  u32 wol_cfg ;
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  err = 0;
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323460UL, & err);
  wol_cfg = (u32 )tmp;
  if ((int )((unsigned long )wol_cfg >> (int )adapter->portnum) & 1) {
    tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323464UL, & err);
    wol_cfg = (u32 )tmp___0;
    if (err == -5) {
      return (err);
    } else {
    }
    if (((u32 )(1 << (int )adapter->portnum) & wol_cfg) != 0U) {
      return (1);
    } else {
    }
  } else {
  }
  return (0);
}
}
int qlcnic_82xx_config_led(struct qlcnic_adapter *adapter , u32 state , u32 rate )
{
  struct qlcnic_nic_req req ;
  int rv ;
  u64 word ;
  {
  memset((void *)(& req), 0, 64UL);
  req.qhdr = 159383552ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 4ULL;
  req.req_hdr = word;
  req.words[0] = ((unsigned long long )rate << 32) | (unsigned long long )adapter->portnum;
  req.words[1] = (unsigned long long )state;
  rv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)(& req), 1);
  if (rv != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "LED configuration failed.\n");
  } else {
  }
  return (rv);
}
}
void qlcnic_82xx_get_beacon_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_cmd_args cmd ;
  u8 beacon_state ;
  int err ;
  {
  ahw = adapter->ahw;
  err = 0;
  if ((ahw->extra_capability[0] & 128U) != 0U) {
    err = qlcnic_alloc_mbx_args(& cmd, adapter, 60U);
    if (err == 0) {
      err = qlcnic_issue_cmd(adapter, & cmd);
      if (err != 0) {
        netdev_err((struct net_device const *)adapter->netdev, "Failed to get current beacon state, err=%d\n",
                   err);
      } else {
        beacon_state = (u8 )*(cmd.rsp.arg + 1UL);
        if ((unsigned int )beacon_state == 13U) {
          ahw->beacon_state = 0U;
        } else
        if ((unsigned int )beacon_state == 12U) {
          ahw->beacon_state = 2U;
        } else {
        }
      }
    } else {
    }
    qlcnic_free_mbx_args(& cmd);
  } else {
  }
  return;
}
}
void qlcnic_82xx_get_func_no(struct qlcnic_adapter *adapter )
{
  void *msix_base_addr ;
  u32 func ;
  u32 msix_base ;
  {
  pci_read_config_dword((struct pci_dev const *)adapter->pdev, 68, & func);
  msix_base_addr = (adapter->ahw)->pci_base0 + 1253648UL;
  msix_base = readl((void const volatile *)msix_base_addr);
  func = (func - msix_base) / 4096U;
  (adapter->ahw)->pci_func = (u8 )func;
  return;
}
}
void qlcnic_82xx_read_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                          size_t size )
{
  int err ;
  u32 data ;
  u64 qmdata ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  err = 0;
  if ((unsigned long long )offset <= 75499519ULL && (unsigned long long )offset > 75497471ULL) {
    qlcnic_pci_camqm_read_2M(adapter, (u64 )offset, & qmdata);
    __len = size;
    __ret = memcpy((void *)buf, (void const *)(& qmdata), __len);
  } else {
    tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )offset, & err);
    data = (u32 )tmp;
    __len___0 = size;
    __ret___0 = memcpy((void *)buf, (void const *)(& data), __len___0);
  }
  return;
}
}
void qlcnic_82xx_write_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                           size_t size )
{
  u32 data ;
  u64 qmdata ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  if ((unsigned long long )offset <= 75499519ULL && (unsigned long long )offset > 75497471ULL) {
    __len = size;
    __ret = memcpy((void *)(& qmdata), (void const *)buf, __len);
    qlcnic_pci_camqm_write_2M(adapter, (u64 )offset, qmdata);
  } else {
    __len___0 = size;
    __ret___0 = memcpy((void *)(& data), (void const *)buf, __len___0);
    (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (ulong )offset, data);
  }
  return;
}
}
int qlcnic_82xx_api_lock(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = qlcnic_pcie_sem_lock(adapter, 5, 0U);
  return (tmp);
}
}
void qlcnic_82xx_api_unlock(struct qlcnic_adapter *adapter )
{
  {
  qlcnic_pcie_sem_unlock(adapter, 5);
  return;
}
}
int qlcnic_82xx_shutdown(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  int retval ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  netdev = adapter->netdev;
  netif_device_detach(netdev);
  qlcnic_cancel_idc_work(adapter);
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_clr_all_drv_state(adapter, 0);
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  retval = pci_save_state(pdev);
  if (retval != 0) {
    return (retval);
  } else {
  }
  tmp___1 = qlcnic_wol_supported(adapter);
  if (tmp___1 != 0) {
    pci_enable_wake(pdev, 4, 1);
    pci_enable_wake(pdev, 3, 1);
  } else {
  }
  return (0);
}
}
int qlcnic_82xx_resume(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  int err ;
  bool tmp ;
  {
  netdev = adapter->netdev;
  err = qlcnic_start_firmware(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "failed to start firmware\n");
    return (err);
  } else {
  }
  tmp = netif_running((struct net_device const *)netdev);
  if ((int )tmp) {
    err = qlcnic_up(adapter, netdev);
    if (err == 0) {
      qlcnic_restore_indev_addr(netdev, 1UL);
    } else {
    }
  } else {
  }
  netif_device_attach(netdev);
  qlcnic_schedule_work(adapter, & qlcnic_fw_poll_work, 250);
  return (err);
}
}
__inline static void spin_lock_bh(spinlock_t *lock )
{
  {
  ldv_spin_lock();
  ldv_spin_lock_bh_2(lock);
  return;
}
}
__inline static void spin_unlock_bh(spinlock_t *lock )
{
  {
  ldv_spin_unlock();
  ldv_spin_unlock_bh_6(lock);
  return;
}
}
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_26(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_33(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
extern struct module __this_module ;
extern struct pv_irq_ops pv_irq_ops ;
__inline static int test_and_set_bit(long nr , unsigned long volatile *addr )
{
  char c ;
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
  return ((int )((signed char )c) != 0);
}
}
__inline static int fls64(__u64 x )
{
  int bitpos ;
  {
  bitpos = -1;
  __asm__ ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
  return (bitpos + 1);
}
}
extern unsigned long find_next_bit(unsigned long const * , unsigned long , unsigned long ) ;
extern unsigned long find_first_bit(unsigned long const * , unsigned long ) ;
__inline static __u16 __fswab16(__u16 val )
{
  {
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
__inline static unsigned int fls_long(unsigned long l )
{
  int tmp___0 ;
  {
  tmp___0 = fls64((__u64 )l);
  return ((unsigned int )tmp___0);
}
}
__inline static bool is_power_of_2(unsigned long n )
{
  {
  return ((bool )(n != 0UL && ((n - 1UL) & n) == 0UL));
}
}
__inline static unsigned long __rounddown_pow_of_two(unsigned long n )
{
  unsigned int tmp ;
  {
  tmp = fls_long(n);
  return (1UL << (int )(tmp - 1U));
}
}
extern void print_hex_dump(char const * , char const * , int , int , int ,
                           void const * , size_t , bool ) ;
extern int sprintf(char * , char const * , ...) ;
extern int snprintf(char * , size_t , char const * , ...) ;
__inline static void INIT_LIST_HEAD(struct list_head *list )
{
  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern char *strcpy(char * , char const * ) ;
extern int __bitmap_weight(unsigned long const * , int ) ;
__inline static int bitmap_weight(unsigned long const *src , int nbits )
{
  int tmp___0 ;
  {
  tmp___0 = __bitmap_weight(src, nbits);
  return (tmp___0);
}
}
extern int nr_cpu_ids ;
extern struct cpumask const * const cpu_online_mask ;
__inline static unsigned int cpumask_weight(struct cpumask const *srcp )
{
  int tmp ;
  {
  tmp = bitmap_weight((unsigned long const *)(& srcp->bits), nr_cpu_ids);
  return ((unsigned int )tmp);
}
}
__inline static unsigned long arch_local_save_flags(void)
{
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
    ldv_4851: ;
    goto ldv_4851;
  } else {
  }
  __asm__ volatile ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static int arch_irqs_disabled_flags(unsigned long flags )
{
  {
  return ((flags & 512UL) == 0UL);
}
}
__inline static void atomic_inc(atomic_t *v )
{
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
  return;
}
}
__inline static int atomic_dec_and_test(atomic_t *v )
{
  char c ;
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
  return ((int )((signed char )c) != 0);
}
}
extern int __preempt_count ;
__inline static void __preempt_count_add(int val )
{
  int pao_ID__ ;
  {
  pao_ID__ = 0;
  switch (4UL) {
  case 1UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incb %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decb %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addb %1, %%gs:%P0": "+m" (__preempt_count): "qi" (val));
  }
  goto ldv_6061;
  case 2UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incw %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decw %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addw %1, %%gs:%P0": "+m" (__preempt_count): "ri" (val));
  }
  goto ldv_6061;
  case 4UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incl %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decl %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addl %1, %%gs:%P0": "+m" (__preempt_count): "ri" (val));
  }
  goto ldv_6061;
  case 8UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incq %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decq %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addq %1, %%gs:%P0": "+m" (__preempt_count): "re" (val));
  }
  goto ldv_6061;
  default:
  __bad_percpu_size();
  }
  ldv_6061: ;
  return;
}
}
__inline static void __preempt_count_sub(int val )
{
  int pao_ID__ ;
  {
  pao_ID__ = 0;
  switch (4UL) {
  case 1UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incb %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decb %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addb %1, %%gs:%P0": "+m" (__preempt_count): "qi" (- val));
  }
  goto ldv_6073;
  case 2UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incw %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decw %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addw %1, %%gs:%P0": "+m" (__preempt_count): "ri" (- val));
  }
  goto ldv_6073;
  case 4UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incl %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decl %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addl %1, %%gs:%P0": "+m" (__preempt_count): "ri" (- val));
  }
  goto ldv_6073;
  case 8UL: ;
  if (pao_ID__ == 1) {
    __asm__ ("incq %%gs:%P0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__ ("decq %%gs:%P0": "+m" (__preempt_count));
  } else {
    __asm__ ("addq %1, %%gs:%P0": "+m" (__preempt_count): "re" (- val));
  }
  goto ldv_6073;
  default:
  __bad_percpu_size();
  }
  ldv_6073: ;
  return;
}
}
extern void __local_bh_disable_ip(unsigned long , unsigned int ) ;
__inline static void local_bh_disable(void)
{
  {
  __local_bh_disable_ip((unsigned long )((void *)0), 512U);
  return;
}
}
extern void __local_bh_enable_ip(unsigned long , unsigned int ) ;
__inline static void local_bh_enable(void)
{
  {
  __local_bh_enable_ip((unsigned long )((void *)0), 512U);
  return;
}
}
extern void lockdep_init_map(struct lockdep_map * , char const * , struct lock_class_key * ,
                             int ) ;
extern void lock_acquire(struct lockdep_map * , unsigned int , int , int , int ,
                         struct lockdep_map * , unsigned long ) ;
extern void lock_release(struct lockdep_map * , int , unsigned long ) ;
extern int lock_is_held(struct lockdep_map * ) ;
extern void lockdep_rcu_suspicious(char const * , int const , char const * ) ;
extern void __raw_spin_lock_init(raw_spinlock_t * , char const * , struct lock_class_key * ) ;
extern void __rwlock_init(rwlock_t * , char const * , struct lock_class_key * ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock )
{
  {
  return (& lock->ldv_6347.rlock);
}
}
__inline static void ldv_spin_lock_45(spinlock_t *lock )
{
  {
  _raw_spin_lock(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_lock(spinlock_t *lock ) ;
__inline static void ldv_spin_unlock_49(spinlock_t *lock )
{
  {
  _raw_spin_unlock(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock ) ;
extern void __mutex_init(struct mutex * , char const * , struct lock_class_key * ) ;
extern void init_timer_key(struct timer_list * , unsigned int , char const * ,
                           struct lock_class_key * ) ;
extern unsigned long round_jiffies_relative(unsigned long ) ;
extern void delayed_work_timer_fn(unsigned long ) ;
extern void __init_work(struct work_struct * , int ) ;
extern struct workqueue_struct *__alloc_workqueue_key(char const * , unsigned int ,
                                                      int , struct lock_class_key * ,
                                                      char const * , ...) ;
extern void destroy_workqueue(struct workqueue_struct * ) ;
extern bool queue_delayed_work_on(int , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long ) ;
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay )
{
  bool tmp ;
  {
  tmp = queue_delayed_work_on(8192, wq, dwork, delay);
  return (tmp);
}
}
extern void iounmap(void volatile * ) ;
extern void *vzalloc(unsigned long ) ;
void *ldv_vzalloc_78(unsigned long ldv_func_arg1 ) ;
void *ldv_vzalloc_80(unsigned long ldv_func_arg1 ) ;
extern void vfree(void const * ) ;
__inline static void __rcu_read_lock(void)
{
  {
  __preempt_count_add(1);
  __asm__ volatile ("": : : "memory");
  return;
}
}
__inline static void __rcu_read_unlock(void)
{
  {
  __asm__ volatile ("": : : "memory");
  __preempt_count_sub(1);
  return;
}
}
extern bool rcu_is_watching(void) ;
extern bool rcu_lockdep_current_cpu_online(void) ;
__inline static void rcu_lock_acquire(struct lockdep_map *map )
{
  {
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, (unsigned long )((void *)0));
  return;
}
}
__inline static void rcu_lock_release(struct lockdep_map *map )
{
  {
  lock_release(map, 1, (unsigned long )((void *)0));
  return;
}
}
extern struct lockdep_map rcu_lock_map ;
extern int debug_lockdep_rcu_enabled(void) ;
__inline static int rcu_read_lock_held(void)
{
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {
  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {
  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {
  }
  tmp___4 = lock_is_held(& rcu_lock_map);
  return (tmp___4);
}
}
__inline static void rcu_read_lock(void)
{
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  __rcu_read_lock();
  rcu_lock_acquire(& rcu_lock_map);
  tmp = debug_lockdep_rcu_enabled();
  if (tmp != 0 && ! __warned) {
    tmp___0 = rcu_is_watching();
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      __warned = 1;
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 871, "rcu_read_lock() used illegally while idle");
    } else {
    }
  } else {
  }
  return;
}
}
__inline static void rcu_read_unlock(void)
{
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  tmp = debug_lockdep_rcu_enabled();
  if (tmp != 0 && ! __warned) {
    tmp___0 = rcu_is_watching();
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      __warned = 1;
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 892, "rcu_read_unlock() used illegally while idle");
    } else {
    }
  } else {
  }
  rcu_lock_release(& rcu_lock_map);
  __rcu_read_unlock();
  return;
}
}
__inline static char const *kobject_name(struct kobject const *kobj )
{
  {
  return ((char const *)kobj->name);
}
}
extern void *ldv_malloc(size_t);
void *__kmalloc(size_t size, gfp_t t)
{
 return ldv_malloc(size);
}
void *ldv_kmem_cache_alloc_60(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_77(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags )
{
  void *tmp ;
  {
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
    return ((void *)0);
  } else {
  }
  tmp = __kmalloc(n * size, flags);
  return (tmp);
}
}
__inline static void *ldv_kcalloc_58(size_t n , size_t size , gfp_t flags )
{
  void *tmp ;
  {
  tmp = kmalloc_array(n, size, flags | 32768U);
  return (tmp);
}
}
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
void ldv_check_alloc_nonatomic(void) ;
extern size_t __VERIFIER_nondet_size_t(void) ;
extern loff_t __VERIFIER_nondet_loff_t(void) ;
extern u32 __VERIFIER_nondet_u32(void) ;
extern u16 __VERIFIER_nondet_u16(void) ;
extern u8 __VERIFIER_nondet_u8(void) ;
__inline static void ldv_stop(void)
{
  {
  LDV_STOP: ;
  goto LDV_STOP;
}
}
struct qlcnic_dcb *qlcnic_83xx_dcb_ops_group0 ;
int ldv_state_variable_20 ;
struct qlcnic_adapter *qlcnic_sriov_vf_hw_ops_group0 ;
struct qlcnic_adapter *qlcnic_hw_ops_group3 ;
struct qlcnic_adapter *qlcnic_83xx_ops_group0 ;
int ldv_state_variable_30 ;
struct ethtool_ringparam *qlcnic_ethtool_ops_group5 ;
struct qlcnic_dcb *qlcnic_82xx_dcb_ops_group0 ;
struct device_attribute *dev_attr_diag_mode_group1 ;
int ldv_state_variable_0 ;
struct device *dev_attr_beacon_group0 ;
struct pci_dev *qlcnic_hw_ops_group5 ;
int ldv_state_variable_12 ;
struct ethtool_cmd *qlcnic_ethtool_ops_group0 ;
int ldv_state_variable_22 ;
struct net_device *qlcnic_ethtool_failed_ops_group0 ;
int ldv_state_variable_14 ;
struct qlcnic_adapter *qlcnic_ops_group0 ;
struct ethtool_ringparam *qlcnic_sriov_vf_ethtool_ops_group1 ;
int ldv_state_variable_29 ;
int ldv_state_variable_17 ;
struct device *dev_attr_bridged_mode_group0 ;
int ldv_state_variable_19 ;
int ldv_state_variable_27 ;
int ldv_state_variable_9 ;
struct qlcnic_host_tx_ring *qlcnic_sriov_vf_hw_ops_group2 ;
struct qlcnic_adapter *qlcnic_sriov_vf_ops_group0 ;
int ref_cnt ;
int ldv_state_variable_7 ;
int ldv_state_variable_23 ;
struct kobject *bin_attr_esw_stats_group1 ;
struct kobject *bin_attr_mem_group1 ;
struct qlcnic_cmd_args *qlcnic_83xx_mbx_ops_group1 ;
struct net_device *qlcnic_netdev_ops_group1 ;
struct bin_attribute *bin_attr_flash_group0 ;
struct bin_attribute *bin_attr_crb_group0 ;
struct ethtool_pauseparam *qlcnic_ethtool_ops_group3 ;
int ldv_state_variable_6 ;
struct kobject *bin_attr_port_stats_group1 ;
struct bin_attribute *bin_attr_mem_group0 ;
struct pci_dev *qlcnic_driver_group0 ;
struct bin_attribute *bin_attr_npar_config_group0 ;
int ldv_state_variable_26 ;
int ldv_state_variable_28 ;
struct kobject *bin_attr_crb_group1 ;
struct ethtool_wolinfo *qlcnic_ethtool_ops_group1 ;
struct file *bin_attr_npar_config_group2 ;
struct qlcnic_info *qlcnic_hw_ops_group1 ;
struct qlcnic_host_tx_ring *qlcnic_83xx_hw_ops_group0 ;
struct net_device *qlcnic_dcbnl_ops_group0 ;
struct pci_dev *qlcnic_err_handler_group0 ;
struct bin_attribute *bin_attr_esw_config_group0 ;
int ldv_state_variable_3 ;
struct bin_attribute *bin_attr_pm_config_group0 ;
struct ethtool_dump *qlcnic_ethtool_ops_group6 ;
int ldv_state_variable_31 ;
int ldv_state_variable_4 ;
int ldv_state_variable_8 ;
struct qlcnic_host_sds_ring *qlcnic_sriov_vf_hw_ops_group1 ;
int ldv_state_variable_15 ;
int ldv_state_variable_5 ;
int ldv_state_variable_21 ;
struct pci_dev *qlcnic_83xx_hw_ops_group5 ;
int ldv_state_variable_33 ;
int ldv_state_variable_13 ;
struct qlcnic_adapter *qlcnic_83xx_hw_ops_group3 ;
struct qlcnic_info *qlcnic_sriov_vf_hw_ops_group3 ;
struct qlcnic_host_sds_ring *qlcnic_hw_ops_group4 ;
struct device_attribute *dev_attr_bridged_mode_group1 ;
struct device *dev_attr_diag_mode_group0 ;
struct file *bin_attr_mem_group2 ;
struct ethtool_channels *qlcnic_ethtool_ops_group4 ;
struct file *bin_attr_flash_group2 ;
struct file *bin_attr_esw_config_group2 ;
struct ethtool_coalesce *qlcnic_sriov_vf_ethtool_ops_group0 ;
struct qlcnic_cmd_args *qlcnic_sriov_vf_hw_ops_group4 ;
int ldv_state_variable_24 ;
struct file *bin_attr_esw_stats_group2 ;
struct net_device *qlcnic_sriov_vf_ethtool_ops_group2 ;
int ldv_state_variable_1 ;
struct qlcnic_cmd_args *qlcnic_hw_ops_group2 ;
struct file *bin_attr_pm_config_group2 ;
struct net_device *qlcnic_ethtool_ops_group7 ;
struct file *bin_attr_port_stats_group2 ;
struct qlcnic_host_sds_ring *qlcnic_83xx_hw_ops_group4 ;
int ldv_state_variable_10 ;
struct qlcnic_adapter *qlcnic_83xx_mbx_ops_group0 ;
struct ethtool_coalesce *qlcnic_ethtool_ops_group2 ;
int ldv_state_variable_16 ;
int ldv_state_variable_2 ;
int ldv_state_variable_25 ;
struct kobject *bin_attr_pm_config_group1 ;
struct qlcnic_info *qlcnic_83xx_hw_ops_group1 ;
struct bin_attribute *bin_attr_port_stats_group0 ;
int ldv_state_variable_11 ;
struct kobject *bin_attr_flash_group1 ;
int ldv_state_variable_18 ;
struct net_device *qlcnic_netdev_failed_ops_group1 ;
struct qlcnic_adapter *qlcnic_vf_ops_group0 ;
struct device_attribute *dev_attr_beacon_group1 ;
struct file *bin_attr_crb_group2 ;
struct kobject *bin_attr_npar_config_group1 ;
int ldv_state_variable_32 ;
struct qlcnic_host_tx_ring *qlcnic_hw_ops_group0 ;
struct bin_attribute *bin_attr_esw_stats_group0 ;
struct qlcnic_cmd_args *qlcnic_83xx_hw_ops_group2 ;
struct kobject *bin_attr_esw_config_group1 ;
void ldv_initialize_bin_attribute_10(void) ;
void ldv_initialize_ethtool_ops_22(void) ;
void ldv_initialize_qlcnic_dcb_ops_2(void) ;
void ldv_initialize_pci_error_handlers_26(void) ;
void ldv_net_device_ops_32(void) ;
void ldv_initialize_device_attribute_21(void) ;
void ldv_initialize_qlcnic_dcb_ops_3(void) ;
void ldv_initialize_ethtool_ops_24(void) ;
void ldv_initialize_qlcnic_nic_template_31(void) ;
void ldv_initialize_bin_attribute_12(void) ;
void ldv_initialize_bin_attribute_18(void) ;
void ldv_initialize_dcbnl_rtnl_ops_1(void) ;
void ldv_initialize_device_attribute_20(void) ;
void ldv_initialize_pci_driver_25(void) ;
void ldv_initialize_bin_attribute_16(void) ;
void ldv_initialize_qlcnic_hardware_ops_8(void) ;
void ldv_initialize_qlcnic_mbx_ops_6(void) ;
void ldv_initialize_qlcnic_hardware_ops_5(void) ;
void ldv_initialize_ethtool_ops_23(void) ;
void ldv_initialize_bin_attribute_13(void) ;
void ldv_net_device_ops_33(void) ;
void ldv_initialize_device_attribute_19(void) ;
void ldv_initialize_bin_attribute_17(void) ;
void ldv_initialize_bin_attribute_14(void) ;
void ldv_initialize_qlcnic_nic_template_30(void) ;
void ldv_initialize_qlcnic_hardware_ops_29(void) ;
void ldv_initialize_qlcnic_nic_template_7(void) ;
void ldv_initialize_qlcnic_nic_template_4(void) ;
void ldv_initialize_bin_attribute_11(void) ;
extern int request_threaded_irq(unsigned int , irqreturn_t (*)(int , void * ) ,
                                irqreturn_t (*)(int , void * ) , unsigned long ,
                                char const * , void * ) ;
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int , void * ) ,
                                unsigned long flags , char const *name , void *dev )
{
  int tmp ;
  {
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int , void * ))0, flags,
                             name, dev);
  return (tmp);
}
}
extern void free_irq(unsigned int , void * ) ;
__inline static char const *dev_name(struct device const *dev )
{
  char const *tmp ;
  {
  if ((unsigned long )dev->init_name != (unsigned long )((char const * )0)) {
    return ((char const *)dev->init_name);
  } else {
  }
  tmp = kobject_name(& dev->kobj);
  return (tmp);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data )
{
  {
  dev->driver_data = data;
  return;
}
}
extern int _dev_info(struct device const * , char const * , ...) ;
extern void pci_dev_put(struct pci_dev * ) ;
extern struct pci_dev *pci_get_domain_bus_and_slot(int , unsigned int , unsigned int ) ;
extern int pci_enable_device(struct pci_dev * ) ;
extern void pci_disable_device(struct pci_dev * ) ;
extern void pci_set_master(struct pci_dev * ) ;
extern void pci_restore_state(struct pci_dev * ) ;
extern int pci_set_power_state(struct pci_dev * , pci_power_t ) ;
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t ) ;
extern int pci_request_regions(struct pci_dev * , char const * ) ;
extern void pci_release_regions(struct pci_dev * ) ;
extern int __pci_register_driver(struct pci_driver * , struct module * , char const * ) ;
extern void pci_unregister_driver(struct pci_driver * ) ;
extern void pci_disable_msi(struct pci_dev * ) ;
extern void pci_disable_msix(struct pci_dev * ) ;
extern int pci_enable_msi_range(struct pci_dev * , int , int ) ;
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec )
{
  int rc ;
  int tmp ;
  {
  tmp = pci_enable_msi_range(dev, nvec, nvec);
  rc = tmp;
  if (rc < 0) {
    return (rc);
  } else {
  }
  return (0);
}
}
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int , int ) ;
__inline static int pci_enable_msix_exact(struct pci_dev *dev , struct msix_entry *entries ,
                                          int nvec )
{
  int rc ;
  int tmp ;
  {
  tmp = pci_enable_msix_range(dev, entries, nvec, nvec);
  rc = tmp;
  if (rc < 0) {
    return (rc);
  } else {
  }
  return (0);
}
}
__inline static int pci_domain_nr(struct pci_bus *bus )
{
  struct pci_sysdata *sd ;
  {
  sd = (struct pci_sysdata *)bus->sysdata;
  return (sd->domain);
}
}
extern void debug_dma_free_coherent(struct device * , size_t , void * , dma_addr_t ) ;
extern struct dma_map_ops *dma_ops ;
__inline static struct dma_map_ops *get_dma_ops(struct device *dev )
{
  long tmp ;
  {
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
    return (dma_ops);
  } else {
    return (dev->archdata.dma_ops);
  }
}
}
extern int dma_supported(struct device * , u64 ) ;
extern int dma_set_mask(struct device * , u64 ) ;
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  _flags = arch_local_save_flags();
  tmp___0 = arch_irqs_disabled_flags(_flags);
  __ret_warn_on = tmp___0 != 0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("./arch/x86/include/asm/dma-mapping.h", 166);
  } else {
  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  debug_dma_free_coherent(dev, size, vaddr, bus);
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t ,
                                                              void * , dma_addr_t ,
                                                              struct dma_attrs * ))0)) {
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {
  }
  return;
}
}
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask )
{
  int tmp ;
  {
  tmp = dma_supported(dev, mask);
  if (tmp == 0) {
    return (-5);
  } else {
  }
  dev->coherent_dma_mask = mask;
  return (0);
}
}
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask )
{
  int tmp ;
  {
  tmp = dma_set_mask(& dev->dev, mask);
  return (tmp);
}
}
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask )
{
  int tmp ;
  {
  tmp = dma_set_coherent_mask(& dev->dev, mask);
  return (tmp);
}
}
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data )
{
  {
  dev_set_drvdata(& pdev->dev, data);
  return;
}
}
extern void *pci_ioremap_bar(struct pci_dev * , int ) ;
extern void usleep_range(unsigned long , unsigned long ) ;
struct sk_buff *ldv_skb_clone_68(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_76(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_70(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_66(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_74(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_75(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_71(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_72(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_73(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
extern void __napi_schedule(struct napi_struct * ) ;
__inline static bool napi_disable_pending(struct napi_struct *n )
{
  int tmp ;
  {
  tmp = constant_test_bit(1L, (unsigned long const volatile *)(& n->state));
  return (tmp != 0);
}
}
__inline static bool napi_schedule_prep(struct napi_struct *n )
{
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = napi_disable_pending(n);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile *)(& n->state));
    if (tmp___1 == 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return ((bool )tmp___2);
}
}
__inline static void napi_schedule(struct napi_struct *n )
{
  bool tmp ;
  {
  tmp = napi_schedule_prep(n);
  if ((int )tmp) {
    __napi_schedule(n);
  } else {
  }
  return;
}
}
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev ,
                                                         unsigned int index )
{
  {
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
extern int register_netdevice_notifier(struct notifier_block * ) ;
extern int unregister_netdevice_notifier(struct notifier_block * ) ;
__inline static struct net_device *netdev_notifier_info_to_dev(struct netdev_notifier_info const *info )
{
  {
  return ((struct net_device *)info->dev);
}
}
extern void free_netdev(struct net_device * ) ;
void ldv_free_netdev_81(struct net_device *dev ) ;
void ldv_free_netdev_84(struct net_device *dev ) ;
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue )
{
  {
  clear_bit(0L, (unsigned long volatile *)(& dev_queue->state));
  return;
}
}
__inline static void netif_tx_start_all_queues(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_42506;
  ldv_42505:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_start_queue(txq);
  i = i + 1U;
  ldv_42506: ;
  if (dev->num_tx_queues > i) {
    goto ldv_42505;
  } else {
  }
  return;
}
}
extern int netif_set_real_num_tx_queues(struct net_device * , unsigned int ) ;
extern int netif_set_real_num_rx_queues(struct net_device * , unsigned int ) ;
extern void netif_carrier_off(struct net_device * ) ;
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu )
{
  {
  spin_lock(& txq->_xmit_lock);
  txq->xmit_lock_owner = cpu;
  return;
}
}
__inline static void __netif_tx_unlock(struct netdev_queue *txq )
{
  {
  txq->xmit_lock_owner = -1;
  spin_unlock(& txq->_xmit_lock);
  return;
}
}
__inline static void netif_tx_disable(struct net_device *dev )
{
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  local_bh_disable();
  __vpp_verify = (void const *)0;
  switch (4UL) {
  case 1UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
  goto ldv_43075;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_43075;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_43075;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_43075;
  default:
  __bad_percpu_size();
  }
  ldv_43075:
  pscr_ret__ = pfo_ret__;
  goto ldv_43081;
  case 2UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_43085;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_43085;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_43085;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_43085;
  default:
  __bad_percpu_size();
  }
  ldv_43085:
  pscr_ret__ = pfo_ret_____0;
  goto ldv_43081;
  case 4UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_43094;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_43094;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_43094;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_43094;
  default:
  __bad_percpu_size();
  }
  ldv_43094:
  pscr_ret__ = pfo_ret_____1;
  goto ldv_43081;
  case 8UL: ;
  switch (4UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_43103;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_43103;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_43103;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_43103;
  default:
  __bad_percpu_size();
  }
  ldv_43103:
  pscr_ret__ = pfo_ret_____2;
  goto ldv_43081;
  default:
  __bad_size_call_parameter();
  goto ldv_43081;
  }
  ldv_43081:
  cpu = pscr_ret__;
  i = 0U;
  goto ldv_43113;
  ldv_43112:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  __netif_tx_lock(txq, cpu);
  netif_tx_stop_queue(txq);
  __netif_tx_unlock(txq);
  i = i + 1U;
  ldv_43113: ;
  if (dev->num_tx_queues > i) {
    goto ldv_43112;
  } else {
  }
  local_bh_enable();
  return;
}
}
extern int register_netdev(struct net_device * ) ;
int ldv_register_netdev_79(struct net_device *dev ) ;
int ldv_register_netdev_82(struct net_device *dev ) ;
extern void unregister_netdev(struct net_device * ) ;
void ldv_unregister_netdev_83(struct net_device *dev ) ;
extern int dev_uc_add_excl(struct net_device * , unsigned char const * ) ;
extern int dev_uc_del(struct net_device * , unsigned char const * ) ;
extern int dev_mc_add_excl(struct net_device * , unsigned char const * ) ;
extern int dev_mc_del(struct net_device * , unsigned char const * ) ;
extern void netdev_update_features(struct net_device * ) ;
extern int netdev_info(struct net_device const * , char const * , ...) ;
extern int eth_validate_addr(struct net_device * ) ;
extern struct net_device *alloc_etherdev_mqs(int , unsigned int , unsigned int ) ;
__inline static bool is_zero_ether_addr(u8 const *addr )
{
  {
  return (((unsigned int )*((u32 const *)addr) | (unsigned int )*((u16 const *)addr + 4U)) == 0U);
}
}
__inline static bool is_multicast_ether_addr(u8 const *addr )
{
  {
  return (((int )*addr & 1) != 0);
}
}
__inline static bool is_unicast_ether_addr(u8 const *addr )
{
  bool tmp ;
  int tmp___0 ;
  {
  tmp = is_multicast_ether_addr(addr);
  if ((int )tmp != 0) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((bool )tmp___0);
}
}
__inline static bool is_valid_ether_addr(u8 const *addr )
{
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  tmp = is_multicast_ether_addr(addr);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp___1 = is_zero_ether_addr(addr);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  return ((bool )tmp___3);
}
}
__inline static bool ether_addr_equal_unaligned(u8 const *addr1 , u8 const *addr2 )
{
  bool tmp ;
  {
  tmp = ether_addr_equal(addr1, addr2);
  return (tmp);
}
}
extern void rtnl_lock(void) ;
extern void rtnl_unlock(void) ;
extern int ndo_dflt_fdb_dump(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                             int ) ;
extern int ndo_dflt_fdb_add(struct ndmsg * , struct nlattr ** , struct net_device * ,
                            unsigned char const * , u16 ) ;
extern int ndo_dflt_fdb_del(struct ndmsg * , struct nlattr ** , struct net_device * ,
                            unsigned char const * ) ;
extern struct net_device *__vlan_find_dev_deep_rcu(struct net_device * , __be16 ,
                                                   u16 ) ;
extern struct net_device *vlan_dev_real_dev(struct net_device const * ) ;
int qlcnic_82xx_napi_add(struct qlcnic_adapter *adapter , struct net_device *netdev ) ;
void qlcnic_82xx_change_filter(struct qlcnic_adapter *adapter , u64 *uaddr , u16 vlan_id ) ;
void qlcnic_82xx_process_rcv_ring_diag(struct qlcnic_host_sds_ring *sds_ring ) ;
int qlcnic_82xx_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd ) ;
int qlcnic_82xx_mq_intrpt(struct qlcnic_adapter *adapter , int op_type ) ;
int qlcnic_82xx_config_intrpt(struct qlcnic_adapter *adapter , u8 op_type ) ;
int qlcnic_82xx_fw_cmd_create_rx_ctx(struct qlcnic_adapter *adapter ) ;
int qlcnic_82xx_fw_cmd_create_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring ,
                                     int ring ) ;
void qlcnic_82xx_fw_cmd_del_rx_ctx(struct qlcnic_adapter *adapter ) ;
void qlcnic_82xx_fw_cmd_del_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring ) ;
int qlcnic_82xx_get_mac_address(struct qlcnic_adapter *adapter , u8 *mac , u8 function ) ;
int qlcnic_82xx_get_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info ,
                             u8 func_id ) ;
int qlcnic_82xx_set_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *nic ) ;
int qlcnic_82xx_get_pci_info(struct qlcnic_adapter *adapter , struct qlcnic_pci_info *pci_info ) ;
int qlcnic_82xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx , struct qlcnic_adapter *adapter ,
                               u32 type ) ;
void qlcnic_82xx_napi_enable(struct qlcnic_adapter *adapter ) ;
void qlcnic_82xx_napi_disable(struct qlcnic_adapter *adapter ) ;
void qlcnic_82xx_napi_del(struct qlcnic_adapter *adapter ) ;
extern u32 qlcnic_82xx_get_saved_state(void * , u32 ) ;
extern void qlcnic_82xx_set_saved_state(void * , u32 , u32 ) ;
void qlcnic_82xx_cache_tmpl_hdr_values(struct qlcnic_fw_dump *fw_dump ) ;
extern u32 qlcnic_82xx_get_cap_size(void * , int ) ;
void qlcnic_82xx_set_sys_info(void *t_hdr , int idx , u32 value ) ;
void qlcnic_82xx_store_cap_mask(void *tmpl_hdr , u32 mask ) ;
void qlcnic_83xx_initialize_nic(struct qlcnic_adapter *adapter , int enable ) ;
int qlcnic_83xx_set_rx_tx_intr_coal(struct qlcnic_adapter *adapter ) ;
irqreturn_t qlcnic_83xx_intr(int irq , void *data ) ;
irqreturn_t qlcnic_83xx_tmp_intr(int irq , void *data ) ;
void qlcnic_83xx_check_vf(struct qlcnic_adapter *adapter , struct pci_device_id const *ent ) ;
int qlcnic_83xx_setup_mbx_intr(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_free_mbx_intr(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_register_map(struct qlcnic_hardware_context *ahw ) ;
int qlcnic_83xx_init(struct qlcnic_adapter *adapter , int pci_using_dac ) ;
void qlcnic_83xx_idc_request_reset(struct qlcnic_adapter *adapter , u32 key ) ;
int qlcnic_83xx_set_port_eswitch_status(struct qlcnic_adapter *adapter , int func ,
                                        int *port_id ) ;
void qlcnic_83xx_enable_mbx_poll(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_disable_mbx_poll(struct qlcnic_adapter *adapter ) ;
int qlcnic_register_dcb(struct qlcnic_adapter *adapter ) ;
__inline static void qlcnic_clear_dcb_ops(struct qlcnic_dcb *dcb )
{
  {
  kfree((void const *)dcb);
  dcb = (struct qlcnic_dcb *)0;
  return;
}
}
__inline static void qlcnic_dcb_free(struct qlcnic_dcb *dcb )
{
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->free != (unsigned long )((void (*)(struct qlcnic_dcb * ))0)) {
    (*((dcb->ops)->free))(dcb);
  } else {
  }
  return;
}
}
__inline static int qlcnic_dcb_attach(struct qlcnic_dcb *dcb )
{
  int tmp ;
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->attach != (unsigned long )((int (*)(struct qlcnic_dcb * ))0)) {
    tmp = (*((dcb->ops)->attach))(dcb);
    return (tmp);
  } else {
  }
  return (0);
}
}
__inline static void qlcnic_dcb_get_info(struct qlcnic_dcb *dcb )
{
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->get_info != (unsigned long )((void (*)(struct qlcnic_dcb * ))0)) {
    (*((dcb->ops)->get_info))(dcb);
  } else {
  }
  return;
}
}
__inline static void qlcnic_dcb_init_dcbnl_ops(struct qlcnic_dcb *dcb )
{
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->init_dcbnl_ops != (unsigned long )((void (*)(struct qlcnic_dcb * ))0)) {
    (*((dcb->ops)->init_dcbnl_ops))(dcb);
  } else {
  }
  return;
}
}
__inline static void qlcnic_dcb_enable(struct qlcnic_dcb *dcb )
{
  int tmp ;
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0)) {
    tmp = qlcnic_dcb_attach(dcb);
    if (tmp != 0) {
      qlcnic_clear_dcb_ops(dcb);
    } else {
    }
  } else {
  }
  return;
}
}
char qlcnic_driver_name[7U] ;
int qlcnic_use_msi ;
int qlcnic_use_msi_x ;
int qlcnic_auto_fw_reset ;
int qlcnic_load_fw_file ;
int qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter ) ;
int qlcnic_dump_fw(struct qlcnic_adapter *adapter ) ;
bool qlcnic_check_fw_dump_state(struct qlcnic_adapter *adapter ) ;
int qlcnic_load_firmware(struct qlcnic_adapter *adapter ) ;
int qlcnic_need_fw_reset(struct qlcnic_adapter *adapter ) ;
void qlcnic_request_firmware(struct qlcnic_adapter *adapter ) ;
void qlcnic_release_firmware(struct qlcnic_adapter *adapter ) ;
int qlcnic_pinit_from_rom(struct qlcnic_adapter *adapter ) ;
int qlcnic_setup_idc_param(struct qlcnic_adapter *adapter ) ;
int qlcnic_check_flash_fw_ver(struct qlcnic_adapter *adapter ) ;
int qlcnic_alloc_sw_resources(struct qlcnic_adapter *adapter ) ;
void qlcnic_free_sw_resources(struct qlcnic_adapter *adapter ) ;
int qlcnic_alloc_hw_resources(struct qlcnic_adapter *adapter ) ;
void qlcnic_free_hw_resources(struct qlcnic_adapter *adapter ) ;
int qlcnic_fw_create_ctx(struct qlcnic_adapter *dev ) ;
void qlcnic_fw_destroy_ctx(struct qlcnic_adapter *adapter ) ;
void qlcnic_reset_rx_buffers_list(struct qlcnic_adapter *adapter ) ;
void qlcnic_release_rx_buffers(struct qlcnic_adapter *adapter ) ;
void qlcnic_release_tx_buffers(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring ) ;
int qlcnic_check_fw_status(struct qlcnic_adapter *adapter ) ;
void qlcnic_post_rx_buffers(struct qlcnic_adapter *adapter , struct qlcnic_host_rds_ring *rds_ring ,
                            u8 ring_id ) ;
int qlcnic_fw_cmd_set_drv_version(struct qlcnic_adapter *adapter , u32 fw_cmd ) ;
int qlcnic_reset_context(struct qlcnic_adapter *adapter ) ;
void qlcnic_diag_free_res(struct net_device *netdev , int drv_sds_rings ) ;
int qlcnic_diag_alloc_res(struct net_device *netdev , int test ) ;
netdev_tx_t qlcnic_xmit_frame(struct sk_buff *skb , struct net_device *netdev ) ;
void qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter , u8 tx_cnt ) ;
void qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter , u8 rx_cnt ) ;
int qlcnic_setup_rings(struct qlcnic_adapter *adapter ) ;
int qlcnic_validate_rings(struct qlcnic_adapter *adapter , __u32 ring_cnt , int queue_type ) ;
int qlcnic_enable_msix(struct qlcnic_adapter *adapter , u32 num_msix ) ;
void qlcnic_set_drv_version(struct qlcnic_adapter *adapter ) ;
int qlcnic_config_switch_port(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg ) ;
int qlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg ) ;
int qlcnic_config_port_mirroring(struct qlcnic_adapter *adapter , u8 id , u8 enable_mirroring ,
                                 u8 pci_func ) ;
int qlcnic_alloc_sds_rings(struct qlcnic_recv_context *recv_ctx , int count ) ;
void qlcnic_free_sds_rings(struct qlcnic_recv_context *recv_ctx ) ;
void qlcnic_free_tx_rings(struct qlcnic_adapter *adapter ) ;
int qlcnic_alloc_tx_rings(struct qlcnic_adapter *adapter , struct net_device *netdev ) ;
void qlcnic_create_sysfs_entries(struct qlcnic_adapter *adapter ) ;
void qlcnic_remove_sysfs_entries(struct qlcnic_adapter *adapter ) ;
void qlcnic_82xx_add_sysfs(struct qlcnic_adapter *adapter ) ;
void qlcnic_82xx_remove_sysfs(struct qlcnic_adapter *adapter ) ;
int qlcnicvf_config_bridged_mode(struct qlcnic_adapter *adapter , u32 enable ) ;
int qlcnicvf_config_led(struct qlcnic_adapter *adapter , u32 state , u32 rate ) ;
void qlcnic_set_vlan_config(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg ) ;
void qlcnic_set_eswitch_port_features(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg ) ;
int qlcnic_setup_tss_rss_intr(struct qlcnic_adapter *adapter ) ;
void __qlcnic_down(struct qlcnic_adapter *adapter , struct net_device *netdev ) ;
void qlcnic_detach(struct qlcnic_adapter *adapter ) ;
void qlcnic_teardown_intr(struct qlcnic_adapter *adapter ) ;
int qlcnic_attach(struct qlcnic_adapter *adapter ) ;
int __qlcnic_up(struct qlcnic_adapter *adapter , struct net_device *netdev ) ;
int qlcnic_check_temp(struct qlcnic_adapter *adapter ) ;
int qlcnic_init_pci_info(struct qlcnic_adapter *adapter ) ;
int qlcnic_set_default_offload_settings(struct qlcnic_adapter *adapter ) ;
int qlcnic_reset_npar_config(struct qlcnic_adapter *adapter ) ;
int qlcnic_set_eswitch_port_config(struct qlcnic_adapter *adapter ) ;
int qlcnic_read_mac_addr(struct qlcnic_adapter *adapter ) ;
int qlcnic_setup_netdev(struct qlcnic_adapter *adapter , struct net_device *netdev ,
                        int pci_using_dac ) ;
void qlcnic_set_netdev_features(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg ) ;
void qlcnic_83xx_detach_mailbox_work(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_free_mailbox(struct qlcnic_mailbox *mbx ) ;
void qlcnic_update_stats(struct qlcnic_adapter *adapter ) ;
struct qlcnic_nic_template qlcnic_vf_ops ;
__inline static bool qlcnic_encap_tx_offload(struct qlcnic_adapter *adapter )
{
  {
  return (((adapter->ahw)->extra_capability[0] & 2U) != 0U);
}
}
__inline static bool qlcnic_encap_rx_offload(struct qlcnic_adapter *adapter )
{
  {
  return (((adapter->ahw)->extra_capability[0] & 1U) != 0U);
}
}
__inline static int qlcnic_setup_intr(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->setup_intr))(adapter);
  return (tmp);
}
}
__inline static void qlcnic_get_func_no(struct qlcnic_adapter *adapter )
{
  {
  (*(((adapter->ahw)->hw_ops)->get_func_no))(adapter);
  return;
}
}
__inline static int qlcnic_api_lock(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->api_lock))(adapter);
  return (tmp);
}
}
__inline static void qlcnic_api_unlock(struct qlcnic_adapter *adapter )
{
  {
  (*(((adapter->ahw)->hw_ops)->api_unlock))(adapter);
  return;
}
}
__inline static void qlcnic_add_sysfs(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->add_sysfs != (unsigned long )((void (*)(struct qlcnic_adapter * ))0)) {
    (*(((adapter->ahw)->hw_ops)->add_sysfs))(adapter);
  } else {
  }
  return;
}
}
__inline static void qlcnic_remove_sysfs(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->remove_sysfs != (unsigned long )((void (*)(struct qlcnic_adapter * ))0)) {
    (*(((adapter->ahw)->hw_ops)->remove_sysfs))(adapter);
  } else {
  }
  return;
}
}
__inline static int qlcnic_linkevent_request(struct qlcnic_adapter *adapter , int enable )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->setup_link_event))(adapter, enable);
  return (tmp);
}
}
__inline static int qlcnic_get_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *info ,
                                        u8 id )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->get_nic_info))(adapter, info, (int )id);
  return (tmp);
}
}
__inline static int qlcnic_get_pci_info(struct qlcnic_adapter *adapter , struct qlcnic_pci_info *info )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->get_pci_info))(adapter, info);
  return (tmp);
}
}
__inline static int qlcnic_set_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *info )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->set_nic_info))(adapter, info);
  return (tmp);
}
}
__inline static int qlcnic_napi_add(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  int tmp ;
  {
  tmp = (*((adapter->nic_ops)->napi_add))(adapter, netdev);
  return (tmp);
}
}
__inline static void qlcnic_napi_del(struct qlcnic_adapter *adapter )
{
  {
  (*((adapter->nic_ops)->napi_del))(adapter);
  return;
}
}
__inline static void qlcnic_napi_enable(struct qlcnic_adapter *adapter )
{
  {
  (*(((adapter->ahw)->hw_ops)->napi_enable))(adapter);
  return;
}
}
__inline static int __qlcnic_shutdown(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = (*((adapter->nic_ops)->shutdown))(pdev);
  return (tmp___0);
}
}
__inline static int __qlcnic_resume(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = (*((adapter->nic_ops)->resume))(adapter);
  return (tmp);
}
}
__inline static void qlcnic_napi_disable(struct qlcnic_adapter *adapter )
{
  {
  (*(((adapter->ahw)->hw_ops)->napi_disable))(adapter);
  return;
}
}
__inline static int qlcnic_config_rss(struct qlcnic_adapter *adapter , int enable )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->config_rss))(adapter, enable);
  return (tmp);
}
}
__inline static int qlcnic_get_board_info(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->get_board_info))(adapter);
  return (tmp);
}
}
__inline static void qlcnic_free_mac_list(struct qlcnic_adapter *adapter )
{
  {
  return;
}
}
__inline static void qlcnic_set_mac_filter_count(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->set_mac_filter_count != (unsigned long )((void (*)(struct qlcnic_adapter * ))0)) {
    (*(((adapter->ahw)->hw_ops)->set_mac_filter_count))(adapter);
  } else {
  }
  return;
}
}
__inline static void qlcnic_read_phys_port_id(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->read_phys_port_id != (unsigned long )((int (*)(struct qlcnic_adapter * ))0)) {
    (*(((adapter->ahw)->hw_ops)->read_phys_port_id))(adapter);
  } else {
  }
  return;
}
}
__inline static void qlcnic_dev_request_reset(struct qlcnic_adapter *adapter , u32 key )
{
  {
  if ((unsigned long )(adapter->nic_ops)->request_reset != (unsigned long )((void (*)(struct qlcnic_adapter * ,
                                                                                      u32 ))0)) {
    (*((adapter->nic_ops)->request_reset))(adapter, key);
  } else {
  }
  return;
}
}
__inline static irqreturn_t qlcnic_clear_legacy_intr(struct qlcnic_adapter *adapter )
{
  irqreturn_t tmp ;
  {
  tmp = (*((adapter->nic_ops)->clear_legacy_intr))(adapter);
  return (tmp);
}
}
__inline static void qlcnic_config_ipaddr(struct qlcnic_adapter *adapter , __be32 ip ,
                                          int cmd )
{
  {
  (*((adapter->nic_ops)->config_ipaddr))(adapter, ip, cmd);
  return;
}
}
__inline static bool qlcnic_check_multi_tx(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = constant_test_bit(9L, (unsigned long const volatile *)(& adapter->state));
  return (tmp != 0);
}
}
__inline static void qlcnic_82xx_enable_tx_intr(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring )
{
  bool tmp ;
  {
  tmp = qlcnic_check_multi_tx(adapter);
  if ((int )tmp && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    writel(0U, (void volatile *)tx_ring->crb_intr_mask);
  } else {
  }
  return;
}
}
__inline static void qlcnic_82xx_disable_tx_intr(struct qlcnic_adapter *adapter ,
                                                 struct qlcnic_host_tx_ring *tx_ring )
{
  bool tmp ;
  {
  tmp = qlcnic_check_multi_tx(adapter);
  if ((int )tmp && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    writel(1U, (void volatile *)tx_ring->crb_intr_mask);
  } else {
  }
  return;
}
}
__inline static void qlcnic_disable_multi_tx(struct qlcnic_adapter *adapter )
{
  {
  test_and_clear_bit(9L, (unsigned long volatile *)(& adapter->state));
  adapter->drv_tx_rings = 1U;
  return;
}
}
__inline static void qlcnic_82xx_disable_sds_intr(struct qlcnic_adapter *adapter ,
                                                  struct qlcnic_host_sds_ring *sds_ring )
{
  bool tmp ;
  {
  tmp = qlcnic_check_multi_tx(adapter);
  if (((int )tmp && (unsigned int )(adapter->ahw)->diag_test == 0U) && (adapter->flags & 4U) != 0U) {
    writel(1U, (void volatile *)sds_ring->crb_intr_mask);
  } else {
    writel(0U, (void volatile *)sds_ring->crb_intr_mask);
  }
  return;
}
}
__inline static void qlcnic_enable_sds_intr(struct qlcnic_adapter *adapter , struct qlcnic_host_sds_ring *sds_ring )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->enable_sds_intr != (unsigned long )((void (*)(struct qlcnic_adapter * ,
                                                                                              struct qlcnic_host_sds_ring * ))0)) {
    (*(((adapter->ahw)->hw_ops)->enable_sds_intr))(adapter, sds_ring);
  } else {
  }
  return;
}
}
__inline static void qlcnic_disable_sds_intr(struct qlcnic_adapter *adapter , struct qlcnic_host_sds_ring *sds_ring )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->disable_sds_intr != (unsigned long )((void (*)(struct qlcnic_adapter * ,
                                                                                               struct qlcnic_host_sds_ring * ))0)) {
    (*(((adapter->ahw)->hw_ops)->disable_sds_intr))(adapter, sds_ring);
  } else {
  }
  return;
}
}
__inline static void qlcnic_disable_tx_intr(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->disable_tx_intr != (unsigned long )((void (*)(struct qlcnic_adapter * ,
                                                                                              struct qlcnic_host_tx_ring * ))0)) {
    (*(((adapter->ahw)->hw_ops)->disable_tx_intr))(adapter, tx_ring);
  } else {
  }
  return;
}
}
__inline static void qlcnic_82xx_enable_sds_intr(struct qlcnic_adapter *adapter ,
                                                 struct qlcnic_host_sds_ring *sds_ring )
{
  bool tmp ;
  {
  tmp = qlcnic_check_multi_tx(adapter);
  if (((int )tmp && (unsigned int )(adapter->ahw)->diag_test == 0U) && (adapter->flags & 4U) != 0U) {
    writel(0U, (void volatile *)sds_ring->crb_intr_mask);
  } else {
    writel(1U, (void volatile *)sds_ring->crb_intr_mask);
  }
  if ((adapter->flags & 6U) == 0U) {
    writel(64511U, (void volatile *)adapter->tgt_mask_reg);
  } else {
  }
  return;
}
}
struct ethtool_ops const qlcnic_sriov_vf_ethtool_ops ;
struct ethtool_ops const qlcnic_ethtool_ops ;
struct ethtool_ops const qlcnic_ethtool_failed_ops ;
__inline static bool qlcnic_84xx_check(struct qlcnic_adapter *adapter )
{
  unsigned short device ;
  {
  device = (adapter->pdev)->device;
  return ((bool )((unsigned int )device == 32832U || (unsigned int )device == 33856U));
}
}
__inline static bool qlcnic_83xx_check(struct qlcnic_adapter *adapter )
{
  unsigned short device ;
  bool status ;
  {
  device = (adapter->pdev)->device;
  status = (bool )((((unsigned int )device == 32816U || (unsigned int )device == 32832U) || (unsigned int )device == 33856U) || (unsigned int )device == 33840U);
  return (status);
}
}
__inline static bool qlcnic_sriov_pf_check(struct qlcnic_adapter *adapter )
{
  {
  return ((unsigned int )(adapter->ahw)->op_mode == 3U);
}
}
__inline static bool qlcnic_sriov_check(struct qlcnic_adapter *adapter )
{
  bool status ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  tmp = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp) {
    tmp___1 = 1;
  } else {
    tmp___0 = qlcnic_sriov_vf_check(adapter);
    if ((int )tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  status = (bool )tmp___1;
  return (status);
}
}
__inline static u32 qlcnic_get_vnic_func_count(struct qlcnic_adapter *adapter )
{
  bool tmp ;
  {
  tmp = qlcnic_84xx_check(adapter);
  if ((int )tmp) {
    return (16U);
  } else {
    return (8U);
  }
}
}
void qlcnic_register_hwmon_dev(struct qlcnic_adapter *adapter ) ;
void qlcnic_unregister_hwmon_dev(struct qlcnic_adapter *adapter ) ;
void qlcnic_sriov_cleanup(struct qlcnic_adapter *adapter ) ;
void qlcnic_sriov_vf_register_map(struct qlcnic_hardware_context *ahw ) ;
void qlcnic_sriov_cleanup_async_list(struct qlcnic_back_channel *bc ) ;
int qlcnic_sriov_cfg_vf_guest_vlan(struct qlcnic_adapter *adapter , u16 vid , u8 enable ) ;
void qlcnic_sriov_pf_disable(struct qlcnic_adapter *adapter ) ;
int qlcnic_pci_sriov_configure(struct pci_dev *dev , int num_vfs ) ;
int qlcnic_sriov_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) ;
int qlcnic_sriov_set_vf_tx_rate(struct net_device *netdev , int vf , int min_tx_rate ,
                                int max_tx_rate ) ;
int qlcnic_sriov_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *ivi ) ;
int qlcnic_sriov_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) ;
int qlcnic_sriov_set_vf_spoofchk(struct net_device *netdev , int vf , bool chk ) ;
extern int register_inetaddr_notifier(struct notifier_block * ) ;
extern int unregister_inetaddr_notifier(struct notifier_block * ) ;
__inline static struct in_device *__in_dev_get_rcu(struct net_device const *dev )
{
  struct in_device *_________p1 ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  {
  _________p1 = *((struct in_device * const volatile *)(& dev->ip_ptr));
  tmp = debug_lockdep_rcu_enabled();
  if (tmp != 0 && ! __warned) {
    tmp___0 = rcu_read_lock_held();
    if (tmp___0 == 0 && 1) {
      __warned = 1;
      lockdep_rcu_suspicious("include/linux/inetdevice.h", 202, "suspicious rcu_dereference_check() usage");
    } else {
    }
  } else {
  }
  return (_________p1);
}
}
__inline static struct in_device *in_dev_get(struct net_device const *dev )
{
  struct in_device *in_dev ;
  {
  rcu_read_lock();
  in_dev = __in_dev_get_rcu(dev);
  if ((unsigned long )in_dev != (unsigned long )((struct in_device *)0)) {
    atomic_inc(& in_dev->refcnt);
  } else {
  }
  rcu_read_unlock();
  return (in_dev);
}
}
extern void in_dev_finish_destroy(struct in_device * ) ;
__inline static void in_dev_put(struct in_device *idev )
{
  int tmp ;
  {
  tmp = atomic_dec_and_test(& idev->refcnt);
  if (tmp != 0) {
    in_dev_finish_destroy(idev);
  } else {
  }
  return;
}
}
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
extern void vxlan_get_rx_port(struct net_device * ) ;
char qlcnic_driver_name[7U] = { 'q', 'l', 'c', 'n',
        'i', 'c', '\000'};
static char const qlcnic_driver_string[62U] =
  { 'Q', 'L', 'o', 'g',
        'i', 'c', ' ', '1',
        '/', '1', '0', ' ',
        'G', 'b', 'E', ' ',
        'C', 'o', 'n', 'v',
        'e', 'r', 'g', 'e',
        'd', '/', 'I', 'n',
        't', 'e', 'l', 'l',
        'i', 'g', 'e', 'n',
        't', ' ', 'E', 't',
        'h', 'e', 'r', 'n',
        'e', 't', ' ', 'D',
        'r', 'i', 'v', 'e',
        'r', ' ', 'v', '5',
        '.', '3', '.', '6',
        '0', '\000'};
static int qlcnic_mac_learn ;
int qlcnic_use_msi = 1;
int qlcnic_use_msi_x = 1;
int qlcnic_auto_fw_reset = 1;
static int qlcnic_probe(struct pci_dev *pdev , struct pci_device_id const *ent ) ;
static void qlcnic_remove(struct pci_dev *pdev ) ;
static int qlcnic_open(struct net_device *netdev ) ;
static int qlcnic_close(struct net_device *netdev ) ;
static void qlcnic_tx_timeout(struct net_device *netdev ) ;
static void qlcnic_attach_work(struct work_struct *work ) ;
static void qlcnic_fwinit_work(struct work_struct *work ) ;
static void qlcnic_poll_controller(struct net_device *netdev ) ;
static void qlcnic_idc_debug_info(struct qlcnic_adapter *adapter , u8 encoding ) ;
static int qlcnic_can_start_firmware(struct qlcnic_adapter *adapter ) ;
static irqreturn_t qlcnic_tmp_intr(int irq , void *data ) ;
static irqreturn_t qlcnic_intr(int irq , void *data ) ;
static irqreturn_t qlcnic_msi_intr(int irq , void *data ) ;
static irqreturn_t qlcnic_msix_intr(int irq , void *data ) ;
static irqreturn_t qlcnic_msix_tx_intr(int irq , void *data ) ;
static struct net_device_stats *qlcnic_get_stats(struct net_device *netdev ) ;
static void qlcnic_free_lb_filters_mem(struct qlcnic_adapter *adapter ) ;
static void qlcnic_dev_set_npar_ready(struct qlcnic_adapter *adapter ) ;
static int qlcnicvf_start_firmware(struct qlcnic_adapter *adapter ) ;
static int qlcnic_vlan_rx_add(struct net_device *netdev , __be16 proto , u16 vid ) ;
static int qlcnic_vlan_rx_del(struct net_device *netdev , __be16 proto , u16 vid ) ;
static int qlcnic_82xx_setup_intr(struct qlcnic_adapter *adapter ) ;
static void qlcnic_82xx_dev_request_reset(struct qlcnic_adapter *adapter , u32 key ) ;
static irqreturn_t qlcnic_82xx_clear_legacy_intr(struct qlcnic_adapter *adapter ) ;
static pci_ers_result_t qlcnic_82xx_io_slot_reset(struct pci_dev *pdev ) ;
static int qlcnic_82xx_start_firmware(struct qlcnic_adapter *adapter ) ;
static void qlcnic_82xx_io_resume(struct pci_dev *pdev ) ;
static void qlcnic_82xx_set_mac_filter_count(struct qlcnic_adapter *adapter ) ;
static pci_ers_result_t qlcnic_82xx_io_error_detected(struct pci_dev *pdev , pci_channel_state_t state ) ;
static u32 qlcnic_vlan_tx_check(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  if ((unsigned int )(adapter->pdev)->device == 32800U) {
    return (ahw->capabilities & 512U);
  } else {
    return (1U);
  }
}
}
static struct pci_device_id const qlcnic_pci_tbl[6U] = { {4215U, 32800U, 4294967295U, 4294967295U, 131072U, 4294967295U, 0UL},
        {4215U, 32816U, 4294967295U, 4294967295U, 131072U, 4294967295U, 0UL},
        {4215U, 33840U, 4294967295U, 4294967295U, 131072U, 4294967295U, 0UL},
        {4215U, 32832U, 4294967295U, 4294967295U, 131072U, 4294967295U, 0UL},
        {4215U, 33856U, 4294967295U, 4294967295U, 131072U, 4294967295U, 0UL},
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
struct pci_device_id const __mod_pci__qlcnic_pci_tbl_device_table ;
static u32 const msi_tgt_status[8U] =
  { 101777688U, 101777760U, 101777764U, 101777768U,
        101778272U, 101778276U, 101778280U, 101778284U};
static u32 const qlcnic_reg_tbl[23U] =
  { 1777832U, 1777836U, 1777840U, 1777920U,
        1777960U, 1777976U, 1777984U, 1777988U,
        1777992U, 1777996U, 1778036U, 1778000U,
        1778004U, 1778008U, 1778076U, 1778172U,
        1778256U, 1778492U, 1778612U, 1778028U,
        1778032U, 1294352U, 1294356U};
static struct qlcnic_board_info const qlcnic_boards[21U] =
  { {4215U, 32832U, 0U, 0U, {'8', '4', '0', '0', ' ', 's', 'e', 'r', 'i', 'e', 's',
                              ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o', 'n', 'v',
                              'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e', 't', 'w', 'o',
                              'r', 'k', ' ', 'A', 'd', 'a', 'p', 't', 'e', 'r', ' ',
                              '(', 'T', 'C', 'P', '/', 'I', 'P', ' ', 'N', 'e', 't',
                              'w', 'o', 'r', 'k', 'i', 'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 590U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 579U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'S', 'i', 'n', 'g', 'l', 'e', ' ', 'P',
                                   'o', 'r', 't', ' ', '1', '0', 'G', 'b', 'E', ' ',
                                   'C', 'o', 'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ',
                                   'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'A', 'd',
                                   'a', 'p', 't', 'e', 'r', ' ', '(', 'T', 'C', 'P',
                                   '/', 'I', 'P', ' ', 'N', 'e', 't', 'w', 'o', 'r',
                                   'k', 'i', 'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 586U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 582U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 594U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 622U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 608U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 614U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'S', 'i', 'n', 'g', 'l', 'e', ' ', 'P',
                                   'o', 'r', 't', ' ', '1', '0', 'G', 'b', 'E', ' ',
                                   'C', 'o', 'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ',
                                   'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'A', 'd',
                                   'a', 'p', 't', 'e', 'r', ' ', '(', 'T', 'C', 'P',
                                   '/', 'I', 'P', ' ', 'N', 'e', 't', 'w', 'o', 'r',
                                   'k', 'i', 'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 617U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 4215U, 625U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', ' ', '(', 'T', 'C', 'P', '/', 'I',
                                   'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i',
                                   'n', 'g', ')', '\000'}},
        {4215U, 32816U, 0U, 0U, {'8', '3', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e', 's',
                              ' ', '1', '/', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                              'n', 't', 'r', 'o', 'l', 'l', 'e', 'r', '\000'}},
        {4215U, 32800U, 4215U, 515U, {'8', '2', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'S', 'i', 'n', 'g', 'l', 'e', ' ', 'P',
                                   'o', 'r', 't', ' ', '1', '0', 'G', 'b', 'E', ' ',
                                   'C', 'o', 'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ',
                                   'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'A', 'd',
                                   'a', 'p', 't', 'e', 'r', '(', 'T', 'C', 'P', '/',
                                   'I', 'P', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k',
                                   'i', 'n', 'g', ')', '\000'}},
        {4215U, 32800U, 4215U, 519U, {'8', '2', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', 'E', ' ', 'C', 'o',
                                   'n', 'v', 'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e',
                                   't', 'w', 'o', 'r', 'k', ' ', 'A', 'd', 'a', 'p',
                                   't', 'e', 'r', '(', 'T', 'C', 'P', '/', 'I', 'P',
                                   ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'i', 'n',
                                   'g', ')', '\000'}},
        {4215U, 32800U, 4215U, 523U, {'3', '2', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'D', 'u', 'a', 'l', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', '0', 'G', 'b', ' ', 'I', 'n', 't',
                                   'e', 'l', 'l', 'i', 'g', 'e', 'n', 't', ' ', 'E',
                                   't', 'h', 'e', 'r', 'n', 'e', 't', ' ', 'A', 'd',
                                   'a', 'p', 't', 'e', 'r', '\000'}},
        {4215U, 32800U, 4215U, 524U, {'3', '2', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'Q', 'u', 'a', 'd', ' ', 'P', 'o', 'r',
                                   't', ' ', '1', 'G', 'b', ' ', 'I', 'n', 't', 'e',
                                   'l', 'l', 'i', 'g', 'e', 'n', 't', ' ', 'E', 't',
                                   'h', 'e', 'r', 'n', 'e', 't', ' ', 'A', 'd', 'a',
                                   'p', 't', 'e', 'r', '\000'}},
        {4215U, 32800U, 4215U, 527U, {'3', '2', '0', '0', ' ', 'S', 'e', 'r', 'i', 'e',
                                   's', ' ', 'S', 'i', 'n', 'g', 'l', 'e', ' ', 'P',
                                   'o', 'r', 't', ' ', '1', '0', 'G', 'b', ' ', 'I',
                                   'n', 't', 'e', 'l', 'l', 'i', 'g', 'e', 'n', 't',
                                   ' ', 'E', 't', 'h', 'e', 'r', 'n', 'e', 't', ' ',
                                   'A', 'd', 'a', 'p', 't', 'e', 'r', '\000'}},
        {4215U, 32800U, 4156U, 14131U, {'N', 'C', '5', '2', '3', 'S', 'F', 'P', ' ',
                                     '1', '0', 'G', 'b', ' ', '2', '-', 'p', 'o',
                                     'r', 't', ' ', 'S', 'e', 'r', 'v', 'e', 'r',
                                     ' ', 'A', 'd', 'a', 'p', 't', 'e', 'r', '\000'}},
        {4215U,
      32800U, 4156U, 13126U, {'C', 'N', '1', '0', '0', '0', 'Q', ' ', 'D', 'u', 'a',
                              'l', ' ', 'P', 'o', 'r', 't', ' ', 'C', 'o', 'n', 'v',
                              'e', 'r', 'g', 'e', 'd', ' ', 'N', 'e', 't', 'w', 'o',
                              'r', 'k', ' ', 'A', 'd', 'a', 'p', 't', 'e', 'r', '\000'}},
        {4215U,
      32800U, 4215U, 528U, {'Q', 'M', 'E', '8', '2', '4', '2', '-', 'k', ' ', '1',
                            '0', 'G', 'b', 'E', ' ', 'D', 'u', 'a', 'l', ' ', 'P',
                            'o', 'r', 't', ' ', 'M', 'e', 'z', 'z', 'a', 'n', 'i',
                            'n', 'e', ' ', 'C', 'a', 'r', 'd', '\000'}},
        {4215U, 32800U, 0U, 0U, {'c', 'L', 'O', 'M', '8', '2', '1', '4', ' ', '1', '/',
                              '1', '0', 'G', 'b', 'E', ' ', 'C', 'o', 'n', 't', 'r',
                              'o', 'l', 'l', 'e', 'r', '\000'}}};
static struct qlcnic_legacy_intr_set const legacy_intr[8U] =
  { {128U, 101777688U, 101777704U, 0U},
        {256U, 101777760U, 101777776U, 0U},
        {512U, 101777764U, 101777780U, 0U},
        {1024U, 101777768U, 101777784U, 0U},
        {2048U, 101778272U, 101778288U, 0U},
        {4096U, 101778276U, 101778292U, 0U},
        {8192U, 101778280U, 101778296U, 0U},
        {16384U, 101778284U, 101778300U, 0U}};
int qlcnic_alloc_sds_rings(struct qlcnic_recv_context *recv_ctx , int count )
{
  int size ;
  void *tmp ;
  {
  size = (int )((unsigned int )count * 4096U);
  tmp = kzalloc((size_t )size, 208U);
  recv_ctx->sds_rings = (struct qlcnic_host_sds_ring *)tmp;
  return ((unsigned long )recv_ctx->sds_rings == (unsigned long )((struct qlcnic_host_sds_ring *)0));
}
}
void qlcnic_free_sds_rings(struct qlcnic_recv_context *recv_ctx )
{
  {
  if ((unsigned long )recv_ctx->sds_rings != (unsigned long )((struct qlcnic_host_sds_ring *)0)) {
    kfree((void const *)recv_ctx->sds_rings);
  } else {
  }
  recv_ctx->sds_rings = (struct qlcnic_host_sds_ring *)0;
  return;
}
}
int qlcnic_read_mac_addr(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  struct pci_dev *pdev ;
  u8 mac_addr[6U] ;
  int ret ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp ;
  int tmp___0 ;
  {
  netdev = adapter->netdev;
  pdev = adapter->pdev;
  ret = qlcnic_get_mac_address(adapter, (u8 *)(& mac_addr), (int )(adapter->ahw)->pci_func);
  if (ret != 0) {
    return (ret);
  } else {
  }
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)netdev->dev_addr, (void const *)(& mac_addr), __len);
  } else {
    __ret = memcpy((void *)netdev->dev_addr, (void const *)(& mac_addr),
                             __len);
  }
  __len___0 = (size_t )netdev->addr_len;
  __ret___0 = memcpy((void *)(& adapter->mac_addr), (void const *)netdev->dev_addr,
                               __len___0);
  tmp = is_valid_ether_addr((u8 const *)netdev->dev_addr);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    dev_warn((struct device const *)(& pdev->dev), "Bad MAC address %pM.\n", netdev->dev_addr);
  } else {
  }
  return (0);
}
}
static void qlcnic_delete_adapter_mac(struct qlcnic_adapter *adapter )
{
  struct qlcnic_mac_vlan_list *cur ;
  struct list_head *head ;
  struct list_head const *__mptr ;
  bool tmp ;
  {
  head = adapter->mac_list.next;
  goto ldv_53486;
  ldv_53485:
  __mptr = (struct list_head const *)head;
  cur = (struct qlcnic_mac_vlan_list *)__mptr;
  tmp = ether_addr_equal_unaligned((u8 const *)(& adapter->mac_addr), (u8 const *)(& cur->mac_addr));
  if ((int )tmp) {
    qlcnic_sre_macaddr_change(adapter, (u8 *)(& cur->mac_addr), 0, 2);
    list_del(& cur->list);
    kfree((void const *)cur);
    return;
  } else {
  }
  head = head->next;
  ldv_53486: ;
  if ((unsigned long )(& adapter->mac_list) != (unsigned long )head) {
    goto ldv_53485;
  } else {
  }
  return;
}
}
static int qlcnic_set_mac(struct net_device *netdev , void *p )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct sockaddr *addr ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___5 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  addr = (struct sockaddr *)p;
  tmp___0 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___0) {
    return (-22);
  } else {
  }
  if ((adapter->flags & 1024U) != 0U) {
    return (-95);
  } else {
  }
  tmp___1 = is_valid_ether_addr((u8 const *)(& addr->sa_data));
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (-22);
  } else {
  }
  tmp___3 = ether_addr_equal_unaligned((u8 const *)(& adapter->mac_addr), (u8 const *)(& addr->sa_data));
  if ((int )tmp___3) {
    return (0);
  } else {
  }
  tmp___4 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___4 != 0) {
    netif_device_detach(netdev);
    qlcnic_napi_disable(adapter);
  } else {
  }
  qlcnic_delete_adapter_mac(adapter);
  __len = (size_t )netdev->addr_len;
  __ret = memcpy((void *)(& adapter->mac_addr), (void const *)(& addr->sa_data),
                           __len);
  __len___0 = (size_t )netdev->addr_len;
  __ret___0 = memcpy((void *)netdev->dev_addr, (void const *)(& addr->sa_data),
                               __len___0);
  qlcnic_set_multi(adapter->netdev);
  tmp___5 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___5 != 0) {
    netif_device_attach(netdev);
    qlcnic_napi_enable(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_fdb_del(struct ndmsg *ndm , struct nlattr **tb , struct net_device *netdev ,
                          unsigned char const *addr )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = -95;
  if (! adapter->fdb_mac_learn) {
    tmp___0 = ndo_dflt_fdb_del(ndm, tb, netdev, addr);
    return (tmp___0);
  } else {
  }
  if ((adapter->flags & 64U) != 0U) {
    goto _L;
  } else {
    tmp___3 = qlcnic_sriov_check(adapter);
    if ((int )tmp___3) {
      _L:
      tmp___2 = is_unicast_ether_addr(addr);
      if ((int )tmp___2) {
        err = dev_uc_del(netdev, addr);
        if (err == 0) {
          err = qlcnic_nic_del_mac(adapter, addr);
        } else {
        }
      } else {
        tmp___1 = is_multicast_ether_addr(addr);
        if ((int )tmp___1) {
          err = dev_mc_del(netdev, addr);
        } else {
          err = -22;
        }
      }
    } else {
    }
  }
  return (err);
}
}
static int qlcnic_fdb_add(struct ndmsg *ndm , struct nlattr **tb , struct net_device *netdev ,
                          unsigned char const *addr , u16 flags )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = 0;
  if (! adapter->fdb_mac_learn) {
    tmp___0 = ndo_dflt_fdb_add(ndm, tb, netdev, addr, (int )flags);
    return (tmp___0);
  } else {
  }
  if ((adapter->flags & 64U) == 0U) {
    tmp___1 = qlcnic_sriov_check(adapter);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      printk("\016%s: FDB e-switch is not enabled\n", "qlcnic_fdb_add");
      return (-95);
    } else {
    }
  } else {
  }
  tmp___3 = ether_addr_equal(addr, (u8 const *)(& adapter->mac_addr));
  if ((int )tmp___3) {
    return (err);
  } else {
  }
  tmp___5 = is_unicast_ether_addr(addr);
  if ((int )tmp___5) {
    if (netdev->uc.count < (int )(adapter->ahw)->max_uc_count) {
      err = dev_uc_add_excl(netdev, addr);
    } else {
      err = -12;
    }
  } else {
    tmp___4 = is_multicast_ether_addr(addr);
    if ((int )tmp___4) {
      err = dev_mc_add_excl(netdev, addr);
    } else {
      err = -22;
    }
  }
  return (err);
}
}
static int qlcnic_fdb_dump(struct sk_buff *skb , struct netlink_callback *ncb , struct net_device *netdev ,
                           int idx )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  if (! adapter->fdb_mac_learn) {
    tmp___0 = ndo_dflt_fdb_dump(skb, ncb, netdev, idx);
    return (tmp___0);
  } else {
  }
  if ((adapter->flags & 64U) != 0U) {
    idx = ndo_dflt_fdb_dump(skb, ncb, netdev, idx);
  } else {
    tmp___1 = qlcnic_sriov_check(adapter);
    if ((int )tmp___1) {
      idx = ndo_dflt_fdb_dump(skb, ncb, netdev, idx);
    } else {
    }
  }
  return (idx);
}
}
static void qlcnic_82xx_cancel_idc_work(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  goto ldv_53529;
  ldv_53528:
  usleep_range(10000UL, 11000UL);
  ldv_53529:
  tmp = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    goto ldv_53528;
  } else {
  }
  if ((unsigned long )adapter->fw_work.work.func == (unsigned long )((void (*)(struct work_struct * ))0)) {
    return;
  } else {
  }
  cancel_delayed_work_sync(& adapter->fw_work);
  return;
}
}
static int qlcnic_get_phys_port_id(struct net_device *netdev , struct netdev_phys_port_id *ppid )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  size_t __len ;
  void *__ret ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  if ((adapter->flags & 262144U) == 0U) {
    return (-95);
  } else {
  }
  ppid->id_len = 6U;
  __len = (size_t )ppid->id_len;
  __ret = memcpy((void *)(& ppid->id), (void const *)(& ahw->phys_port_id),
                           __len);
  return (0);
}
}
static void qlcnic_add_vxlan_port(struct net_device *netdev , sa_family_t sa_family ,
                                  __be16 port )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  bool tmp___0 ;
  int tmp___1 ;
  __u16 tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  tmp___0 = qlcnic_encap_rx_offload(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1 || (unsigned int )ahw->vxlan_port != 0U) {
    return;
  } else {
  }
  tmp___2 = __fswab16((int )port);
  ahw->vxlan_port = tmp___2;
  adapter->flags = adapter->flags | 1048576U;
  return;
}
}
static void qlcnic_del_vxlan_port(struct net_device *netdev , sa_family_t sa_family ,
                                  __be16 port )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  bool tmp___0 ;
  int tmp___1 ;
  __u16 tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  tmp___0 = qlcnic_encap_rx_offload(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1 || (unsigned int )ahw->vxlan_port == 0U) {
    return;
  } else {
    tmp___2 = __fswab16((int )port);
    if ((int )ahw->vxlan_port != (int )tmp___2) {
      return;
    } else {
    }
  }
  adapter->flags = adapter->flags | 2097152U;
  return;
}
}
static struct net_device_ops const qlcnic_netdev_ops =
     {0, 0, & qlcnic_open, & qlcnic_close, & qlcnic_xmit_frame, 0, 0, & qlcnic_set_multi,
    & qlcnic_set_mac, & eth_validate_addr, 0, 0, & qlcnic_change_mtu, 0, & qlcnic_tx_timeout,
    0, & qlcnic_get_stats, & qlcnic_vlan_rx_add, & qlcnic_vlan_rx_del, & qlcnic_poll_controller,
    0, 0, 0, & qlcnic_sriov_set_vf_mac, & qlcnic_sriov_set_vf_vlan, & qlcnic_sriov_set_vf_tx_rate,
    & qlcnic_sriov_set_vf_spoofchk, & qlcnic_sriov_get_vf_config, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, & qlcnic_fix_features, & qlcnic_set_features, 0, 0, & qlcnic_fdb_add,
    & qlcnic_fdb_del, & qlcnic_fdb_dump, 0, 0, 0, 0, & qlcnic_get_phys_port_id, & qlcnic_add_vxlan_port,
    & qlcnic_del_vxlan_port, 0, 0, 0, 0};
static struct net_device_ops const qlcnic_netdev_failed_ops =
     {0, 0, & qlcnic_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct qlcnic_nic_template qlcnic_ops =
     {& qlcnic_config_bridged_mode, & qlcnic_82xx_config_led, & qlcnic_82xx_start_firmware,
    0, & qlcnic_82xx_dev_request_reset, & qlcnic_82xx_cancel_idc_work, & qlcnic_82xx_napi_add,
    & qlcnic_82xx_napi_del, & qlcnic_82xx_config_ipaddr, & qlcnic_82xx_clear_legacy_intr,
    & qlcnic_82xx_shutdown, & qlcnic_82xx_resume};
struct qlcnic_nic_template qlcnic_vf_ops =
     {& qlcnicvf_config_bridged_mode, & qlcnicvf_config_led, & qlcnicvf_start_firmware,
    0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct qlcnic_hardware_ops qlcnic_hw_ops =
     {& qlcnic_82xx_read_crb, & qlcnic_82xx_write_crb, & qlcnic_82xx_hw_read_wx_2M,
    & qlcnic_82xx_hw_write_wx_2M, 0, & qlcnic_82xx_get_mac_address, & qlcnic_82xx_setup_intr,
    & qlcnic_82xx_alloc_mbx_args, & qlcnic_82xx_issue_cmd, & qlcnic_82xx_get_func_no,
    & qlcnic_82xx_api_lock, & qlcnic_82xx_api_unlock, & qlcnic_82xx_add_sysfs, & qlcnic_82xx_remove_sysfs,
    & qlcnic_82xx_process_rcv_ring_diag, & qlcnic_82xx_fw_cmd_create_rx_ctx, & qlcnic_82xx_fw_cmd_create_tx_ctx,
    & qlcnic_82xx_fw_cmd_del_rx_ctx, & qlcnic_82xx_fw_cmd_del_tx_ctx, & qlcnic_82xx_linkevent_request,
    & qlcnic_82xx_get_nic_info, & qlcnic_82xx_get_pci_info, & qlcnic_82xx_set_nic_info,
    & qlcnic_82xx_sre_macaddr_change, & qlcnic_82xx_napi_enable, & qlcnic_82xx_napi_disable,
    & qlcnic_82xx_config_intr_coalesce, & qlcnic_82xx_config_rss, & qlcnic_82xx_config_hw_lro,
    & qlcnic_82xx_set_lb_mode, & qlcnic_82xx_clear_lb_mode, & qlcnic_82xx_nic_set_promisc,
    & qlcnic_82xx_change_filter, & qlcnic_82xx_get_board_info, & qlcnic_82xx_set_mac_filter_count,
    & qlcnic_82xx_free_mac_list, & qlcnic_82xx_read_phys_port_id, & qlcnic_82xx_io_error_detected,
    & qlcnic_82xx_io_slot_reset, & qlcnic_82xx_io_resume, & qlcnic_82xx_get_beacon_state,
    & qlcnic_82xx_enable_sds_intr, & qlcnic_82xx_disable_sds_intr, & qlcnic_82xx_enable_tx_intr,
    & qlcnic_82xx_disable_tx_intr, & qlcnic_82xx_get_saved_state, & qlcnic_82xx_set_saved_state,
    & qlcnic_82xx_cache_tmpl_hdr_values, & qlcnic_82xx_get_cap_size, & qlcnic_82xx_set_sys_info,
    & qlcnic_82xx_store_cap_mask};
static int qlcnic_check_multi_tx_capability(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  bool tmp ;
  {
  ahw = adapter->ahw;
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp && (ahw->extra_capability[0] & 16U) != 0U) {
    test_and_set_bit(9L, (unsigned long volatile *)(& adapter->state));
    return (0);
  } else {
    return (1);
  }
}
}
static int qlcnic_max_rings(struct qlcnic_adapter *adapter , u8 ring_cnt , int queue_type )
{
  int num_rings ;
  int max_rings ;
  int __min1 ;
  unsigned int tmp ;
  int __min2 ;
  unsigned long tmp___0 ;
  {
  max_rings = 8;
  if (queue_type == 2) {
    max_rings = (int )adapter->max_sds_rings;
  } else
  if (queue_type == 1) {
    max_rings = (int )adapter->max_tx_rings;
  } else {
  }
  tmp = cpumask_weight(cpu_online_mask);
  __min1 = (int )tmp;
  __min2 = max_rings;
  tmp___0 = __rounddown_pow_of_two((unsigned long )(__min1 < __min2 ? __min1 : __min2));
  num_rings = (int )tmp___0;
  if ((int )ring_cnt > num_rings) {
    return (num_rings);
  } else {
    return ((int )ring_cnt);
  }
}
}
void qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter , u8 tx_cnt )
{
  int tmp ;
  {
  if ((unsigned int )adapter->max_tx_rings != 0U) {
    tmp = qlcnic_max_rings(adapter, (int )tx_cnt, 1);
    adapter->drv_tx_rings = (u8 )tmp;
  } else {
    adapter->drv_tx_rings = tx_cnt;
  }
  return;
}
}
void qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter , u8 rx_cnt )
{
  int tmp ;
  {
  if ((unsigned int )adapter->max_sds_rings != 0U) {
    tmp = qlcnic_max_rings(adapter, (int )rx_cnt, 2);
    adapter->drv_sds_rings = (u8 )tmp;
  } else {
    adapter->drv_sds_rings = rx_cnt;
  }
  return;
}
}
int qlcnic_setup_tss_rss_intr(struct qlcnic_adapter *adapter )
{
  struct pci_dev *pdev ;
  int num_msix ;
  int err ;
  int vector ;
  bool tmp ;
  void *tmp___0 ;
  bool tmp___1 ;
  {
  pdev = adapter->pdev;
  num_msix = 0;
  err = 0;
  adapter->flags = adapter->flags & 4294443007U;
  if ((unsigned int )adapter->drv_tss_rings != 0U) {
    num_msix = (int )adapter->drv_tss_rings + num_msix;
  } else {
    num_msix = (int )adapter->drv_tx_rings + num_msix;
  }
  if ((unsigned int )adapter->drv_rss_rings != 0U) {
    num_msix = (int )adapter->drv_rss_rings + num_msix;
  } else {
    num_msix = (int )adapter->drv_sds_rings + num_msix;
  }
  tmp = qlcnic_83xx_check(adapter);
  if ((int )tmp) {
    num_msix = num_msix + 1;
  } else {
  }
  if ((unsigned long )adapter->msix_entries == (unsigned long )((struct msix_entry *)0)) {
    tmp___0 = kcalloc((size_t )num_msix, 8UL, 208U);
    adapter->msix_entries = (struct msix_entry *)tmp___0;
    if ((unsigned long )adapter->msix_entries == (unsigned long )((struct msix_entry *)0)) {
      return (-12);
    } else {
    }
  } else {
  }
  vector = 0;
  goto ldv_53799;
  ldv_53798:
  (adapter->msix_entries + (unsigned long )vector)->entry = (u16 )vector;
  vector = vector + 1;
  ldv_53799: ;
  if (vector < num_msix) {
    goto ldv_53798;
  } else {
  }
  restore:
  err = pci_enable_msix_exact(pdev, adapter->msix_entries, num_msix);
  if (err == -28) {
    if ((unsigned int )adapter->drv_tss_rings == 0U && (unsigned int )adapter->drv_rss_rings == 0U) {
      return (err);
    } else {
    }
    netdev_info((struct net_device const *)adapter->netdev, "Unable to allocate %d MSI-X vectors, Available vectors %d\n",
                num_msix, err);
    num_msix = (int )adapter->drv_tx_rings + (int )adapter->drv_sds_rings;
    adapter->drv_tss_rings = 0U;
    adapter->drv_rss_rings = 0U;
    tmp___1 = qlcnic_83xx_check(adapter);
    if ((int )tmp___1) {
      num_msix = num_msix + 1;
    } else {
    }
    netdev_info((struct net_device const *)adapter->netdev, "Restoring %d Tx, %d SDS rings for total %d vectors.\n",
                (int )adapter->drv_tx_rings, (int )adapter->drv_sds_rings, num_msix);
    goto restore;
  } else
  if (err < 0) {
    return (err);
  } else {
  }
  (adapter->ahw)->num_msix = (u8 )num_msix;
  if ((unsigned int )adapter->drv_tss_rings != 0U) {
    adapter->drv_tx_rings = adapter->drv_tss_rings;
  } else {
  }
  if ((unsigned int )adapter->drv_rss_rings != 0U) {
    adapter->drv_sds_rings = adapter->drv_rss_rings;
  } else {
  }
  return (0);
}
}
int qlcnic_enable_msix(struct qlcnic_adapter *adapter , u32 num_msix )
{
  struct pci_dev *pdev ;
  int err ;
  int vector ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  {
  pdev = adapter->pdev;
  if ((unsigned long )adapter->msix_entries == (unsigned long )((struct msix_entry *)0)) {
    tmp = kcalloc((size_t )num_msix, 8UL, 208U);
    adapter->msix_entries = (struct msix_entry *)tmp;
    if ((unsigned long )adapter->msix_entries == (unsigned long )((struct msix_entry *)0)) {
      return (-12);
    } else {
    }
  } else {
  }
  adapter->flags = adapter->flags & 4294967289U;
  if ((unsigned int )(adapter->ahw)->msix_supported != 0U) {
    enable_msix:
    vector = 0;
    goto ldv_53811;
    ldv_53810:
    (adapter->msix_entries + (unsigned long )vector)->entry = (u16 )vector;
    vector = vector + 1;
    ldv_53811: ;
    if ((u32 )vector < num_msix) {
      goto ldv_53810;
    } else {
    }
    err = pci_enable_msix_range(pdev, adapter->msix_entries, 1, (int )num_msix);
    if ((u32 )err == num_msix) {
      adapter->flags = adapter->flags | 4U;
      (adapter->ahw)->num_msix = (u8 )num_msix;
      _dev_info((struct device const *)(& pdev->dev), "using msi-x interrupts\n");
      return (0);
    } else
    if (err > 0) {
      pci_disable_msix(pdev);
      _dev_info((struct device const *)(& pdev->dev), "Unable to allocate %d MSI-X vectors, Available vectors %d\n",
                num_msix, err);
      tmp___2 = qlcnic_82xx_check(adapter);
      if ((int )tmp___2) {
        tmp___0 = __rounddown_pow_of_two((unsigned long )err);
        num_msix = (u32 )tmp___0;
        if (err <= 1) {
          return (-28);
        } else {
        }
      } else {
        tmp___1 = __rounddown_pow_of_two((unsigned long )(err + -1));
        num_msix = (u32 )tmp___1;
        num_msix = num_msix + 1U;
        if (err <= 2) {
          return (-28);
        } else {
        }
      }
      tmp___3 = qlcnic_82xx_check(adapter);
      if ((int )tmp___3) {
        tmp___4 = qlcnic_check_multi_tx(adapter);
        if (tmp___4) {
          tmp___5 = 0;
        } else {
          tmp___5 = 1;
        }
        if (tmp___5) {
          adapter->drv_sds_rings = (u8 )num_msix;
          adapter->drv_tx_rings = 1U;
        } else {
          adapter->drv_tx_rings = (u8 )(num_msix / 2U);
          adapter->drv_sds_rings = adapter->drv_tx_rings;
        }
      } else {
        adapter->drv_tx_rings = (u8 )(num_msix / 2U);
        adapter->drv_sds_rings = adapter->drv_tx_rings;
      }
      if (num_msix != 0U) {
        _dev_info((struct device const *)(& pdev->dev), "Trying to allocate %d MSI-X interrupt vectors\n",
                  num_msix);
        goto enable_msix;
      } else {
      }
    } else {
      _dev_info((struct device const *)(& pdev->dev), "Unable to allocate %d MSI-X vectors, err=%d\n",
                num_msix, err);
      return (err);
    }
  } else {
  }
  return (-5);
}
}
static int qlcnic_82xx_calculate_msix_vector(struct qlcnic_adapter *adapter )
{
  int num_msix ;
  bool tmp ;
  {
  num_msix = (int )adapter->drv_sds_rings;
  tmp = qlcnic_check_multi_tx(adapter);
  if ((int )tmp) {
    num_msix = (int )adapter->drv_tx_rings + num_msix;
  } else {
    num_msix = num_msix + 1;
  }
  return (num_msix);
}
}
static int qlcnic_enable_msi_legacy(struct qlcnic_adapter *adapter )
{
  int err ;
  u32 offset ;
  u32 mask_reg ;
  struct qlcnic_legacy_intr_set const *legacy_intrp ;
  struct qlcnic_hardware_context *ahw ;
  struct pci_dev *pdev ;
  int tmp ;
  {
  err = 0;
  ahw = adapter->ahw;
  pdev = adapter->pdev;
  if (qlcnic_use_msi != 0) {
    tmp = pci_enable_msi_exact(pdev, 1);
    if (tmp == 0) {
      adapter->flags = adapter->flags | 2U;
      offset = msi_tgt_status[(int )(adapter->ahw)->pci_func];
      adapter->tgt_status_reg = qlcnic_get_ioaddr(adapter->ahw, offset);
      _dev_info((struct device const *)(& pdev->dev), "using msi interrupts\n");
      (adapter->msix_entries)->vector = pdev->irq;
      return (err);
    } else {
    }
  } else {
  }
  if (qlcnic_use_msi != 0 || qlcnic_use_msi_x != 0) {
    return (-95);
  } else {
  }
  legacy_intrp = (struct qlcnic_legacy_intr_set const *)(& legacy_intr) + (unsigned long )(adapter->ahw)->pci_func;
  (adapter->ahw)->int_vec_bit = legacy_intrp->int_vec_bit;
  offset = legacy_intrp->tgt_status_reg;
  adapter->tgt_status_reg = qlcnic_get_ioaddr(ahw, offset);
  mask_reg = legacy_intrp->tgt_mask_reg;
  adapter->tgt_mask_reg = qlcnic_get_ioaddr(ahw, mask_reg);
  adapter->isr_int_vec = qlcnic_get_ioaddr(ahw, 101777664U);
  adapter->crb_int_state_reg = qlcnic_get_ioaddr(ahw, 101785708U);
  _dev_info((struct device const *)(& pdev->dev), "using legacy interrupts\n");
  (adapter->msix_entries)->vector = pdev->irq;
  return (err);
}
}
static int qlcnic_82xx_setup_intr(struct qlcnic_adapter *adapter )
{
  int num_msix ;
  int err ;
  {
  err = 0;
  if ((adapter->flags & 524288U) != 0U) {
    err = qlcnic_setup_tss_rss_intr(adapter);
    if (err < 0) {
      return (err);
    } else {
    }
    num_msix = (int )(adapter->ahw)->num_msix;
  } else {
    num_msix = qlcnic_82xx_calculate_msix_vector(adapter);
    err = qlcnic_enable_msix(adapter, (u32 )num_msix);
    if (err == -12) {
      return (err);
    } else {
    }
    if ((adapter->flags & 4U) == 0U) {
      qlcnic_disable_multi_tx(adapter);
      adapter->drv_sds_rings = 1U;
      err = qlcnic_enable_msi_legacy(adapter);
      if (err != 0) {
        return (err);
      } else {
      }
    } else {
    }
  }
  return (0);
}
}
int qlcnic_82xx_mq_intrpt(struct qlcnic_adapter *adapter , int op_type )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  int i ;
  void *tmp ;
  bool tmp___0 ;
  {
  ahw = adapter->ahw;
  tmp___0 = qlcnic_check_multi_tx(adapter);
  if (((int )tmp___0 && (unsigned int )ahw->diag_test == 0U) && (adapter->flags & 4U) != 0U) {
    tmp = ldv_vzalloc_78((unsigned long )ahw->num_msix * 8UL);
    ahw->intr_tbl = (struct qlcnic_intrpt_config *)tmp;
    if ((unsigned long )ahw->intr_tbl == (unsigned long )((struct qlcnic_intrpt_config *)0)) {
      return (-12);
    } else {
    }
    i = 0;
    goto ldv_53839;
    ldv_53838:
    (ahw->intr_tbl + (unsigned long )i)->type = 3U;
    (ahw->intr_tbl + (unsigned long )i)->id = (u16 )i;
    (ahw->intr_tbl + (unsigned long )i)->src = 0U;
    i = i + 1;
    ldv_53839: ;
    if ((int )ahw->num_msix > i) {
      goto ldv_53838;
    } else {
    }
    err = qlcnic_82xx_config_intrpt(adapter, 1);
    if (err != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to configure Interrupt for %d vector\n",
              (int )ahw->num_msix);
    } else {
    }
    return (err);
  } else {
  }
  return (0);
}
}
void qlcnic_teardown_intr(struct qlcnic_adapter *adapter )
{
  {
  if ((adapter->flags & 4U) != 0U) {
    pci_disable_msix(adapter->pdev);
  } else {
  }
  if ((adapter->flags & 2U) != 0U) {
    pci_disable_msi(adapter->pdev);
  } else {
  }
  kfree((void const *)adapter->msix_entries);
  adapter->msix_entries = (struct msix_entry *)0;
  if ((unsigned long )(adapter->ahw)->intr_tbl != (unsigned long )((struct qlcnic_intrpt_config *)0)) {
    vfree((void const *)(adapter->ahw)->intr_tbl);
    (adapter->ahw)->intr_tbl = (struct qlcnic_intrpt_config *)0;
  } else {
  }
  return;
}
}
static void qlcnic_cleanup_pci_map(struct qlcnic_hardware_context *ahw )
{
  {
  if ((unsigned long )ahw->pci_base0 != (unsigned long )((void *)0)) {
    iounmap((void volatile *)ahw->pci_base0);
  } else {
  }
  return;
}
}
static int qlcnic_get_act_pci_func(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_pci_info *pci_info ;
  int ret ;
  void *tmp ;
  {
  ahw = adapter->ahw;
  if ((adapter->flags & 64U) == 0U) {
    switch ((int )ahw->port_type) {
    case 1:
    ahw->total_nic_func = 4U;
    goto ldv_53854;
    case 2:
    ahw->total_nic_func = 2U;
    goto ldv_53854;
    }
    ldv_53854: ;
    return (0);
  } else {
  }
  if ((unsigned int )ahw->op_mode == 0U) {
    return (0);
  } else {
  }
  tmp = kcalloc((size_t )ahw->max_vnic_func, 20UL, 208U);
  pci_info = (struct qlcnic_pci_info *)tmp;
  if ((unsigned long )pci_info == (unsigned long )((struct qlcnic_pci_info *)0)) {
    return (-12);
  } else {
  }
  ret = qlcnic_get_pci_info(adapter, pci_info);
  kfree((void const *)pci_info);
  return (ret);
}
}
static bool qlcnic_port_eswitch_cfg_capability(struct qlcnic_adapter *adapter )
{
  bool ret ;
  bool tmp ;
  bool tmp___0 ;
  {
  ret = 0;
  tmp___0 = qlcnic_84xx_check(adapter);
  if ((int )tmp___0) {
    ret = 1;
  } else {
    tmp = qlcnic_83xx_check(adapter);
    if ((int )tmp) {
      if (((adapter->ahw)->extra_capability[0] & 512U) != 0U) {
        ret = 1;
      } else {
        ret = 0;
      }
    } else {
    }
  }
  return (ret);
}
}
int qlcnic_init_pci_info(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_pci_info *pci_info ;
  int i ;
  int id ;
  int ret ;
  int j ;
  u16 act_pci_func ;
  u8 pfn ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  size_t __len ;
  void *__ret ;
  bool tmp___4 ;
  int tmp___5 ;
  {
  ahw = adapter->ahw;
  id = 0;
  ret = 0;
  j = 0;
  tmp = kcalloc((size_t )ahw->max_vnic_func, 20UL, 208U);
  pci_info = (struct qlcnic_pci_info *)tmp;
  if ((unsigned long )pci_info == (unsigned long )((struct qlcnic_pci_info *)0)) {
    return (-12);
  } else {
  }
  ret = qlcnic_get_pci_info(adapter, pci_info);
  if (ret != 0) {
    goto err_pci_info;
  } else {
  }
  act_pci_func = ahw->total_nic_func;
  tmp___0 = kzalloc((unsigned long )act_pci_func * 26UL, 208U);
  adapter->npars = (struct qlcnic_npar_info *)tmp___0;
  if ((unsigned long )adapter->npars == (unsigned long )((struct qlcnic_npar_info *)0)) {
    ret = -12;
    goto err_pci_info;
  } else {
  }
  tmp___1 = kzalloc(24UL, 208U);
  adapter->eswitch = (struct qlcnic_eswitch *)tmp___1;
  if ((unsigned long )adapter->eswitch == (unsigned long )((struct qlcnic_eswitch *)0)) {
    ret = -12;
    goto err_npars;
  } else {
  }
  i = 0;
  goto ldv_53880;
  ldv_53879:
  pfn = (u8 )(pci_info + (unsigned long )i)->id;
  if ((u32 )pfn >= ahw->max_vnic_func) {
    ret = -1;
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid function 0x%x, max 0x%x\n",
            "qlcnic_init_pci_info", (int )pfn, ahw->max_vnic_func);
    goto err_eswitch;
  } else {
  }
  if ((unsigned int )(pci_info + (unsigned long )i)->active == 0U || (unsigned int )(pci_info + (unsigned long )i)->type != 1U) {
    goto ldv_53875;
  } else {
  }
  tmp___3 = qlcnic_port_eswitch_cfg_capability(adapter);
  if ((int )tmp___3) {
    tmp___2 = qlcnic_83xx_set_port_eswitch_status(adapter, (int )pfn, & id);
    if (tmp___2 == 0) {
      (adapter->npars + (unsigned long )j)->eswitch_status = 1;
    } else {
      goto ldv_53875;
    }
  } else {
    (adapter->npars + (unsigned long )j)->eswitch_status = 1;
  }
  (adapter->npars + (unsigned long )j)->pci_func = pfn;
  (adapter->npars + (unsigned long )j)->active = (unsigned char )(pci_info + (unsigned long )i)->active;
  (adapter->npars + (unsigned long )j)->type = (unsigned char )(pci_info + (unsigned long )i)->type;
  (adapter->npars + (unsigned long )j)->phy_port = (unsigned char )(pci_info + (unsigned long )i)->default_port;
  (adapter->npars + (unsigned long )j)->min_bw = (pci_info + (unsigned long )i)->tx_min_bw;
  (adapter->npars + (unsigned long )j)->max_bw = (pci_info + (unsigned long )i)->tx_max_bw;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& (adapter->npars + (unsigned long )j)->mac), (void const *)(& (pci_info + (unsigned long )i)->mac),
                     __len);
  } else {
    __ret = memcpy((void *)(& (adapter->npars + (unsigned long )j)->mac),
                             (void const *)(& (pci_info + (unsigned long )i)->mac),
                             __len);
  }
  j = j + 1;
  ldv_53875:
  i = i + 1;
  ldv_53880: ;
  if ((u32 )i < ahw->max_vnic_func) {
    goto ldv_53879;
  } else {
  }
  tmp___4 = qlcnic_port_eswitch_cfg_capability(adapter);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    i = 0;
    goto ldv_53883;
    ldv_53882:
    (adapter->eswitch + (unsigned long )i)->flags = (adapter->eswitch + (unsigned long )i)->flags | 2U;
    i = i + 1;
    ldv_53883: ;
    if (i <= 1) {
      goto ldv_53882;
    } else {
    }
  } else {
  }
  kfree((void const *)pci_info);
  return (0);
  err_eswitch:
  kfree((void const *)adapter->eswitch);
  adapter->eswitch = (struct qlcnic_eswitch *)0;
  err_npars:
  kfree((void const *)adapter->npars);
  adapter->npars = (struct qlcnic_npar_info *)0;
  err_pci_info:
  kfree((void const *)pci_info);
  return (ret);
}
}
static int qlcnic_set_function_modes(struct qlcnic_adapter *adapter )
{
  u8 id ;
  int ret ;
  u32 data ;
  struct qlcnic_hardware_context *ahw ;
  {
  data = 0U;
  ahw = adapter->ahw;
  ret = qlcnic_api_lock(adapter);
  if (ret != 0) {
    goto err_lock;
  } else {
  }
  id = ahw->pci_func;
  data = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 20UL));
  data = (u32 )(~ (15 << (int )id * 4)) & data;
  writel(data, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 20UL));
  qlcnic_api_unlock(adapter);
  err_lock: ;
  return (ret);
}
}
static void qlcnic_check_vf(struct qlcnic_adapter *adapter , struct pci_device_id const *ent )
{
  u32 op_mode ;
  u32 priv_level ;
  {
  (adapter->ahw)->fw_hal_version = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 19UL));
  qlcnic_get_func_no(adapter);
  op_mode = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 20UL));
  if (op_mode == 286331153U) {
    priv_level = 0U;
  } else {
    priv_level = (op_mode >> (int )(adapter->ahw)->pci_func * 4) & 15U;
  }
  if (priv_level == 2U) {
    (adapter->ahw)->op_mode = 2U;
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d Non Privileged function\n",
              (adapter->ahw)->fw_hal_version);
    adapter->nic_ops = & qlcnic_vf_ops;
  } else {
    adapter->nic_ops = & qlcnic_ops;
  }
  return;
}
}
static void qlcnic_get_bar_length(u32 dev_id , ulong *bar )
{
  {
  switch (dev_id) {
  case 32800U:
  *bar = 2097152UL;
  goto ldv_53904;
  case 32816U: ;
  case 32832U: ;
  case 33840U: ;
  case 33856U:
  *bar = 16384UL;
  goto ldv_53904;
  default:
  *bar = 0UL;
  }
  ldv_53904: ;
  return;
}
}
static int qlcnic_setup_pci_map(struct pci_dev *pdev , struct qlcnic_hardware_context *ahw )
{
  u32 offset ;
  void *mem_ptr0 ;
  unsigned long mem_len ;
  unsigned long pci_len0 ;
  unsigned long bar0_len ;
  {
  mem_ptr0 = (void *)0;
  pci_len0 = 0UL;
  mem_len = pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start ? (unsigned long )((pdev->resource[0].end - pdev->resource[0].start) + 1ULL) : 0UL;
  qlcnic_get_bar_length((u32 )pdev->device, & bar0_len);
  if (mem_len >= bar0_len) {
    mem_ptr0 = pci_ioremap_bar(pdev, 0);
    if ((unsigned long )mem_ptr0 == (unsigned long )((void *)0)) {
      dev_err((struct device const *)(& pdev->dev), "failed to map PCI bar 0\n");
      return (-5);
    } else {
    }
    pci_len0 = mem_len;
  } else {
    return (-5);
  }
  _dev_info((struct device const *)(& pdev->dev), "%dKB memory map\n", (int )(mem_len >> 10));
  ahw->pci_base0 = mem_ptr0;
  ahw->pci_len0 = pci_len0;
  offset = ((u32 )ahw->pci_func + 25444864U) * 4U;
  qlcnic_get_ioaddr(ahw, offset);
  return (0);
}
}
static bool qlcnic_validate_subsystem_id(struct qlcnic_adapter *adapter , int index )
{
  struct pci_dev *pdev ;
  unsigned short subsystem_vendor ;
  bool ret ;
  {
  pdev = adapter->pdev;
  ret = 1;
  subsystem_vendor = pdev->subsystem_vendor;
  if ((unsigned int )pdev->device == 32800U || (unsigned int )pdev->device == 32816U) {
    if ((int )((unsigned short )qlcnic_boards[index].sub_vendor) == (int )subsystem_vendor && (int )((unsigned short )qlcnic_boards[index].sub_device) == (int )pdev->subsystem_device) {
      ret = 1;
    } else {
      ret = 0;
    }
  } else {
  }
  return (ret);
}
}
static void qlcnic_get_board_name(struct qlcnic_adapter *adapter , char *name )
{
  struct pci_dev *pdev ;
  int i ;
  int found ;
  bool tmp ;
  {
  pdev = adapter->pdev;
  found = 0;
  i = 0;
  goto ldv_53937;
  ldv_53936: ;
  if ((int )((unsigned short )qlcnic_boards[i].vendor) == (int )pdev->vendor && (int )((unsigned short )qlcnic_boards[i].device) == (int )pdev->device) {
    tmp = qlcnic_validate_subsystem_id(adapter, i);
    if ((int )tmp) {
      found = 1;
      goto ldv_53935;
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_53937: ;
  if ((unsigned int )i <= 20U) {
    goto ldv_53936;
  } else {
  }
  ldv_53935: ;
  if (found == 0) {
    sprintf(name, "%pM Gigabit Ethernet", (u8 *)(& adapter->mac_addr));
  } else {
    sprintf(name, "%pM: %s", (u8 *)(& adapter->mac_addr), (char const *)(& qlcnic_boards[i].short_name));
  }
  return;
}
}
static void qlcnic_check_options(struct qlcnic_adapter *adapter )
{
  int err ;
  u32 fw_major ;
  u32 fw_minor ;
  u32 fw_build ;
  u32 prev_fw_version ;
  struct pci_dev *pdev ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_fw_dump *fw_dump ;
  int tmp ;
  {
  pdev = adapter->pdev;
  ahw = adapter->ahw;
  fw_dump = & ahw->fw_dump;
  prev_fw_version = adapter->fw_version;
  fw_major = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 11UL));
  fw_minor = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 12UL));
  fw_build = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 13UL));
  adapter->fw_version = ((fw_major << 24) + (fw_minor << 16)) + fw_build;
  err = qlcnic_get_board_info(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& pdev->dev), "Error getting board config info.\n");
    return;
  } else {
  }
  if ((unsigned int )ahw->op_mode != 2U) {
    if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0) || adapter->fw_version > prev_fw_version) {
      if ((unsigned long )fw_dump->tmpl_hdr != (unsigned long )((void *)0)) {
        vfree((void const *)fw_dump->tmpl_hdr);
      } else {
      }
      tmp = qlcnic_fw_cmd_get_minidump_temp(adapter);
      if (tmp == 0) {
        _dev_info((struct device const *)(& pdev->dev), "Supports FW dump capability\n");
      } else {
      }
    } else {
    }
  } else {
  }
  _dev_info((struct device const *)(& pdev->dev), "Driver v%s, firmware v%d.%d.%d\n",
            (char *)"5.3.60", fw_major, fw_minor, fw_build);
  if ((unsigned int )(adapter->ahw)->port_type == 2U) {
    if ((adapter->flags & 64U) != 0U) {
      adapter->num_rxd = 1024U;
      adapter->max_rxd = 2048U;
    } else {
      adapter->num_rxd = 4096U;
      adapter->max_rxd = 8192U;
    }
    adapter->num_jumbo_rxd = 1024U;
    adapter->max_jumbo_rxd = 1024U;
  } else
  if ((unsigned int )(adapter->ahw)->port_type == 1U) {
    adapter->num_rxd = 2048U;
    adapter->num_jumbo_rxd = 512U;
    adapter->max_jumbo_rxd = 512U;
    adapter->max_rxd = 4096U;
  } else {
  }
  (adapter->ahw)->msix_supported = qlcnic_use_msi_x != 0;
  adapter->num_txd = 1024U;
  adapter->max_rds_rings = 2U;
  return;
}
}
static int qlcnic_initialize_nic(struct qlcnic_adapter *adapter )
{
  struct qlcnic_info nic_info ;
  int err ;
  u32 temp ;
  int tmp ;
  {
  err = 0;
  memset((void *)(& nic_info), 0, 72UL);
  err = qlcnic_get_nic_info(adapter, & nic_info, (int )(adapter->ahw)->pci_func);
  if (err != 0) {
    return (err);
  } else {
  }
  (adapter->ahw)->physical_port = (unsigned char )nic_info.phys_port;
  (adapter->ahw)->switch_mode = nic_info.switch_mode;
  (adapter->ahw)->max_tx_ques = nic_info.max_tx_ques;
  (adapter->ahw)->max_rx_ques = nic_info.max_rx_ques;
  (adapter->ahw)->capabilities = nic_info.capabilities;
  if ((int )(adapter->ahw)->capabilities < 0) {
    tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323372UL, & err);
    temp = (u32 )tmp;
    if (err == -5) {
      return (err);
    } else {
    }
    (adapter->ahw)->extra_capability[0] = temp;
  } else {
    (adapter->ahw)->extra_capability[0] = 0U;
  }
  (adapter->ahw)->max_mac_filters = nic_info.max_mac_filters;
  (adapter->ahw)->max_mtu = nic_info.max_mtu;
  if (((adapter->ahw)->capabilities & 64U) != 0U) {
    adapter->flags = adapter->flags | 64U;
    (adapter->ahw)->nic_mode = 255U;
    adapter->max_tx_rings = 4U;
    adapter->max_sds_rings = 4U;
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "vNIC mode enabled.\n");
  } else {
    (adapter->ahw)->nic_mode = 0U;
    adapter->max_tx_rings = 8U;
    adapter->max_sds_rings = 8U;
    adapter->flags = adapter->flags & 4294967231U;
  }
  return (err);
}
}
void qlcnic_set_vlan_config(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg )
{
  {
  if ((unsigned int )esw_cfg->discard_tagged != 0U) {
    adapter->flags = adapter->flags & 4294967039U;
  } else {
    adapter->flags = adapter->flags | 256U;
  }
  if ((unsigned int )esw_cfg->vlan_id != 0U) {
    adapter->rx_pvid = esw_cfg->vlan_id;
    adapter->tx_pvid = esw_cfg->vlan_id;
  } else {
    adapter->rx_pvid = 0U;
    adapter->tx_pvid = 0U;
  }
  return;
}
}
static int qlcnic_vlan_rx_add(struct net_device *netdev , __be16 proto , u16 vid )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  bool tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___0) {
    err = qlcnic_sriov_cfg_vf_guest_vlan(adapter, (int )vid, 1);
    if (err != 0) {
      netdev_err((struct net_device const *)netdev, "Cannot add VLAN filter for VLAN id %d, err=%d",
                 (int )vid, err);
      return (err);
    } else {
    }
  } else {
  }
  set_bit((long )vid, (unsigned long volatile *)(& adapter->vlans));
  return (0);
}
}
static int qlcnic_vlan_rx_del(struct net_device *netdev , __be16 proto , u16 vid )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  bool tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___0) {
    err = qlcnic_sriov_cfg_vf_guest_vlan(adapter, (int )vid, 0);
    if (err != 0) {
      netdev_err((struct net_device const *)netdev, "Cannot delete VLAN filter for VLAN id %d, err=%d",
                 (int )vid, err);
      return (err);
    } else {
    }
  } else {
  }
  qlcnic_restore_indev_addr(netdev, 2UL);
  clear_bit((long )vid, (unsigned long volatile *)(& adapter->vlans));
  return (0);
}
}
void qlcnic_set_eswitch_port_features(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg )
{
  {
  adapter->flags = adapter->flags & 4294963711U;
  if ((unsigned int )esw_cfg->mac_anti_spoof != 0U) {
    adapter->flags = adapter->flags | 512U;
  } else {
  }
  if ((unsigned int )esw_cfg->mac_override == 0U) {
    adapter->flags = adapter->flags | 1024U;
  } else {
  }
  if ((unsigned int )esw_cfg->promisc_mode == 0U) {
    adapter->flags = adapter->flags | 2048U;
  } else {
  }
  return;
}
}
int qlcnic_set_eswitch_port_config(struct qlcnic_adapter *adapter )
{
  struct qlcnic_esw_func_cfg esw_cfg ;
  int tmp ;
  {
  if ((adapter->flags & 64U) == 0U) {
    return (0);
  } else {
  }
  esw_cfg.pci_func = (adapter->ahw)->pci_func;
  tmp = qlcnic_get_eswitch_port_config(adapter, & esw_cfg);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  qlcnic_set_vlan_config(adapter, & esw_cfg);
  qlcnic_set_eswitch_port_features(adapter, & esw_cfg);
  qlcnic_set_netdev_features(adapter, & esw_cfg);
  return (0);
}
}
void qlcnic_set_netdev_features(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg )
{
  struct net_device *netdev ;
  bool tmp ;
  {
  netdev = adapter->netdev;
  tmp = qlcnic_83xx_check(adapter);
  if ((int )tmp) {
    return;
  } else {
  }
  adapter->offload_flags = (u32 )esw_cfg->offload_flags;
  adapter->flags = adapter->flags | 131072U;
  netdev_update_features(netdev);
  adapter->flags = adapter->flags & 4294836223U;
  return;
}
}
static int qlcnic_check_eswitch_mode(struct qlcnic_adapter *adapter )
{
  u32 op_mode ;
  u32 priv_level ;
  int err ;
  {
  err = 0;
  err = qlcnic_initialize_nic(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  if ((adapter->flags & 128U) != 0U) {
    return (0);
  } else {
  }
  op_mode = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 20UL));
  priv_level = (op_mode >> (int )(adapter->ahw)->pci_func * 4) & 15U;
  if (op_mode == 286331153U) {
    priv_level = 0U;
  } else {
    priv_level = (op_mode >> (int )(adapter->ahw)->pci_func * 4) & 15U;
  }
  if ((adapter->flags & 64U) != 0U) {
    if (priv_level == 0U) {
      (adapter->ahw)->op_mode = 0U;
      err = qlcnic_init_pci_info(adapter);
      if (err != 0) {
        return (err);
      } else {
      }
      qlcnic_set_function_modes(adapter);
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d, Management function\n",
                (adapter->ahw)->fw_hal_version);
    } else
    if (priv_level == 1U) {
      (adapter->ahw)->op_mode = 1U;
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d, Privileged function\n",
                (adapter->ahw)->fw_hal_version);
    } else {
    }
  } else {
    (adapter->ahw)->nic_mode = 0U;
  }
  adapter->flags = adapter->flags | 128U;
  return (err);
}
}
int qlcnic_set_default_offload_settings(struct qlcnic_adapter *adapter )
{
  struct qlcnic_esw_func_cfg esw_cfg ;
  struct qlcnic_npar_info *npar ;
  u8 i ;
  bool tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )adapter->need_fw_reset != 0U) {
    return (0);
  } else {
  }
  i = 0U;
  goto ldv_54000;
  ldv_53999: ;
  if (! (adapter->npars + (unsigned long )i)->eswitch_status) {
    goto ldv_53998;
  } else {
  }
  memset((void *)(& esw_cfg), 0, 16UL);
  esw_cfg.pci_func = (adapter->npars + (unsigned long )i)->pci_func;
  esw_cfg.mac_override = 1U;
  esw_cfg.promisc_mode = 1U;
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    esw_cfg.offload_flags = 1U;
    if (((adapter->ahw)->capabilities & 2U) != 0U) {
      esw_cfg.offload_flags = (u8 )((unsigned int )esw_cfg.offload_flags | 6U);
    } else {
    }
  } else {
  }
  tmp___0 = qlcnic_config_switch_port(adapter, & esw_cfg);
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  npar = adapter->npars + (unsigned long )i;
  npar->pvid = esw_cfg.vlan_id;
  npar->mac_override = esw_cfg.mac_override;
  npar->mac_anti_spoof = esw_cfg.mac_anti_spoof;
  npar->discard_tagged = esw_cfg.discard_tagged;
  npar->promisc_mode = esw_cfg.promisc_mode;
  npar->offload_flags = esw_cfg.offload_flags;
  ldv_53998:
  i = (u8 )((int )i + 1);
  ldv_54000: ;
  if ((int )((unsigned short )i) < (int )(adapter->ahw)->total_nic_func) {
    goto ldv_53999;
  } else {
  }
  return (0);
}
}
static int qlcnic_reset_eswitch_config(struct qlcnic_adapter *adapter , struct qlcnic_npar_info *npar ,
                                       int pci_func )
{
  struct qlcnic_esw_func_cfg esw_cfg ;
  int tmp ;
  int tmp___0 ;
  {
  esw_cfg.op_mode = 0U;
  esw_cfg.pci_func = (u8 )pci_func;
  esw_cfg.vlan_id = npar->pvid;
  esw_cfg.mac_override = npar->mac_override;
  esw_cfg.discard_tagged = npar->discard_tagged;
  esw_cfg.mac_anti_spoof = npar->mac_anti_spoof;
  esw_cfg.offload_flags = npar->offload_flags;
  esw_cfg.promisc_mode = npar->promisc_mode;
  tmp = qlcnic_config_switch_port(adapter, & esw_cfg);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  esw_cfg.op_mode = 1U;
  tmp___0 = qlcnic_config_switch_port(adapter, & esw_cfg);
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_reset_npar_config(struct qlcnic_adapter *adapter )
{
  int i ;
  int err ;
  struct qlcnic_npar_info *npar ;
  struct qlcnic_info nic_info ;
  u8 pci_func ;
  bool tmp ;
  {
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    if ((unsigned int )adapter->need_fw_reset == 0U) {
      return (0);
    } else {
    }
  } else {
  }
  i = 0;
  goto ldv_54018;
  ldv_54017:
  npar = adapter->npars + (unsigned long )i;
  pci_func = npar->pci_func;
  if (! (adapter->npars + (unsigned long )i)->eswitch_status) {
    goto ldv_54016;
  } else {
  }
  memset((void *)(& nic_info), 0, 72UL);
  err = qlcnic_get_nic_info(adapter, & nic_info, (int )pci_func);
  if (err != 0) {
    return (err);
  } else {
  }
  nic_info.min_tx_bw = npar->min_bw;
  nic_info.max_tx_bw = npar->max_bw;
  err = qlcnic_set_nic_info(adapter, & nic_info);
  if (err != 0) {
    return (err);
  } else {
  }
  if ((unsigned int )npar->enable_pm != 0U) {
    err = qlcnic_config_port_mirroring(adapter, (int )npar->dest_npar, 1, (int )pci_func);
    if (err != 0) {
      return (err);
    } else {
    }
  } else {
  }
  err = qlcnic_reset_eswitch_config(adapter, npar, (int )pci_func);
  if (err != 0) {
    return (err);
  } else {
  }
  ldv_54016:
  i = i + 1;
  ldv_54018: ;
  if ((int )(adapter->ahw)->total_nic_func > i) {
    goto ldv_54017;
  } else {
  }
  return (0);
}
}
static int qlcnic_check_npar_opertional(struct qlcnic_adapter *adapter )
{
  u8 npar_opt_timeo ;
  u32 npar_state ;
  {
  npar_opt_timeo = 30U;
  if ((unsigned int )(adapter->ahw)->op_mode == 0U) {
    return (0);
  } else {
  }
  npar_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 14UL));
  goto ldv_54026;
  ldv_54025:
  msleep(1000U);
  npar_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 14UL));
  ldv_54026: ;
  if (npar_state != 1U) {
    npar_opt_timeo = (u8 )((int )npar_opt_timeo - 1);
    if ((unsigned int )npar_opt_timeo != 0U) {
      goto ldv_54025;
    } else {
      goto ldv_54027;
    }
  } else {
  }
  ldv_54027: ;
  if ((unsigned int )npar_opt_timeo == 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Waiting for NPAR state to operational timeout\n");
    return (-5);
  } else {
  }
  return (0);
}
}
static int qlcnic_set_mgmt_operations(struct qlcnic_adapter *adapter )
{
  int err ;
  {
  if ((adapter->flags & 64U) == 0U || (unsigned int )(adapter->ahw)->op_mode != 0U) {
    return (0);
  } else {
  }
  err = qlcnic_set_default_offload_settings(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_reset_npar_config(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_dev_set_npar_ready(adapter);
  return (err);
}
}
static int qlcnic_82xx_start_firmware(struct qlcnic_adapter *adapter )
{
  int err ;
  {
  err = qlcnic_can_start_firmware(adapter);
  if (err < 0) {
    return (err);
  } else
  if (err == 0) {
    goto check_fw_status;
  } else {
  }
  if (qlcnic_load_fw_file != 0) {
    qlcnic_request_firmware(adapter);
  } else {
    err = qlcnic_check_flash_fw_ver(adapter);
    if (err != 0) {
      goto err_out;
    } else {
    }
    (adapter->ahw)->fw_type = 1U;
  }
  err = qlcnic_need_fw_reset(adapter);
  if (err == 0) {
    goto check_fw_status;
  } else {
  }
  err = qlcnic_pinit_from_rom(adapter);
  if (err != 0) {
    goto err_out;
  } else {
  }
  err = qlcnic_load_firmware(adapter);
  if (err != 0) {
    goto err_out;
  } else {
  }
  qlcnic_release_firmware(adapter);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 136324256UL, 328508U);
  check_fw_status:
  err = qlcnic_check_fw_status(adapter);
  if (err != 0) {
    goto err_out;
  } else {
  }
  writel(3U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  qlcnic_idc_debug_info(adapter, 1);
  err = qlcnic_check_eswitch_mode(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Memory allocation failed for eswitch\n");
    goto err_out;
  } else {
  }
  err = qlcnic_set_mgmt_operations(adapter);
  if (err != 0) {
    goto err_out;
  } else {
  }
  qlcnic_check_options(adapter);
  adapter->need_fw_reset = 0U;
  qlcnic_release_firmware(adapter);
  return (0);
  err_out:
  writel(6U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Device state set to failed\n");
  qlcnic_release_firmware(adapter);
  return (err);
}
}
static int qlcnic_request_irq(struct qlcnic_adapter *adapter )
{
  irqreturn_t (*handler)(int , void * ) ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  int err ;
  int ring ;
  int num_sds_rings ;
  unsigned long flags ;
  struct net_device *netdev ;
  struct qlcnic_recv_context *recv_ctx ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  {
  flags = 0UL;
  netdev = adapter->netdev;
  recv_ctx = adapter->recv_ctx;
  if ((unsigned int )(adapter->ahw)->diag_test == 1U) {
    tmp = qlcnic_82xx_check(adapter);
    if ((int )tmp) {
      handler = & qlcnic_tmp_intr;
    } else {
      handler = & qlcnic_83xx_tmp_intr;
    }
    if ((adapter->flags & 6U) == 0U) {
      flags = flags | 128UL;
    } else {
    }
  } else
  if ((adapter->flags & 4U) != 0U) {
    handler = & qlcnic_msix_intr;
  } else
  if ((adapter->flags & 2U) != 0U) {
    handler = & qlcnic_msi_intr;
  } else {
    flags = flags | 128UL;
    tmp___0 = qlcnic_82xx_check(adapter);
    if ((int )tmp___0) {
      handler = & qlcnic_intr;
    } else {
      handler = & qlcnic_83xx_intr;
    }
  }
  adapter->irq = (u32 )netdev->irq;
  if ((unsigned int )(adapter->ahw)->diag_test != 2U) {
    tmp___4 = qlcnic_82xx_check(adapter);
    if ((int )tmp___4) {
      goto _L;
    } else {
      tmp___5 = qlcnic_83xx_check(adapter);
      if ((int )tmp___5 && (adapter->flags & 4U) != 0U) {
        _L:
        num_sds_rings = (int )adapter->drv_sds_rings;
        ring = 0;
        goto ldv_54051;
        ldv_54050:
        sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
        tmp___1 = qlcnic_82xx_check(adapter);
        if ((int )tmp___1) {
          tmp___2 = qlcnic_check_multi_tx(adapter);
          if (tmp___2) {
            tmp___3 = 0;
          } else {
            tmp___3 = 1;
          }
          if (tmp___3) {
            if (num_sds_rings + -1 == ring) {
              if ((adapter->flags & 4U) == 0U) {
                snprintf((char *)(& sds_ring->name), 28UL, "qlcnic");
              } else {
                snprintf((char *)(& sds_ring->name), 28UL, "%s-tx-0-rx-%d", (char *)(& netdev->name),
                         ring);
              }
            } else {
              snprintf((char *)(& sds_ring->name), 28UL, "%s-rx-%d", (char *)(& netdev->name),
                       ring);
            }
          } else {
            snprintf((char *)(& sds_ring->name), 28UL, "%s-rx-%d", (char *)(& netdev->name),
                     ring);
          }
        } else {
          snprintf((char *)(& sds_ring->name), 28UL, "%s-rx-%d", (char *)(& netdev->name),
                   ring);
        }
        err = request_irq((unsigned int )sds_ring->irq, handler, flags, (char const *)(& sds_ring->name),
                          (void *)sds_ring);
        if (err != 0) {
          return (err);
        } else {
        }
        ring = ring + 1;
        ldv_54051: ;
        if (ring < num_sds_rings) {
          goto ldv_54050;
        } else {
        }
      } else {
      }
    }
    tmp___6 = qlcnic_82xx_check(adapter);
    if ((int )tmp___6) {
      tmp___7 = qlcnic_check_multi_tx(adapter);
      if ((int )tmp___7) {
        goto _L___0;
      } else {
        goto _L___1;
      }
    } else {
      _L___1:
      tmp___8 = qlcnic_83xx_check(adapter);
      if (((int )tmp___8 && (adapter->flags & 4U) != 0U) && (adapter->flags & 65536U) == 0U) {
        _L___0:
        handler = & qlcnic_msix_tx_intr;
        ring = 0;
        goto ldv_54054;
        ldv_54053:
        tx_ring = adapter->tx_ring + (unsigned long )ring;
        snprintf((char *)(& tx_ring->name), 28UL, "%s-tx-%d", (char *)(& netdev->name),
                 ring);
        err = request_irq((unsigned int )tx_ring->irq, handler, flags, (char const *)(& tx_ring->name),
                          (void *)tx_ring);
        if (err != 0) {
          return (err);
        } else {
        }
        ring = ring + 1;
        ldv_54054: ;
        if ((int )adapter->drv_tx_rings > ring) {
          goto ldv_54053;
        } else {
        }
      } else {
      }
    }
  } else {
  }
  return (0);
}
}
static void qlcnic_free_irq(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  recv_ctx = adapter->recv_ctx;
  if ((unsigned int )(adapter->ahw)->diag_test != 2U) {
    tmp = qlcnic_82xx_check(adapter);
    if ((int )tmp) {
      goto _L;
    } else {
      tmp___0 = qlcnic_83xx_check(adapter);
      if ((int )tmp___0 && (adapter->flags & 4U) != 0U) {
        _L:
        ring = 0;
        goto ldv_54064;
        ldv_54063:
        sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
        free_irq((unsigned int )sds_ring->irq, (void *)sds_ring);
        ring = ring + 1;
        ldv_54064: ;
        if ((int )adapter->drv_sds_rings > ring) {
          goto ldv_54063;
        } else {
        }
      } else {
      }
    }
    tmp___1 = qlcnic_83xx_check(adapter);
    if ((int )tmp___1 && (adapter->flags & 65536U) == 0U) {
      goto _L___0;
    } else {
      tmp___2 = qlcnic_82xx_check(adapter);
      if ((int )tmp___2) {
        tmp___3 = qlcnic_check_multi_tx(adapter);
        if ((int )tmp___3) {
          _L___0:
          ring = 0;
          goto ldv_54067;
          ldv_54066:
          tx_ring = adapter->tx_ring + (unsigned long )ring;
          if (tx_ring->irq != 0) {
            free_irq((unsigned int )tx_ring->irq, (void *)tx_ring);
          } else {
          }
          ring = ring + 1;
          ldv_54067: ;
          if ((int )adapter->drv_tx_rings > ring) {
            goto ldv_54066;
          } else {
          }
        } else {
        }
      } else {
      }
    }
  } else {
  }
  return;
}
}
static void qlcnic_get_lro_mss_capability(struct qlcnic_adapter *adapter )
{
  u32 capab ;
  bool tmp ;
  {
  capab = 0U;
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    if (((adapter->ahw)->extra_capability[0] & 4U) != 0U) {
      adapter->flags = adapter->flags | 32768U;
    } else {
    }
  } else {
    capab = (adapter->ahw)->capabilities;
    if ((capab & 131072U) != 0U) {
      adapter->flags = adapter->flags | 32768U;
    } else {
    }
  }
  return;
}
}
static int qlcnic_config_def_intr_coalesce(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  bool tmp ;
  {
  ahw = adapter->ahw;
  ahw->coal.flag = 4U;
  tmp = qlcnic_83xx_check(adapter);
  if ((int )tmp) {
    ahw->coal.type = 3U;
    ahw->coal.tx_time_us = 64U;
    ahw->coal.tx_packets = 64U;
    ahw->coal.rx_time_us = 3U;
    ahw->coal.rx_packets = 256U;
    err = qlcnic_83xx_set_rx_tx_intr_coal(adapter);
  } else {
    ahw->coal.type = 1U;
    ahw->coal.rx_time_us = 3U;
    ahw->coal.rx_packets = 256U;
    err = qlcnic_82xx_set_rx_coalesce(adapter);
  }
  return (err);
}
}
int __qlcnic_up(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  int ring ;
  struct qlcnic_host_rds_ring *rds_ring ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if ((unsigned int )adapter->is_up != 777U) {
    return (-5);
  } else {
  }
  tmp = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    return (0);
  } else {
  }
  tmp___0 = qlcnic_set_eswitch_port_config(adapter);
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  qlcnic_get_lro_mss_capability(adapter);
  tmp___1 = qlcnic_fw_create_ctx(adapter);
  if (tmp___1 != 0) {
    return (-5);
  } else {
  }
  ring = 0;
  goto ldv_54085;
  ldv_54084:
  rds_ring = (adapter->recv_ctx)->rds_rings + (unsigned long )ring;
  qlcnic_post_rx_buffers(adapter, rds_ring, (int )((u8 )ring));
  ring = ring + 1;
  ldv_54085: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_54084;
  } else {
  }
  qlcnic_set_multi(netdev);
  qlcnic_fw_cmd_set_mtu(adapter, (int )netdev->mtu);
  (adapter->ahw)->linkup = 0U;
  if ((unsigned int )adapter->drv_sds_rings > 1U) {
    qlcnic_config_rss(adapter, 1);
  } else {
  }
  qlcnic_config_def_intr_coalesce(adapter);
  if ((netdev->features & 32768ULL) != 0ULL) {
    qlcnic_config_hw_lro(adapter, 1);
  } else {
  }
  set_bit(1L, (unsigned long volatile *)(& adapter->state));
  qlcnic_napi_enable(adapter);
  qlcnic_linkevent_request(adapter, 1);
  (adapter->ahw)->reset_context = 0U;
  netif_tx_start_all_queues(netdev);
  return (0);
}
}
int qlcnic_up(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  int err ;
  bool tmp ;
  {
  err = 0;
  rtnl_lock();
  tmp = netif_running((struct net_device const *)netdev);
  if ((int )tmp) {
    err = __qlcnic_up(adapter, netdev);
  } else {
  }
  rtnl_unlock();
  return (err);
}
}
void __qlcnic_down(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  int ring ;
  int tmp ;
  bool tmp___0 ;
  {
  if ((unsigned int )adapter->is_up != 777U) {
    return;
  } else {
  }
  tmp = test_and_clear_bit(1L, (unsigned long volatile *)(& adapter->state));
  if (tmp == 0) {
    return;
  } else {
  }
  __asm__ volatile ("mfence": : : "memory");
  netif_carrier_off(netdev);
  (adapter->ahw)->linkup = 0U;
  netif_tx_disable(netdev);
  qlcnic_free_mac_list(adapter);
  if ((unsigned int )adapter->fhash.fnum != 0U) {
    qlcnic_delete_lb_filters(adapter);
  } else {
  }
  qlcnic_nic_set_promisc(adapter, 0U);
  tmp___0 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___0) {
    qlcnic_sriov_cleanup_async_list(& ((adapter->ahw)->sriov)->bc);
  } else {
  }
  qlcnic_napi_disable(adapter);
  qlcnic_fw_destroy_ctx(adapter);
  adapter->flags = adapter->flags & 4294934527U;
  qlcnic_reset_rx_buffers_list(adapter);
  ring = 0;
  goto ldv_54098;
  ldv_54097:
  qlcnic_release_tx_buffers(adapter, adapter->tx_ring + (unsigned long )ring);
  ring = ring + 1;
  ldv_54098: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_54097;
  } else {
  }
  return;
}
}
void qlcnic_down(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  bool tmp ;
  {
  rtnl_lock();
  tmp = netif_running((struct net_device const *)netdev);
  if ((int )tmp) {
    __qlcnic_down(adapter, netdev);
  } else {
  }
  rtnl_unlock();
  return;
}
}
int qlcnic_attach(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  struct pci_dev *pdev ;
  int err ;
  bool tmp ;
  {
  netdev = adapter->netdev;
  pdev = adapter->pdev;
  if ((unsigned int )adapter->is_up == 777U) {
    return (0);
  } else {
  }
  err = qlcnic_napi_add(adapter, netdev);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_alloc_sw_resources(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& pdev->dev), "Error in setting sw resources\n");
    goto err_out_napi_del;
  } else {
  }
  err = qlcnic_alloc_hw_resources(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& pdev->dev), "Error in setting hw resources\n");
    goto err_out_free_sw;
  } else {
  }
  err = qlcnic_request_irq(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& pdev->dev), "failed to setup interrupt\n");
    goto err_out_free_hw;
  } else {
  }
  qlcnic_create_sysfs_entries(adapter);
  tmp = qlcnic_encap_rx_offload(adapter);
  if ((int )tmp) {
    vxlan_get_rx_port(netdev);
  } else {
  }
  adapter->is_up = 777U;
  return (0);
  err_out_free_hw:
  qlcnic_free_hw_resources(adapter);
  err_out_free_sw:
  qlcnic_free_sw_resources(adapter);
  err_out_napi_del:
  qlcnic_napi_del(adapter);
  return (err);
}
}
void qlcnic_detach(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned int )adapter->is_up != 777U) {
    return;
  } else {
  }
  qlcnic_remove_sysfs_entries(adapter);
  qlcnic_free_hw_resources(adapter);
  qlcnic_release_rx_buffers(adapter);
  qlcnic_free_irq(adapter);
  qlcnic_napi_del(adapter);
  qlcnic_free_sw_resources(adapter);
  adapter->is_up = 0U;
  return;
}
}
void qlcnic_diag_free_res(struct net_device *netdev , int drv_sds_rings )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_host_sds_ring *sds_ring ;
  int drv_tx_rings ;
  int ring ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  drv_tx_rings = (int )adapter->drv_tx_rings;
  clear_bit(1L, (unsigned long volatile *)(& adapter->state));
  if ((unsigned int )(adapter->ahw)->diag_test == 1U) {
    ring = 0;
    goto ldv_54125;
    ldv_54124:
    sds_ring = (adapter->recv_ctx)->sds_rings + (unsigned long )ring;
    qlcnic_disable_sds_intr(adapter, sds_ring);
    ring = ring + 1;
    ldv_54125: ;
    if ((int )adapter->drv_sds_rings > ring) {
      goto ldv_54124;
    } else {
    }
  } else {
  }
  qlcnic_fw_destroy_ctx(adapter);
  qlcnic_detach(adapter);
  (adapter->ahw)->diag_test = 0U;
  adapter->drv_sds_rings = (u8 )drv_sds_rings;
  adapter->drv_tx_rings = (u8 )drv_tx_rings;
  tmp___0 = qlcnic_attach(adapter);
  if (tmp___0 != 0) {
    goto out;
  } else {
  }
  tmp___1 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___1) {
    __qlcnic_up(adapter, netdev);
  } else {
  }
  out:
  netif_device_attach(netdev);
  return;
}
}
static int qlcnic_alloc_adapter_resources(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  void *tmp ;
  bool tmp___0 ;
  {
  ahw = adapter->ahw;
  err = 0;
  tmp = kzalloc(24UL, 208U);
  adapter->recv_ctx = (struct qlcnic_recv_context *)tmp;
  if ((unsigned long )adapter->recv_ctx == (unsigned long )((struct qlcnic_recv_context *)0)) {
    err = -12;
    goto err_out;
  } else {
  }
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    ahw->coal.type = 3U;
    ahw->coal.tx_time_us = 64U;
    ahw->coal.tx_packets = 64U;
    ahw->coal.rx_time_us = 3U;
    ahw->coal.rx_packets = 256U;
  } else {
    ahw->coal.type = 1U;
    ahw->coal.rx_time_us = 3U;
    ahw->coal.rx_packets = 256U;
  }
  memset((void *)(& adapter->stats), 0, 176UL);
  err_out: ;
  return (err);
}
}
static void qlcnic_free_adapter_resources(struct qlcnic_adapter *adapter )
{
  struct qlcnic_fw_dump *fw_dump ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  kfree((void const *)adapter->recv_ctx);
  adapter->recv_ctx = (struct qlcnic_recv_context *)0;
  if ((unsigned long )fw_dump->tmpl_hdr != (unsigned long )((void *)0)) {
    vfree((void const *)fw_dump->tmpl_hdr);
    fw_dump->tmpl_hdr = (void *)0;
  } else {
  }
  if ((unsigned long )fw_dump->dma_buffer != (unsigned long )((void *)0)) {
    dma_free_attrs(& (adapter->pdev)->dev, 65536UL, fw_dump->dma_buffer, fw_dump->phys_addr,
                   (struct dma_attrs *)0);
    fw_dump->dma_buffer = (void *)0;
  } else {
  }
  kfree((void const *)(adapter->ahw)->reset.buff);
  (adapter->ahw)->fw_dump.tmpl_hdr = (void *)0;
  return;
}
}
int qlcnic_diag_alloc_res(struct net_device *netdev , int test )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_rds_ring *rds_ring ;
  int ring ;
  int ret ;
  bool tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  netif_device_detach(netdev);
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    __qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_detach(adapter);
  adapter->drv_sds_rings = 1U;
  (adapter->ahw)->diag_test = (u8 )test;
  (adapter->ahw)->linkup = 0U;
  ret = qlcnic_attach(adapter);
  if (ret != 0) {
    netif_device_attach(netdev);
    return (ret);
  } else {
  }
  ret = qlcnic_fw_create_ctx(adapter);
  if (ret != 0) {
    qlcnic_detach(adapter);
    netif_device_attach(netdev);
    return (ret);
  } else {
  }
  ring = 0;
  goto ldv_54148;
  ldv_54147:
  rds_ring = (adapter->recv_ctx)->rds_rings + (unsigned long )ring;
  qlcnic_post_rx_buffers(adapter, rds_ring, (int )((u8 )ring));
  ring = ring + 1;
  ldv_54148: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_54147;
  } else {
  }
  if ((unsigned int )(adapter->ahw)->diag_test == 1U) {
    ring = 0;
    goto ldv_54151;
    ldv_54150:
    sds_ring = (adapter->recv_ctx)->sds_rings + (unsigned long )ring;
    qlcnic_enable_sds_intr(adapter, sds_ring);
    ring = ring + 1;
    ldv_54151: ;
    if ((int )adapter->drv_sds_rings > ring) {
      goto ldv_54150;
    } else {
    }
  } else {
  }
  if ((unsigned int )(adapter->ahw)->diag_test == 2U) {
    (adapter->ahw)->loopback_state = 0U;
    qlcnic_linkevent_request(adapter, 1);
  } else {
  }
  set_bit(1L, (unsigned long volatile *)(& adapter->state));
  return (0);
}
}
static int qlcnic_reset_hw_context(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  int tmp ;
  {
  netdev = adapter->netdev;
  tmp = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    return (-16);
  } else {
  }
  netif_device_detach(netdev);
  qlcnic_down(adapter, netdev);
  qlcnic_up(adapter, netdev);
  netif_device_attach(netdev);
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  netdev_info((struct net_device const *)adapter->netdev, "%s: soft reset complete\n",
              "qlcnic_reset_hw_context");
  return (0);
}
}
int qlcnic_reset_context(struct qlcnic_adapter *adapter )
{
  int err ;
  struct net_device *netdev ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  err = 0;
  netdev = adapter->netdev;
  tmp = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    return (-16);
  } else {
  }
  if ((unsigned int )adapter->is_up == 777U) {
    netif_device_detach(netdev);
    tmp___0 = netif_running((struct net_device const *)netdev);
    if ((int )tmp___0) {
      __qlcnic_down(adapter, netdev);
    } else {
    }
    qlcnic_detach(adapter);
    tmp___1 = netif_running((struct net_device const *)netdev);
    if ((int )tmp___1) {
      err = qlcnic_attach(adapter);
      if (err == 0) {
        __qlcnic_up(adapter, netdev);
        qlcnic_restore_indev_addr(netdev, 1UL);
      } else {
      }
    } else {
    }
    netif_device_attach(netdev);
  } else {
  }
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (err);
}
}
static void qlcnic_82xx_set_mac_filter_count(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  u16 act_pci_fn ;
  u16 count ;
  {
  ahw = adapter->ahw;
  act_pci_fn = ahw->total_nic_func;
  ahw->max_mc_count = 38U;
  if ((unsigned int )act_pci_fn <= 2U) {
    count = (u16 )(474 / (int )act_pci_fn);
  } else {
    count = (u16 )(26 / (int )act_pci_fn);
  }
  ahw->max_uc_count = count;
  return;
}
}
static int qlcnic_set_real_num_queues(struct qlcnic_adapter *adapter , u8 tx_queues ,
                                      u8 rx_queues )
{
  struct net_device *netdev ;
  int err ;
  {
  netdev = adapter->netdev;
  err = 0;
  if ((unsigned int )tx_queues != 0U) {
    err = netif_set_real_num_tx_queues(netdev, (unsigned int )tx_queues);
    if (err != 0) {
      netdev_err((struct net_device const *)netdev, "failed to set %d Tx queues\n",
                 (int )tx_queues);
      return (err);
    } else {
    }
  } else {
  }
  if ((unsigned int )rx_queues != 0U) {
    err = netif_set_real_num_rx_queues(netdev, (unsigned int )rx_queues);
    if (err != 0) {
      netdev_err((struct net_device const *)netdev, "failed to set %d Rx queues\n",
                 (int )rx_queues);
    } else {
    }
  } else {
  }
  return (err);
}
}
int qlcnic_setup_netdev(struct qlcnic_adapter *adapter , struct net_device *netdev ,
                        int pci_using_dac )
{
  int err ;
  struct pci_dev *pdev ;
  bool tmp ;
  u32 tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  pdev = adapter->pdev;
  adapter->rx_csum = 1U;
  (adapter->ahw)->mc_enabled = 0U;
  qlcnic_set_mac_filter_count(adapter);
  netdev->netdev_ops = & qlcnic_netdev_ops;
  netdev->watchdog_timeo = 1250;
  qlcnic_change_mtu(netdev, (int )netdev->mtu);
  tmp = qlcnic_sriov_vf_check(adapter);
  netdev->ethtool_ops = (int )tmp ? & qlcnic_sriov_vf_ethtool_ops : & qlcnic_ethtool_ops;
  netdev->features = netdev->features | 17179885843ULL;
  netdev->vlan_features = netdev->vlan_features | 19ULL;
  if (((adapter->ahw)->capabilities & 2U) != 0U) {
    netdev->features = netdev->features | 1114112ULL;
    netdev->vlan_features = netdev->vlan_features | 1114112ULL;
  } else {
  }
  if (pci_using_dac != 0) {
    netdev->features = netdev->features | 32ULL;
    netdev->vlan_features = netdev->vlan_features | 32ULL;
  } else {
  }
  tmp___0 = qlcnic_vlan_tx_check(adapter);
  if (tmp___0 != 0U) {
    netdev->features = netdev->features | 128ULL;
  } else {
  }
  tmp___1 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___1) {
    netdev->features = netdev->features | 512ULL;
  } else {
  }
  if (((adapter->ahw)->capabilities & 1024U) != 0U) {
    netdev->features = netdev->features | 32768ULL;
  } else {
  }
  tmp___2 = qlcnic_encap_tx_offload(adapter);
  if ((int )tmp___2) {
    netdev->features = netdev->features | 67108864ULL;
    netdev->hw_enc_features = 68222978ULL;
  } else {
  }
  tmp___3 = qlcnic_encap_rx_offload(adapter);
  if ((int )tmp___3) {
    netdev->hw_enc_features = netdev->hw_enc_features | 17179869184ULL;
  } else {
  }
  netdev->hw_features = netdev->features;
  netdev->priv_flags = netdev->priv_flags | 131072U;
  netdev->irq = (int )(adapter->msix_entries)->vector;
  err = qlcnic_set_real_num_queues(adapter, (int )adapter->drv_tx_rings, (int )adapter->drv_sds_rings);
  if (err != 0) {
    return (err);
  } else {
  }
  err = ldv_register_netdev_79(netdev);
  if (err != 0) {
    dev_err((struct device const *)(& pdev->dev), "failed to register net device\n");
    return (err);
  } else {
  }
  qlcnic_dcb_init_dcbnl_ops(adapter->dcb);
  return (0);
}
}
static int qlcnic_set_dma_mask(struct pci_dev *pdev , int *pci_using_dac )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp___1 = pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
  if (tmp___1 == 0) {
    tmp___2 = pci_set_consistent_dma_mask(pdev, 0xffffffffffffffffULL);
    if (tmp___2 == 0) {
      *pci_using_dac = 1;
    } else {
      goto _L;
    }
  } else {
    _L:
    tmp = pci_set_dma_mask(pdev, 4294967295ULL);
    if (tmp == 0) {
      tmp___0 = pci_set_consistent_dma_mask(pdev, 4294967295ULL);
      if (tmp___0 == 0) {
        *pci_using_dac = 0;
      } else {
        dev_err((struct device const *)(& pdev->dev), "Unable to set DMA mask, aborting\n");
        return (-5);
      }
    } else {
      dev_err((struct device const *)(& pdev->dev), "Unable to set DMA mask, aborting\n");
      return (-5);
    }
  }
  return (0);
}
}
void qlcnic_free_tx_rings(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  {
  ring = 0;
  goto ldv_54193;
  ldv_54192:
  tx_ring = adapter->tx_ring + (unsigned long )ring;
  if ((unsigned long )tx_ring != (unsigned long )((struct qlcnic_host_tx_ring *)0) && (unsigned long )tx_ring->cmd_buf_arr != (unsigned long )((struct qlcnic_cmd_buffer *)0)) {
    vfree((void const *)tx_ring->cmd_buf_arr);
    tx_ring->cmd_buf_arr = (struct qlcnic_cmd_buffer *)0;
  } else {
  }
  ring = ring + 1;
  ldv_54193: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_54192;
  } else {
  }
  if ((unsigned long )adapter->tx_ring != (unsigned long )((struct qlcnic_host_tx_ring *)0)) {
    kfree((void const *)adapter->tx_ring);
  } else {
  }
  return;
}
}
int qlcnic_alloc_tx_rings(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  int ring ;
  int vector ;
  int index ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_cmd_buffer *cmd_buf_arr ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  tmp = kcalloc((size_t )adapter->drv_tx_rings, 4096UL, 208U);
  tx_ring = (struct qlcnic_host_tx_ring *)tmp;
  if ((unsigned long )tx_ring == (unsigned long )((struct qlcnic_host_tx_ring *)0)) {
    return (-12);
  } else {
  }
  adapter->tx_ring = tx_ring;
  ring = 0;
  goto ldv_54206;
  ldv_54205:
  tx_ring = adapter->tx_ring + (unsigned long )ring;
  tx_ring->num_desc = (u32 )adapter->num_txd;
  tx_ring->txq = netdev_get_tx_queue((struct net_device const *)netdev, (unsigned int )ring);
  tmp___0 = ldv_vzalloc_80((unsigned long )tx_ring->num_desc * 304UL);
  cmd_buf_arr = (struct qlcnic_cmd_buffer *)tmp___0;
  if ((unsigned long )cmd_buf_arr == (unsigned long )((struct qlcnic_cmd_buffer *)0)) {
    qlcnic_free_tx_rings(adapter);
    return (-12);
  } else {
  }
  memset((void *)cmd_buf_arr, 0, (unsigned long )tx_ring->num_desc * 304UL);
  tx_ring->cmd_buf_arr = cmd_buf_arr;
  spinlock_check(& tx_ring->tx_clean_lock);
  __raw_spin_lock_init(& tx_ring->tx_clean_lock.ldv_6347.rlock, "&(&tx_ring->tx_clean_lock)->rlock",
                       & __key);
  ring = ring + 1;
  ldv_54206: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_54205;
  } else {
  }
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    goto _L;
  } else {
    tmp___2 = qlcnic_82xx_check(adapter);
    if ((int )tmp___2) {
      tmp___3 = qlcnic_check_multi_tx(adapter);
      if ((int )tmp___3) {
        _L:
        ring = 0;
        goto ldv_54209;
        ldv_54208:
        tx_ring = adapter->tx_ring + (unsigned long )ring;
        tx_ring->adapter = adapter;
        if ((adapter->flags & 4U) != 0U) {
          index = (int )adapter->drv_sds_rings + ring;
          vector = (int )(adapter->msix_entries + (unsigned long )index)->vector;
          tx_ring->irq = vector;
        } else {
        }
        ring = ring + 1;
        ldv_54209: ;
        if ((int )adapter->drv_tx_rings > ring) {
          goto ldv_54208;
        } else {
        }
      } else {
      }
    } else {
    }
  }
  return (0);
}
}
void qlcnic_set_drv_version(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  u32 fw_cmd ;
  bool tmp ;
  bool tmp___0 ;
  {
  ahw = adapter->ahw;
  fw_cmd = 0U;
  tmp___0 = qlcnic_82xx_check(adapter);
  if ((int )tmp___0) {
    fw_cmd = 56U;
  } else {
    tmp = qlcnic_83xx_check(adapter);
    if ((int )tmp) {
      fw_cmd = 111U;
    } else {
    }
  }
  if ((ahw->extra_capability[0] & 32U) != 0U) {
    qlcnic_fw_cmd_set_drv_version(adapter, fw_cmd);
  } else {
  }
  return;
}
}
static void qlcnic_reset_api_lock(struct qlcnic_adapter *adapter )
{
  {
  qlcnic_api_lock(adapter);
  qlcnic_api_unlock(adapter);
  return;
}
}
static int qlcnic_probe(struct pci_dev *pdev , struct pci_device_id const *ent )
{
  struct net_device *netdev ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_hardware_context *ahw ;
  int err ;
  int pci_using_dac ;
  char board_name[119U] ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  char const *__lock_name ;
  struct workqueue_struct *tmp___1 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  struct module *__mod ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  {
  netdev = (struct net_device *)0;
  adapter = (struct qlcnic_adapter *)0;
  pci_using_dac = -1;
  err = pci_enable_device(pdev);
  if (err != 0) {
    return (err);
  } else {
  }
  if ((pdev->resource[0].flags & 512UL) == 0UL) {
    err = -19;
    goto err_out_disable_pdev;
  } else {
  }
  err = qlcnic_set_dma_mask(pdev, & pci_using_dac);
  if (err != 0) {
    goto err_out_disable_pdev;
  } else {
  }
  err = pci_request_regions(pdev, (char const *)(& qlcnic_driver_name));
  if (err != 0) {
    goto err_out_disable_pdev;
  } else {
  }
  pci_set_master(pdev);
  pci_enable_pcie_error_reporting(pdev);
  tmp = kzalloc(880UL, 208U);
  ahw = (struct qlcnic_hardware_context *)tmp;
  if ((unsigned long )ahw == (unsigned long )((struct qlcnic_hardware_context *)0)) {
    err = -12;
    goto err_out_free_res;
  } else {
  }
  switch (ent->device) {
  case 32800U:
  ahw->hw_ops = & qlcnic_hw_ops;
  ahw->reg_tbl = (u32 *)(& qlcnic_reg_tbl);
  goto ldv_54232;
  case 32816U: ;
  case 32832U:
  qlcnic_83xx_register_map(ahw);
  goto ldv_54232;
  case 33840U: ;
  case 33856U:
  qlcnic_sriov_vf_register_map(ahw);
  goto ldv_54232;
  default: ;
  goto err_out_free_hw_res;
  }
  ldv_54232:
  err = qlcnic_setup_pci_map(pdev, ahw);
  if (err != 0) {
    goto err_out_free_hw_res;
  } else {
  }
  netdev = alloc_etherdev_mqs(1800, 8U, 8U);
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
    err = -12;
    goto err_out_iounmap;
  } else {
  }
  netdev->dev.parent = & pdev->dev;
  tmp___0 = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp___0;
  adapter->netdev = netdev;
  adapter->pdev = pdev;
  adapter->ahw = ahw;
  __lock_name = "\"%s\"(\"qlcnic\")";
  tmp___1 = __alloc_workqueue_key("%s", 10U, 1, & __key, __lock_name, (char *)"qlcnic");
  adapter->qlcnic_wq = tmp___1;
  if ((unsigned long )adapter->qlcnic_wq == (unsigned long )((struct workqueue_struct *)0)) {
    err = -12;
    dev_err((struct device const *)(& pdev->dev), "Failed to create workqueue\n");
    goto err_out_free_netdev;
  } else {
  }
  err = qlcnic_alloc_adapter_resources(adapter);
  if (err != 0) {
    goto err_out_free_wq;
  } else {
  }
  adapter->dev_rst_time = (u64 )jiffies;
  ahw->revision_id = pdev->revision;
  ahw->max_vnic_func = qlcnic_get_vnic_func_count(adapter);
  if (qlcnic_mac_learn == 2) {
    adapter->fdb_mac_learn = 1;
  } else
  if (qlcnic_mac_learn == 1) {
    adapter->drv_mac_learn = 1;
  } else {
  }
  __rwlock_init(& (adapter->ahw)->crb_lock, "&adapter->ahw->crb_lock", & __key___0);
  __mutex_init(& (adapter->ahw)->mem_lock, "&adapter->ahw->mem_lock", & __key___1);
  INIT_LIST_HEAD(& adapter->mac_list);
  qlcnic_register_dcb(adapter);
  tmp___5 = qlcnic_82xx_check(adapter);
  if ((int )tmp___5) {
    qlcnic_check_vf(adapter, ent);
    adapter->portnum = (adapter->ahw)->pci_func;
    qlcnic_reset_api_lock(adapter);
    err = qlcnic_start_firmware(adapter);
    if (err != 0) {
      dev_err((struct device const *)(& pdev->dev), "Loading fw failed.Please Reboot\n\t\tIf reboot doesn\'t help, try flashing the card\n");
      goto err_out_maintenance_mode;
    } else {
    }
    if ((unsigned int )(adapter->ahw)->msix_supported != 0U) {
      tmp___2 = qlcnic_check_multi_tx_capability(adapter);
      if (tmp___2 == 1) {
        qlcnic_set_tx_ring_count(adapter, 1);
      } else {
        qlcnic_set_tx_ring_count(adapter, 4);
      }
      qlcnic_set_sds_ring_count(adapter, 4);
    } else {
      qlcnic_set_tx_ring_count(adapter, 1);
      qlcnic_set_sds_ring_count(adapter, 1);
    }
    err = qlcnic_setup_idc_param(adapter);
    if (err != 0) {
      goto err_out_free_hw;
    } else {
    }
    adapter->flags = adapter->flags | 4096U;
  } else {
    tmp___4 = qlcnic_83xx_check(adapter);
    if ((int )tmp___4) {
      qlcnic_83xx_check_vf(adapter, ent);
      adapter->portnum = (adapter->ahw)->pci_func;
      err = qlcnic_83xx_init(adapter, pci_using_dac);
      if (err != 0) {
        switch (err) {
        case -131:
        dev_err((struct device const *)(& pdev->dev), "Adapter initialization failed due to a faulty hardware\n");
        dev_err((struct device const *)(& pdev->dev), "Please replace the adapter with new one and return the faulty adapter for repair\n");
        goto err_out_free_hw;
        case -12:
        dev_err((struct device const *)(& pdev->dev), "Adapter initialization failed. Please reboot\n");
        goto err_out_free_hw;
        case -95:
        dev_err((struct device const *)(& pdev->dev), "Adapter initialization failed\n");
        goto err_out_free_hw;
        default:
        dev_err((struct device const *)(& pdev->dev), "Adapter initialization failed. Driver will load in maintenance mode to recover the adapter using the application\n");
        goto err_out_maintenance_mode;
        }
      } else {
      }
      tmp___3 = qlcnic_sriov_vf_check(adapter);
      if ((int )tmp___3) {
        return (0);
      } else {
      }
    } else {
      dev_err((struct device const *)(& pdev->dev), "%s: failed. Please Reboot\n",
              "qlcnic_probe");
      goto err_out_free_hw;
    }
  }
  tmp___6 = qlcnic_read_mac_addr(adapter);
  if (tmp___6 != 0) {
    dev_warn((struct device const *)(& pdev->dev), "failed to read mac addr\n");
  } else {
  }
  qlcnic_read_phys_port_id(adapter);
  if ((unsigned int )adapter->portnum == 0U) {
    qlcnic_get_board_name(adapter, (char *)(& board_name));
    __mod = & __this_module;
    printk("\016%s: %s Board Chip rev 0x%x\n", (unsigned long )__mod != (unsigned long )((struct module *)0) ? (char *)(& __mod->name) : (char *)"kernel",
           (char *)(& board_name), (int )(adapter->ahw)->revision_id);
  } else {
  }
  tmp___7 = qlcnic_83xx_check(adapter);
  if (((int )tmp___7 && qlcnic_use_msi_x == 0) && qlcnic_use_msi != 0) {
    dev_warn((struct device const *)(& pdev->dev), "Device does not support MSI interrupts\n");
  } else {
  }
  tmp___8 = qlcnic_82xx_check(adapter);
  if ((int )tmp___8) {
    qlcnic_dcb_enable(adapter->dcb);
    qlcnic_dcb_get_info(adapter->dcb);
    err = qlcnic_setup_intr(adapter);
    if (err != 0) {
      dev_err((struct device const *)(& pdev->dev), "Failed to setup interrupt\n");
      goto err_out_disable_msi;
    } else {
    }
  } else {
  }
  err = qlcnic_get_act_pci_func(adapter);
  if (err != 0) {
    goto err_out_disable_mbx_intr;
  } else {
  }
  err = qlcnic_setup_netdev(adapter, netdev, pci_using_dac);
  if (err != 0) {
    goto err_out_disable_mbx_intr;
  } else {
  }
  if ((unsigned int )adapter->portnum == 0U) {
    qlcnic_set_drv_version(adapter);
  } else {
  }
  pci_set_drvdata(pdev, (void *)adapter);
  tmp___9 = qlcnic_82xx_check(adapter);
  if ((int )tmp___9) {
    qlcnic_schedule_work(adapter, & qlcnic_fw_poll_work, 250);
  } else {
  }
  switch ((int )(adapter->ahw)->port_type) {
  case 1:
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: GbE port initialized\n",
            (char *)(& (adapter->netdev)->name));
  goto ldv_54259;
  case 2:
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: XGbE port initialized\n",
            (char *)(& (adapter->netdev)->name));
  goto ldv_54259;
  }
  ldv_54259: ;
  if ((int )adapter->drv_mac_learn) {
    qlcnic_alloc_lb_filters_mem(adapter);
  } else {
  }
  qlcnic_add_sysfs(adapter);
  qlcnic_register_hwmon_dev(adapter);
  return (0);
  err_out_disable_mbx_intr:
  tmp___10 = qlcnic_83xx_check(adapter);
  if ((int )tmp___10) {
    qlcnic_83xx_free_mbx_intr(adapter);
  } else {
  }
  err_out_disable_msi:
  qlcnic_teardown_intr(adapter);
  qlcnic_cancel_idc_work(adapter);
  qlcnic_clr_all_drv_state(adapter, 0);
  err_out_free_hw:
  qlcnic_free_adapter_resources(adapter);
  err_out_free_wq:
  destroy_workqueue(adapter->qlcnic_wq);
  err_out_free_netdev:
  ldv_free_netdev_81(netdev);
  err_out_iounmap:
  qlcnic_cleanup_pci_map(ahw);
  err_out_free_hw_res:
  kfree((void const *)ahw);
  err_out_free_res:
  pci_release_regions(pdev);
  err_out_disable_pdev:
  pci_disable_device(pdev);
  return (err);
  err_out_maintenance_mode:
  set_bit(16L, (unsigned long volatile *)(& adapter->state));
  netdev->netdev_ops = & qlcnic_netdev_failed_ops;
  netdev->ethtool_ops = & qlcnic_ethtool_failed_ops;
  ahw->port_type = 2U;
  tmp___11 = qlcnic_83xx_check(adapter);
  if ((int )tmp___11) {
    adapter->tgt_status_reg = (void *)0;
  } else {
    ahw->board_type = 38U;
  }
  err = ldv_register_netdev_82(netdev);
  if (err != 0) {
    dev_err((struct device const *)(& pdev->dev), "Failed to register net device\n");
    qlcnic_clr_all_drv_state(adapter, 0);
    goto err_out_free_hw;
  } else {
  }
  pci_set_drvdata(pdev, (void *)adapter);
  qlcnic_add_sysfs(adapter);
  return (0);
}
}
static void qlcnic_remove(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  struct net_device *netdev ;
  struct qlcnic_hardware_context *ahw ;
  void *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  if ((unsigned long )adapter == (unsigned long )((struct qlcnic_adapter *)0)) {
    return;
  } else {
  }
  netdev = adapter->netdev;
  qlcnic_cancel_idc_work(adapter);
  qlcnic_sriov_pf_disable(adapter);
  ahw = adapter->ahw;
  ldv_unregister_netdev_83(netdev);
  qlcnic_sriov_cleanup(adapter);
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    qlcnic_83xx_initialize_nic(adapter, 0);
    cancel_delayed_work_sync(& adapter->idc_aen_work);
    qlcnic_83xx_free_mbx_intr(adapter);
    qlcnic_83xx_detach_mailbox_work(adapter);
    qlcnic_83xx_free_mailbox(ahw->mailbox);
    kfree((void const *)ahw->fw_info);
  } else {
  }
  qlcnic_dcb_free(adapter->dcb);
  qlcnic_detach(adapter);
  if ((unsigned long )adapter->npars != (unsigned long )((struct qlcnic_npar_info *)0)) {
    kfree((void const *)adapter->npars);
  } else {
  }
  if ((unsigned long )adapter->eswitch != (unsigned long )((struct qlcnic_eswitch *)0)) {
    kfree((void const *)adapter->eswitch);
  } else {
  }
  tmp___1 = qlcnic_82xx_check(adapter);
  if ((int )tmp___1) {
    qlcnic_clr_all_drv_state(adapter, 0);
  } else {
  }
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  qlcnic_free_lb_filters_mem(adapter);
  qlcnic_teardown_intr(adapter);
  qlcnic_remove_sysfs(adapter);
  qlcnic_unregister_hwmon_dev(adapter);
  qlcnic_cleanup_pci_map(adapter->ahw);
  qlcnic_release_firmware(adapter);
  pci_disable_pcie_error_reporting(pdev);
  pci_release_regions(pdev);
  pci_disable_device(pdev);
  if ((unsigned long )adapter->qlcnic_wq != (unsigned long )((struct workqueue_struct *)0)) {
    destroy_workqueue(adapter->qlcnic_wq);
    adapter->qlcnic_wq = (struct workqueue_struct *)0;
  } else {
  }
  qlcnic_free_adapter_resources(adapter);
  kfree((void const *)ahw);
  ldv_free_netdev_84(netdev);
  return;
}
}
static void qlcnic_shutdown(struct pci_dev *pdev )
{
  int tmp ;
  {
  tmp = __qlcnic_shutdown(pdev);
  if (tmp != 0) {
    return;
  } else {
  }
  pci_disable_device(pdev);
  return;
}
}
static int qlcnic_suspend(struct pci_dev *pdev , pm_message_t state )
{
  int retval ;
  pci_power_t tmp ;
  {
  retval = __qlcnic_shutdown(pdev);
  if (retval != 0) {
    return (retval);
  } else {
  }
  tmp = pci_choose_state(pdev, state);
  pci_set_power_state(pdev, tmp);
  return (0);
}
}
static int qlcnic_resume(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  int tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = pci_enable_device(pdev);
  if (err != 0) {
    return (err);
  } else {
  }
  pci_set_power_state(pdev, 0);
  pci_set_master(pdev);
  pci_restore_state(pdev);
  tmp___0 = __qlcnic_resume(adapter);
  return (tmp___0);
}
}
static int qlcnic_open(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(16L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    netdev_err((struct net_device const *)netdev, "%s: Device is in non-operational state\n",
               "qlcnic_open");
    return (-5);
  } else {
  }
  netif_carrier_off(netdev);
  err = qlcnic_attach(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  err = __qlcnic_up(adapter, netdev);
  if (err != 0) {
    qlcnic_detach(adapter);
  } else {
  }
  return (err);
}
}
static int qlcnic_close(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  __qlcnic_down(adapter, netdev);
  return (0);
}
}
void qlcnic_alloc_lb_filters_mem(struct qlcnic_adapter *adapter )
{
  void *head ;
  int i ;
  struct net_device *netdev ;
  u32 filter_size ;
  u16 act_pci_func ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  bool tmp ;
  bool tmp___0 ;
  {
  netdev = adapter->netdev;
  filter_size = 0U;
  act_pci_func = 0U;
  if ((unsigned int )adapter->fhash.fmax != 0U && (unsigned long )adapter->fhash.fhead != (unsigned long )((struct hlist_head *)0)) {
    return;
  } else {
  }
  act_pci_func = (adapter->ahw)->total_nic_func;
  spinlock_check(& adapter->mac_learn_lock);
  __raw_spin_lock_init(& adapter->mac_learn_lock.ldv_6347.rlock, "&(&adapter->mac_learn_lock)->rlock",
                       & __key);
  spinlock_check(& adapter->rx_mac_learn_lock);
  __raw_spin_lock_init(& adapter->rx_mac_learn_lock.ldv_6347.rlock, "&(&adapter->rx_mac_learn_lock)->rlock",
                       & __key___0);
  tmp___0 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___0) {
    filter_size = 1U;
    adapter->fhash.fbucket_size = 1U;
  } else {
    tmp = qlcnic_82xx_check(adapter);
    if ((int )tmp) {
      filter_size = 64U;
      adapter->fhash.fbucket_size = 32U;
    } else {
      filter_size = 2048U;
      adapter->fhash.fbucket_size = 256U;
    }
  }
  head = kcalloc((size_t )adapter->fhash.fbucket_size, 8UL, 32U);
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    return;
  } else {
  }
  adapter->fhash.fmax = (u16 )(filter_size / (u32 )act_pci_func);
  adapter->fhash.fhead = (struct hlist_head *)head;
  netdev_info((struct net_device const *)netdev, "active nic func = %d, mac filter size=%d\n",
              (int )act_pci_func, (int )adapter->fhash.fmax);
  i = 0;
  goto ldv_54301;
  ldv_54300:
  (adapter->fhash.fhead + (unsigned long )i)->first = (struct hlist_node *)0;
  i = i + 1;
  ldv_54301: ;
  if ((int )adapter->fhash.fbucket_size > i) {
    goto ldv_54300;
  } else {
  }
  adapter->rx_fhash.fbucket_size = adapter->fhash.fbucket_size;
  head = kcalloc((size_t )adapter->rx_fhash.fbucket_size, 8UL, 32U);
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    return;
  } else {
  }
  adapter->rx_fhash.fmax = (u16 )(filter_size / (u32 )act_pci_func);
  adapter->rx_fhash.fhead = (struct hlist_head *)head;
  i = 0;
  goto ldv_54304;
  ldv_54303:
  (adapter->rx_fhash.fhead + (unsigned long )i)->first = (struct hlist_node *)0;
  i = i + 1;
  ldv_54304: ;
  if ((int )adapter->rx_fhash.fbucket_size > i) {
    goto ldv_54303;
  } else {
  }
  return;
}
}
static void qlcnic_free_lb_filters_mem(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned int )adapter->fhash.fmax != 0U && (unsigned long )adapter->fhash.fhead != (unsigned long )((struct hlist_head *)0)) {
    kfree((void const *)adapter->fhash.fhead);
  } else {
  }
  adapter->fhash.fhead = (struct hlist_head *)0;
  adapter->fhash.fmax = 0U;
  if ((unsigned int )adapter->rx_fhash.fmax != 0U && (unsigned long )adapter->rx_fhash.fhead != (unsigned long )((struct hlist_head *)0)) {
    kfree((void const *)adapter->rx_fhash.fhead);
  } else {
  }
  adapter->rx_fhash.fmax = 0U;
  adapter->rx_fhash.fhead = (struct hlist_head *)0;
  return;
}
}
int qlcnic_check_temp(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  u32 temp_state ;
  u32 temp_val ;
  u32 temp ;
  int rv ;
  bool tmp ;
  bool tmp___0 ;
  {
  netdev = adapter->netdev;
  temp = 0U;
  rv = 0;
  tmp = qlcnic_83xx_check(adapter);
  if ((int )tmp) {
    temp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 42UL));
  } else {
  }
  tmp___0 = qlcnic_82xx_check(adapter);
  if ((int )tmp___0) {
    temp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 18UL));
  } else {
  }
  temp_state = temp & 65535U;
  temp_val = temp >> 16;
  if (temp_state == 3U) {
    dev_err((struct device const *)(& netdev->dev), "Device temperature %d degrees C exceeds maximum allowed. Hardware has been shut down.\n",
            temp_val);
    rv = 1;
  } else
  if (temp_state == 2U) {
    if ((adapter->ahw)->temp == 1U) {
      dev_err((struct device const *)(& netdev->dev), "Device temperature %d degrees C exceeds operating range. Immediate action needed.\n",
              temp_val);
    } else {
    }
  } else
  if ((adapter->ahw)->temp == 2U) {
    _dev_info((struct device const *)(& netdev->dev), "Device temperature is now %d degrees C in normal range.\n",
              temp_val);
  } else {
  }
  (adapter->ahw)->temp = temp_state;
  return (rv);
}
}
__inline static void dump_tx_ring_desc(struct qlcnic_host_tx_ring *tx_ring )
{
  int i ;
  struct cmd_desc_type0 *tx_desc_info ;
  {
  i = 0;
  goto ldv_54323;
  ldv_54322:
  tx_desc_info = tx_ring->desc_head + (unsigned long )i;
  printk("\016TX Desc: %d\n", i);
  print_hex_dump("\016", "TX: ", 2, 16, 1, (void const *)tx_ring->desc_head + (unsigned long )i,
                 64UL, 1);
  i = i + 1;
  ldv_54323: ;
  if ((u32 )i < tx_ring->num_desc) {
    goto ldv_54322;
  } else {
  }
  return;
}
}
static void qlcnic_dump_tx_rings(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  struct qlcnic_host_tx_ring *tx_ring ;
  int ring ;
  bool tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  u32 tmp___3 ;
  {
  netdev = adapter->netdev;
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
    return;
  } else {
    tmp = netif_running((struct net_device const *)netdev);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return;
    } else {
    }
  }
  ring = 0;
  goto ldv_54332;
  ldv_54331:
  tx_ring = adapter->tx_ring + (unsigned long )ring;
  netdev_info((struct net_device const *)netdev, "Tx ring=%d Context Id=0x%x\n",
              ring, (int )tx_ring->ctx_id);
  netdev_info((struct net_device const *)netdev, "xmit_finished=%llu, xmit_called=%llu, xmit_on=%llu, xmit_off=%llu\n",
              tx_ring->tx_stats.xmit_finished, tx_ring->tx_stats.xmit_called, tx_ring->tx_stats.xmit_on,
              tx_ring->tx_stats.xmit_off);
  if ((unsigned long )tx_ring->crb_intr_mask != (unsigned long )((void *)0)) {
    tmp___1 = readl((void const volatile *)tx_ring->crb_intr_mask);
    netdev_info((struct net_device const *)netdev, "crb_intr_mask=%d\n", tmp___1);
  } else {
  }
  tmp___2 = readl((void const volatile *)tx_ring->crb_cmd_producer);
  netdev_info((struct net_device const *)netdev, "hw_producer=%d, sw_producer=%d sw_consumer=%d, hw_consumer=%d\n",
              tmp___2, tx_ring->producer, tx_ring->sw_consumer, *(tx_ring->hw_consumer));
  tmp___3 = qlcnic_tx_avail(tx_ring);
  netdev_info((struct net_device const *)netdev, "Total desc=%d, Available desc=%d\n",
              tx_ring->num_desc, tmp___3);
  if (((adapter->ahw)->msg_enable & 1024U) != 0U) {
    dump_tx_ring_desc(tx_ring);
  } else {
  }
  ring = ring + 1;
  ldv_54332: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_54331;
  } else {
  }
  return;
}
}
static void qlcnic_tx_timeout(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    return;
  } else {
  }
  adapter->tx_timeo_cnt = (u8 )((int )adapter->tx_timeo_cnt + 1);
  if ((unsigned int )adapter->tx_timeo_cnt > 1U) {
    netdev_info((struct net_device const *)netdev, "Tx timeout, reset the adapter.\n");
    tmp___2 = qlcnic_82xx_check(adapter);
    if ((int )tmp___2) {
      adapter->need_fw_reset = 1U;
    } else {
      tmp___1 = qlcnic_83xx_check(adapter);
      if ((int )tmp___1) {
        qlcnic_83xx_idc_request_reset(adapter, 3735944941U);
      } else {
      }
    }
  } else {
    netdev_info((struct net_device const *)netdev, "Tx timeout, reset adapter context.\n");
    qlcnic_dump_tx_rings(adapter);
    (adapter->ahw)->reset_context = 1U;
  }
  return;
}
}
static struct net_device_stats *qlcnic_get_stats(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct net_device_stats *stats ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  stats = & netdev->stats;
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    qlcnic_update_stats(adapter);
  } else {
  }
  stats->rx_packets = (unsigned long )(adapter->stats.rx_pkts + adapter->stats.lro_pkts);
  stats->tx_packets = (unsigned long )adapter->stats.xmitfinished;
  stats->rx_bytes = (unsigned long )(adapter->stats.rxbytes + adapter->stats.lrobytes);
  stats->tx_bytes = (unsigned long )adapter->stats.txbytes;
  stats->rx_dropped = (unsigned long )adapter->stats.rxdropped;
  stats->tx_dropped = (unsigned long )adapter->stats.txdropped;
  return (stats);
}
}
static irqreturn_t qlcnic_82xx_clear_legacy_intr(struct qlcnic_adapter *adapter )
{
  u32 status ;
  {
  status = readl((void const volatile *)adapter->isr_int_vec);
  if (((adapter->ahw)->int_vec_bit & status) == 0U) {
    return (0);
  } else {
  }
  status = readl((void const volatile *)adapter->crb_int_state_reg);
  if ((status & 768U) != 512U) {
    return (0);
  } else {
  }
  writel(4294967295U, (void volatile *)adapter->tgt_status_reg);
  readl((void const volatile *)adapter->isr_int_vec);
  readl((void const volatile *)adapter->isr_int_vec);
  return (1);
}
}
static irqreturn_t qlcnic_tmp_intr(int irq , void *data )
{
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  irqreturn_t tmp ;
  {
  sds_ring = (struct qlcnic_host_sds_ring *)data;
  adapter = sds_ring->adapter;
  if ((adapter->flags & 4U) != 0U) {
    goto done;
  } else
  if ((adapter->flags & 2U) != 0U) {
    writel(4294967295U, (void volatile *)adapter->tgt_status_reg);
    goto done;
  } else {
  }
  tmp = qlcnic_clear_legacy_intr(adapter);
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {
  }
  done:
  (adapter->ahw)->diag_cnt = (adapter->ahw)->diag_cnt + 1;
  qlcnic_enable_sds_intr(adapter, sds_ring);
  return (1);
}
}
static irqreturn_t qlcnic_intr(int irq , void *data )
{
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  irqreturn_t tmp ;
  {
  sds_ring = (struct qlcnic_host_sds_ring *)data;
  adapter = sds_ring->adapter;
  tmp = qlcnic_clear_legacy_intr(adapter);
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {
  }
  napi_schedule(& sds_ring->napi);
  return (1);
}
}
static irqreturn_t qlcnic_msi_intr(int irq , void *data )
{
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  {
  sds_ring = (struct qlcnic_host_sds_ring *)data;
  adapter = sds_ring->adapter;
  writel(4294967295U, (void volatile *)adapter->tgt_status_reg);
  napi_schedule(& sds_ring->napi);
  return (1);
}
}
static irqreturn_t qlcnic_msix_intr(int irq , void *data )
{
  struct qlcnic_host_sds_ring *sds_ring ;
  {
  sds_ring = (struct qlcnic_host_sds_ring *)data;
  napi_schedule(& sds_ring->napi);
  return (1);
}
}
static irqreturn_t qlcnic_msix_tx_intr(int irq , void *data )
{
  struct qlcnic_host_tx_ring *tx_ring ;
  {
  tx_ring = (struct qlcnic_host_tx_ring *)data;
  napi_schedule(& tx_ring->napi);
  return (1);
}
}
static void qlcnic_poll_controller(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_tx_ring *tx_ring ;
  int ring ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    return;
  } else {
  }
  recv_ctx = adapter->recv_ctx;
  ring = 0;
  goto ldv_54385;
  ldv_54384:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  qlcnic_disable_sds_intr(adapter, sds_ring);
  napi_schedule(& sds_ring->napi);
  ring = ring + 1;
  ldv_54385: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_54384;
  } else {
  }
  if ((adapter->flags & 4U) != 0U) {
    tmp___1 = qlcnic_83xx_check(adapter);
    if ((int )tmp___1 && (adapter->flags & 65536U) != 0U) {
      return;
    } else {
      tmp___2 = qlcnic_82xx_check(adapter);
      if ((int )tmp___2) {
        tmp___3 = qlcnic_check_multi_tx(adapter);
        if (tmp___3) {
          tmp___4 = 0;
        } else {
          tmp___4 = 1;
        }
        if (tmp___4) {
          return;
        } else {
        }
      } else {
      }
    }
    ring = 0;
    goto ldv_54388;
    ldv_54387:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    qlcnic_disable_tx_intr(adapter, tx_ring);
    napi_schedule(& tx_ring->napi);
    ring = ring + 1;
    ldv_54388: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_54387;
    } else {
    }
  } else {
  }
  return;
}
}
static void qlcnic_idc_debug_info(struct qlcnic_adapter *adapter , u8 encoding )
{
  u32 val ;
  {
  val = (u32 )adapter->portnum & 15U;
  val = (u32 )((int )encoding << 7) | val;
  val = (((u32 )jiffies - (u32 )adapter->dev_rst_time) << 8U) | val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 8UL));
  adapter->dev_rst_time = (u64 )jiffies;
  return;
}
}
static int qlcnic_set_drv_state(struct qlcnic_adapter *adapter , u8 state )
{
  u32 val ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  {
  __ret_warn_on = (unsigned int )state != 4U && (unsigned int )state != 5U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.o.c.prepared",
                       3359);
  } else {
  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = qlcnic_api_lock(adapter);
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  if ((unsigned int )state == 4U) {
    val = (u32 )(1 << (int )adapter->portnum * 4) | val;
  } else
  if ((unsigned int )state == 5U) {
    val = (u32 )(2 << (int )adapter->portnum * 4) | val;
  } else {
  }
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  qlcnic_api_unlock(adapter);
  return (0);
}
}
static int qlcnic_clr_drv_state(struct qlcnic_adapter *adapter )
{
  u32 val ;
  int tmp ;
  {
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    return (-16);
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  val = (u32 )(~ (3 << (int )adapter->portnum * 4)) & val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  qlcnic_api_unlock(adapter);
  return (0);
}
}
void qlcnic_clr_all_drv_state(struct qlcnic_adapter *adapter , u8 failed )
{
  u32 val ;
  int tmp ;
  {
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    goto err;
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 5UL));
  val = (u32 )(~ (1 << (int )adapter->portnum * 4)) & val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 5UL));
  if ((unsigned int )failed != 0U) {
    writel(6U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Device state set to Failed. Please Reboot\n");
  } else
  if ((val & 286331153U) == 0U) {
    writel(1U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  val = (u32 )(~ (3 << (int )adapter->portnum * 4)) & val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  qlcnic_api_unlock(adapter);
  err:
  adapter->fw_fail_cnt = 0U;
  adapter->flags = adapter->flags & 4294950911U;
  clear_bit(4L, (unsigned long volatile *)(& adapter->state));
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return;
}
}
static int qlcnic_check_drv_state(struct qlcnic_adapter *adapter )
{
  int act ;
  int state ;
  int active_mask ;
  struct qlcnic_hardware_context *ahw ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  {
  ahw = adapter->ahw;
  tmp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  state = (int )tmp;
  tmp___0 = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 5UL));
  act = (int )tmp___0;
  if ((adapter->flags & 8192U) != 0U) {
    active_mask = ~ (1 << (int )ahw->pci_func * 4);
    act = act & active_mask;
  } else {
  }
  if (((state ^ act) & 286331153) == 0 || (((state >> 1) ^ act) & 286331153) == 0) {
    return (0);
  } else {
    return (1);
  }
}
}
static int qlcnic_check_idc_ver(struct qlcnic_adapter *adapter )
{
  u32 val ;
  unsigned int tmp ;
  {
  tmp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 10UL));
  val = tmp;
  if (val != 1U) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "IDC Version mismatch, driver\'s idc ver = %x; reqd = %x\n",
             1, val);
  } else {
  }
  return (0);
}
}
static int qlcnic_can_start_firmware(struct qlcnic_adapter *adapter )
{
  u32 val ;
  u32 prev_state ;
  u8 dev_init_timeo ;
  u8 portnum ;
  u8 ret ;
  int tmp ;
  int tmp___0 ;
  char const *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  dev_init_timeo = adapter->dev_init_timeo;
  portnum = adapter->portnum;
  tmp = test_and_clear_bit(4L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    return (1);
  } else {
  }
  tmp___0 = qlcnic_api_lock(adapter);
  if (tmp___0 != 0) {
    return (-1);
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 5UL));
  if (((u32 )(1 << (int )portnum * 4) & val) == 0U) {
    val = (u32 )(1 << (int )portnum * 4) | val;
    writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 5UL));
  } else {
  }
  prev_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  if (((adapter->ahw)->msg_enable & 8192U) != 0U) {
    tmp___1 = dev_name((struct device const *)(& (adapter->pdev)->dev));
    printk("\016%s: %s: Device state = %u\n", tmp___1, "qlcnic_can_start_firmware",
           prev_state);
  } else {
  }
  switch (prev_state) {
  case 1U:
  writel(2U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  writel(1U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 10UL));
  qlcnic_idc_debug_info(adapter, 0);
  qlcnic_api_unlock(adapter);
  return (1);
  case 3U:
  tmp___2 = qlcnic_check_idc_ver(adapter);
  ret = (u8 )tmp___2;
  qlcnic_api_unlock(adapter);
  return ((int )ret);
  case 4U:
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  val = (u32 )(1 << (int )portnum * 4) | val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  goto ldv_54435;
  case 5U:
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  val = (u32 )(2 << (int )portnum * 4) | val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  goto ldv_54435;
  case 6U:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Device in failed state.\n");
  qlcnic_api_unlock(adapter);
  return (-1);
  case 2U: ;
  case 7U: ;
  goto ldv_54435;
  }
  ldv_54435:
  qlcnic_api_unlock(adapter);
  ldv_54441:
  msleep(1000U);
  prev_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  if (prev_state == 7U) {
  } else {
  }
  if (prev_state != 3U) {
    dev_init_timeo = (u8 )((int )dev_init_timeo - 1);
    if ((unsigned int )dev_init_timeo != 0U) {
      goto ldv_54441;
    } else {
      goto ldv_54442;
    }
  } else {
  }
  ldv_54442: ;
  if ((unsigned int )dev_init_timeo == 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Waiting for device to initialize timeout\n");
    return (-1);
  } else {
  }
  tmp___3 = qlcnic_api_lock(adapter);
  if (tmp___3 != 0) {
    return (-1);
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  val = (u32 )(~ (3 << (int )portnum * 4)) & val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
  tmp___4 = qlcnic_check_idc_ver(adapter);
  ret = (u8 )tmp___4;
  qlcnic_api_unlock(adapter);
  return ((int )ret);
}
}
static void qlcnic_fwinit_work(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  struct work_struct const *__mptr ;
  u32 dev_state ;
  u32 val ;
  int tmp ;
  u8 tmp___0 ;
  char const *tmp___1 ;
  char const *tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const *tmp___6 ;
  int tmp___7 ;
  {
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffc78UL;
  dev_state = 15U;
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    goto err_ret;
  } else {
  }
  dev_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  if (dev_state == 7U || dev_state == 5U) {
    qlcnic_api_unlock(adapter);
    qlcnic_schedule_work(adapter, & qlcnic_fwinit_work, 500);
    return;
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode == 2U) {
    qlcnic_api_unlock(adapter);
    goto wait_npar;
  } else {
  }
  if (dev_state == 2U || dev_state == 3U) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Detected state change from DEV_NEED_RESET, skipping ack check\n");
    goto skip_ack_check;
  } else {
  }
  tmp___0 = adapter->fw_wait_cnt;
  adapter->fw_wait_cnt = (u8 )((int )adapter->fw_wait_cnt + 1);
  if ((int )tmp___0 > (int )adapter->reset_ack_timeo) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Reset:Failed to get ack %d sec\n",
              (int )adapter->reset_ack_timeo);
    goto skip_ack_check;
  } else {
  }
  tmp___5 = qlcnic_check_drv_state(adapter);
  if (tmp___5 == 0) {
    skip_ack_check:
    dev_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
    if (dev_state == 4U) {
      writel(2U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
      set_bit(4L, (unsigned long volatile *)(& adapter->state));
      if ((int )(adapter->ahw)->msg_enable & 1) {
        tmp___1 = dev_name((struct device const *)(& (adapter->pdev)->dev));
        printk("\016%s: %s: Restarting fw\n", tmp___1, "qlcnic_fwinit_work");
      } else {
      }
      qlcnic_idc_debug_info(adapter, 0);
      val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
      val = (u32 )(1 << (int )adapter->portnum * 4) | val;
      writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 7UL));
    } else {
    }
    qlcnic_api_unlock(adapter);
    rtnl_lock();
    tmp___3 = qlcnic_check_fw_dump_state(adapter);
    if ((int )tmp___3 && (adapter->flags & 8192U) != 0U) {
      if ((int )(adapter->ahw)->msg_enable & 1) {
        tmp___2 = dev_name((struct device const *)(& (adapter->pdev)->dev));
        printk("\016%s: %s: Take FW dump\n", tmp___2, "qlcnic_fwinit_work");
      } else {
      }
      qlcnic_dump_fw(adapter);
      adapter->flags = adapter->flags | 16384U;
    } else {
    }
    rtnl_unlock();
    adapter->flags = adapter->flags & 4294959103U;
    tmp___4 = (*((adapter->nic_ops)->start_firmware))(adapter);
    if (tmp___4 == 0) {
      qlcnic_schedule_work(adapter, & qlcnic_attach_work, 0);
      adapter->fw_wait_cnt = 0U;
      return;
    } else {
    }
    goto err_ret;
  } else {
  }
  qlcnic_api_unlock(adapter);
  wait_npar:
  dev_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  if (((adapter->ahw)->msg_enable & 8192U) != 0U) {
    tmp___6 = dev_name((struct device const *)(& (adapter->pdev)->dev));
    printk("\016%s: %s: Func waiting: Device state=%u\n", tmp___6, "qlcnic_fwinit_work",
           dev_state);
  } else {
  }
  switch (dev_state) {
  case 3U:
  tmp___7 = qlcnic_start_firmware(adapter);
  if (tmp___7 == 0) {
    qlcnic_schedule_work(adapter, & qlcnic_attach_work, 0);
    adapter->fw_wait_cnt = 0U;
    return;
  } else {
  }
  case 6U: ;
  goto ldv_54457;
  default:
  qlcnic_schedule_work(adapter, & qlcnic_fwinit_work, 250);
  return;
  }
  ldv_54457: ;
  err_ret:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Fwinit work failed state=%u fw_wait_cnt=%u\n",
          dev_state, (int )adapter->fw_wait_cnt);
  netif_device_attach(adapter->netdev);
  qlcnic_clr_all_drv_state(adapter, 0);
  return;
}
}
static void qlcnic_detach_work(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  struct work_struct const *__mptr ;
  struct net_device *netdev ;
  u32 status ;
  bool tmp ;
  int tmp___0 ;
  {
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffc78UL;
  netdev = adapter->netdev;
  netif_device_detach(netdev);
  if ((unsigned int )adapter->dev_state == 5U) {
    tmp = netif_running((struct net_device const *)netdev);
    if ((int )tmp) {
      __qlcnic_down(adapter, netdev);
    } else {
    }
  } else {
    qlcnic_down(adapter, netdev);
  }
  status = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl));
  if ((int )status < 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Detaching the device: peg halt status1=0x%x\n",
            status);
    if (((status >> 8) & 2097151U) == 22U) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "On board active cooling fan failed. Device has been halted.\n");
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Replace the adapter.\n");
    } else {
    }
    goto err_ret;
  } else {
  }
  if ((adapter->ahw)->temp == 3U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Detaching the device: temp=%d\n",
            (adapter->ahw)->temp);
    goto err_ret;
  } else {
  }
  if ((adapter->flags & 8192U) == 0U) {
    tmp___0 = qlcnic_set_drv_state(adapter, (int )adapter->dev_state);
    if (tmp___0 != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to set driver state,detaching the device.\n");
      goto err_ret;
    } else {
    }
  } else {
  }
  adapter->fw_wait_cnt = 0U;
  qlcnic_schedule_work(adapter, & qlcnic_fwinit_work, 250);
  return;
  err_ret:
  netif_device_attach(netdev);
  qlcnic_clr_all_drv_state(adapter, 1);
  return;
}
}
static void qlcnic_set_npar_non_operational(struct qlcnic_adapter *adapter )
{
  u32 state ;
  int tmp ;
  {
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 14UL));
  if (state == 0U) {
    return;
  } else {
  }
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    return;
  } else {
  }
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 14UL));
  qlcnic_api_unlock(adapter);
  return;
}
}
static void qlcnic_82xx_dev_request_reset(struct qlcnic_adapter *adapter , u32 key )
{
  u32 state ;
  u32 xg_val ;
  u32 gb_val ;
  int tmp ;
  int tmp___0 ;
  char const *tmp___1 ;
  {
  xg_val = 0U;
  gb_val = 0U;
  xg_val = xg_val | 1U;
  xg_val = xg_val | 8U;
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 106954904UL, xg_val);
  gb_val = gb_val | 1U;
  gb_val = gb_val | 4U;
  gb_val = gb_val | 16U;
  gb_val = gb_val | 64U;
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 106955532UL, gb_val);
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Pause control frames disabled on all ports\n");
  adapter->need_fw_reset = 1U;
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    return;
  } else {
  }
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  tmp___0 = constant_test_bit(16L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "%s: Device is in non-operational state\n",
               "qlcnic_82xx_dev_request_reset");
    qlcnic_api_unlock(adapter);
    return;
  } else {
  }
  if (state == 3U) {
    writel(4U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
    adapter->flags = adapter->flags | 8192U;
    if ((int )(adapter->ahw)->msg_enable & 1) {
      tmp___1 = dev_name((struct device const *)(& (adapter->pdev)->dev));
      printk("\016%s: %s: NEED_RESET state set\n", tmp___1, "qlcnic_82xx_dev_request_reset");
    } else {
    }
    qlcnic_idc_debug_info(adapter, 0);
  } else {
  }
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 14UL));
  qlcnic_api_unlock(adapter);
  return;
}
}
static void qlcnic_dev_set_npar_ready(struct qlcnic_adapter *adapter )
{
  int tmp ;
  char const *tmp___0 ;
  {
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    return;
  } else {
  }
  writel(1U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 14UL));
  if ((int )(adapter->ahw)->msg_enable & 1) {
    tmp___0 = dev_name((struct device const *)(& (adapter->pdev)->dev));
    printk("\016%s: %s: NPAR operational state set\n", tmp___0, "qlcnic_dev_set_npar_ready");
  } else {
  }
  qlcnic_api_unlock(adapter);
  return;
}
}
void qlcnic_schedule_work(struct qlcnic_adapter *adapter , void (*func)(struct work_struct * ) ,
                          int delay )
{
  int tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  unsigned long tmp___0 ;
  {
  tmp = constant_test_bit(5L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    return;
  } else {
  }
  __init_work(& adapter->fw_work.work, 0);
  __constr_expr_0.counter = 137438953408L;
  adapter->fw_work.work.data = __constr_expr_0;
  lockdep_init_map(& adapter->fw_work.work.lockdep_map, "(&(&adapter->fw_work)->work)",
                   & __key, 0);
  INIT_LIST_HEAD(& adapter->fw_work.work.entry);
  adapter->fw_work.work.func = func;
  init_timer_key(& adapter->fw_work.timer, 2U, "(&(&adapter->fw_work)->timer)", & __key___0);
  adapter->fw_work.timer.function = & delayed_work_timer_fn;
  adapter->fw_work.timer.data = (unsigned long )(& adapter->fw_work);
  tmp___0 = round_jiffies_relative((unsigned long )delay);
  queue_delayed_work(adapter->qlcnic_wq, & adapter->fw_work, tmp___0);
  return;
}
}
static void qlcnic_attach_work(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  struct work_struct const *__mptr ;
  struct net_device *netdev ;
  u32 npar_state ;
  u8 tmp ;
  char const *tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffc78UL;
  netdev = adapter->netdev;
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    npar_state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 14UL));
    tmp = adapter->fw_wait_cnt;
    adapter->fw_wait_cnt = (u8 )((int )adapter->fw_wait_cnt + 1);
    if ((unsigned int )tmp > 30U) {
      qlcnic_clr_all_drv_state(adapter, 0);
    } else
    if (npar_state != 1U) {
      qlcnic_schedule_work(adapter, & qlcnic_attach_work, 250);
    } else {
      goto attach;
    }
    if ((int )(adapter->ahw)->msg_enable & 1) {
      tmp___0 = dev_name((struct device const *)(& (adapter->pdev)->dev));
      printk("\016%s: %s: Waiting for NPAR state to operational\n", tmp___0, "qlcnic_attach_work");
    } else {
    }
    return;
  } else {
  }
  attach:
  qlcnic_dcb_get_info(adapter->dcb);
  tmp___2 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___2) {
    tmp___1 = qlcnic_up(adapter, netdev);
    if (tmp___1 != 0) {
      goto done;
    } else {
    }
    qlcnic_restore_indev_addr(netdev, 1UL);
  } else {
  }
  done:
  netif_device_attach(netdev);
  adapter->fw_fail_cnt = 0U;
  adapter->flags = adapter->flags & 4294950911U;
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  if ((unsigned int )adapter->portnum == 0U) {
    qlcnic_set_drv_version(adapter);
  } else {
  }
  tmp___3 = qlcnic_clr_drv_state(adapter);
  if (tmp___3 == 0) {
    qlcnic_schedule_work(adapter, & qlcnic_fw_poll_work, 250);
  } else {
  }
  return;
}
}
static int qlcnic_check_health(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_fw_dump *fw_dump ;
  u32 state ;
  u32 heartbeat ;
  u32 peg_status ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  char const *tmp___6 ;
  int tmp___7 ;
  {
  ahw = adapter->ahw;
  fw_dump = & ahw->fw_dump;
  state = 0U;
  err = 0;
  tmp = qlcnic_check_temp(adapter);
  if (tmp != 0) {
    goto detach;
  } else {
  }
  if ((unsigned int )adapter->need_fw_reset != 0U) {
    qlcnic_dev_request_reset(adapter, 0U);
  } else {
  }
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  if (state == 4U) {
    qlcnic_set_npar_non_operational(adapter);
    adapter->need_fw_reset = 1U;
  } else
  if (state == 5U) {
    goto detach;
  } else {
  }
  heartbeat = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 2UL));
  if (adapter->heartbeat != heartbeat) {
    adapter->heartbeat = heartbeat;
    adapter->fw_fail_cnt = 0U;
    if ((unsigned int )adapter->need_fw_reset != 0U) {
      goto detach;
    } else {
    }
    if ((unsigned int )ahw->reset_context != 0U && qlcnic_auto_fw_reset != 0) {
      qlcnic_reset_hw_context(adapter);
    } else {
    }
    return (0);
  } else {
  }
  adapter->fw_fail_cnt = (u8 )((int )adapter->fw_fail_cnt + 1);
  if ((unsigned int )adapter->fw_fail_cnt <= 1U) {
    return (0);
  } else {
  }
  adapter->flags = adapter->flags | 16384U;
  qlcnic_dev_request_reset(adapter, 0U);
  if (qlcnic_auto_fw_reset != 0) {
    clear_bit(0L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  dev_err((struct device const *)(& (adapter->pdev)->dev), "firmware hang detected\n");
  peg_status = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl));
  tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 116391996UL, & err);
  tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 121634876UL, & err);
  tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 120586300UL, & err);
  tmp___3 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 119537724UL, & err);
  tmp___4 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 118489148UL, & err);
  tmp___5 = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 1UL));
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Dumping hw/fw registers\nPEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\nPEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\nPEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\nPEG_NET_4_PC: 0x%x\n",
          peg_status, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0);
  if (((peg_status >> 8) & 2097151U) == 103U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Firmware aborted with error code 0x00006700. Device is being reset.\n");
  } else {
  }
  detach:
  adapter->dev_state = state == 5U ? 5U : 4U;
  if (qlcnic_auto_fw_reset != 0) {
    tmp___7 = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
    if (tmp___7 == 0) {
      qlcnic_schedule_work(adapter, & qlcnic_detach_work, 0);
      if ((int )(adapter->ahw)->msg_enable & 1) {
        tmp___6 = dev_name((struct device const *)(& (adapter->pdev)->dev));
        printk("\016%s: %s: fw recovery scheduled.\n", tmp___6, "qlcnic_check_health");
      } else {
      }
    } else {
      goto _L;
    }
  } else
  _L:
  if ((qlcnic_auto_fw_reset == 0 && (int )fw_dump->enable) && (adapter->flags & 8192U) != 0U) {
    qlcnic_dump_fw(adapter);
  } else {
  }
  return (1);
}
}
void qlcnic_fw_poll_work(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  struct work_struct const *__mptr ;
  int tmp ;
  int tmp___0 ;
  {
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffc78UL;
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    goto reschedule;
  } else {
  }
  tmp___0 = qlcnic_check_health(adapter);
  if (tmp___0 != 0) {
    return;
  } else {
  }
  if ((unsigned int )adapter->fhash.fnum != 0U) {
    qlcnic_prune_lb_filters(adapter);
  } else {
  }
  reschedule:
  qlcnic_schedule_work(adapter, & qlcnic_fw_poll_work, 250);
  return;
}
}
static int qlcnic_is_first_func(struct pci_dev *pdev )
{
  struct pci_dev *oth_pdev ;
  int val ;
  int tmp ;
  int tmp___0 ;
  {
  val = (int )pdev->devfn;
  goto ldv_54526;
  ldv_54527:
  tmp = pci_domain_nr(pdev->bus);
  oth_pdev = pci_get_domain_bus_and_slot(tmp, (unsigned int )(pdev->bus)->number,
                                         (pdev->devfn & 248U) | ((unsigned int )val & 7U));
  if ((unsigned long )oth_pdev == (unsigned long )((struct pci_dev *)0)) {
    goto ldv_54526;
  } else {
  }
  if (oth_pdev->current_state != 4) {
    pci_dev_put(oth_pdev);
    return (0);
  } else {
  }
  pci_dev_put(oth_pdev);
  ldv_54526:
  tmp___0 = val;
  val = val - 1;
  if (tmp___0 > 0) {
    goto ldv_54527;
  } else {
  }
  return (1);
}
}
static int qlcnic_attach_func(struct pci_dev *pdev )
{
  int err ;
  int first_func ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  int tmp___0 ;
  char const *tmp___1 ;
  bool tmp___2 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  netdev = adapter->netdev;
  pdev->error_state = 1U;
  err = pci_enable_device(pdev);
  if (err != 0) {
    return (err);
  } else {
  }
  pci_set_master(pdev);
  pci_restore_state(pdev);
  first_func = qlcnic_is_first_func(pdev);
  tmp___0 = qlcnic_api_lock(adapter);
  if (tmp___0 != 0) {
    return (-22);
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode != 2U && first_func != 0) {
    adapter->need_fw_reset = 1U;
    set_bit(4L, (unsigned long volatile *)(& adapter->state));
    writel(2U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
    if ((int )(adapter->ahw)->msg_enable & 1) {
      tmp___1 = dev_name((struct device const *)(& (adapter->pdev)->dev));
      printk("\016%s: %s: Restarting fw\n", tmp___1, "qlcnic_attach_func");
    } else {
    }
  } else {
  }
  qlcnic_api_unlock(adapter);
  err = qlcnic_start_firmware(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_clr_drv_state(adapter);
  kfree((void const *)adapter->msix_entries);
  adapter->msix_entries = (struct msix_entry *)0;
  err = qlcnic_setup_intr(adapter);
  if (err != 0) {
    kfree((void const *)adapter->msix_entries);
    netdev_err((struct net_device const *)netdev, "failed to setup interrupt\n");
    return (err);
  } else {
  }
  tmp___2 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___2) {
    err = qlcnic_attach(adapter);
    if (err != 0) {
      qlcnic_clr_all_drv_state(adapter, 1);
      clear_bit(5L, (unsigned long volatile *)(& adapter->state));
      netif_device_attach(netdev);
      return (err);
    } else {
    }
    err = qlcnic_up(adapter, netdev);
    if (err != 0) {
      goto done;
    } else {
    }
    qlcnic_restore_indev_addr(netdev, 1UL);
  } else {
  }
  done:
  netif_device_attach(netdev);
  return (err);
}
}
static pci_ers_result_t qlcnic_82xx_io_error_detected(struct pci_dev *pdev , pci_channel_state_t state )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  netdev = adapter->netdev;
  if (state == 3U) {
    return (4U);
  } else {
  }
  if (state == 1U) {
    return (5U);
  } else {
  }
  set_bit(5L, (unsigned long volatile *)(& adapter->state));
  netif_device_detach(netdev);
  cancel_delayed_work_sync(& adapter->fw_work);
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_detach(adapter);
  qlcnic_teardown_intr(adapter);
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  pci_save_state(pdev);
  pci_disable_device(pdev);
  return (3U);
}
}
static pci_ers_result_t qlcnic_82xx_io_slot_reset(struct pci_dev *pdev )
{
  int tmp ;
  {
  tmp = qlcnic_attach_func(pdev);
  return (tmp != 0 ? 4U : 5U);
}
}
static void qlcnic_82xx_io_resume(struct pci_dev *pdev )
{
  u32 state ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  pci_cleanup_aer_uncorrect_error_status(pdev);
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 6UL));
  if (state == 3U) {
    tmp___0 = test_and_clear_bit(5L, (unsigned long volatile *)(& adapter->state));
    if (tmp___0 != 0) {
      qlcnic_schedule_work(adapter, & qlcnic_fw_poll_work, 250);
    } else {
    }
  } else {
  }
  return;
}
}
static pci_ers_result_t qlcnic_io_error_detected(struct pci_dev *pdev , pci_channel_state_t state )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_ops *hw_ops ;
  pci_ers_result_t tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  hw_ops = (adapter->ahw)->hw_ops;
  if ((unsigned long )hw_ops->io_error_detected != (unsigned long )((pci_ers_result_t (*)(struct pci_dev * ,
                                                                                          pci_channel_state_t ))0)) {
    tmp___0 = (*(hw_ops->io_error_detected))(pdev, state);
    return (tmp___0);
  } else {
    dev_err((struct device const *)(& pdev->dev), "AER error_detected handler not registered.\n");
    return (4U);
  }
}
}
static pci_ers_result_t qlcnic_io_slot_reset(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_ops *hw_ops ;
  pci_ers_result_t tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  hw_ops = (adapter->ahw)->hw_ops;
  if ((unsigned long )hw_ops->io_slot_reset != (unsigned long )((pci_ers_result_t (*)(struct pci_dev * ))0)) {
    tmp___0 = (*(hw_ops->io_slot_reset))(pdev);
    return (tmp___0);
  } else {
    dev_err((struct device const *)(& pdev->dev), "AER slot_reset handler not registered.\n");
    return (4U);
  }
}
}
static void qlcnic_io_resume(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_ops *hw_ops ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  hw_ops = (adapter->ahw)->hw_ops;
  if ((unsigned long )hw_ops->io_resume != (unsigned long )((void (*)(struct pci_dev * ))0)) {
    (*(hw_ops->io_resume))(pdev);
  } else {
    dev_err((struct device const *)(& pdev->dev), "AER resume handler not registered.\n");
  }
  return;
}
}
static int qlcnicvf_start_firmware(struct qlcnic_adapter *adapter )
{
  int err ;
  {
  err = qlcnic_can_start_firmware(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_check_npar_opertional(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_initialize_nic(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_check_options(adapter);
  err = qlcnic_set_eswitch_port_config(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  adapter->need_fw_reset = 0U;
  return (err);
}
}
int qlcnic_validate_rings(struct qlcnic_adapter *adapter , __u32 ring_cnt , int queue_type )
{
  struct net_device *netdev ;
  u8 max_hw_rings ;
  char buf[8U] ;
  int cur_rings ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  {
  netdev = adapter->netdev;
  max_hw_rings = 0U;
  if (queue_type == 2) {
    max_hw_rings = adapter->max_sds_rings;
    cur_rings = (int )adapter->drv_sds_rings;
    strcpy((char *)(& buf), "SDS");
  } else
  if (queue_type == 1) {
    max_hw_rings = adapter->max_tx_rings;
    cur_rings = (int )adapter->drv_tx_rings;
    strcpy((char *)(& buf), "Tx");
  } else {
  }
  tmp = is_power_of_2((unsigned long )ring_cnt);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    netdev_err((struct net_device const *)netdev, "%s rings value should be a power of 2\n",
               (char *)(& buf));
    return (-22);
  } else {
  }
  tmp___1 = qlcnic_82xx_check(adapter);
  if ((int )tmp___1 && queue_type == 1) {
    tmp___2 = qlcnic_check_multi_tx(adapter);
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      netdev_err((struct net_device const *)netdev, "No Multi Tx queue support\n");
      return (-22);
    } else {
    }
  } else {
  }
  tmp___5 = cpumask_weight(cpu_online_mask);
  if (tmp___5 < ring_cnt) {
    tmp___4 = cpumask_weight(cpu_online_mask);
    netdev_err((struct net_device const *)netdev, "%s value[%u] should not be higher than, number of online CPUs\n",
               (char *)(& buf), tmp___4);
    return (-22);
  } else {
  }
  return (0);
}
}
int qlcnic_setup_rings(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  u8 tx_rings ;
  u8 rx_rings ;
  int err ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  netdev = adapter->netdev;
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    return (-16);
  } else {
  }
  tx_rings = adapter->drv_tss_rings;
  rx_rings = adapter->drv_rss_rings;
  netif_device_detach(netdev);
  err = qlcnic_set_real_num_queues(adapter, (int )tx_rings, (int )rx_rings);
  if (err != 0) {
    goto done;
  } else {
  }
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    __qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_detach(adapter);
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    qlcnic_83xx_free_mbx_intr(adapter);
    qlcnic_83xx_enable_mbx_poll(adapter);
  } else {
  }
  qlcnic_teardown_intr(adapter);
  err = qlcnic_setup_intr(adapter);
  if (err != 0) {
    kfree((void const *)adapter->msix_entries);
    netdev_err((struct net_device const *)netdev, "failed to setup interrupt\n");
    return (err);
  } else {
  }
  if ((int )adapter->drv_tx_rings != (int )tx_rings || (int )adapter->drv_sds_rings != (int )rx_rings) {
    err = qlcnic_set_real_num_queues(adapter, (int )adapter->drv_tx_rings, (int )adapter->drv_sds_rings);
    if (err != 0) {
      goto done;
    } else {
    }
  } else {
  }
  tmp___2 = qlcnic_83xx_check(adapter);
  if ((int )tmp___2) {
    qlcnic_83xx_initialize_nic(adapter, 1);
    err = qlcnic_83xx_setup_mbx_intr(adapter);
    qlcnic_83xx_disable_mbx_poll(adapter);
    if (err != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "failed to setup mbx interrupt\n");
      goto done;
    } else {
    }
  } else {
  }
  tmp___3 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___3) {
    err = qlcnic_attach(adapter);
    if (err != 0) {
      goto done;
    } else {
    }
    err = __qlcnic_up(adapter, netdev);
    if (err != 0) {
      goto done;
    } else {
    }
    qlcnic_restore_indev_addr(netdev, 1UL);
  } else {
  }
  done:
  netif_device_attach(netdev);
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (err);
}
}
static void qlcnic_config_indev_addr(struct qlcnic_adapter *adapter , struct net_device *dev ,
                                     unsigned long event )
{
  struct in_device *indev ;
  struct in_ifaddr *ifa ;
  {
  indev = in_dev_get((struct net_device const *)dev);
  if ((unsigned long )indev == (unsigned long )((struct in_device *)0)) {
    return;
  } else {
  }
  ifa = indev->ifa_list;
  goto ldv_54601;
  ldv_54600: ;
  switch (event) {
  case 1UL:
  qlcnic_config_ipaddr(adapter, ifa->ifa_address, 2);
  goto ldv_54597;
  case 2UL:
  qlcnic_config_ipaddr(adapter, ifa->ifa_address, 3);
  goto ldv_54597;
  default: ;
  goto ldv_54597;
  }
  ldv_54597:
  ifa = ifa->ifa_next;
  ldv_54601: ;
  if ((unsigned long )ifa != (unsigned long )((struct in_ifaddr *)0)) {
    goto ldv_54600;
  } else {
  }
  in_dev_put(indev);
  return;
}
}
void qlcnic_restore_indev_addr(struct net_device *netdev , unsigned long event )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct net_device *dev ;
  u16 vid ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  qlcnic_config_indev_addr(adapter, netdev, event);
  rcu_read_lock();
  tmp___0 = find_first_bit((unsigned long const *)(& adapter->vlans), 4096UL);
  vid = (u16 )tmp___0;
  goto ldv_54612;
  ldv_54611:
  dev = __vlan_find_dev_deep_rcu(netdev, 129, (int )vid);
  if ((unsigned long )dev == (unsigned long )((struct net_device *)0)) {
    goto ldv_54610;
  } else {
  }
  qlcnic_config_indev_addr(adapter, dev, event);
  ldv_54610:
  tmp___1 = find_next_bit((unsigned long const *)(& adapter->vlans), 4096UL, (unsigned long )((int )vid + 1));
  vid = (u16 )tmp___1;
  ldv_54612: ;
  if ((unsigned int )vid <= 4095U) {
    goto ldv_54611;
  } else {
  }
  rcu_read_unlock();
  return;
}
}
static int qlcnic_netdev_event(struct notifier_block *this , unsigned long event ,
                               void *ptr )
{
  struct qlcnic_adapter *adapter ;
  struct net_device *dev ;
  struct net_device *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  tmp = netdev_notifier_info_to_dev((struct netdev_notifier_info const *)ptr);
  dev = tmp;
  recheck: ;
  if ((unsigned long )dev == (unsigned long )((struct net_device *)0)) {
    goto done;
  } else {
  }
  if ((int )dev->priv_flags & 1) {
    dev = vlan_dev_real_dev((struct net_device const *)dev);
    goto recheck;
  } else {
  }
  if ((unsigned long )dev->netdev_ops != (unsigned long )(& qlcnic_netdev_ops)) {
    goto done;
  } else {
  }
  tmp___0 = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp___0;
  if ((unsigned long )adapter == (unsigned long )((struct qlcnic_adapter *)0)) {
    goto done;
  } else {
  }
  tmp___1 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___1 == 0) {
    goto done;
  } else {
  }
  qlcnic_config_indev_addr(adapter, dev, event);
  done: ;
  return (0);
}
}
static int qlcnic_inetaddr_event(struct notifier_block *this , unsigned long event ,
                                 void *ptr )
{
  struct qlcnic_adapter *adapter ;
  struct net_device *dev ;
  struct in_ifaddr *ifa ;
  void *tmp ;
  int tmp___0 ;
  {
  ifa = (struct in_ifaddr *)ptr;
  dev = (unsigned long )ifa->ifa_dev != (unsigned long )((struct in_device *)0) ? (ifa->ifa_dev)->dev : (struct net_device *)0;
  recheck: ;
  if ((unsigned long )dev == (unsigned long )((struct net_device *)0)) {
    goto done;
  } else {
  }
  if ((int )dev->priv_flags & 1) {
    dev = vlan_dev_real_dev((struct net_device const *)dev);
    goto recheck;
  } else {
  }
  if ((unsigned long )dev->netdev_ops != (unsigned long )(& qlcnic_netdev_ops)) {
    goto done;
  } else {
  }
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  if ((unsigned long )adapter == (unsigned long )((struct qlcnic_adapter *)0)) {
    goto done;
  } else {
  }
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    goto done;
  } else {
  }
  switch (event) {
  case 1UL:
  qlcnic_config_ipaddr(adapter, ifa->ifa_address, 2);
  goto ldv_54634;
  case 2UL:
  qlcnic_config_ipaddr(adapter, ifa->ifa_address, 3);
  goto ldv_54634;
  default: ;
  goto ldv_54634;
  }
  ldv_54634: ;
  done: ;
  return (0);
}
}
static struct notifier_block qlcnic_netdev_cb = {& qlcnic_netdev_event, 0, 0};
static struct notifier_block qlcnic_inetaddr_cb = {& qlcnic_inetaddr_event, 0, 0};
static struct pci_error_handlers const qlcnic_err_handler = {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state ))(& qlcnic_io_error_detected),
    0, 0, & qlcnic_io_slot_reset, 0, & qlcnic_io_resume};
static struct pci_driver qlcnic_driver =
     {{0, 0}, (char const *)(& qlcnic_driver_name), (struct pci_device_id const *)(& qlcnic_pci_tbl),
    & qlcnic_probe, & qlcnic_remove, & qlcnic_suspend, 0, 0, & qlcnic_resume, & qlcnic_shutdown,
    & qlcnic_pci_sriov_configure, & qlcnic_err_handler, {0, 0, 0, 0, (_Bool)0, 0,
                                                         0, 0, 0, 0, 0, 0, 0, 0, 0},
    {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}};
static int qlcnic_init_module(void)
{
  int ret ;
  {
  printk("\016%s\n", (char const *)(& qlcnic_driver_string));
  register_netdevice_notifier(& qlcnic_netdev_cb);
  register_inetaddr_notifier(& qlcnic_inetaddr_cb);
  ret = __pci_register_driver(& qlcnic_driver, & __this_module, "qlcnic");
  if (ret != 0) {
    unregister_inetaddr_notifier(& qlcnic_inetaddr_cb);
    unregister_netdevice_notifier(& qlcnic_netdev_cb);
  } else {
  }
  return (ret);
}
}
static void qlcnic_exit_module(void)
{
  {
  pci_unregister_driver(& qlcnic_driver);
  unregister_inetaddr_notifier(& qlcnic_inetaddr_cb);
  unregister_netdevice_notifier(& qlcnic_netdev_cb);
  return;
}
}
extern int ldv_release_31(void) ;
extern int ldv_release_29(void) ;
extern int ldv_ndo_uninit_33(void) ;
int ldv_retval_2 ;
extern int ldv_probe_26(void) ;
int ldv_retval_5 ;
int ldv_retval_0 ;
int ldv_retval_6 ;
int ldv_retval_1 ;
extern void ldv_initialize(void) ;
extern int ldv_ndo_uninit_32(void) ;
extern int ldv_suspend_26(void) ;
extern int ldv_probe_29(void) ;
extern int ldv_release_26(void) ;
extern int ldv_ndo_stop_32(void) ;
int ldv_retval_9 ;
extern int ldv_probe_31(void) ;
extern int ldv_ndo_init_32(void) ;
extern int ldv_ndo_init_33(void) ;
extern int ldv_suspend_31(void) ;
extern void ldv_check_final_state(void) ;
int ldv_retval_8 ;
int ldv_retval_3 ;
int ldv_retval_7 ;
void ldv_initialize_pci_error_handlers_26(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(2976UL);
  qlcnic_err_handler_group0 = (struct pci_dev *)tmp;
  return;
}
}
void ldv_net_device_ops_32(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(3264UL);
  qlcnic_netdev_failed_ops_group1 = (struct net_device *)tmp;
  return;
}
}
void ldv_initialize_qlcnic_nic_template_31(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_ops_group0 = (struct qlcnic_adapter *)tmp;
  return;
}
}
void ldv_initialize_pci_driver_25(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(2976UL);
  qlcnic_driver_group0 = (struct pci_dev *)tmp;
  return;
}
}
void ldv_net_device_ops_33(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(3264UL);
  qlcnic_netdev_ops_group1 = (struct net_device *)tmp;
  return;
}
}
void ldv_initialize_qlcnic_nic_template_30(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_vf_ops_group0 = (struct qlcnic_adapter *)tmp;
  return;
}
}
void ldv_initialize_qlcnic_hardware_ops_29(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_hw_ops_group3 = (struct qlcnic_adapter *)tmp;
  tmp___0 = ldv_zalloc(4096UL);
  qlcnic_hw_ops_group4 = (struct qlcnic_host_sds_ring *)tmp___0;
  tmp___1 = ldv_zalloc(4096UL);
  qlcnic_hw_ops_group0 = (struct qlcnic_host_tx_ring *)tmp___1;
  tmp___2 = ldv_zalloc(72UL);
  qlcnic_hw_ops_group1 = (struct qlcnic_info *)tmp___2;
  tmp___3 = ldv_zalloc(2976UL);
  qlcnic_hw_ops_group5 = (struct pci_dev *)tmp___3;
  tmp___4 = ldv_zalloc(200UL);
  qlcnic_hw_ops_group2 = (struct qlcnic_cmd_args *)tmp___4;
  return;
}
}
void ldv_main_exported_22(void) ;
void ldv_main_exported_24(void) ;
void ldv_main_exported_23(void) ;
void ldv_main_exported_11(void) ;
void ldv_main_exported_21(void) ;
void ldv_main_exported_9(void) ;
void ldv_main_exported_17(void) ;
void ldv_main_exported_12(void) ;
void ldv_main_exported_20(void) ;
void ldv_main_exported_15(void) ;
void ldv_main_exported_14(void) ;
void ldv_main_exported_18(void) ;
void ldv_main_exported_19(void) ;
void ldv_main_exported_10(void) ;
void ldv_main_exported_13(void) ;
void ldv_main_exported_16(void) ;
void ldv_main_exported_1(void) ;
void ldv_main_exported_3(void) ;
void ldv_main_exported_2(void) ;
void ldv_main_exported_8(void) ;
void ldv_main_exported_6(void) ;
void ldv_main_exported_7(void) ;
void ldv_main_exported_4(void) ;
void ldv_main_exported_5(void) ;
int main(void)
{
  sa_family_t ldvarg18 ;
  u8 ldvarg11 ;
  u8 tmp ;
  int ldvarg32 ;
  int tmp___0 ;
  unsigned char *ldvarg7 ;
  void *tmp___1 ;
  struct ifla_vf_info *ldvarg23 ;
  void *tmp___2 ;
  u16 ldvarg12 ;
  u16 tmp___3 ;
  int ldvarg1 ;
  int tmp___4 ;
  __be16 ldvarg29 ;
  int ldvarg24 ;
  int tmp___5 ;
  struct nlattr **ldvarg35 ;
  void *tmp___6 ;
  u8 *ldvarg0 ;
  void *tmp___7 ;
  __be16 ldvarg5 ;
  unsigned char *ldvarg33 ;
  void *tmp___8 ;
  struct netlink_callback *ldvarg16 ;
  void *tmp___9 ;
  sa_family_t ldvarg6 ;
  netdev_features_t ldvarg4 ;
  int ldvarg14 ;
  int tmp___10 ;
  struct ndmsg *ldvarg34 ;
  void *tmp___11 ;
  u16 ldvarg28 ;
  u16 tmp___12 ;
  void *ldvarg2 ;
  void *tmp___13 ;
  struct sk_buff *ldvarg20 ;
  void *tmp___14 ;
  int ldvarg31 ;
  int tmp___15 ;
  int ldvarg3 ;
  int tmp___16 ;
  struct ndmsg *ldvarg8 ;
  void *tmp___17 ;
  int ldvarg13 ;
  int tmp___18 ;
  u16 ldvarg10 ;
  u16 tmp___19 ;
  struct nlattr **ldvarg9 ;
  void *tmp___20 ;
  __be16 ldvarg26 ;
  struct netdev_phys_port_id *ldvarg27 ;
  void *tmp___21 ;
  struct sk_buff *ldvarg15 ;
  void *tmp___22 ;
  int ldvarg30 ;
  int tmp___23 ;
  bool ldvarg21 ;
  __be16 ldvarg17 ;
  u16 ldvarg25 ;
  u16 tmp___24 ;
  int ldvarg22 ;
  int tmp___25 ;
  netdev_features_t ldvarg19 ;
  enum pci_channel_state ldvarg47 ;
  u32 ldvarg95 ;
  u32 tmp___26 ;
  u32 ldvarg94 ;
  u32 tmp___27 ;
  u32 ldvarg96 ;
  u32 tmp___28 ;
  void *ldvarg104 ;
  void *tmp___29 ;
  unsigned long ldvarg105 ;
  unsigned long tmp___30 ;
  struct notifier_block *ldvarg103 ;
  void *tmp___31 ;
  pm_message_t ldvarg108 ;
  int ldvarg106 ;
  int tmp___32 ;
  struct pci_device_id *ldvarg107 ;
  void *tmp___33 ;
  unsigned long ldvarg111 ;
  unsigned long tmp___34 ;
  void *ldvarg110 ;
  void *tmp___35 ;
  struct notifier_block *ldvarg109 ;
  void *tmp___36 ;
  struct net_device *ldvarg147 ;
  void *tmp___37 ;
  u32 ldvarg145 ;
  u32 tmp___38 ;
  struct pci_dev *ldvarg146 ;
  void *tmp___39 ;
  u32 ldvarg144 ;
  u32 tmp___40 ;
  u32 ldvarg143 ;
  u32 tmp___41 ;
  __be32 ldvarg149 ;
  u32 ldvarg142 ;
  u32 tmp___42 ;
  int ldvarg148 ;
  int tmp___43 ;
  int ldvarg203 ;
  int tmp___44 ;
  struct qlcnic_fw_dump *ldvarg212 ;
  void *tmp___45 ;
  u32 ldvarg202 ;
  u32 tmp___46 ;
  loff_t ldvarg219 ;
  loff_t tmp___47 ;
  u8 *ldvarg215 ;
  void *tmp___48 ;
  u8 ldvarg181 ;
  u8 tmp___49 ;
  size_t ldvarg218 ;
  size_t tmp___50 ;
  int ldvarg185 ;
  int tmp___51 ;
  void *ldvarg188 ;
  void *tmp___52 ;
  void *ldvarg216 ;
  void *tmp___53 ;
  void *ldvarg210 ;
  void *tmp___54 ;
  ulong ldvarg191 ;
  u64 *ldvarg208 ;
  void *tmp___55 ;
  u16 ldvarg214 ;
  u16 tmp___56 ;
  u32 ldvarg196 ;
  u32 tmp___57 ;
  int ldvarg221 ;
  int tmp___58 ;
  struct ethtool_coalesce *ldvarg197 ;
  void *tmp___59 ;
  u32 ldvarg211 ;
  u32 tmp___60 ;
  int ldvarg182 ;
  int tmp___61 ;
  int ldvarg189 ;
  int tmp___62 ;
  int ldvarg198 ;
  int tmp___63 ;
  u32 ldvarg199 ;
  u32 tmp___64 ;
  struct qlcnic_pci_info *ldvarg222 ;
  void *tmp___65 ;
  u8 *ldvarg206 ;
  void *tmp___66 ;
  u32 ldvarg201 ;
  u32 tmp___67 ;
  u8 ldvarg213 ;
  u8 tmp___68 ;
  u8 ldvarg204 ;
  u8 tmp___69 ;
  u8 ldvarg195 ;
  u8 tmp___70 ;
  u16 ldvarg207 ;
  u16 tmp___71 ;
  ulong ldvarg187 ;
  u32 ldvarg184 ;
  u32 tmp___72 ;
  int *ldvarg186 ;
  void *tmp___73 ;
  u32 ldvarg190 ;
  u32 tmp___74 ;
  pci_channel_state_t ldvarg209 ;
  loff_t ldvarg193 ;
  loff_t tmp___75 ;
  size_t ldvarg192 ;
  size_t tmp___76 ;
  void *ldvarg183 ;
  void *tmp___77 ;
  void *ldvarg200 ;
  void *tmp___78 ;
  u32 ldvarg217 ;
  u32 tmp___79 ;
  char *ldvarg194 ;
  void *tmp___80 ;
  char *ldvarg220 ;
  void *tmp___81 ;
  u8 ldvarg205 ;
  u8 tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  {
  tmp = __VERIFIER_nondet_u8();
  ldvarg11 = tmp;
  tmp___0 = __VERIFIER_nondet_int();
  ldvarg32 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg7 = (unsigned char *)tmp___1;
  tmp___2 = ldv_zalloc(60UL);
  ldvarg23 = (struct ifla_vf_info *)tmp___2;
  tmp___3 = __VERIFIER_nondet_u16();
  ldvarg12 = tmp___3;
  tmp___4 = __VERIFIER_nondet_int();
  ldvarg1 = tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  ldvarg24 = tmp___5;
  tmp___6 = ldv_zalloc(8UL);
  ldvarg35 = (struct nlattr **)tmp___6;
  tmp___7 = ldv_zalloc(1UL);
  ldvarg0 = (u8 *)tmp___7;
  tmp___8 = ldv_zalloc(1UL);
  ldvarg33 = (unsigned char *)tmp___8;
  tmp___9 = ldv_zalloc(112UL);
  ldvarg16 = (struct netlink_callback *)tmp___9;
  tmp___10 = __VERIFIER_nondet_int();
  ldvarg14 = tmp___10;
  tmp___11 = ldv_zalloc(12UL);
  ldvarg34 = (struct ndmsg *)tmp___11;
  tmp___12 = __VERIFIER_nondet_u16();
  ldvarg28 = tmp___12;
  tmp___13 = ldv_zalloc(1UL);
  ldvarg2 = tmp___13;
  tmp___14 = ldv_zalloc(232UL);
  ldvarg20 = (struct sk_buff *)tmp___14;
  tmp___15 = __VERIFIER_nondet_int();
  ldvarg31 = tmp___15;
  tmp___16 = __VERIFIER_nondet_int();
  ldvarg3 = tmp___16;
  tmp___17 = ldv_zalloc(12UL);
  ldvarg8 = (struct ndmsg *)tmp___17;
  tmp___18 = __VERIFIER_nondet_int();
  ldvarg13 = tmp___18;
  tmp___19 = __VERIFIER_nondet_u16();
  ldvarg10 = tmp___19;
  tmp___20 = ldv_zalloc(8UL);
  ldvarg9 = (struct nlattr **)tmp___20;
  tmp___21 = ldv_zalloc(33UL);
  ldvarg27 = (struct netdev_phys_port_id *)tmp___21;
  tmp___22 = ldv_zalloc(232UL);
  ldvarg15 = (struct sk_buff *)tmp___22;
  tmp___23 = __VERIFIER_nondet_int();
  ldvarg30 = tmp___23;
  tmp___24 = __VERIFIER_nondet_u16();
  ldvarg25 = tmp___24;
  tmp___25 = __VERIFIER_nondet_int();
  ldvarg22 = tmp___25;
  tmp___26 = __VERIFIER_nondet_u32();
  ldvarg95 = tmp___26;
  tmp___27 = __VERIFIER_nondet_u32();
  ldvarg94 = tmp___27;
  tmp___28 = __VERIFIER_nondet_u32();
  ldvarg96 = tmp___28;
  tmp___29 = ldv_zalloc(1UL);
  ldvarg104 = tmp___29;
  tmp___30 = __VERIFIER_nondet_ulong();
  ldvarg105 = tmp___30;
  tmp___31 = ldv_zalloc(24UL);
  ldvarg103 = (struct notifier_block *)tmp___31;
  tmp___32 = __VERIFIER_nondet_int();
  ldvarg106 = tmp___32;
  tmp___33 = ldv_zalloc(32UL);
  ldvarg107 = (struct pci_device_id *)tmp___33;
  tmp___34 = __VERIFIER_nondet_ulong();
  ldvarg111 = tmp___34;
  tmp___35 = ldv_zalloc(1UL);
  ldvarg110 = tmp___35;
  tmp___36 = ldv_zalloc(24UL);
  ldvarg109 = (struct notifier_block *)tmp___36;
  tmp___37 = ldv_zalloc(3264UL);
  ldvarg147 = (struct net_device *)tmp___37;
  tmp___38 = __VERIFIER_nondet_u32();
  ldvarg145 = tmp___38;
  tmp___39 = ldv_zalloc(2976UL);
  ldvarg146 = (struct pci_dev *)tmp___39;
  tmp___40 = __VERIFIER_nondet_u32();
  ldvarg144 = tmp___40;
  tmp___41 = __VERIFIER_nondet_u32();
  ldvarg143 = tmp___41;
  tmp___42 = __VERIFIER_nondet_u32();
  ldvarg142 = tmp___42;
  tmp___43 = __VERIFIER_nondet_int();
  ldvarg148 = tmp___43;
  tmp___44 = __VERIFIER_nondet_int();
  ldvarg203 = tmp___44;
  tmp___45 = ldv_zalloc(72UL);
  ldvarg212 = (struct qlcnic_fw_dump *)tmp___45;
  tmp___46 = __VERIFIER_nondet_u32();
  ldvarg202 = tmp___46;
  tmp___47 = __VERIFIER_nondet_loff_t();
  ldvarg219 = tmp___47;
  tmp___48 = ldv_zalloc(1UL);
  ldvarg215 = (u8 *)tmp___48;
  tmp___49 = __VERIFIER_nondet_u8();
  ldvarg181 = tmp___49;
  tmp___50 = __VERIFIER_nondet_size_t();
  ldvarg218 = tmp___50;
  tmp___51 = __VERIFIER_nondet_int();
  ldvarg185 = tmp___51;
  tmp___52 = ldv_zalloc(1UL);
  ldvarg188 = tmp___52;
  tmp___53 = ldv_zalloc(1UL);
  ldvarg216 = tmp___53;
  tmp___54 = ldv_zalloc(1UL);
  ldvarg210 = tmp___54;
  tmp___55 = ldv_zalloc(8UL);
  ldvarg208 = (u64 *)tmp___55;
  tmp___56 = __VERIFIER_nondet_u16();
  ldvarg214 = tmp___56;
  tmp___57 = __VERIFIER_nondet_u32();
  ldvarg196 = tmp___57;
  tmp___58 = __VERIFIER_nondet_int();
  ldvarg221 = tmp___58;
  tmp___59 = ldv_zalloc(92UL);
  ldvarg197 = (struct ethtool_coalesce *)tmp___59;
  tmp___60 = __VERIFIER_nondet_u32();
  ldvarg211 = tmp___60;
  tmp___61 = __VERIFIER_nondet_int();
  ldvarg182 = tmp___61;
  tmp___62 = __VERIFIER_nondet_int();
  ldvarg189 = tmp___62;
  tmp___63 = __VERIFIER_nondet_int();
  ldvarg198 = tmp___63;
  tmp___64 = __VERIFIER_nondet_u32();
  ldvarg199 = tmp___64;
  tmp___65 = ldv_zalloc(20UL);
  ldvarg222 = (struct qlcnic_pci_info *)tmp___65;
  tmp___66 = ldv_zalloc(1UL);
  ldvarg206 = (u8 *)tmp___66;
  tmp___67 = __VERIFIER_nondet_u32();
  ldvarg201 = tmp___67;
  tmp___68 = __VERIFIER_nondet_u8();
  ldvarg213 = tmp___68;
  tmp___69 = __VERIFIER_nondet_u8();
  ldvarg204 = tmp___69;
  tmp___70 = __VERIFIER_nondet_u8();
  ldvarg195 = tmp___70;
  tmp___71 = __VERIFIER_nondet_u16();
  ldvarg207 = tmp___71;
  tmp___72 = __VERIFIER_nondet_u32();
  ldvarg184 = tmp___72;
  tmp___73 = ldv_zalloc(4UL);
  ldvarg186 = (int *)tmp___73;
  tmp___74 = __VERIFIER_nondet_u32();
  ldvarg190 = tmp___74;
  tmp___75 = __VERIFIER_nondet_loff_t();
  ldvarg193 = tmp___75;
  tmp___76 = __VERIFIER_nondet_size_t();
  ldvarg192 = tmp___76;
  tmp___77 = ldv_zalloc(1UL);
  ldvarg183 = tmp___77;
  tmp___78 = ldv_zalloc(1UL);
  ldvarg200 = tmp___78;
  tmp___79 = __VERIFIER_nondet_u32();
  ldvarg217 = tmp___79;
  tmp___80 = ldv_zalloc(1UL);
  ldvarg194 = (char *)tmp___80;
  tmp___81 = ldv_zalloc(1UL);
  ldvarg220 = (char *)tmp___81;
  tmp___82 = __VERIFIER_nondet_u8();
  ldvarg205 = tmp___82;
  ldv_initialize();
  memset((void *)(& ldvarg18), 0, 2UL);
  memset((void *)(& ldvarg29), 0, 2UL);
  memset((void *)(& ldvarg5), 0, 2UL);
  memset((void *)(& ldvarg6), 0, 2UL);
  memset((void *)(& ldvarg4), 0, 8UL);
  memset((void *)(& ldvarg26), 0, 2UL);
  memset((void *)(& ldvarg21), 0, 1UL);
  memset((void *)(& ldvarg17), 0, 2UL);
  memset((void *)(& ldvarg19), 0, 8UL);
  memset((void *)(& ldvarg47), 0, 4UL);
  memset((void *)(& ldvarg108), 0, 4UL);
  memset((void *)(& ldvarg149), 0, 4UL);
  memset((void *)(& ldvarg191), 0, 8UL);
  memset((void *)(& ldvarg187), 0, 8UL);
  memset((void *)(& ldvarg209), 0, 4UL);
  ldv_state_variable_33 = 0;
  ldv_state_variable_32 = 0;
  ldv_state_variable_21 = 0;
  ldv_state_variable_7 = 0;
  ldv_state_variable_26 = 0;
  ldv_state_variable_17 = 0;
  ldv_state_variable_2 = 0;
  ldv_state_variable_1 = 0;
  ldv_state_variable_18 = 0;
  ldv_state_variable_30 = 0;
  ldv_state_variable_16 = 0;
  ldv_state_variable_27 = 0;
  ldv_state_variable_25 = 0;
  ldv_state_variable_28 = 0;
  ldv_state_variable_20 = 0;
  ldv_state_variable_14 = 0;
  ldv_state_variable_24 = 0;
  ldv_state_variable_10 = 0;
  ldv_state_variable_31 = 0;
  ldv_state_variable_11 = 0;
  ldv_state_variable_22 = 0;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_13 = 0;
  ldv_state_variable_23 = 0;
  ldv_state_variable_29 = 0;
  ldv_state_variable_6 = 0;
  ldv_state_variable_3 = 0;
  ldv_state_variable_9 = 0;
  ldv_state_variable_12 = 0;
  ldv_state_variable_15 = 0;
  ldv_state_variable_8 = 0;
  ldv_state_variable_4 = 0;
  ldv_state_variable_19 = 0;
  ldv_state_variable_5 = 0;
  ldv_55063:
  tmp___83 = __VERIFIER_nondet_int();
  switch (tmp___83) {
  case 0: ;
  if (ldv_state_variable_33 != 0) {
    tmp___84 = __VERIFIER_nondet_int();
    switch (tmp___84) {
    case 0: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_fdb_del(ldvarg34, ldvarg35, qlcnic_netdev_ops_group1, (unsigned char const *)ldvarg33);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_fdb_del(ldvarg34, ldvarg35, qlcnic_netdev_ops_group1, (unsigned char const *)ldvarg33);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_fdb_del(ldvarg34, ldvarg35, qlcnic_netdev_ops_group1, (unsigned char const *)ldvarg33);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 1: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_sriov_set_vf_tx_rate(qlcnic_netdev_ops_group1, ldvarg32, ldvarg31, ldvarg30);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_sriov_set_vf_tx_rate(qlcnic_netdev_ops_group1, ldvarg32, ldvarg31, ldvarg30);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_sriov_set_vf_tx_rate(qlcnic_netdev_ops_group1, ldvarg32, ldvarg31, ldvarg30);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 2: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_vlan_rx_del(qlcnic_netdev_ops_group1, (int )ldvarg29, (int )ldvarg28);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_vlan_rx_del(qlcnic_netdev_ops_group1, (int )ldvarg29, (int )ldvarg28);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_vlan_rx_del(qlcnic_netdev_ops_group1, (int )ldvarg29, (int )ldvarg28);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 3: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_get_phys_port_id(qlcnic_netdev_ops_group1, ldvarg27);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_get_phys_port_id(qlcnic_netdev_ops_group1, ldvarg27);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_get_phys_port_id(qlcnic_netdev_ops_group1, ldvarg27);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 4: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_vlan_rx_add(qlcnic_netdev_ops_group1, (int )ldvarg26, (int )ldvarg25);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_vlan_rx_add(qlcnic_netdev_ops_group1, (int )ldvarg26, (int )ldvarg25);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_vlan_rx_add(qlcnic_netdev_ops_group1, (int )ldvarg26, (int )ldvarg25);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 5: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_sriov_get_vf_config(qlcnic_netdev_ops_group1, ldvarg24, ldvarg23);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_sriov_get_vf_config(qlcnic_netdev_ops_group1, ldvarg24, ldvarg23);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_sriov_get_vf_config(qlcnic_netdev_ops_group1, ldvarg24, ldvarg23);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 6: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_get_stats(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_get_stats(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_get_stats(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 7: ;
    if (ldv_state_variable_33 == 2) {
      ldv_retval_1 = qlcnic_open(qlcnic_netdev_ops_group1);
      if (ldv_retval_1 == 0) {
        ldv_state_variable_33 = 3;
      } else {
      }
    } else {
    }
    goto ldv_54892;
    case 8: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_sriov_set_vf_spoofchk(qlcnic_netdev_ops_group1, ldvarg22, (int )ldvarg21);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_sriov_set_vf_spoofchk(qlcnic_netdev_ops_group1, ldvarg22, (int )ldvarg21);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_sriov_set_vf_spoofchk(qlcnic_netdev_ops_group1, ldvarg22, (int )ldvarg21);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 9: ;
    if (ldv_state_variable_33 == 3) {
      qlcnic_xmit_frame(ldvarg20, qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 3;
    } else {
    }
    goto ldv_54892;
    case 10: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_fix_features(qlcnic_netdev_ops_group1, ldvarg19);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_fix_features(qlcnic_netdev_ops_group1, ldvarg19);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_fix_features(qlcnic_netdev_ops_group1, ldvarg19);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 11: ;
    if (ldv_state_variable_33 == 3) {
      qlcnic_close(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 12: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_set_multi(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_set_multi(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_set_multi(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 13: ;
    if (ldv_state_variable_33 == 1) {
      eth_validate_addr(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      eth_validate_addr(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      eth_validate_addr(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 14: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_del_vxlan_port(qlcnic_netdev_ops_group1, (int )ldvarg18, (int )ldvarg17);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_del_vxlan_port(qlcnic_netdev_ops_group1, (int )ldvarg18, (int )ldvarg17);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_del_vxlan_port(qlcnic_netdev_ops_group1, (int )ldvarg18, (int )ldvarg17);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 15: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_fdb_dump(ldvarg15, ldvarg16, qlcnic_netdev_ops_group1, ldvarg14);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_fdb_dump(ldvarg15, ldvarg16, qlcnic_netdev_ops_group1, ldvarg14);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_fdb_dump(ldvarg15, ldvarg16, qlcnic_netdev_ops_group1, ldvarg14);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 16: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_sriov_set_vf_vlan(qlcnic_netdev_ops_group1, ldvarg13, (int )ldvarg12,
                               (int )ldvarg11);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_sriov_set_vf_vlan(qlcnic_netdev_ops_group1, ldvarg13, (int )ldvarg12,
                               (int )ldvarg11);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_sriov_set_vf_vlan(qlcnic_netdev_ops_group1, ldvarg13, (int )ldvarg12,
                               (int )ldvarg11);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 17: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_poll_controller(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_poll_controller(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_poll_controller(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 18: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_fdb_add(ldvarg8, ldvarg9, qlcnic_netdev_ops_group1, (unsigned char const *)ldvarg7,
                     (int )ldvarg10);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_fdb_add(ldvarg8, ldvarg9, qlcnic_netdev_ops_group1, (unsigned char const *)ldvarg7,
                     (int )ldvarg10);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_fdb_add(ldvarg8, ldvarg9, qlcnic_netdev_ops_group1, (unsigned char const *)ldvarg7,
                     (int )ldvarg10);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 19: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_add_vxlan_port(qlcnic_netdev_ops_group1, (int )ldvarg6, (int )ldvarg5);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_add_vxlan_port(qlcnic_netdev_ops_group1, (int )ldvarg6, (int )ldvarg5);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_add_vxlan_port(qlcnic_netdev_ops_group1, (int )ldvarg6, (int )ldvarg5);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 20: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_set_features(qlcnic_netdev_ops_group1, ldvarg4);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_set_features(qlcnic_netdev_ops_group1, ldvarg4);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_set_features(qlcnic_netdev_ops_group1, ldvarg4);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 21: ;
    if (ldv_state_variable_33 == 3) {
      qlcnic_change_mtu(qlcnic_netdev_ops_group1, ldvarg3);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_change_mtu(qlcnic_netdev_ops_group1, ldvarg3);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 22: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_set_mac(qlcnic_netdev_ops_group1, ldvarg2);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_set_mac(qlcnic_netdev_ops_group1, ldvarg2);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_set_mac(qlcnic_netdev_ops_group1, ldvarg2);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 23: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_sriov_set_vf_mac(qlcnic_netdev_ops_group1, ldvarg1, ldvarg0);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_sriov_set_vf_mac(qlcnic_netdev_ops_group1, ldvarg1, ldvarg0);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_sriov_set_vf_mac(qlcnic_netdev_ops_group1, ldvarg1, ldvarg0);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 24: ;
    if (ldv_state_variable_33 == 1) {
      qlcnic_tx_timeout(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 1;
    } else {
    }
    if (ldv_state_variable_33 == 3) {
      qlcnic_tx_timeout(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 3;
    } else {
    }
    if (ldv_state_variable_33 == 2) {
      qlcnic_tx_timeout(qlcnic_netdev_ops_group1);
      ldv_state_variable_33 = 2;
    } else {
    }
    goto ldv_54892;
    case 25: ;
    if (ldv_state_variable_33 == 1) {
      ldv_retval_0 = ldv_ndo_init_33();
      if (ldv_retval_0 == 0) {
        ldv_state_variable_33 = 2;
        ref_cnt = ref_cnt + 1;
      } else {
      }
    } else {
    }
    goto ldv_54892;
    case 26: ;
    if (ldv_state_variable_33 == 2) {
      ldv_ndo_uninit_33();
      ldv_state_variable_33 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    goto ldv_54892;
    default:
    ldv_stop();
    }
    ldv_54892: ;
  } else {
  }
  goto ldv_54920;
  case 1: ;
  if (ldv_state_variable_32 != 0) {
    tmp___85 = __VERIFIER_nondet_int();
    switch (tmp___85) {
    case 0: ;
    if (ldv_state_variable_32 == 2) {
      ldv_retval_3 = qlcnic_open(qlcnic_netdev_failed_ops_group1);
      if (ldv_retval_3 == 0) {
        ldv_state_variable_32 = 3;
      } else {
      }
    } else {
    }
    goto ldv_54923;
    case 1: ;
    if (ldv_state_variable_32 == 1) {
      ldv_retval_2 = ldv_ndo_init_32();
      if (ldv_retval_2 == 0) {
        ldv_state_variable_32 = 2;
        ref_cnt = ref_cnt + 1;
      } else {
      }
    } else {
    }
    goto ldv_54923;
    case 2: ;
    if (ldv_state_variable_32 == 2) {
      ldv_ndo_uninit_32();
      ldv_state_variable_32 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    goto ldv_54923;
    case 3: ;
    if (ldv_state_variable_32 == 3) {
      ldv_ndo_stop_32();
      ldv_state_variable_32 = 2;
    } else {
    }
    goto ldv_54923;
    default:
    ldv_stop();
    }
    ldv_54923: ;
  } else {
  }
  goto ldv_54920;
  case 2: ;
  if (ldv_state_variable_21 != 0) {
    ldv_main_exported_21();
  } else {
  }
  goto ldv_54920;
  case 3: ;
  if (ldv_state_variable_7 != 0) {
    ldv_main_exported_7();
  } else {
  }
  goto ldv_54920;
  case 4: ;
  if (ldv_state_variable_26 != 0) {
    tmp___86 = __VERIFIER_nondet_int();
    switch (tmp___86) {
    case 0: ;
    if (ldv_state_variable_26 == 3) {
      qlcnic_io_resume(qlcnic_err_handler_group0);
      ldv_state_variable_26 = 2;
    } else {
    }
    goto ldv_54932;
    case 1: ;
    if (ldv_state_variable_26 == 1) {
      qlcnic_io_slot_reset(qlcnic_err_handler_group0);
      ldv_state_variable_26 = 1;
    } else {
    }
    if (ldv_state_variable_26 == 3) {
      qlcnic_io_slot_reset(qlcnic_err_handler_group0);
      ldv_state_variable_26 = 3;
    } else {
    }
    if (ldv_state_variable_26 == 2) {
      qlcnic_io_slot_reset(qlcnic_err_handler_group0);
      ldv_state_variable_26 = 2;
    } else {
    }
    goto ldv_54932;
    case 2: ;
    if (ldv_state_variable_26 == 1) {
      qlcnic_io_error_detected(qlcnic_err_handler_group0, (pci_channel_state_t )ldvarg47);
      ldv_state_variable_26 = 1;
    } else {
    }
    if (ldv_state_variable_26 == 3) {
      qlcnic_io_error_detected(qlcnic_err_handler_group0, (pci_channel_state_t )ldvarg47);
      ldv_state_variable_26 = 3;
    } else {
    }
    if (ldv_state_variable_26 == 2) {
      qlcnic_io_error_detected(qlcnic_err_handler_group0, (pci_channel_state_t )ldvarg47);
      ldv_state_variable_26 = 2;
    } else {
    }
    goto ldv_54932;
    case 3: ;
    if (ldv_state_variable_26 == 2) {
      ldv_suspend_26();
      ldv_state_variable_26 = 3;
    } else {
    }
    goto ldv_54932;
    case 4: ;
    if (ldv_state_variable_26 == 3) {
      ldv_release_26();
      ldv_state_variable_26 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    if (ldv_state_variable_26 == 2) {
      ldv_release_26();
      ldv_state_variable_26 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    goto ldv_54932;
    case 5: ;
    if (ldv_state_variable_26 == 1) {
      ldv_probe_26();
      ldv_state_variable_26 = 2;
      ref_cnt = ref_cnt + 1;
    } else {
    }
    goto ldv_54932;
    default:
    ldv_stop();
    }
    ldv_54932: ;
  } else {
  }
  goto ldv_54920;
  case 5: ;
  if (ldv_state_variable_17 != 0) {
    ldv_main_exported_17();
  } else {
  }
  goto ldv_54920;
  case 6: ;
  if (ldv_state_variable_2 != 0) {
    ldv_main_exported_2();
  } else {
  }
  goto ldv_54920;
  case 7: ;
  if (ldv_state_variable_1 != 0) {
    ldv_main_exported_1();
  } else {
  }
  goto ldv_54920;
  case 8: ;
  if (ldv_state_variable_18 != 0) {
    ldv_main_exported_18();
  } else {
  }
  goto ldv_54920;
  case 9: ;
  if (ldv_state_variable_30 != 0) {
    tmp___87 = __VERIFIER_nondet_int();
    switch (tmp___87) {
    case 0: ;
    if (ldv_state_variable_30 == 1) {
      qlcnicvf_start_firmware(qlcnic_vf_ops_group0);
      ldv_state_variable_30 = 1;
    } else {
    }
    goto ldv_54945;
    case 1: ;
    if (ldv_state_variable_30 == 1) {
      qlcnicvf_config_bridged_mode(qlcnic_vf_ops_group0, ldvarg96);
      ldv_state_variable_30 = 1;
    } else {
    }
    goto ldv_54945;
    case 2: ;
    if (ldv_state_variable_30 == 1) {
      qlcnicvf_config_led(qlcnic_vf_ops_group0, ldvarg95, ldvarg94);
      ldv_state_variable_30 = 1;
    } else {
    }
    goto ldv_54945;
    default:
    ldv_stop();
    }
    ldv_54945: ;
  } else {
  }
  goto ldv_54920;
  case 10: ;
  if (ldv_state_variable_16 != 0) {
    ldv_main_exported_16();
  } else {
  }
  goto ldv_54920;
  case 11: ;
  if (ldv_state_variable_27 != 0) {
    tmp___88 = __VERIFIER_nondet_int();
    switch (tmp___88) {
    case 0: ;
    if (ldv_state_variable_27 == 1) {
      qlcnic_inetaddr_event(ldvarg103, ldvarg105, ldvarg104);
      ldv_state_variable_27 = 1;
    } else {
    }
    goto ldv_54952;
    default:
    ldv_stop();
    }
    ldv_54952: ;
  } else {
  }
  goto ldv_54920;
  case 12: ;
  if (ldv_state_variable_25 != 0) {
    tmp___89 = __VERIFIER_nondet_int();
    switch (tmp___89) {
    case 0: ;
    if (ldv_state_variable_25 == 2) {
      ldv_retval_7 = qlcnic_suspend(qlcnic_driver_group0, ldvarg108);
      if (ldv_retval_7 == 0) {
        ldv_state_variable_25 = 3;
      } else {
      }
    } else {
    }
    goto ldv_54956;
    case 1: ;
    if (ldv_state_variable_25 == 3) {
      ldv_retval_6 = qlcnic_resume(qlcnic_driver_group0);
      if (ldv_retval_6 == 0) {
        ldv_state_variable_25 = 2;
      } else {
      }
    } else {
    }
    goto ldv_54956;
    case 2: ;
    if (ldv_state_variable_25 == 1) {
      ldv_retval_5 = qlcnic_probe(qlcnic_driver_group0, (struct pci_device_id const *)ldvarg107);
      if (ldv_retval_5 == 0) {
        ldv_state_variable_25 = 2;
        ref_cnt = ref_cnt + 1;
      } else {
      }
    } else {
    }
    goto ldv_54956;
    case 3: ;
    if (ldv_state_variable_25 == 3) {
      qlcnic_shutdown(qlcnic_driver_group0);
      ldv_state_variable_25 = 4;
    } else {
    }
    if (ldv_state_variable_25 == 2) {
      qlcnic_shutdown(qlcnic_driver_group0);
      ldv_state_variable_25 = 4;
    } else {
    }
    goto ldv_54956;
    case 4: ;
    if (ldv_state_variable_25 == 4) {
      qlcnic_pci_sriov_configure(qlcnic_driver_group0, ldvarg106);
      ldv_state_variable_25 = 4;
    } else {
    }
    if (ldv_state_variable_25 == 1) {
      qlcnic_pci_sriov_configure(qlcnic_driver_group0, ldvarg106);
      ldv_state_variable_25 = 1;
    } else {
    }
    if (ldv_state_variable_25 == 3) {
      qlcnic_pci_sriov_configure(qlcnic_driver_group0, ldvarg106);
      ldv_state_variable_25 = 3;
    } else {
    }
    if (ldv_state_variable_25 == 2) {
      qlcnic_pci_sriov_configure(qlcnic_driver_group0, ldvarg106);
      ldv_state_variable_25 = 2;
    } else {
    }
    goto ldv_54956;
    case 5: ;
    if (ldv_state_variable_25 == 4) {
      qlcnic_remove(qlcnic_driver_group0);
      ldv_state_variable_25 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    if (ldv_state_variable_25 == 3) {
      qlcnic_remove(qlcnic_driver_group0);
      ldv_state_variable_25 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    if (ldv_state_variable_25 == 2) {
      qlcnic_remove(qlcnic_driver_group0);
      ldv_state_variable_25 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    goto ldv_54956;
    default:
    ldv_stop();
    }
    ldv_54956: ;
  } else {
  }
  goto ldv_54920;
  case 13: ;
  if (ldv_state_variable_28 != 0) {
    tmp___90 = __VERIFIER_nondet_int();
    switch (tmp___90) {
    case 0: ;
    if (ldv_state_variable_28 == 1) {
      qlcnic_netdev_event(ldvarg109, ldvarg111, ldvarg110);
      ldv_state_variable_28 = 1;
    } else {
    }
    goto ldv_54965;
    default:
    ldv_stop();
    }
    ldv_54965: ;
  } else {
  }
  goto ldv_54920;
  case 14: ;
  if (ldv_state_variable_20 != 0) {
    ldv_main_exported_20();
  } else {
  }
  goto ldv_54920;
  case 15: ;
  if (ldv_state_variable_14 != 0) {
    ldv_main_exported_14();
  } else {
  }
  goto ldv_54920;
  case 16: ;
  if (ldv_state_variable_24 != 0) {
    ldv_main_exported_24();
  } else {
  }
  goto ldv_54920;
  case 17: ;
  if (ldv_state_variable_10 != 0) {
    ldv_main_exported_10();
  } else {
  }
  goto ldv_54920;
  case 18: ;
  if (ldv_state_variable_31 != 0) {
    tmp___91 = __VERIFIER_nondet_int();
    switch (tmp___91) {
    case 0: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_config_ipaddr(qlcnic_ops_group0, ldvarg149, ldvarg148);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_config_ipaddr(qlcnic_ops_group0, ldvarg149, ldvarg148);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_config_ipaddr(qlcnic_ops_group0, ldvarg149, ldvarg148);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_config_ipaddr(qlcnic_ops_group0, ldvarg149, ldvarg148);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 1: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_clear_legacy_intr(qlcnic_ops_group0);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_clear_legacy_intr(qlcnic_ops_group0);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_clear_legacy_intr(qlcnic_ops_group0);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_clear_legacy_intr(qlcnic_ops_group0);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 2: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_napi_del(qlcnic_ops_group0);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_napi_del(qlcnic_ops_group0);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_napi_del(qlcnic_ops_group0);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_napi_del(qlcnic_ops_group0);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 3: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_napi_add(qlcnic_ops_group0, ldvarg147);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_napi_add(qlcnic_ops_group0, ldvarg147);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_napi_add(qlcnic_ops_group0, ldvarg147);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_napi_add(qlcnic_ops_group0, ldvarg147);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 4: ;
    if (ldv_state_variable_31 == 4) {
      ldv_retval_8 = qlcnic_82xx_resume(qlcnic_ops_group0);
      if (ldv_retval_8 == 0) {
        ldv_state_variable_31 = 2;
      } else {
      }
    } else {
    }
    goto ldv_54973;
    case 5: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_start_firmware(qlcnic_ops_group0);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_start_firmware(qlcnic_ops_group0);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_start_firmware(qlcnic_ops_group0);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_start_firmware(qlcnic_ops_group0);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 6: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_shutdown(ldvarg146);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_shutdown(ldvarg146);
      ldv_state_variable_31 = 3;
    } else {
    }
    goto ldv_54973;
    case 7: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_dev_request_reset(qlcnic_ops_group0, ldvarg145);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_dev_request_reset(qlcnic_ops_group0, ldvarg145);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_dev_request_reset(qlcnic_ops_group0, ldvarg145);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_dev_request_reset(qlcnic_ops_group0, ldvarg145);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 8: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_config_bridged_mode(qlcnic_ops_group0, ldvarg144);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_config_bridged_mode(qlcnic_ops_group0, ldvarg144);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_config_bridged_mode(qlcnic_ops_group0, ldvarg144);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_config_bridged_mode(qlcnic_ops_group0, ldvarg144);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 9: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_cancel_idc_work(qlcnic_ops_group0);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_cancel_idc_work(qlcnic_ops_group0);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_cancel_idc_work(qlcnic_ops_group0);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_cancel_idc_work(qlcnic_ops_group0);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 10: ;
    if (ldv_state_variable_31 == 4) {
      qlcnic_82xx_config_led(qlcnic_ops_group0, ldvarg143, ldvarg142);
      ldv_state_variable_31 = 4;
    } else {
    }
    if (ldv_state_variable_31 == 1) {
      qlcnic_82xx_config_led(qlcnic_ops_group0, ldvarg143, ldvarg142);
      ldv_state_variable_31 = 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      qlcnic_82xx_config_led(qlcnic_ops_group0, ldvarg143, ldvarg142);
      ldv_state_variable_31 = 3;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      qlcnic_82xx_config_led(qlcnic_ops_group0, ldvarg143, ldvarg142);
      ldv_state_variable_31 = 2;
    } else {
    }
    goto ldv_54973;
    case 11: ;
    if (ldv_state_variable_31 == 2) {
      ldv_suspend_31();
      ldv_state_variable_31 = 4;
    } else {
    }
    goto ldv_54973;
    case 12: ;
    if (ldv_state_variable_31 == 4) {
      ldv_release_31();
      ldv_state_variable_31 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    if (ldv_state_variable_31 == 3) {
      ldv_release_31();
      ldv_state_variable_31 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    if (ldv_state_variable_31 == 2) {
      ldv_release_31();
      ldv_state_variable_31 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    goto ldv_54973;
    case 13: ;
    if (ldv_state_variable_31 == 1) {
      ldv_probe_31();
      ldv_state_variable_31 = 2;
      ref_cnt = ref_cnt + 1;
    } else {
    }
    goto ldv_54973;
    default:
    ldv_stop();
    }
    ldv_54973: ;
  } else {
  }
  goto ldv_54920;
  case 19: ;
  if (ldv_state_variable_11 != 0) {
    ldv_main_exported_11();
  } else {
  }
  goto ldv_54920;
  case 20: ;
  if (ldv_state_variable_22 != 0) {
    ldv_main_exported_22();
  } else {
  }
  goto ldv_54920;
  case 21: ;
  if (ldv_state_variable_0 != 0) {
    tmp___92 = __VERIFIER_nondet_int();
    switch (tmp___92) {
    case 0: ;
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
      qlcnic_exit_module();
      ldv_state_variable_0 = 3;
      goto ldv_final;
    } else {
    }
    goto ldv_54993;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_9 = qlcnic_init_module();
      if (ldv_retval_9 != 0) {
        ldv_state_variable_0 = 3;
        goto ldv_final;
      } else {
      }
      if (ldv_retval_9 == 0) {
        ldv_state_variable_0 = 2;
        ldv_state_variable_5 = 1;
        ldv_initialize_qlcnic_hardware_ops_5();
        ldv_state_variable_31 = 1;
        ldv_initialize_qlcnic_nic_template_31();
        ldv_state_variable_10 = 1;
        ldv_initialize_bin_attribute_10();
        ldv_state_variable_19 = 1;
        ldv_initialize_device_attribute_19();
        ldv_state_variable_24 = 1;
        ldv_initialize_ethtool_ops_24();
        ldv_state_variable_4 = 1;
        ldv_initialize_qlcnic_nic_template_4();
        ldv_state_variable_8 = 1;
        ldv_initialize_qlcnic_hardware_ops_8();
        ldv_state_variable_15 = 1;
        ldv_state_variable_14 = 1;
        ldv_initialize_bin_attribute_14();
        ldv_state_variable_20 = 1;
        ldv_initialize_device_attribute_20();
        ldv_state_variable_12 = 1;
        ldv_initialize_bin_attribute_12();
        ldv_state_variable_9 = 1;
        ldv_state_variable_3 = 1;
        ldv_initialize_qlcnic_dcb_ops_3();
        ldv_state_variable_28 = 1;
        ldv_state_variable_6 = 1;
        ldv_initialize_qlcnic_mbx_ops_6();
        ldv_state_variable_25 = 1;
        ldv_initialize_pci_driver_25();
        ldv_state_variable_27 = 1;
        ldv_state_variable_29 = 1;
        ldv_initialize_qlcnic_hardware_ops_29();
        ldv_state_variable_13 = 1;
        ldv_initialize_bin_attribute_13();
        ldv_state_variable_16 = 1;
        ldv_initialize_bin_attribute_16();
        ldv_state_variable_23 = 1;
        ldv_initialize_ethtool_ops_23();
        ldv_state_variable_30 = 1;
        ldv_initialize_qlcnic_nic_template_30();
        ldv_state_variable_18 = 1;
        ldv_initialize_bin_attribute_18();
        ldv_state_variable_1 = 1;
        ldv_initialize_dcbnl_rtnl_ops_1();
        ldv_state_variable_22 = 1;
        ldv_initialize_ethtool_ops_22();
        ldv_state_variable_2 = 1;
        ldv_initialize_qlcnic_dcb_ops_2();
        ldv_state_variable_17 = 1;
        ldv_initialize_bin_attribute_17();
        ldv_state_variable_26 = 1;
        ldv_initialize_pci_error_handlers_26();
        ldv_state_variable_7 = 1;
        ldv_initialize_qlcnic_nic_template_7();
        ldv_state_variable_21 = 1;
        ldv_initialize_device_attribute_21();
        ldv_state_variable_11 = 1;
        ldv_initialize_bin_attribute_11();
      } else {
      }
    } else {
    }
    goto ldv_54993;
    default:
    ldv_stop();
    }
    ldv_54993: ;
  } else {
  }
  goto ldv_54920;
  case 22: ;
  if (ldv_state_variable_13 != 0) {
    ldv_main_exported_13();
  } else {
  }
  goto ldv_54920;
  case 23: ;
  if (ldv_state_variable_23 != 0) {
    ldv_main_exported_23();
  } else {
  }
  goto ldv_54920;
  case 24: ;
  if (ldv_state_variable_29 != 0) {
    tmp___93 = __VERIFIER_nondet_int();
    switch (tmp___93) {
    case 0: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_pci_info(qlcnic_hw_ops_group3, ldvarg222);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_pci_info(qlcnic_hw_ops_group3, ldvarg222);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 1: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_enable_tx_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_enable_tx_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 2: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_fw_cmd_create_tx_ctx(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0,
                                       ldvarg221);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_fw_cmd_create_tx_ctx(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0,
                                       ldvarg221);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 3: ;
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_read_phys_port_id(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 4: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_read_crb(qlcnic_hw_ops_group3, ldvarg220, ldvarg219, ldvarg218);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_read_crb(qlcnic_hw_ops_group3, ldvarg220, ldvarg219, ldvarg218);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 5: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_store_cap_mask(ldvarg216, ldvarg217);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_store_cap_mask(ldvarg216, ldvarg217);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 6: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_sre_macaddr_change(qlcnic_hw_ops_group3, ldvarg215, (int )ldvarg214,
                                     (int )ldvarg213);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_sre_macaddr_change(qlcnic_hw_ops_group3, ldvarg215, (int )ldvarg214,
                                     (int )ldvarg213);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 7: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_free_mac_list(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_free_mac_list(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 8: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_cache_tmpl_hdr_values(ldvarg212);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_cache_tmpl_hdr_values(ldvarg212);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 9: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_saved_state(ldvarg210, ldvarg211);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_saved_state(ldvarg210, ldvarg211);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 10: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_set_nic_info(qlcnic_hw_ops_group3, qlcnic_hw_ops_group1);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_set_nic_info(qlcnic_hw_ops_group3, qlcnic_hw_ops_group1);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 11: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_io_error_detected(qlcnic_hw_ops_group5, ldvarg209);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_io_error_detected(qlcnic_hw_ops_group5, ldvarg209);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 12: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_add_sysfs(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_add_sysfs(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 13: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_change_filter(qlcnic_hw_ops_group3, ldvarg208, (int )ldvarg207);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_change_filter(qlcnic_hw_ops_group3, ldvarg208, (int )ldvarg207);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 14: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_mac_address(qlcnic_hw_ops_group3, ldvarg206, (int )ldvarg205);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_mac_address(qlcnic_hw_ops_group3, ldvarg206, (int )ldvarg205);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 15: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_set_lb_mode(qlcnic_hw_ops_group3, (int )ldvarg204);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_set_lb_mode(qlcnic_hw_ops_group3, (int )ldvarg204);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 16: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_set_mac_filter_count(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_set_mac_filter_count(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 17: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_config_hw_lro(qlcnic_hw_ops_group3, ldvarg203);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_config_hw_lro(qlcnic_hw_ops_group3, ldvarg203);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 18: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_func_no(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_func_no(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 19: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_set_saved_state(ldvarg200, ldvarg202, ldvarg201);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_set_saved_state(ldvarg200, ldvarg202, ldvarg201);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 20: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_api_lock(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_api_lock(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 21: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_setup_intr(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_setup_intr(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 22: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_alloc_mbx_args(qlcnic_hw_ops_group2, qlcnic_hw_ops_group3, ldvarg199);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_alloc_mbx_args(qlcnic_hw_ops_group2, qlcnic_hw_ops_group3, ldvarg199);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 23: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_disable_tx_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_disable_tx_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 24: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_beacon_state(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_beacon_state(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 25: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_fw_cmd_del_tx_ctx(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_fw_cmd_del_tx_ctx(qlcnic_hw_ops_group3, qlcnic_hw_ops_group0);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 26: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_io_slot_reset(qlcnic_hw_ops_group5);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_io_slot_reset(qlcnic_hw_ops_group5);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 27: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_linkevent_request(qlcnic_hw_ops_group3, ldvarg198);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_linkevent_request(qlcnic_hw_ops_group3, ldvarg198);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 28: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_disable_sds_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group4);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_disable_sds_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group4);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 29: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_config_intr_coalesce(qlcnic_hw_ops_group3, ldvarg197);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_config_intr_coalesce(qlcnic_hw_ops_group3, ldvarg197);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 30: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_issue_cmd(qlcnic_hw_ops_group3, qlcnic_hw_ops_group2);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_issue_cmd(qlcnic_hw_ops_group3, qlcnic_hw_ops_group2);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 31: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_api_unlock(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_api_unlock(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 32: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_fw_cmd_create_rx_ctx(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_fw_cmd_create_rx_ctx(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 33: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_io_resume(qlcnic_hw_ops_group5);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_io_resume(qlcnic_hw_ops_group5);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 34: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_nic_set_promisc(qlcnic_hw_ops_group3, ldvarg196);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_nic_set_promisc(qlcnic_hw_ops_group3, ldvarg196);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 35: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_clear_lb_mode(qlcnic_hw_ops_group3, (int )ldvarg195);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_clear_lb_mode(qlcnic_hw_ops_group3, (int )ldvarg195);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 36: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_napi_enable(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_napi_enable(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 37: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_process_rcv_ring_diag(qlcnic_hw_ops_group4);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_process_rcv_ring_diag(qlcnic_hw_ops_group4);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 38: ;
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_write_crb(qlcnic_hw_ops_group3, ldvarg194, ldvarg193, ldvarg192);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 39: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_hw_write_wx_2M(qlcnic_hw_ops_group3, ldvarg191, ldvarg190);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_hw_write_wx_2M(qlcnic_hw_ops_group3, ldvarg191, ldvarg190);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 40: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_cap_size(ldvarg188, ldvarg189);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_cap_size(ldvarg188, ldvarg189);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 41: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_board_info(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_board_info(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 42: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_napi_disable(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_napi_disable(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 43: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_hw_read_wx_2M(qlcnic_hw_ops_group3, ldvarg187, ldvarg186);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_hw_read_wx_2M(qlcnic_hw_ops_group3, ldvarg187, ldvarg186);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 44: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_set_sys_info(ldvarg183, ldvarg185, ldvarg184);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_set_sys_info(ldvarg183, ldvarg185, ldvarg184);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 45: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_remove_sysfs(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_remove_sysfs(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 46: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_enable_sds_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group4);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_enable_sds_intr(qlcnic_hw_ops_group3, qlcnic_hw_ops_group4);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 47: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_config_rss(qlcnic_hw_ops_group3, ldvarg182);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_config_rss(qlcnic_hw_ops_group3, ldvarg182);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 48: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_fw_cmd_del_rx_ctx(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_fw_cmd_del_rx_ctx(qlcnic_hw_ops_group3);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 49: ;
    if (ldv_state_variable_29 == 1) {
      qlcnic_82xx_get_nic_info(qlcnic_hw_ops_group3, qlcnic_hw_ops_group1, (int )ldvarg181);
      ldv_state_variable_29 = 1;
    } else {
    }
    if (ldv_state_variable_29 == 2) {
      qlcnic_82xx_get_nic_info(qlcnic_hw_ops_group3, qlcnic_hw_ops_group1, (int )ldvarg181);
      ldv_state_variable_29 = 2;
    } else {
    }
    goto ldv_55000;
    case 50: ;
    if (ldv_state_variable_29 == 2) {
      ldv_release_29();
      ldv_state_variable_29 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    goto ldv_55000;
    case 51: ;
    if (ldv_state_variable_29 == 1) {
      ldv_probe_29();
      ldv_state_variable_29 = 2;
      ref_cnt = ref_cnt + 1;
    } else {
    }
    goto ldv_55000;
    default:
    ldv_stop();
    }
    ldv_55000: ;
  } else {
  }
  goto ldv_54920;
  case 25: ;
  if (ldv_state_variable_6 != 0) {
    ldv_main_exported_6();
  } else {
  }
  goto ldv_54920;
  case 26: ;
  if (ldv_state_variable_3 != 0) {
    ldv_main_exported_3();
  } else {
  }
  goto ldv_54920;
  case 27: ;
  if (ldv_state_variable_9 != 0) {
    ldv_main_exported_9();
  } else {
  }
  goto ldv_54920;
  case 28: ;
  if (ldv_state_variable_12 != 0) {
    ldv_main_exported_12();
  } else {
  }
  goto ldv_54920;
  case 29: ;
  if (ldv_state_variable_15 != 0) {
    ldv_main_exported_15();
  } else {
  }
  goto ldv_54920;
  case 30: ;
  if (ldv_state_variable_8 != 0) {
    ldv_main_exported_8();
  } else {
  }
  goto ldv_54920;
  case 31: ;
  if (ldv_state_variable_4 != 0) {
    ldv_main_exported_4();
  } else {
  }
  goto ldv_54920;
  case 32: ;
  if (ldv_state_variable_19 != 0) {
    ldv_main_exported_19();
  } else {
  }
  goto ldv_54920;
  case 33: ;
  if (ldv_state_variable_5 != 0) {
    ldv_main_exported_5();
  } else {
  }
  goto ldv_54920;
  default:
  ldv_stop();
  }
  ldv_54920: ;
  goto ldv_55063;
  ldv_final:
  ldv_check_final_state();
  return 0;
}
}
__inline static void spin_lock(spinlock_t *lock )
{
  {
  ldv_spin_lock();
  ldv_spin_lock_45(lock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock )
{
  {
  ldv_spin_unlock();
  ldv_spin_unlock_49(lock);
  return;
}
}
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  ldv_kcalloc_58(n, size, flags);
  return ((void *)0);
}
}
void *ldv_kmem_cache_alloc_60(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_66(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_68(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_70(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_71(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_72(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_73(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_74(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_75(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_76(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_77(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_vzalloc_78(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
int ldv_register_netdev_79(struct net_device *dev )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = register_netdev(dev);
  ldv_func_res = tmp;
  ldv_state_variable_33 = 1;
  ldv_net_device_ops_33();
  return (ldv_func_res);
}
}
void *ldv_vzalloc_80(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
void ldv_free_netdev_81(struct net_device *dev )
{
  {
  free_netdev(dev);
  ldv_state_variable_33 = 0;
  return;
}
}
int ldv_register_netdev_82(struct net_device *dev )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = register_netdev(dev);
  ldv_func_res = tmp;
  ldv_state_variable_33 = 1;
  ldv_net_device_ops_33();
  return (ldv_func_res);
}
}
void ldv_unregister_netdev_83(struct net_device *dev )
{
  {
  unregister_netdev(dev);
  ldv_state_variable_33 = 0;
  return;
}
}
void ldv_free_netdev_84(struct net_device *dev )
{
  {
  free_netdev(dev);
  ldv_state_variable_33 = 0;
  return;
}
}
extern void __might_sleep(char const * , int , int ) ;
extern int sscanf(char const * , char const * , ...) ;
extern int strncmp(char const * , char const * , __kernel_size_t ) ;
__inline static void spin_lock(spinlock_t *lock ) ;
__inline static void spin_unlock(spinlock_t *lock ) ;
void *ldv_vzalloc_136(unsigned long ldv_func_arg1 ) ;
void *ldv_vzalloc_137(unsigned long ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_118(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_135(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
__inline static int valid_dma_direction(int dma_direction )
{
  {
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
extern void debug_dma_unmap_page(struct device * , dma_addr_t , size_t , int ,
                                 bool ) ;
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_22472: ;
    goto ldv_22472;
  } else {
  }
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t ,
                                                                    size_t , enum dma_data_direction ,
                                                                    struct dma_attrs * ))0)) {
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {
  }
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
  return;
}
}
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
    ldv_22514: ;
    goto ldv_22514;
  } else {
  }
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t ,
                                                                    size_t , enum dma_data_direction ,
                                                                    struct dma_attrs * ))0)) {
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {
  }
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
  return;
}
}
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction )
{
  {
  dma_unmap_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         dma_addr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
  return;
}
}
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction )
{
  {
  dma_unmap_page((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 dma_address, size, (enum dma_data_direction )direction);
  return;
}
}
extern void __const_udelay(unsigned long ) ;
extern int _cond_resched(void) ;
struct sk_buff *ldv_skb_clone_126(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_134(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_128(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_124(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_132(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_133(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_129(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_130(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_131(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason ) ;
__inline static void dev_kfree_skb_any(struct sk_buff *skb )
{
  {
  __dev_kfree_skb_any(skb, 1);
  return;
}
}
extern int request_firmware(struct firmware const ** , char const * , struct device * ) ;
extern void release_firmware(struct firmware const * ) ;
int qlcnic_rom_fast_read_words(struct qlcnic_adapter *adapter , int addr , u8 *bytes ,
                               size_t size ) ;
static unsigned int crb_addr_xform[60U] ;
static int qlcnic_check_fw_hearbeat(struct qlcnic_adapter *adapter ) ;
static void crb_addr_transform_setup(void)
{
  {
  crb_addr_xform[49] = 1078984704U;
  crb_addr_xform[40] = 1097859072U;
  crb_addr_xform[5] = 218103808U;
  crb_addr_xform[11] = 238026752U;
  crb_addr_xform[10] = 236978176U;
  crb_addr_xform[9] = 235929600U;
  crb_addr_xform[8] = 234881024U;
  crb_addr_xform[16] = 1883242496U;
  crb_addr_xform[15] = 1882193920U;
  crb_addr_xform[14] = 1881145344U;
  crb_addr_xform[13] = 1880096768U;
  crb_addr_xform[48] = 1894776832U;
  crb_addr_xform[47] = 148897792U;
  crb_addr_xform[46] = 147849216U;
  crb_addr_xform[45] = 1891631104U;
  crb_addr_xform[44] = 1890582528U;
  crb_addr_xform[43] = 1889533952U;
  crb_addr_xform[42] = 143654912U;
  crb_addr_xform[53] = 142606336U;
  crb_addr_xform[51] = 1108344832U;
  crb_addr_xform[29] = 1090519040U;
  crb_addr_xform[7] = 241172480U;
  crb_addr_xform[12] = 1879048192U;
  crb_addr_xform[22] = 876609536U;
  crb_addr_xform[21] = 877658112U;
  crb_addr_xform[20] = 875560960U;
  crb_addr_xform[19] = 874512384U;
  crb_addr_xform[18] = 873463808U;
  crb_addr_xform[17] = 872415232U;
  crb_addr_xform[28] = 1010827264U;
  crb_addr_xform[27] = 1011875840U;
  crb_addr_xform[26] = 1009778688U;
  crb_addr_xform[25] = 1008730112U;
  crb_addr_xform[24] = 1007681536U;
  crb_addr_xform[23] = 1006632960U;
  crb_addr_xform[1] = 1999634432U;
  crb_addr_xform[0] = 698351616U;
  crb_addr_xform[6] = 454033408U;
  crb_addr_xform[50] = 1107296256U;
  crb_addr_xform[31] = 219152384U;
  crb_addr_xform[2] = 693108736U;
  crb_addr_xform[3] = 709885952U;
  crb_addr_xform[37] = 209715200U;
  crb_addr_xform[36] = 208666624U;
  crb_addr_xform[35] = 207618048U;
  crb_addr_xform[34] = 1096810496U;
  crb_addr_xform[39] = 1972371456U;
  crb_addr_xform[38] = 1971322880U;
  crb_addr_xform[58] = 1904214016U;
  crb_addr_xform[56] = 1080033280U;
  crb_addr_xform[59] = 428867584U;
  return;
}
}
void qlcnic_release_rx_buffers(struct qlcnic_adapter *adapter )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_rx_buffer *rx_buf ;
  int i ;
  int ring ;
  {
  recv_ctx = adapter->recv_ctx;
  ring = 0;
  goto ldv_50867;
  ldv_50866:
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  i = 0;
  goto ldv_50864;
  ldv_50863:
  rx_buf = rds_ring->rx_buf_arr + (unsigned long )i;
  if ((unsigned long )rx_buf->skb == (unsigned long )((struct sk_buff *)0)) {
    goto ldv_50862;
  } else {
  }
  pci_unmap_single(adapter->pdev, rx_buf->dma, (size_t )rds_ring->dma_size, 2);
  dev_kfree_skb_any(rx_buf->skb);
  ldv_50862:
  i = i + 1;
  ldv_50864: ;
  if ((u32 )i < rds_ring->num_desc) {
    goto ldv_50863;
  } else {
  }
  ring = ring + 1;
  ldv_50867: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_50866;
  } else {
  }
  return;
}
}
void qlcnic_reset_rx_buffers_list(struct qlcnic_adapter *adapter )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_rx_buffer *rx_buf ;
  int i ;
  int ring ;
  {
  recv_ctx = adapter->recv_ctx;
  ring = 0;
  goto ldv_50881;
  ldv_50880:
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  INIT_LIST_HEAD(& rds_ring->free_list);
  rx_buf = rds_ring->rx_buf_arr;
  i = 0;
  goto ldv_50878;
  ldv_50877:
  list_add_tail(& rx_buf->list, & rds_ring->free_list);
  rx_buf = rx_buf + 1;
  i = i + 1;
  ldv_50878: ;
  if ((u32 )i < rds_ring->num_desc) {
    goto ldv_50877;
  } else {
  }
  ring = ring + 1;
  ldv_50881: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_50880;
  } else {
  }
  return;
}
}
void qlcnic_release_tx_buffers(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring )
{
  struct qlcnic_cmd_buffer *cmd_buf ;
  struct qlcnic_skb_frag *buffrag ;
  int i ;
  int j ;
  {
  spin_lock(& tx_ring->tx_clean_lock);
  cmd_buf = tx_ring->cmd_buf_arr;
  i = 0;
  goto ldv_50895;
  ldv_50894:
  buffrag = (struct qlcnic_skb_frag *)(& cmd_buf->frag_array);
  if (buffrag->dma != 0ULL) {
    pci_unmap_single(adapter->pdev, buffrag->dma, (size_t )buffrag->length, 1);
    buffrag->dma = 0ULL;
  } else {
  }
  j = 1;
  goto ldv_50892;
  ldv_50891:
  buffrag = buffrag + 1;
  if (buffrag->dma != 0ULL) {
    pci_unmap_page(adapter->pdev, buffrag->dma, (size_t )buffrag->length, 1);
    buffrag->dma = 0ULL;
  } else {
  }
  j = j + 1;
  ldv_50892: ;
  if ((u32 )j < cmd_buf->frag_count) {
    goto ldv_50891;
  } else {
  }
  if ((unsigned long )cmd_buf->skb != (unsigned long )((struct sk_buff *)0)) {
    dev_kfree_skb_any(cmd_buf->skb);
    cmd_buf->skb = (struct sk_buff *)0;
  } else {
  }
  cmd_buf = cmd_buf + 1;
  i = i + 1;
  ldv_50895: ;
  if ((u32 )i < tx_ring->num_desc) {
    goto ldv_50894;
  } else {
  }
  spin_unlock(& tx_ring->tx_clean_lock);
  return;
}
}
void qlcnic_free_sw_resources(struct qlcnic_adapter *adapter )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_rds_ring *rds_ring ;
  int ring ;
  {
  recv_ctx = adapter->recv_ctx;
  if ((unsigned long )recv_ctx->rds_rings == (unsigned long )((struct qlcnic_host_rds_ring *)0)) {
    return;
  } else {
  }
  ring = 0;
  goto ldv_50904;
  ldv_50903:
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  vfree((void const *)rds_ring->rx_buf_arr);
  rds_ring->rx_buf_arr = (struct qlcnic_rx_buffer *)0;
  ring = ring + 1;
  ldv_50904: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_50903;
  } else {
  }
  kfree((void const *)recv_ctx->rds_rings);
  return;
}
}
int qlcnic_alloc_sw_resources(struct qlcnic_adapter *adapter )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_rx_buffer *rx_buf ;
  int ring ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  bool tmp___1 ;
  bool tmp___2 ;
  {
  recv_ctx = adapter->recv_ctx;
  tmp = kcalloc((size_t )adapter->max_rds_rings, 4096UL, 208U);
  rds_ring = (struct qlcnic_host_rds_ring *)tmp;
  if ((unsigned long )rds_ring == (unsigned long )((struct qlcnic_host_rds_ring *)0)) {
    goto err_out;
  } else {
  }
  recv_ctx->rds_rings = rds_ring;
  ring = 0;
  goto ldv_50924;
  ldv_50923:
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  switch (ring) {
  case 0:
  rds_ring->num_desc = (u32 )adapter->num_rxd;
  rds_ring->dma_size = 1532U;
  rds_ring->skb_size = rds_ring->dma_size;
  goto ldv_50917;
  case 1:
  rds_ring->num_desc = (u32 )adapter->num_jumbo_rxd;
  rds_ring->dma_size = 9632U;
  if (((adapter->ahw)->capabilities & 1024U) != 0U) {
    rds_ring->dma_size = rds_ring->dma_size + 2048U;
  } else {
  }
  rds_ring->skb_size = rds_ring->dma_size;
  goto ldv_50917;
  }
  ldv_50917:
  tmp___0 = ldv_vzalloc_136((unsigned long )rds_ring->num_desc * 40UL);
  rds_ring->rx_buf_arr = (struct qlcnic_rx_buffer *)tmp___0;
  if ((unsigned long )rds_ring->rx_buf_arr == (unsigned long )((struct qlcnic_rx_buffer *)0)) {
    goto err_out;
  } else {
  }
  INIT_LIST_HEAD(& rds_ring->free_list);
  rx_buf = rds_ring->rx_buf_arr;
  i = 0;
  goto ldv_50920;
  ldv_50919:
  list_add_tail(& rx_buf->list, & rds_ring->free_list);
  rx_buf->ref_handle = (u16 )i;
  rx_buf = rx_buf + 1;
  i = i + 1;
  ldv_50920: ;
  if ((u32 )i < rds_ring->num_desc) {
    goto ldv_50919;
  } else {
  }
  spinlock_check(& rds_ring->lock);
  __raw_spin_lock_init(& rds_ring->lock.ldv_6347.rlock, "&(&rds_ring->lock)->rlock",
                       & __key);
  ring = ring + 1;
  ldv_50924: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_50923;
  } else {
  }
  ring = 0;
  goto ldv_50930;
  ldv_50929:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  sds_ring->irq = (int )(adapter->msix_entries + (unsigned long )ring)->vector;
  sds_ring->adapter = adapter;
  sds_ring->num_desc = (u32 )adapter->num_rxd;
  tmp___2 = qlcnic_82xx_check(adapter);
  if ((int )tmp___2) {
    tmp___1 = qlcnic_check_multi_tx(adapter);
    if ((int )tmp___1 && (unsigned int )(adapter->ahw)->diag_test == 0U) {
      sds_ring->tx_ring = adapter->tx_ring + (unsigned long )ring;
    } else {
      sds_ring->tx_ring = adapter->tx_ring;
    }
  } else {
  }
  i = 0;
  goto ldv_50927;
  ldv_50926:
  INIT_LIST_HEAD((struct list_head *)(& sds_ring->free_list) + (unsigned long )i);
  i = i + 1;
  ldv_50927: ;
  if (i <= 2) {
    goto ldv_50926;
  } else {
  }
  ring = ring + 1;
  ldv_50930: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_50929;
  } else {
  }
  return (0);
  err_out:
  qlcnic_free_sw_resources(adapter);
  return (-12);
}
}
static u32 qlcnic_decode_crb_addr(u32 addr )
{
  int i ;
  u32 base_addr ;
  u32 offset ;
  u32 pci_base ;
  {
  crb_addr_transform_setup();
  pci_base = 4294967295U;
  base_addr = addr & 4293918720U;
  offset = addr & 1048575U;
  i = 0;
  goto ldv_50941;
  ldv_50940: ;
  if (crb_addr_xform[i] == base_addr) {
    pci_base = (u32 )(i << 20);
    goto ldv_50939;
  } else {
  }
  i = i + 1;
  ldv_50941: ;
  if (i <= 59) {
    goto ldv_50940;
  } else {
  }
  ldv_50939: ;
  if (pci_base == 4294967295U) {
    return (pci_base);
  } else {
    return (pci_base + offset);
  }
}
}
static int qlcnic_wait_rom_done(struct qlcnic_adapter *adapter )
{
  long timeout ;
  long done ;
  int err ;
  int tmp ;
  {
  timeout = 0L;
  done = 0L;
  err = 0;
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.o.c.prepared",
                457, 0);
  _cond_resched();
  goto ldv_50950;
  ldv_50949:
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 154140676UL, & err);
  done = (long )tmp;
  done = done & 2L;
  timeout = timeout + 1L;
  if (timeout > 99L) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Timeout reached  waiting for rom done");
    return (-5);
  } else {
  }
  __const_udelay(4295UL);
  ldv_50950: ;
  if (done == 0L) {
    goto ldv_50949;
  } else {
  }
  return (0);
}
}
static int do_rom_fast_read(struct qlcnic_adapter *adapter , u32 addr , u32 *valp )
{
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  err = 0;
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154206216UL, addr);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154206228UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154206224UL, 3U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154206212UL, 11U);
  tmp = qlcnic_wait_rom_done(adapter);
  if (tmp != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Error waiting for rom done\n");
    return (-5);
  } else {
  }
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154206224UL, 0U);
  __const_udelay(42950UL);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154206228UL, 0U);
  tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 154206232UL, & err);
  *valp = (u32 )tmp___0;
  if (err == -5) {
    return (err);
  } else {
  }
  return (0);
}
}
static int do_rom_fast_read_words(struct qlcnic_adapter *adapter , int addr , u8 *bytes ,
                                  size_t size )
{
  int addridx ;
  int ret ;
  int v ;
  {
  ret = 0;
  addridx = addr;
  goto ldv_50969;
  ldv_50968:
  ret = do_rom_fast_read(adapter, (u32 )addridx, (u32 *)(& v));
  if (ret != 0) {
    goto ldv_50967;
  } else {
  }
  *((__le32 *)bytes) = (unsigned int )v;
  bytes = bytes + 4UL;
  addridx = addridx + 4;
  ldv_50969: ;
  if ((size_t )addridx < (size_t )addr + size) {
    goto ldv_50968;
  } else {
  }
  ldv_50967: ;
  return (ret);
}
}
int qlcnic_rom_fast_read_words(struct qlcnic_adapter *adapter , int addr , u8 *bytes ,
                               size_t size )
{
  int ret ;
  {
  ret = qlcnic_pcie_sem_lock(adapter, 2, 136323328U);
  if (ret < 0) {
    return (ret);
  } else {
  }
  ret = do_rom_fast_read_words(adapter, addr, bytes, size);
  qlcnic_pcie_sem_unlock(adapter, 2);
  return (ret);
}
}
int qlcnic_rom_fast_read(struct qlcnic_adapter *adapter , u32 addr , u32 *valp )
{
  int ret ;
  int tmp ;
  {
  tmp = qlcnic_pcie_sem_lock(adapter, 2, 136323328U);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  ret = do_rom_fast_read(adapter, addr, valp);
  qlcnic_pcie_sem_unlock(adapter, 2);
  return (ret);
}
}
int qlcnic_pinit_from_rom(struct qlcnic_adapter *adapter )
{
  int addr ;
  int err ;
  int i ;
  int n ;
  int init_delay ;
  struct crb_addr_pair *buf ;
  unsigned int offset ;
  u32 off ;
  u32 val ;
  struct pci_dev *pdev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  err = 0;
  pdev = adapter->pdev;
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 16UL));
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 17UL));
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 153092112UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 153092116UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 153092120UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 153092124UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 153092128UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 153092132UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 106954816UL, 255U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 107413504UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 107479040UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 107544576UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 107610112UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 107675648UL, 0U);
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 105910272UL, & err);
  val = (u32 )tmp;
  if (err == -5) {
    return (err);
  } else {
  }
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 105910272UL, val & 4294967294U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 133174016UL, 1U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 142606336UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 142606344UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 142606352UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 142606360UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 142606592UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 142606848UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 118489148UL, 1U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 119537724UL, 1U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 120586300UL, 1U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 121634876UL, 1U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 116391996UL, 1U);
  msleep(20U);
  qlcnic_pcie_sem_unlock(adapter, 2);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154140680UL, 4278190079U);
  tmp___0 = qlcnic_rom_fast_read(adapter, 0U, (u32 *)(& n));
  if (tmp___0 != 0 || n != -889271554) {
    dev_err((struct device const *)(& pdev->dev), "OLD_ERROR Reading crb_init area: val:%x\n",
            n);
    return (-5);
  } else {
    tmp___1 = qlcnic_rom_fast_read(adapter, 4U, (u32 *)(& n));
    if (tmp___1 != 0) {
      dev_err((struct device const *)(& pdev->dev), "OLD_ERROR Reading crb_init area: val:%x\n",
              n);
      return (-5);
    } else {
    }
  }
  offset = (unsigned int )n & 65535U;
  n = (int )((unsigned int )n >> 16);
  if (n > 1023) {
    dev_err((struct device const *)(& pdev->dev), "QLOGIC card flash not initialized.\n");
    return (-5);
  } else {
  }
  tmp___2 = kcalloc((size_t )n, 8UL, 208U);
  buf = (struct crb_addr_pair *)tmp___2;
  if ((unsigned long )buf == (unsigned long )((struct crb_addr_pair *)0)) {
    return (-12);
  } else {
  }
  i = 0;
  goto ldv_50997;
  ldv_50996:
  tmp___3 = qlcnic_rom_fast_read(adapter, ((unsigned int )(i * 2) + offset) * 4U,
                                 & val);
  if (tmp___3 != 0) {
    kfree((void const *)buf);
    return (-5);
  } else {
    tmp___4 = qlcnic_rom_fast_read(adapter, (((unsigned int )(i * 2) + offset) + 1U) * 4U,
                                   (u32 *)(& addr));
    if (tmp___4 != 0) {
      kfree((void const *)buf);
      return (-5);
    } else {
    }
  }
  (buf + (unsigned long )i)->addr = (u32 )addr;
  (buf + (unsigned long )i)->data = val;
  i = i + 1;
  ldv_50997: ;
  if (i < n) {
    goto ldv_50996;
  } else {
  }
  i = 0;
  goto ldv_51001;
  ldv_51000:
  off = qlcnic_decode_crb_addr((buf + (unsigned long )i)->addr);
  if (off == 4294967295U) {
    dev_err((struct device const *)(& pdev->dev), "CRB init value out of range %x\n",
            (buf + (unsigned long )i)->addr);
    goto ldv_50999;
  } else {
  }
  off = off + 100663296U;
  if ((int )off & 1) {
    goto ldv_50999;
  } else {
  }
  if (off == 136323580U) {
    goto ldv_50999;
  } else {
  }
  if (off == 162529308U) {
    goto ldv_50999;
  } else {
  }
  if (off == 154140860U) {
    goto ldv_50999;
  } else {
  }
  if (off == 154140840U) {
    goto ldv_50999;
  } else {
  }
  if (off == 154140872U) {
    goto ldv_50999;
  } else {
  }
  if (off == 154140708U) {
    goto ldv_50999;
  } else {
  }
  if (off == 154140700U) {
    goto ldv_50999;
  } else {
  }
  if ((off & 267386880U) == 102760448U) {
    goto ldv_50999;
  } else {
  }
  if (off == 101785664U) {
    goto ldv_50999;
  } else {
  }
  if (off == 101785672U) {
    goto ldv_50999;
  } else {
  }
  if ((off & 267386880U) == 161480704U) {
    goto ldv_50999;
  } else {
  }
  init_delay = 1;
  if (off == 154140680U) {
    init_delay = 1000;
  } else {
  }
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (ulong )off, (buf + (unsigned long )i)->data);
  msleep((unsigned int )init_delay);
  ldv_50999:
  i = i + 1;
  ldv_51001: ;
  if (i < n) {
    goto ldv_51000;
  } else {
  }
  kfree((void const *)buf);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 122683628UL, 30U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 122683468UL, 8U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 123732044UL, 8U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 118489096UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 118489100UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 119537672UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 119537676UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 120586248UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 120586252UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 121634824UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 121634828UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 116391944UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 116391948UL, 0U);
  msleep(1U);
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl));
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 1UL));
  return (0);
}
}
static int qlcnic_cmd_peg_ready(struct qlcnic_adapter *adapter )
{
  u32 val ;
  int retries ;
  {
  retries = 60;
  ldv_51014:
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 16UL));
  switch (val) {
  case 65281U: ;
  case 61455U: ;
  return (0);
  case 65535U: ;
  goto out_err;
  default: ;
  goto ldv_51013;
  }
  ldv_51013:
  msleep(500U);
  retries = retries - 1;
  if (retries != 0) {
    goto ldv_51014;
  } else {
  }
  writel(65535U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 16UL));
  out_err:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Command Peg initialization not complete, state: 0x%x.\n",
          val);
  return (-5);
}
}
static int qlcnic_receive_peg_ready(struct qlcnic_adapter *adapter )
{
  u32 val ;
  int retries ;
  {
  retries = 2000;
  ldv_51021:
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 17UL));
  if (val == 65281U) {
    return (0);
  } else {
  }
  msleep(10U);
  retries = retries - 1;
  if (retries != 0) {
    goto ldv_51021;
  } else {
  }
  if (retries == 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Receive Peg initialization not complete, state: 0x%x.\n",
            val);
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_check_fw_status(struct qlcnic_adapter *adapter )
{
  int err ;
  {
  err = qlcnic_cmd_peg_ready(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_receive_peg_ready(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  writel(61455U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 16UL));
  return (err);
}
}
int qlcnic_setup_idc_param(struct qlcnic_adapter *adapter )
{
  int timeo ;
  u32 val ;
  int tmp ;
  int tmp___0 ;
  {
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 9UL));
  val = (val >> (int )adapter->portnum * 4) & 15U;
  if ((val & 3U) != 1U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Not an Ethernet NIC func=%u\n",
            val);
    return (-5);
  } else {
  }
  (adapter->ahw)->physical_port = (u8 )(val >> 2);
  tmp = qlcnic_rom_fast_read(adapter, 4098140U, (u32 *)(& timeo));
  if (tmp != 0) {
    timeo = 30;
  } else {
  }
  adapter->dev_init_timeo = (u8 )timeo;
  tmp___0 = qlcnic_rom_fast_read(adapter, 4098144U, (u32 *)(& timeo));
  if (tmp___0 != 0) {
    timeo = 10;
  } else {
  }
  adapter->reset_ack_timeo = (u8 )timeo;
  return (0);
}
}
static int qlcnic_get_flt_entry(struct qlcnic_adapter *adapter , u8 region , struct qlcnic_flt_entry *region_entry )
{
  struct qlcnic_flt_header flt_hdr ;
  struct qlcnic_flt_entry *flt_entry ;
  int i ;
  int ret ;
  u32 entry_size ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  {
  i = 0;
  memset((void *)region_entry, 0, 16UL);
  ret = qlcnic_rom_fast_read_words(adapter, 4132864, (u8 *)(& flt_hdr), 8UL);
  if (ret != 0) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "error reading flash layout header\n");
    return (-5);
  } else {
  }
  entry_size = (u32 )flt_hdr.len - 8U;
  tmp = ldv_vzalloc_137((unsigned long )entry_size);
  flt_entry = (struct qlcnic_flt_entry *)tmp;
  if ((unsigned long )flt_entry == (unsigned long )((struct qlcnic_flt_entry *)0)) {
    return (-5);
  } else {
  }
  ret = qlcnic_rom_fast_read_words(adapter, 4132872, (u8 *)flt_entry, (size_t )entry_size);
  if (ret != 0) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "error reading flash layout entries\n");
    goto err_out;
  } else {
  }
  goto ldv_51045;
  ldv_51044: ;
  if ((int )(flt_entry + (unsigned long )i)->region == (int )region) {
    goto ldv_51043;
  } else {
  }
  i = i + 1;
  ldv_51045: ;
  if ((unsigned long )i < (unsigned long )(entry_size / 16U)) {
    goto ldv_51044;
  } else {
  }
  ldv_51043: ;
  if ((unsigned long )i >= (unsigned long )(entry_size / 16U)) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "region=%x not found in %d regions\n",
             (int )region, i);
    ret = -5;
    goto err_out;
  } else {
  }
  __len = 16UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)region_entry, (void const *)flt_entry + (unsigned long )i,
                     __len);
  } else {
    __ret = memcpy((void *)region_entry, (void const *)flt_entry + (unsigned long )i,
                             __len);
  }
  err_out:
  vfree((void const *)flt_entry);
  return (ret);
}
}
int qlcnic_check_flash_fw_ver(struct qlcnic_adapter *adapter )
{
  struct qlcnic_flt_entry fw_entry ;
  u32 ver ;
  u32 min_ver ;
  int ret ;
  {
  ver = 4294967295U;
  if ((unsigned int )(adapter->ahw)->revision_id == 88U) {
    ret = qlcnic_get_flt_entry(adapter, 151, & fw_entry);
  } else {
    ret = qlcnic_get_flt_entry(adapter, 116, & fw_entry);
  }
  if (ret == 0) {
    qlcnic_rom_fast_read(adapter, fw_entry.start_addr + 4U, & ver);
  } else {
    qlcnic_rom_fast_read(adapter, 4097032U, & ver);
  }
  ver = ((ver << 24) + (((ver >> 8) & 255U) << 16)) + (ver >> 16);
  min_ver = 67371010U;
  if (ver < min_ver) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "firmware version %d.%d.%d unsupported.Min supported version %d.%d.%d\n",
            ver >> 24, (ver >> 16) & 255U, ver & 65535U, min_ver >> 24, (min_ver >> 16) & 255U,
            min_ver & 65535U);
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_has_mn(struct qlcnic_adapter *adapter )
{
  u32 capability ;
  int err ;
  int tmp ;
  {
  capability = 0U;
  err = 0;
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323116UL, & err);
  capability = (u32 )tmp;
  if (err == -5) {
    return (err);
  } else {
  }
  if ((int )capability & 1) {
    return (1);
  } else {
  }
  return (0);
}
}
static struct uni_table_desc *qlcnic_get_table_desc(u8 const *unirom , int section )
{
  u32 i ;
  u32 entries ;
  struct uni_table_desc *directory ;
  u32 offs ;
  u32 tab_type ;
  {
  directory = (struct uni_table_desc *)unirom;
  entries = directory->num_entries;
  i = 0U;
  goto ldv_51071;
  ldv_51070:
  offs = directory->findex + directory->entry_size * i;
  tab_type = *((__le32 *)unirom + ((unsigned long )offs + 8UL));
  if ((u32 )section == tab_type) {
    return ((struct uni_table_desc *)unirom + (unsigned long )offs);
  } else {
  }
  i = i + 1U;
  ldv_51071: ;
  if (i < entries) {
    goto ldv_51070;
  } else {
  }
  return ((struct uni_table_desc *)0);
}
}
static int qlcnic_validate_header(struct qlcnic_adapter *adapter )
{
  u8 const *unirom ;
  struct uni_table_desc *directory ;
  u32 entries ;
  u32 entry_size ;
  u32 tab_size ;
  u32 fw_file_size ;
  {
  unirom = (adapter->fw)->data;
  directory = (struct uni_table_desc *)unirom;
  fw_file_size = (u32 )(adapter->fw)->size;
  if (fw_file_size <= 55U) {
    return (-22);
  } else {
  }
  entries = directory->num_entries;
  entry_size = directory->entry_size;
  tab_size = directory->findex + entries * entry_size;
  if (fw_file_size < tab_size) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_validate_bootld(struct qlcnic_adapter *adapter )
{
  struct uni_table_desc *tab_desc ;
  struct uni_data_desc *descr ;
  u32 offs ;
  u32 tab_size ;
  u32 data_size ;
  u32 idx ;
  u8 const *unirom ;
  __le32 temp ;
  {
  unirom = (adapter->fw)->data;
  temp = *((__le32 *)unirom + ((unsigned long )adapter->file_prd_off + 27UL));
  idx = temp;
  tab_desc = qlcnic_get_table_desc(unirom, 6);
  if ((unsigned long )tab_desc == (unsigned long )((struct uni_table_desc *)0)) {
    return (-22);
  } else {
  }
  tab_size = tab_desc->findex + tab_desc->entry_size * (idx + 1U);
  if ((unsigned long )(adapter->fw)->size < (unsigned long )tab_size) {
    return (-22);
  } else {
  }
  offs = tab_desc->findex + tab_desc->entry_size * idx;
  descr = (struct uni_data_desc *)unirom + (unsigned long )offs;
  data_size = descr->findex + descr->size;
  if ((unsigned long )(adapter->fw)->size < (unsigned long )data_size) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_validate_fw(struct qlcnic_adapter *adapter )
{
  struct uni_table_desc *tab_desc ;
  struct uni_data_desc *descr ;
  u8 const *unirom ;
  u32 offs ;
  u32 tab_size ;
  u32 data_size ;
  u32 idx ;
  __le32 temp ;
  {
  unirom = (adapter->fw)->data;
  temp = *((__le32 *)unirom + ((unsigned long )adapter->file_prd_off + 29UL));
  idx = temp;
  tab_desc = qlcnic_get_table_desc(unirom, 7);
  if ((unsigned long )tab_desc == (unsigned long )((struct uni_table_desc *)0)) {
    return (-22);
  } else {
  }
  tab_size = tab_desc->findex + tab_desc->entry_size * (idx + 1U);
  if ((unsigned long )(adapter->fw)->size < (unsigned long )tab_size) {
    return (-22);
  } else {
  }
  offs = tab_desc->findex + tab_desc->entry_size * idx;
  descr = (struct uni_data_desc *)unirom + (unsigned long )offs;
  data_size = descr->findex + descr->size;
  if ((unsigned long )(adapter->fw)->size < (unsigned long )data_size) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_validate_product_offs(struct qlcnic_adapter *adapter )
{
  struct uni_table_desc *ptab_descr ;
  u8 const *unirom ;
  int mn_present ;
  int tmp ;
  u32 entries ;
  u32 entry_size ;
  u32 tab_size ;
  u32 i ;
  __le32 temp ;
  u32 flags ;
  u32 file_chiprev ;
  u32 offs ;
  u8 chiprev ;
  u32 flagbit ;
  {
  unirom = (adapter->fw)->data;
  tmp = qlcnic_has_mn(adapter);
  mn_present = tmp;
  ptab_descr = qlcnic_get_table_desc(unirom, 0);
  if ((unsigned long )ptab_descr == (unsigned long )((struct uni_table_desc *)0)) {
    return (-22);
  } else {
  }
  entries = ptab_descr->num_entries;
  entry_size = ptab_descr->entry_size;
  tab_size = ptab_descr->findex + entries * entry_size;
  if ((unsigned long )(adapter->fw)->size < (unsigned long )tab_size) {
    return (-22);
  } else {
  }
  nomn:
  i = 0U;
  goto ldv_51122;
  ldv_51121:
  chiprev = (adapter->ahw)->revision_id;
  offs = ptab_descr->findex + ptab_descr->entry_size * i;
  temp = *((__le32 *)unirom + ((unsigned long )offs + 11UL));
  flags = temp;
  temp = *((__le32 *)unirom + ((unsigned long )offs + 10UL));
  file_chiprev = temp;
  flagbit = mn_present != 0 ? 1U : 2U;
  if ((u32 )chiprev == file_chiprev && (int )((unsigned long long )flags >> (int )flagbit) & 1) {
    adapter->file_prd_off = offs;
    return (0);
  } else {
  }
  i = i + 1U;
  ldv_51122: ;
  if (i < entries) {
    goto ldv_51121;
  } else {
  }
  if (mn_present != 0) {
    mn_present = 0;
    goto nomn;
  } else {
  }
  return (-22);
}
}
static int qlcnic_validate_unified_romimage(struct qlcnic_adapter *adapter )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = qlcnic_validate_header(adapter);
  if (tmp != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "unified image: header validation failed\n");
    return (-22);
  } else {
  }
  tmp___0 = qlcnic_validate_product_offs(adapter);
  if (tmp___0 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "unified image: product validation failed\n");
    return (-22);
  } else {
  }
  tmp___1 = qlcnic_validate_bootld(adapter);
  if (tmp___1 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "unified image: bootld validation failed\n");
    return (-22);
  } else {
  }
  tmp___2 = qlcnic_validate_fw(adapter);
  if (tmp___2 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "unified image: firmware validation failed\n");
    return (-22);
  } else {
  }
  return (0);
}
}
static struct uni_data_desc *qlcnic_get_data_desc(struct qlcnic_adapter *adapter ,
                                                  u32 section , u32 idx_offset )
{
  u8 const *unirom ;
  struct uni_table_desc *tab_desc ;
  u32 offs ;
  u32 idx ;
  __le32 temp ;
  {
  unirom = (adapter->fw)->data;
  temp = *((__le32 *)unirom + ((unsigned long )adapter->file_prd_off + (unsigned long )idx_offset));
  idx = temp;
  tab_desc = qlcnic_get_table_desc(unirom, (int )section);
  if ((unsigned long )tab_desc == (unsigned long )((struct uni_table_desc *)0)) {
    return ((struct uni_data_desc *)0);
  } else {
  }
  offs = tab_desc->findex + tab_desc->entry_size * idx;
  return ((struct uni_data_desc *)unirom + (unsigned long )offs);
}
}
static u8 *qlcnic_get_bootld_offs(struct qlcnic_adapter *adapter )
{
  u32 offs ;
  struct uni_data_desc *data_desc ;
  {
  offs = 65536U;
  data_desc = qlcnic_get_data_desc(adapter, 6U, 27U);
  if ((unsigned int )(adapter->ahw)->fw_type == 0U) {
    offs = data_desc->findex;
  } else {
  }
  return ((u8 *)(adapter->fw)->data + (unsigned long )offs);
}
}
static u8 *qlcnic_get_fw_offs(struct qlcnic_adapter *adapter )
{
  u32 offs ;
  struct uni_data_desc *data_desc ;
  {
  offs = 274432U;
  data_desc = qlcnic_get_data_desc(adapter, 7U, 29U);
  if ((unsigned int )(adapter->ahw)->fw_type == 0U) {
    offs = data_desc->findex;
  } else {
  }
  return ((u8 *)(adapter->fw)->data + (unsigned long )offs);
}
}
static u32 qlcnic_get_fw_size(struct qlcnic_adapter *adapter )
{
  struct uni_data_desc *data_desc ;
  u8 const *unirom ;
  {
  unirom = (adapter->fw)->data;
  data_desc = qlcnic_get_data_desc(adapter, 7U, 29U);
  if ((unsigned int )(adapter->ahw)->fw_type == 0U) {
    return (data_desc->size);
  } else {
    return (*((__le32 *)unirom + 4097036U));
  }
}
}
static u32 qlcnic_get_fw_version(struct qlcnic_adapter *adapter )
{
  struct uni_data_desc *fw_data_desc ;
  struct firmware const *fw ;
  u32 major ;
  u32 minor ;
  u32 sub ;
  __le32 version_offset ;
  u8 const *ver_str ;
  int i ;
  int ret ;
  int tmp ;
  {
  fw = adapter->fw;
  if ((unsigned int )(adapter->ahw)->fw_type != 0U) {
    version_offset = *((__le32 *)fw->data + 4097032U);
    return (version_offset);
  } else {
  }
  fw_data_desc = qlcnic_get_data_desc(adapter, 7U, 29U);
  ver_str = fw->data + (((unsigned long )fw_data_desc->findex + (unsigned long )fw_data_desc->size) + 0xffffffffffffffefUL);
  i = 0;
  goto ldv_51165;
  ldv_51164:
  tmp = strncmp((char const *)ver_str + (unsigned long )i, "REV=", 4UL);
  if (tmp == 0) {
    ret = sscanf((char const *)(ver_str + ((unsigned long )i + 4UL)), "%u.%u.%u ",
                 & major, & minor, & sub);
    if (ret != 3) {
      return (0U);
    } else {
      return (((minor << 8) + major) + (sub << 16));
    }
  } else {
  }
  i = i + 1;
  ldv_51165: ;
  if (i <= 11) {
    goto ldv_51164;
  } else {
  }
  return (0U);
}
}
static u32 qlcnic_get_bios_version(struct qlcnic_adapter *adapter )
{
  struct firmware const *fw ;
  u32 bios_ver ;
  u32 prd_off ;
  u8 *version_offset ;
  __le32 temp ;
  {
  fw = adapter->fw;
  prd_off = adapter->file_prd_off;
  if ((unsigned int )(adapter->ahw)->fw_type != 0U) {
    version_offset = (u8 *)fw->data + 4098108U;
    return (*((__le32 *)version_offset));
  } else {
  }
  temp = *((__le32 *)fw->data + ((unsigned long )prd_off + 12UL));
  bios_ver = temp;
  return (((bios_ver << 16) + ((bios_ver >> 8) & 65280U)) + (bios_ver >> 24));
}
}
static void qlcnic_rom_lock_recovery(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = qlcnic_pcie_sem_lock(adapter, 2, 136323328U);
  if (tmp != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Resetting rom_lock\n");
  } else {
  }
  qlcnic_pcie_sem_unlock(adapter, 2);
  return;
}
}
static int qlcnic_check_fw_hearbeat(struct qlcnic_adapter *adapter )
{
  u32 heartbeat ;
  u32 ret ;
  int retries ;
  {
  ret = 4294967291U;
  retries = 10;
  adapter->heartbeat = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 2UL));
  ldv_51185:
  msleep(200U);
  heartbeat = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 2UL));
  if (adapter->heartbeat != heartbeat) {
    ret = 0U;
    goto ldv_51184;
  } else {
  }
  retries = retries - 1;
  if (retries != 0) {
    goto ldv_51185;
  } else {
  }
  ldv_51184: ;
  return ((int )ret);
}
}
int qlcnic_need_fw_reset(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  if ((adapter->flags & 16384U) != 0U) {
    qlcnic_rom_lock_recovery(adapter);
    return (1);
  } else {
    tmp = qlcnic_check_fw_hearbeat(adapter);
    if (tmp != 0) {
      qlcnic_rom_lock_recovery(adapter);
      return (1);
    } else {
    }
  }
  if ((unsigned int )adapter->need_fw_reset != 0U) {
    return (1);
  } else {
  }
  if ((unsigned long )adapter->fw != (unsigned long )((struct firmware const *)0)) {
    return (1);
  } else {
  }
  return (0);
}
}
static char const *fw_name[2U] = { "phanfw.bin", "flash"};
int qlcnic_load_firmware(struct qlcnic_adapter *adapter )
{
  __le64 *ptr64 ;
  u32 i ;
  u32 flashaddr ;
  u32 size ;
  struct firmware const *fw ;
  struct pci_dev *pdev ;
  u64 data ;
  u8 *tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  u64 data___0 ;
  u32 hi ;
  u32 lo ;
  int ret ;
  struct qlcnic_flt_entry bootld_entry ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  {
  fw = adapter->fw;
  pdev = adapter->pdev;
  _dev_info((struct device const *)(& pdev->dev), "loading firmware from %s\n",
            fw_name[(int )(adapter->ahw)->fw_type]);
  if ((unsigned long )fw != (unsigned long )((struct firmware const *)0)) {
    size = 26112U;
    tmp = qlcnic_get_bootld_offs(adapter);
    ptr64 = (__le64 *)tmp;
    flashaddr = 65536U;
    i = 0U;
    goto ldv_51201;
    ldv_51200:
    data = *(ptr64 + (unsigned long )i);
    tmp___0 = qlcnic_pci_mem_write_2M(adapter, (u64 )flashaddr, data);
    if (tmp___0 != 0) {
      return (-5);
    } else {
    }
    flashaddr = flashaddr + 8U;
    i = i + 1U;
    ldv_51201: ;
    if (i < size) {
      goto ldv_51200;
    } else {
    }
    tmp___1 = qlcnic_get_fw_size(adapter);
    size = tmp___1 / 8U;
    tmp___2 = qlcnic_get_fw_offs(adapter);
    ptr64 = (__le64 *)tmp___2;
    flashaddr = 274432U;
    i = 0U;
    goto ldv_51204;
    ldv_51203:
    data = *(ptr64 + (unsigned long )i);
    tmp___3 = qlcnic_pci_mem_write_2M(adapter, (u64 )flashaddr, data);
    if (tmp___3 != 0) {
      return (-5);
    } else {
    }
    flashaddr = flashaddr + 8U;
    i = i + 1U;
    ldv_51204: ;
    if (i < size) {
      goto ldv_51203;
    } else {
    }
    tmp___4 = qlcnic_get_fw_size(adapter);
    size = tmp___4 & 7U;
    if (size != 0U) {
      data = *(ptr64 + (unsigned long )i);
      tmp___5 = qlcnic_pci_mem_write_2M(adapter, (u64 )flashaddr, data);
      if (tmp___5 != 0) {
        return (-5);
      } else {
      }
    } else {
    }
  } else {
    ret = qlcnic_get_flt_entry(adapter, 114, & bootld_entry);
    if (ret == 0) {
      size = bootld_entry.size / 8U;
      flashaddr = bootld_entry.start_addr;
    } else {
      size = 26112U;
      flashaddr = 65536U;
      _dev_info((struct device const *)(& pdev->dev), "using legacy method to get flash fw region");
    }
    i = 0U;
    goto ldv_51212;
    ldv_51211:
    tmp___6 = qlcnic_rom_fast_read(adapter, flashaddr, & lo);
    if (tmp___6 != 0) {
      return (-5);
    } else {
    }
    tmp___7 = qlcnic_rom_fast_read(adapter, flashaddr + 4U, & hi);
    if (tmp___7 != 0) {
      return (-5);
    } else {
    }
    data___0 = ((unsigned long long )hi << 32) | (unsigned long long )lo;
    tmp___8 = qlcnic_pci_mem_write_2M(adapter, (u64 )flashaddr, data___0);
    if (tmp___8 != 0) {
      return (-5);
    } else {
    }
    flashaddr = flashaddr + 8U;
    i = i + 1U;
    ldv_51212: ;
    if (i < size) {
      goto ldv_51211;
    } else {
    }
  }
  msleep(1U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 118489112UL, 4128U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 154140680UL, 8388638U);
  return (0);
}
}
static int qlcnic_validate_firmware(struct qlcnic_adapter *adapter )
{
  u32 val ;
  u32 ver ;
  u32 bios ;
  u32 min_size ;
  struct pci_dev *pdev ;
  struct firmware const *fw ;
  u8 fw_type ;
  int tmp ;
  {
  pdev = adapter->pdev;
  fw = adapter->fw;
  fw_type = (adapter->ahw)->fw_type;
  if ((unsigned int )fw_type == 0U) {
    tmp = qlcnic_validate_unified_romimage(adapter);
    if (tmp != 0) {
      return (-22);
    } else {
    }
    min_size = 819200U;
  } else {
    val = *((__le32 *)fw->data + 16680U);
    if (val != 305419896U) {
      return (-22);
    } else {
    }
    min_size = 4194303U;
  }
  if ((unsigned long )fw->size < (unsigned long )min_size) {
    return (-22);
  } else {
  }
  val = qlcnic_get_fw_version(adapter);
  ver = ((val << 24) + (((val >> 8) & 255U) << 16)) + (val >> 16);
  if (ver <= 67371009U) {
    dev_err((struct device const *)(& pdev->dev), "%s: firmware version %d.%d.%d unsupported\n",
            fw_name[(int )fw_type], ver >> 24, (ver >> 16) & 255U, ver & 65535U);
    return (-22);
  } else {
  }
  val = qlcnic_get_bios_version(adapter);
  qlcnic_rom_fast_read(adapter, 4098108U, & bios);
  if (val != bios) {
    dev_err((struct device const *)(& pdev->dev), "%s: firmware bios is incompatible\n",
            fw_name[(int )fw_type]);
    return (-22);
  } else {
  }
  writel(305419896U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 15UL));
  return (0);
}
}
static void qlcnic_get_next_fwtype(struct qlcnic_adapter *adapter )
{
  u8 fw_type ;
  {
  switch ((int )(adapter->ahw)->fw_type) {
  case 255:
  fw_type = 0U;
  goto ldv_51229;
  case 0: ;
  default:
  fw_type = 1U;
  goto ldv_51229;
  }
  ldv_51229:
  (adapter->ahw)->fw_type = fw_type;
  return;
}
}
void qlcnic_request_firmware(struct qlcnic_adapter *adapter )
{
  struct pci_dev *pdev ;
  int rc ;
  {
  pdev = adapter->pdev;
  (adapter->ahw)->fw_type = 255U;
  next:
  qlcnic_get_next_fwtype(adapter);
  if ((unsigned int )(adapter->ahw)->fw_type == 1U) {
    adapter->fw = (struct firmware const *)0;
  } else {
    rc = request_firmware(& adapter->fw, fw_name[(int )(adapter->ahw)->fw_type], & pdev->dev);
    if (rc != 0) {
      goto next;
    } else {
    }
    rc = qlcnic_validate_firmware(adapter);
    if (rc != 0) {
      release_firmware(adapter->fw);
      msleep(1U);
      goto next;
    } else {
    }
  }
  return;
}
}
void qlcnic_release_firmware(struct qlcnic_adapter *adapter )
{
  {
  release_firmware(adapter->fw);
  adapter->fw = (struct firmware const *)0;
  return;
}
}
void *ldv_kmem_cache_alloc_118(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_124(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_126(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_128(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_129(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_130(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_131(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_132(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_133(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_134(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_135(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_vzalloc_136(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
void *ldv_vzalloc_137(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
__inline static unsigned long __roundup_pow_of_two(unsigned long n )
{
  unsigned int tmp ;
  {
  tmp = fls_long(n - 1UL);
  return (1UL << (int )tmp);
}
}
extern int memcmp(void const * , void const * , size_t ) ;
extern size_t strlcpy(char * , char const * , size_t ) ;
void *ldv_kmem_cache_alloc_166(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_183(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static char const *pci_name(struct pci_dev const *pdev )
{
  char const *tmp ;
  {
  tmp = dev_name(& pdev->dev);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_174(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_182(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_176(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_181(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
extern unsigned char *skb_put(struct sk_buff * , unsigned int ) ;
struct sk_buff *ldv___netdev_alloc_skb_177(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_178(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_179(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev , unsigned int length )
{
  struct sk_buff *tmp ;
  {
  tmp = ldv___netdev_alloc_skb_177(dev, length, 32U);
  return (tmp);
}
}
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed )
{
  {
  ep->speed = (unsigned short )speed;
  ep->speed_hi = (unsigned short )(speed >> 16);
  return;
}
}
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd const *ep )
{
  {
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
extern u32 ethtool_op_get_link(struct net_device * ) ;
extern int netdev_warn(struct net_device const * , char const * , ...) ;
int qlcnic_83xx_lock_driver(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_unlock_driver(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_get_stats(struct qlcnic_adapter *adapter , u64 *data ) ;
int qlcnic_83xx_get_settings(struct qlcnic_adapter *adapter , struct ethtool_cmd *ecmd ) ;
int qlcnic_83xx_set_settings(struct qlcnic_adapter *adapter , struct ethtool_cmd *ecmd ) ;
void qlcnic_83xx_get_pauseparam(struct qlcnic_adapter *adapter , struct ethtool_pauseparam *pause ) ;
int qlcnic_83xx_set_pauseparam(struct qlcnic_adapter *adapter , struct ethtool_pauseparam *pause ) ;
int qlcnic_83xx_test_link(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_reg_test(struct qlcnic_adapter *adapter ) ;
extern int qlcnic_83xx_get_regs_len(struct qlcnic_adapter * ) ;
int qlcnic_83xx_get_registers(struct qlcnic_adapter *adapter , u32 *regs_buff ) ;
int qlcnic_83xx_loopback_test(struct net_device *netdev , u8 mode ) ;
int qlcnic_83xx_interrupt_test(struct net_device *netdev ) ;
int qlcnic_83xx_set_led(struct net_device *netdev , enum ethtool_phys_id_state state ) ;
int qlcnic_83xx_flash_test(struct qlcnic_adapter *adapter ) ;
int qlcnic_fw_cmd_set_port(struct qlcnic_adapter *adapter , u32 config ) ;
int qlcnic_enable_fw_dump_state(struct qlcnic_adapter *adapter ) ;
int qlcnic_check_loopback_buff(unsigned char *data , u8 *mac ) ;
int qlcnic_do_lb_test(struct qlcnic_adapter *adapter , u8 mode ) ;
int qlcnic_get_port_stats(struct qlcnic_adapter *adapter , u8 const func , u8 const rx_tx ,
                          struct __qlcnic_esw_statistics *esw_stats ) ;
int qlcnic_get_mac_stats(struct qlcnic_adapter *adapter , struct qlcnic_mac_statistics *mac_stats ) ;
__inline static void qlcnic_process_rcv_ring_diag(struct qlcnic_host_sds_ring *sds_ring )
{
  {
  (*((((sds_ring->adapter)->ahw)->hw_ops)->process_lb_rcv_ring_diag))(sds_ring);
  return;
}
}
__inline static int qlcnic_config_intr_coalesce(struct qlcnic_adapter *adapter , struct ethtool_coalesce *ethcoal )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->config_intr_coal))(adapter, ethcoal);
  return (tmp);
}
}
__inline static int qlcnic_set_lb_mode(struct qlcnic_adapter *adapter , u8 mode )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->config_loopback))(adapter, (int )mode);
  return (tmp);
}
}
__inline static int qlcnic_clear_lb_mode(struct qlcnic_adapter *adapter , u8 mode )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->clear_loopback))(adapter, (int )mode);
  return (tmp);
}
}
__inline static void qlcnic_store_cap_mask(struct qlcnic_adapter *adapter , void *tmpl_hdr ,
                                           u32 mask )
{
  {
  (*(((adapter->ahw)->hw_ops)->store_cap_mask))(tmpl_hdr, mask);
  return;
}
}
static u32 const qlcnic_fw_dump_level[7U] = { 3U, 7U, 15U, 31U,
        63U, 127U, 255U};
static struct qlcnic_stats const qlcnic_gstrings_stats[22U] =
  { {{'x', 'm', 'i', 't', '_', 'o', 'n', '\000'}, 8, 776},
        {{'x', 'm', 'i', 't', '_', 'o', 'f', 'f', '\000'}, 8, 784},
        {{'x', 'm', 'i', 't', '_', 'c', 'a', 'l', 'l', 'e', 'd', '\000'}, 8, 664},
        {{'x', 'm', 'i', 't', '_', 'f', 'i', 'n', 'i', 's', 'h', 'e', 'd', '\000'}, 8,
      672},
        {{'t', 'x', ' ', 'd', 'm', 'a', ' ', 'm', 'a', 'p', ' ', 'e', 'r', 'r', 'o',
       'r', '\000'}, 8, 816},
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 8, 728},
        {{'t', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\000'}, 8, 688},
        {{'r', 'x', ' ', 'd', 'm', 'a', ' ', 'm', 'a', 'p', ' ', 'e', 'r', 'r', 'o',
       'r', '\000'}, 8, 808},
        {{'r', 'x', '_', 'p', 'k', 't', 's', '\000'}, 8, 704},
        {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 8, 720},
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\000'}, 8, 680},
        {{'n', 'u', 'l', 'l', ' ', 'r', 'x', 'b', 'u', 'f', '\000'}, 8, 800},
        {{'c', 's', 'u', 'm', 'm', 'e', 'd', '\000'}, 8, 696},
        {{'l', 'r', 'o', '_', 'p', 'k', 't', 's', '\000'}, 8, 712},
        {{'l', 'r', 'o', 'b', 'y', 't', 'e', 's', '\000'}, 8, 736},
        {{'l', 's', 'o', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 8, 744},
        {{'e', 'n', 'c', 'a', 'p', '_', 'l', 's', 'o', '_', 'f', 'r', 'a', 'm', 'e',
       's', '\000'}, 8, 752},
        {{'e', 'n', 'c', 'a', 'p', '_', 't', 'x', '_', 'c', 's', 'u', 'm', 'm', 'e',
       'd', '\000'}, 8, 760},
        {{'e', 'n', 'c', 'a', 'p', '_', 'r', 'x', '_', 'c', 's', 'u', 'm', 'm', 'e',
       'd', '\000'}, 8, 768},
        {{'s', 'k', 'b', '_', 'a', 'l', 'l', 'o', 'c', '_', 'f', 'a', 'i', 'l', 'u',
       'r', 'e', '\000'}, 8, 792},
        {{'m', 'a', 'c', '_', 'f', 'i', 'l', 't', 'e', 'r', '_', 'l', 'i', 'm', 'i',
       't', '_', 'o', 'v', 'e', 'r', 'r', 'u', 'n', '\000'}, 8, 832},
        {{'s', 'p', 'u', 'r', 'i', 'o', 'u', 's', ' ', 'i', 'n', 't', 'r', '\000'}, 8,
      824}};
static char const qlcnic_device_gstrings_stats[14U][32U] =
  { { 't', 'x', ' ', 'u',
            'n', 'i', 'c', 'a',
            's', 't', ' ', 'f',
            'r', 'a', 'm', 'e',
            's', '\000'},
   { 't', 'x', ' ', 'm',
            'u', 'l', 't', 'i',
            'c', 'a', 's', 't',
            ' ', 'f', 'r', 'a',
            'm', 'e', 's', '\000'},
   { 't', 'x', ' ', 'b',
            'r', 'o', 'a', 'd',
            'c', 'a', 's', 't',
            ' ', 'f', 'r', 'a',
            'm', 'e', 's', '\000'},
   { 't', 'x', ' ', 'd',
            'r', 'o', 'p', 'p',
            'e', 'd', ' ', 'f',
            'r', 'a', 'm', 'e',
            's', '\000'},
   { 't', 'x', ' ', 'e',
            'r', 'r', 'o', 'r',
            's', '\000'},
   { 't', 'x', ' ', 'l',
            'o', 'c', 'a', 'l',
            ' ', 'f', 'r', 'a',
            'm', 'e', 's', '\000'},
   { 't', 'x', ' ', 'n',
            'u', 'm', 'b', 'y',
            't', 'e', 's', '\000'},
   { 'r', 'x', ' ', 'u',
            'n', 'i', 'c', 'a',
            's', 't', ' ', 'f',
            'r', 'a', 'm', 'e',
            's', '\000'},
   { 'r', 'x', ' ', 'm',
            'u', 'l', 't', 'i',
            'c', 'a', 's', 't',
            ' ', 'f', 'r', 'a',
            'm', 'e', 's', '\000'},
   { 'r', 'x', ' ', 'b',
            'r', 'o', 'a', 'd',
            'c', 'a', 's', 't',
            ' ', 'f', 'r', 'a',
            'm', 'e', 's', '\000'},
   { 'r', 'x', ' ', 'd',
            'r', 'o', 'p', 'p',
            'e', 'd', ' ', 'f',
            'r', 'a', 'm', 'e',
            's', '\000'},
   { 'r', 'x', ' ', 'e',
            'r', 'r', 'o', 'r',
            's', '\000'},
   { 'r', 'x', ' ', 'l',
            'o', 'c', 'a', 'l',
            ' ', 'f', 'r', 'a',
            'm', 'e', 's', '\000'},
   { 'r', 'x', ' ', 'n',
            'u', 'm', 'b', 'y',
            't', 'e', 's', '\000'}};
static char const qlcnic_83xx_tx_stats_strings[5U][32U] = { { 'c', 't', 'x', '_',
            't', 'x', '_', 'b',
            'y', 't', 'e', 's',
            '\000'},
   { 'c', 't', 'x', '_',
            't', 'x', '_', 'p',
            'k', 't', 's', '\000'},
   { 'c', 't', 'x', '_',
            't', 'x', '_', 'e',
            'r', 'r', 'o', 'r',
            's', '\000'},
   { 'c', 't', 'x', '_',
            't', 'x', '_', 'd',
            'r', 'o', 'p', 'p',
            'e', 'd', '_', 'p',
            'k', 't', 's', '\000'},
   { 'c', 't', 'x', '_',
            't', 'x', '_', 'n',
            'u', 'm', '_', 'b',
            'u', 'f', 'f', 'e',
            'r', 's', '\000'}};
static char const qlcnic_83xx_mac_stats_strings[40U][32U] =
  { { 'm', 'a', 'c', '_',
            't', 'x', '_', 'f',
            'r', 'a', 'm', 'e',
            's', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'b',
            'y', 't', 'e', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'm',
            'c', 'a', 's', 't',
            '_', 'p', 'k', 't',
            's', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'b',
            'c', 'a', 's', 't',
            '_', 'p', 'k', 't',
            's', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'p',
            'a', 'u', 's', 'e',
            '_', 'c', 'n', 't',
            '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'c',
            't', 'r', 'l', '_',
            'p', 'k', 't', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'l',
            't', '_', '6', '4',
            'b', '_', 'p', 'k',
            't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'l',
            't', '_', '1', '2',
            '7', 'b', '_', 'p',
            'k', 't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'l',
            't', '_', '2', '5',
            '5', 'b', '_', 'p',
            'k', 't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'l',
            't', '_', '5', '1',
            '1', 'b', '_', 'p',
            'k', 't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'l',
            't', '_', '1', '0',
            '2', '3', 'b', '_',
            'p', 'k', 't', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'l',
            't', '_', '1', '5',
            '1', '8', 'b', '_',
            'p', 'k', 't', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            't', 'x', '_', 'g',
            't', '_', '1', '5',
            '1', '8', 'b', '_',
            'p', 'k', 't', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'f',
            'r', 'a', 'm', 'e',
            's', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'b',
            'y', 't', 'e', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'm',
            'c', 'a', 's', 't',
            '_', 'p', 'k', 't',
            's', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'b',
            'c', 'a', 's', 't',
            '_', 'p', 'k', 't',
            's', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'p',
            'a', 'u', 's', 'e',
            '_', 'c', 'n', 't',
            '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'c',
            't', 'r', 'l', '_',
            'p', 'k', 't', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            't', '_', '6', '4',
            'b', '_', 'p', 'k',
            't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            't', '_', '1', '2',
            '7', 'b', '_', 'p',
            'k', 't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            't', '_', '2', '5',
            '5', 'b', '_', 'p',
            'k', 't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            't', '_', '5', '1',
            '1', 'b', '_', 'p',
            'k', 't', 's', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            't', '_', '1', '0',
            '2', '3', 'b', '_',
            'p', 'k', 't', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            't', '_', '1', '5',
            '1', '8', 'b', '_',
            'p', 'k', 't', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'g',
            't', '_', '1', '5',
            '1', '8', 'b', '_',
            'p', 'k', 't', 's',
            '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            'e', 'n', 'g', 't',
            'h', '_', 'e', 'r',
            'r', 'o', 'r', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            'e', 'n', 'g', 't',
            'h', '_', 's', 'm',
            'a', 'l', 'l', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'l',
            'e', 'n', 'g', 't',
            'h', '_', 'l', 'a',
            'r', 'g', 'e', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'j',
            'a', 'b', 'b', 'e',
            'r', '\000'},
   { 'm', 'a', 'c', '_',
            'r', 'x', '_', 'd',
            'r', 'o', 'p', 'p',
            'e', 'd', '\000'},
   { 'm', 'a', 'c', '_',
            'c', 'r', 'c', '_',
            'e', 'r', 'r', 'o',
            'r', '\000'},
   { 'm', 'a', 'c', '_',
            'a', 'l', 'i', 'g',
            'n', '_', 'e', 'r',
            'r', 'o', 'r', '\000'},
   { 'e', 's', 'w', 'i',
            't', 'c', 'h', '_',
            'f', 'r', 'a', 'm',
            'e', 's', '\000'},
   { 'e', 's', 'w', 'i',
            't', 'c', 'h', '_',
            'b', 'y', 't', 'e',
            's', '\000'},
   { 'e', 's', 'w', 'i',
            't', 'c', 'h', '_',
            'm', 'u', 'l', 't',
            'i', 'c', 'a', 's',
            't', '_', 'f', 'r',
            'a', 'm', 'e', 's',
            '\000'},
   { 'e', 's', 'w', 'i',
            't', 'c', 'h', '_',
            'b', 'r', 'o', 'a',
            'd', 'c', 'a', 's',
            't', '_', 'f', 'r',
            'a', 'm', 'e', 's',
            '\000'},
   { 'e', 's', 'w', 'i',
            't', 'c', 'h', '_',
            'u', 'n', 'i', 'c',
            'a', 's', 't', '_',
            'f', 'r', 'a', 'm',
            'e', 's', '\000'},
   { 'e', 's', 'w', 'i',
            't', 'c', 'h', '_',
            'e', 'r', 'r', 'o',
            'r', '_', 'f', 'r',
            'e', 'e', '_', 'f',
            'r', 'a', 'm', 'e',
            's', '\000'},
   { 'e', 's', 'w', 'i',
            't', 'c', 'h', '_',
            'e', 'r', 'r', 'o',
            'r', '_', 'f', 'r',
            'e', 'e', '_', 'b',
            'y', 't', 'e', 's',
            '\000'}};
static char const qlcnic_tx_queue_stats_strings[5U][32U] = { { 'x', 'm', 'i', 't',
            '_', 'o', 'n', '\000'},
   { 'x', 'm', 'i', 't',
            '_', 'o', 'f', 'f',
            '\000'},
   { 'x', 'm', 'i', 't',
            '_', 'c', 'a', 'l',
            'l', 'e', 'd', '\000'},
   { 'x', 'm', 'i', 't',
            '_', 'f', 'i', 'n',
            'i', 's', 'h', 'e',
            'd', '\000'},
   { 't', 'x', '_', 'b',
            'y', 't', 'e', 's',
            '\000'}};
static char const qlcnic_83xx_rx_stats_strings[17U][32U] =
  { { 'c', 't', 'x', '_',
            'r', 'x', '_', 'b',
            'y', 't', 'e', 's',
            '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'p',
            'k', 't', 's', '\000'},
   { 'c', 't', 'x', '_',
            'l', 'r', 'o', '_',
            'p', 'k', 't', '_',
            'c', 'n', 't', '\000'},
   { 'c', 't', 'x', '_',
            'i', 'p', '_', 'c',
            's', 'u', 'm', '_',
            'e', 'r', 'r', 'o',
            'r', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'p',
            'k', 't', 's', '_',
            'w', 'o', '_', 'c',
            't', 'x', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'p',
            'k', 't', 's', '_',
            'd', 'r', 'o', 'p',
            '_', 'w', 'o', '_',
            's', 'd', 's', '_',
            'o', 'n', '_', 'c',
            'a', 'r', 'd', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'p',
            'k', 't', 's', '_',
            'd', 'r', 'o', 'p',
            '_', 'w', 'o', '_',
            's', 'd', 's', '_',
            'o', 'n', '_', 'h',
            'o', 's', 't', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'o',
            's', 'i', 'z', 'e',
            'd', '_', 'p', 'k',
            't', 's', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'p',
            'k', 't', 's', '_',
            'd', 'r', 'o', 'p',
            'p', 'e', 'd', '_',
            'w', 'o', '_', 'r',
            'd', 's', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'u',
            'n', 'e', 'x', 'p',
            'e', 'c', 't', 'e',
            'd', '_', 'm', 'c',
            'a', 's', 't', '_',
            'p', 'k', 't', 's',
            '\000'},
   { 'c', 't', 'x', '_',
            'i', 'n', 'v', 'a',
            'l', 'i', 'd', '_',
            'm', 'a', 'c', '_',
            'a', 'd', 'd', 'r',
            'e', 's', 's', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'r',
            'd', 's', '_', 'r',
            'i', 'n', 'g', '_',
            'p', 'r', 'i', 'm',
            '_', 'a', 't', 't',
            'e', 'm', 'p', 't',
            'e', 'd', '\000'},
   { 'c', 't', 'x', '_',
            'r', 'x', '_', 'r',
            'd', 's', '_', 'r',
            'i', 'n', 'g', '_',
            'p', 'r', 'i', 'm',
            '_', 's', 'u', 'c',
            'c', 'e', 's', 's',
            '\000'},
   { 'c', 't', 'x', '_',
            'n', 'u', 'm', '_',
            'l', 'r', 'o', '_',
            'f', 'l', 'o', 'w',
            's', '_', 'a', 'd',
            'd', 'e', 'd', '\000'},
   { 'c', 't', 'x', '_',
            'n', 'u', 'm', '_',
            'l', 'r', 'o', '_',
            'f', 'l', 'o', 'w',
            's', '_', 'r', 'e',
            'm', 'o', 'v', 'e',
            'd', '\000'},
   { 'c', 't', 'x', '_',
            'n', 'u', 'm', '_',
            'l', 'r', 'o', '_',
            'f', 'l', 'o', 'w',
            's', '_', 'a', 'c',
            't', 'i', 'v', 'e',
            '\000'},
   { 'c', 't', 'x', '_',
            'p', 'k', 't', 's',
            '_', 'd', 'r', 'o',
            'p', 'p', 'e', 'd',
            '_', 'u', 'n', 'k',
            'n', 'o', 'w', 'n',
            '\000'}};
static char const qlcnic_gstrings_test[6U][32U] = { { 'R', 'e', 'g', 'i',
            's', 't', 'e', 'r',
            '_', 'T', 'e', 's',
            't', '_', 'o', 'n',
            '_', 'o', 'f', 'f',
            'l', 'i', 'n', 'e',
            '\000'},
   { 'L', 'i', 'n', 'k',
            '_', 'T', 'e', 's',
            't', '_', 'o', 'n',
            '_', 'o', 'f', 'f',
            'l', 'i', 'n', 'e',
            '\000'},
   { 'I', 'n', 't', 'e',
            'r', 'r', 'u', 'p',
            't', '_', 'T', 'e',
            's', 't', '_', 'o',
            'f', 'f', 'l', 'i',
            'n', 'e', '\000'},
   { 'I', 'n', 't', 'e',
            'r', 'n', 'a', 'l',
            '_', 'L', 'o', 'o',
            'p', 'b', 'a', 'c',
            'k', '_', 'o', 'f',
            'f', 'l', 'i', 'n',
            'e', '\000'},
   { 'E', 'x', 't', 'e',
            'r', 'n', 'a', 'l',
            '_', 'L', 'o', 'o',
            'p', 'b', 'a', 'c',
            'k', '_', 'o', 'f',
            'f', 'l', 'i', 'n',
            'e', '\000'},
   { 'E', 'E', 'P', 'R',
            'O', 'M', '_', 'T',
            'e', 's', 't', '_',
            'o', 'f', 'f', 'l',
            'i', 'n', 'e', '\000'}};
__inline static int qlcnic_82xx_statistics(struct qlcnic_adapter *adapter )
{
  {
  return ((int )((unsigned int )adapter->drv_tx_rings * 5U + 62U));
}
}
__inline static int qlcnic_83xx_statistics(struct qlcnic_adapter *adapter )
{
  {
  return ((int )((unsigned int )adapter->drv_tx_rings * 5U + 84U));
}
}
static int qlcnic_dev_statistics_len(struct qlcnic_adapter *adapter )
{
  int len ;
  bool tmp ;
  bool tmp___0 ;
  {
  len = -1;
  tmp___0 = qlcnic_82xx_check(adapter);
  if ((int )tmp___0) {
    len = qlcnic_82xx_statistics(adapter);
    if ((adapter->flags & 64U) != 0U) {
      len = (int )((unsigned int )len + 14U);
    } else {
    }
  } else {
    tmp = qlcnic_83xx_check(adapter);
    if ((int )tmp) {
      len = qlcnic_83xx_statistics(adapter);
    } else {
    }
  }
  return (len);
}
}
static u32 const diag_registers[13U] =
  { 16U, 17U, 4U, 5U,
        6U, 7U, 8U, 9U,
        10U, 2U, 0U, 1U,
        4294967295U};
static u32 const ext_diag_registers[7U] = { 136323736U, 101785708U, 118489148U, 119537724U,
        120586300U, 116391996U, 4294967295U};
__inline static int qlcnic_get_ring_regs_len(struct qlcnic_adapter *adapter )
{
  int ring_regs_cnt ;
  {
  ring_regs_cnt = (((int )adapter->drv_tx_rings * 5 + (int )adapter->max_rds_rings * 2) + (int )adapter->drv_sds_rings * 3) + 5;
  return ((int )((unsigned int )ring_regs_cnt * 4U));
}
}
static int qlcnic_get_regs_len(struct net_device *dev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u32 len ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    tmp___0 = qlcnic_83xx_get_regs_len(adapter);
    len = (u32 )tmp___0;
  } else {
    len = 80U;
  }
  len = len + 16U;
  tmp___2 = qlcnic_get_ring_regs_len(adapter);
  len = (u32 )tmp___2 + len;
  return ((int )len);
}
}
static int qlcnic_get_eeprom_len(struct net_device *dev )
{
  {
  return (4194304);
}
}
static void qlcnic_get_drvinfo(struct net_device *dev , struct ethtool_drvinfo *drvinfo )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u32 fw_major ;
  u32 fw_minor ;
  u32 fw_build ;
  char const *tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  fw_major = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 11UL));
  fw_minor = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 12UL));
  fw_build = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 13UL));
  snprintf((char *)(& drvinfo->fw_version), 32UL, "%d.%d.%d", fw_major, fw_minor,
           fw_build);
  tmp___0 = pci_name((struct pci_dev const *)adapter->pdev);
  strlcpy((char *)(& drvinfo->bus_info), tmp___0, 32UL);
  strlcpy((char *)(& drvinfo->driver), (char const *)(& qlcnic_driver_name), 32UL);
  strlcpy((char *)(& drvinfo->version), "5.3.60", 32UL);
  return;
}
}
static int qlcnic_82xx_get_settings(struct qlcnic_adapter *adapter , struct ethtool_cmd *ecmd )
{
  struct qlcnic_hardware_context *ahw ;
  u32 speed ;
  u32 reg ;
  int check_sfp_module ;
  int err ;
  u16 pcifn ;
  u32 val ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  ahw = adapter->ahw;
  check_sfp_module = 0;
  err = 0;
  pcifn = (u16 )ahw->pci_func;
  if ((unsigned int )(adapter->ahw)->port_type == 1U) {
    ecmd->supported = 63U;
    ecmd->advertising = 60U;
    ethtool_cmd_speed_set(ecmd, (__u32 )(adapter->ahw)->link_speed);
    ecmd->duplex = (__u8 )(adapter->ahw)->link_duplex;
    ecmd->autoneg = (__u8 )(adapter->ahw)->link_autoneg;
  } else
  if ((unsigned int )(adapter->ahw)->port_type == 2U) {
    val = 0U;
    tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323108UL, & err);
    val = (u32 )tmp;
    if (val == 3U) {
      ecmd->supported = 32U;
      ecmd->advertising = 32U;
    } else {
      ecmd->supported = 4096U;
      ecmd->advertising = 4096U;
    }
    tmp___1 = netif_running((struct net_device const *)adapter->netdev);
    if ((int )tmp___1 && (unsigned int )ahw->has_link_events != 0U) {
      if ((unsigned int )ahw->linkup != 0U) {
        tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (unsigned long )((int )((unsigned int )pcifn / 4U) * 4) + 136323816UL,
                                                          & err);
        reg = (u32 )tmp___0;
        speed = (reg >> ((int )pcifn & 3) * 8) & 255U;
        ahw->link_speed = (unsigned int )((u16 )speed) * 100U;
      } else {
      }
      ethtool_cmd_speed_set(ecmd, (__u32 )ahw->link_speed);
      ecmd->autoneg = (__u8 )ahw->link_autoneg;
      ecmd->duplex = (__u8 )ahw->link_duplex;
      goto skip;
    } else {
    }
    ethtool_cmd_speed_set(ecmd, 4294967295U);
    ecmd->duplex = 255U;
    ecmd->autoneg = 0U;
  } else {
    return (-5);
  }
  skip:
  ecmd->phy_address = (adapter->ahw)->physical_port;
  ecmd->transceiver = 1U;
  switch ((int )(adapter->ahw)->board_type) {
  case 33: ;
  case 36: ;
  case 41:
  ecmd->supported = ecmd->supported | 64U;
  ecmd->advertising = ecmd->advertising | 64U;
  case 49: ;
  case 35: ;
  case 39:
  ecmd->supported = ecmd->supported | 128U;
  ecmd->advertising = ecmd->advertising | 128U;
  ecmd->port = 0U;
  ecmd->autoneg = (__u8 )(adapter->ahw)->link_autoneg;
  goto ldv_50917;
  case 37: ;
  case 40: ;
  case 34:
  ecmd->supported = ecmd->supported | 512U;
  ecmd->advertising = ecmd->advertising | 512U;
  ecmd->port = 2U;
  ecmd->autoneg = 0U;
  goto ldv_50917;
  case 38: ;
  case 42: ;
  case 43:
  ecmd->advertising = ecmd->advertising | 128U;
  ecmd->supported = ecmd->supported | 128U;
  tmp___2 = netif_running((struct net_device const *)adapter->netdev);
  check_sfp_module = (int )tmp___2 && (unsigned int )ahw->has_link_events != 0U;
  case 50:
  ecmd->supported = ecmd->supported | 1024U;
  ecmd->advertising = ecmd->advertising | 1024U;
  ecmd->port = 3U;
  ecmd->autoneg = 0U;
  goto ldv_50917;
  case 128: ;
  if ((unsigned int )(adapter->ahw)->port_type == 2U) {
    ecmd->autoneg = 0U;
    ecmd->supported = ecmd->supported | 1152U;
    ecmd->advertising = ecmd->advertising | 1152U;
    ecmd->port = 3U;
    tmp___3 = netif_running((struct net_device const *)adapter->netdev);
    check_sfp_module = (int )tmp___3 && (unsigned int )ahw->has_link_events != 0U;
  } else {
    ecmd->autoneg = 1U;
    ecmd->supported = ecmd->supported | 192U;
    ecmd->advertising = ecmd->advertising | 192U;
    ecmd->port = 0U;
  }
  goto ldv_50917;
  default:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Unsupported board model %d\n",
          (int )(adapter->ahw)->board_type);
  return (-5);
  }
  ldv_50917: ;
  if (check_sfp_module != 0) {
    switch ((int )(adapter->ahw)->module_type) {
    case 2: ;
    case 3: ;
    case 4: ;
    case 5:
    ecmd->port = 3U;
    goto ldv_50931;
    case 6: ;
    case 7: ;
    case 8:
    ecmd->port = 0U;
    goto ldv_50931;
    default:
    ecmd->port = 255U;
    }
    ldv_50931: ;
  } else {
  }
  return (0);
}
}
static int qlcnic_get_settings(struct net_device *dev , struct ethtool_cmd *ecmd )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___3 = qlcnic_82xx_check(adapter);
  if ((int )tmp___3) {
    tmp___0 = qlcnic_82xx_get_settings(adapter, ecmd);
    return (tmp___0);
  } else {
    tmp___2 = qlcnic_83xx_check(adapter);
    if ((int )tmp___2) {
      tmp___1 = qlcnic_83xx_get_settings(adapter, ecmd);
      return (tmp___1);
    } else {
    }
  }
  return (-5);
}
}
static int qlcnic_set_port_config(struct qlcnic_adapter *adapter , struct ethtool_cmd *ecmd )
{
  u32 ret ;
  u32 config ;
  __u32 tmp ;
  int tmp___0 ;
  {
  ret = 0U;
  config = 0U;
  if ((unsigned int )ecmd->duplex != 0U) {
    config = config | 1U;
  } else {
  }
  if ((unsigned int )ecmd->autoneg != 0U) {
    config = config | 2U;
  } else {
  }
  tmp = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
  switch (tmp) {
  case 10U:
  config = config;
  goto ldv_50948;
  case 100U:
  config = config | 256U;
  goto ldv_50948;
  case 1000U:
  config = config | 2560U;
  goto ldv_50948;
  default: ;
  return (-5);
  }
  ldv_50948:
  tmp___0 = qlcnic_fw_cmd_set_port(adapter, config);
  ret = (u32 )tmp___0;
  if (ret == 9U) {
    return (-95);
  } else
  if (ret != 0U) {
    return (-5);
  } else {
  }
  return ((int )ret);
}
}
static int qlcnic_set_settings(struct net_device *dev , struct ethtool_cmd *ecmd )
{
  u32 ret ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  __u32 tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  {
  ret = 0U;
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  if ((unsigned int )(adapter->ahw)->port_type != 1U) {
    return (-95);
  } else {
  }
  tmp___2 = qlcnic_83xx_check(adapter);
  if ((int )tmp___2) {
    tmp___0 = qlcnic_83xx_set_settings(adapter, ecmd);
    ret = (u32 )tmp___0;
  } else {
    tmp___1 = qlcnic_set_port_config(adapter, ecmd);
    ret = (u32 )tmp___1;
  }
  if (ret == 0U) {
    return ((int )ret);
  } else {
  }
  tmp___3 = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
  (adapter->ahw)->link_speed = (u16 )tmp___3;
  (adapter->ahw)->link_duplex = (u16 )ecmd->duplex;
  (adapter->ahw)->link_autoneg = (u16 )ecmd->autoneg;
  tmp___4 = netif_running((struct net_device const *)dev);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    return (0);
  } else {
  }
  (*((dev->netdev_ops)->ndo_stop))(dev);
  tmp___6 = (*((dev->netdev_ops)->ndo_open))(dev);
  return (tmp___6);
}
}
static int qlcnic_82xx_get_registers(struct qlcnic_adapter *adapter , u32 *regs_buff )
{
  int i ;
  int j ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  j = 0;
  err = 0;
  i = 3;
  goto ldv_50966;
  ldv_50965:
  *(regs_buff + (unsigned long )i) = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + (unsigned long )diag_registers[j]));
  j = j + 1;
  i = i + 1;
  ldv_50966: ;
  if ((unsigned int )diag_registers[j] != 4294967295U) {
    goto ldv_50965;
  } else {
  }
  j = 0;
  goto ldv_50969;
  ldv_50968:
  tmp = i;
  i = i + 1;
  tmp___0 = j;
  j = j + 1;
  tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )ext_diag_registers[tmp___0],
                                                    & err);
  *(regs_buff + (unsigned long )tmp) = (u32 )tmp___1;
  ldv_50969: ;
  if ((unsigned int )ext_diag_registers[j] != 4294967295U) {
    goto ldv_50968;
  } else {
  }
  return (i);
}
}
static void qlcnic_get_regs(struct net_device *dev , struct ethtool_regs *regs , void *p )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_rds_ring *rds_rings ;
  struct qlcnic_host_tx_ring *tx_ring ;
  u32 *regs_buff ;
  int ring ;
  int i ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  recv_ctx = adapter->recv_ctx;
  regs_buff = (u32 *)p;
  i = 0;
  tmp___0 = qlcnic_get_regs_len(dev);
  memset(p, 0, (size_t )tmp___0);
  regs->version = (__u32 )((((int )(adapter->ahw)->revision_id << 16) | 67108864) | (int )(adapter->pdev)->device);
  *regs_buff = 3405643778U;
  *(regs_buff + 1UL) = 3U;
  if (((adapter->ahw)->capabilities & 8388608U) != 0U) {
    *(regs_buff + 2UL) = (adapter->ahw)->max_vnic_func;
  } else {
  }
  tmp___1 = qlcnic_82xx_check(adapter);
  if ((int )tmp___1) {
    i = qlcnic_82xx_get_registers(adapter, regs_buff);
  } else {
    i = qlcnic_83xx_get_registers(adapter, regs_buff);
  }
  tmp___2 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___2 == 0) {
    return;
  } else {
  }
  tmp___3 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___3) = 4293905835U;
  tmp___4 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___4) = (u32 )adapter->drv_tx_rings;
  ring = 0;
  goto ldv_50985;
  ldv_50984:
  tx_ring = adapter->tx_ring + (unsigned long )ring;
  tmp___5 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___5) = *(tx_ring->hw_consumer);
  tmp___6 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___6) = tx_ring->sw_consumer;
  tmp___7 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___7) = readl((void const volatile *)tx_ring->crb_cmd_producer);
  tmp___8 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___8) = tx_ring->producer;
  if ((unsigned long )tx_ring->crb_intr_mask != (unsigned long )((void *)0)) {
    tmp___9 = i;
    i = i + 1;
    *(regs_buff + (unsigned long )tmp___9) = readl((void const volatile *)tx_ring->crb_intr_mask);
  } else {
    tmp___10 = i;
    i = i + 1;
    *(regs_buff + (unsigned long )tmp___10) = 2018915346U;
  }
  ring = ring + 1;
  ldv_50985: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_50984;
  } else {
  }
  tmp___11 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___11) = (u32 )adapter->max_rds_rings;
  ring = 0;
  goto ldv_50988;
  ldv_50987:
  rds_rings = recv_ctx->rds_rings + (unsigned long )ring;
  tmp___12 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___12) = readl((void const volatile *)rds_rings->crb_rcv_producer);
  tmp___13 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___13) = rds_rings->producer;
  ring = ring + 1;
  ldv_50988: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_50987;
  } else {
  }
  tmp___14 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___14) = (u32 )adapter->drv_sds_rings;
  ring = 0;
  goto ldv_50991;
  ldv_50990:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  tmp___15 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___15) = readl((void const volatile *)sds_ring->crb_sts_consumer);
  tmp___16 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___16) = sds_ring->consumer;
  tmp___17 = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp___17) = readl((void const volatile *)sds_ring->crb_intr_mask);
  ring = ring + 1;
  ldv_50991: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_50990;
  } else {
  }
  return;
}
}
static u32 qlcnic_test_link(struct net_device *dev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  u32 val ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = 0;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    tmp___0 = qlcnic_83xx_test_link(adapter);
    val = (u32 )tmp___0;
    return ((int )val & 1 ? 0U : 1U);
  } else {
  }
  tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323736UL, & err);
  val = (u32 )tmp___2;
  if (err == -5) {
    return ((u32 )err);
  } else {
  }
  val = (val >> (int )(adapter->ahw)->pci_func * 4) & 15U;
  return (val != 1U);
}
}
static int qlcnic_get_eeprom(struct net_device *dev , struct ethtool_eeprom *eeprom ,
                             u8 *bytes )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int offset ;
  int ret ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  ret = -1;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    return (0);
  } else {
  }
  if (eeprom->len == 0U) {
    return (-22);
  } else {
  }
  eeprom->magic = (__u32 )((int )(adapter->pdev)->vendor | ((int )(adapter->pdev)->device << 16));
  offset = (int )eeprom->offset;
  tmp___1 = qlcnic_82xx_check(adapter);
  if ((int )tmp___1) {
    ret = qlcnic_rom_fast_read_words(adapter, offset, bytes, (size_t )eeprom->len);
  } else {
  }
  if (ret < 0) {
    return (ret);
  } else {
  }
  return (0);
}
}
static void qlcnic_get_ringparam(struct net_device *dev , struct ethtool_ringparam *ring )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  ring->rx_pending = (__u32 )adapter->num_rxd;
  ring->rx_jumbo_pending = (__u32 )adapter->num_jumbo_rxd;
  ring->tx_pending = (__u32 )adapter->num_txd;
  ring->rx_max_pending = (__u32 )adapter->max_rxd;
  ring->rx_jumbo_max_pending = (__u32 )adapter->max_jumbo_rxd;
  ring->tx_max_pending = 1024U;
  return;
}
}
static u32 qlcnic_validate_ringparam(u32 val , u32 min , u32 max , char *r_name )
{
  u32 num_desc ;
  u32 _max1 ;
  u32 _max2 ;
  u32 _min1 ;
  u32 _min2 ;
  unsigned long tmp ;
  {
  _max1 = val;
  _max2 = min;
  num_desc = _max1 > _max2 ? _max1 : _max2;
  _min1 = num_desc;
  _min2 = max;
  num_desc = _min1 < _min2 ? _min1 : _min2;
  tmp = __roundup_pow_of_two((unsigned long )num_desc);
  num_desc = (u32 )tmp;
  if (val != num_desc) {
    printk("\016%s: setting %s ring size %d instead of %d\n", (char *)(& qlcnic_driver_name),
           r_name, num_desc, val);
  } else {
  }
  return (num_desc);
}
}
static int qlcnic_set_ringparam(struct net_device *dev , struct ethtool_ringparam *ring )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u16 num_rxd ;
  u16 num_jumbo_rxd ;
  u16 num_txd ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  if (ring->rx_mini_pending != 0U) {
    return (-95);
  } else {
  }
  tmp___0 = qlcnic_validate_ringparam(ring->rx_pending, 64U, (u32 )adapter->max_rxd,
                                      (char *)"rx");
  num_rxd = (u16 )tmp___0;
  tmp___1 = qlcnic_validate_ringparam(ring->rx_jumbo_pending, 32U, (u32 )adapter->max_jumbo_rxd,
                                      (char *)"rx jumbo");
  num_jumbo_rxd = (u16 )tmp___1;
  tmp___2 = qlcnic_validate_ringparam(ring->tx_pending, 64U, 1024U, (char *)"tx");
  num_txd = (u16 )tmp___2;
  if (((int )adapter->num_rxd == (int )num_rxd && (int )adapter->num_txd == (int )num_txd) && (int )adapter->num_jumbo_rxd == (int )num_jumbo_rxd) {
    return (0);
  } else {
  }
  adapter->num_rxd = num_rxd;
  adapter->num_jumbo_rxd = num_jumbo_rxd;
  adapter->num_txd = num_txd;
  tmp___3 = qlcnic_reset_context(adapter);
  return (tmp___3);
}
}
static int qlcnic_validate_ring_count(struct qlcnic_adapter *adapter , u8 rx_ring ,
                                      u8 tx_ring )
{
  {
  if ((unsigned int )rx_ring == 0U || (unsigned int )tx_ring == 0U) {
    return (-22);
  } else {
  }
  if ((unsigned int )rx_ring != 0U) {
    if ((int )adapter->max_sds_rings < (int )rx_ring) {
      netdev_err((struct net_device const *)adapter->netdev, "Invalid ring count, SDS ring count %d should not be greater than max %d driver sds rings.\n",
                 (int )rx_ring, (int )adapter->max_sds_rings);
      return (-22);
    } else {
    }
  } else {
  }
  if ((unsigned int )tx_ring != 0U) {
    if ((int )adapter->max_tx_rings < (int )tx_ring) {
      netdev_err((struct net_device const *)adapter->netdev, "Invalid ring count, Tx ring count %d should not be greater than max %d driver Tx rings.\n",
                 (int )tx_ring, (int )adapter->max_tx_rings);
      return (-22);
    } else {
    }
  } else {
  }
  return (0);
}
}
static void qlcnic_get_channels(struct net_device *dev , struct ethtool_channels *channel )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  channel->max_rx = (__u32 )adapter->max_sds_rings;
  channel->max_tx = (__u32 )adapter->max_tx_rings;
  channel->rx_count = (__u32 )adapter->drv_sds_rings;
  channel->tx_count = (__u32 )adapter->drv_tx_rings;
  return;
}
}
static int qlcnic_set_channels(struct net_device *dev , struct ethtool_channels *channel )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  if ((adapter->flags & 4U) == 0U) {
    netdev_err((struct net_device const *)dev, "No RSS/TSS support in non MSI-X mode\n");
    return (-22);
  } else {
  }
  if (channel->other_count != 0U || channel->combined_count != 0U) {
    return (-22);
  } else {
  }
  err = qlcnic_validate_ring_count(adapter, (int )((u8 )channel->rx_count), (int )((u8 )channel->tx_count));
  if (err != 0) {
    return (err);
  } else {
  }
  if ((__u32 )adapter->drv_sds_rings != channel->rx_count) {
    err = qlcnic_validate_rings(adapter, channel->rx_count, 2);
    if (err != 0) {
      netdev_err((struct net_device const *)dev, "Unable to configure %u SDS rings\n",
                 channel->rx_count);
      return (err);
    } else {
    }
    adapter->drv_rss_rings = (u8 )channel->rx_count;
  } else {
  }
  if ((__u32 )adapter->drv_tx_rings != channel->tx_count) {
    err = qlcnic_validate_rings(adapter, channel->tx_count, 1);
    if (err != 0) {
      netdev_err((struct net_device const *)dev, "Unable to configure %u Tx rings\n",
                 channel->tx_count);
      return (err);
    } else {
    }
    adapter->drv_tss_rings = (u8 )channel->tx_count;
  } else {
  }
  adapter->flags = adapter->flags | 524288U;
  err = qlcnic_setup_rings(adapter);
  netdev_info((struct net_device const *)dev, "Allocated %d SDS rings and %d Tx rings\n",
              (int )adapter->drv_sds_rings, (int )adapter->drv_tx_rings);
  return (err);
}
}
static void qlcnic_get_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *pause )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int port ;
  int err ;
  __u32 val ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  port = (int )(adapter->ahw)->physical_port;
  err = 0;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    qlcnic_83xx_get_pauseparam(adapter, pause);
    return;
  } else {
  }
  if ((unsigned int )(adapter->ahw)->port_type == 1U) {
    if (port < 0 || port > 4) {
      return;
    } else {
    }
    tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (unsigned long )(port * 65536) + 107151360UL,
                                                      & err);
    val = (__u32 )tmp___1;
    if (err == -5) {
      return;
    } else {
    }
    pause->rx_pause = (val >> 5) & 1U;
    tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 106955532UL, & err);
    val = (__u32 )tmp___2;
    if (err == -5) {
      return;
    } else {
    }
    switch (port) {
    case 0:
    pause->tx_pause = (val & 1U) == 0U;
    goto ldv_51058;
    case 1:
    pause->tx_pause = (val & 4U) == 0U;
    goto ldv_51058;
    case 2:
    pause->tx_pause = (val & 16U) == 0U;
    goto ldv_51058;
    case 3: ;
    default:
    pause->tx_pause = (val & 64U) == 0U;
    goto ldv_51058;
    }
    ldv_51058: ;
  } else
  if ((unsigned int )(adapter->ahw)->port_type == 2U) {
    if (port < 0 || port > 2) {
      return;
    } else {
    }
    pause->rx_pause = 1U;
    tmp___3 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 106954904UL, & err);
    val = (__u32 )tmp___3;
    if (err == -5) {
      return;
    } else {
    }
    if (port == 0) {
      pause->tx_pause = (val & 1U) == 0U;
    } else {
      pause->tx_pause = (val & 8U) == 0U;
    }
  } else {
    dev_err((struct device const *)(& netdev->dev), "Unknown board type: %x\n",
            (int )(adapter->ahw)->port_type);
  }
  return;
}
}
static int qlcnic_set_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *pause )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int port ;
  int err ;
  __u32 val ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  port = (int )(adapter->ahw)->physical_port;
  err = 0;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    tmp___0 = qlcnic_83xx_set_pauseparam(adapter, pause);
    return (tmp___0);
  } else {
  }
  if ((unsigned int )(adapter->ahw)->port_type == 1U) {
    if (port < 0 || port > 4) {
      return (-5);
    } else {
    }
    tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (unsigned long )(port * 65536) + 107151360UL,
                                                      & err);
    val = (__u32 )tmp___2;
    if (err == -5) {
      return (err);
    } else {
    }
    if (pause->rx_pause != 0U) {
      val = val | 32U;
    } else {
      val = val & 4294967263U;
    }
    (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (unsigned long )(port * 65536) + 107151360UL,
                                             val);
    (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (unsigned long )(port * 65536) + 107151360UL,
                                             val);
    tmp___3 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 106955532UL, & err);
    val = (__u32 )tmp___3;
    if (err == -5) {
      return (err);
    } else {
    }
    switch (port) {
    case 0: ;
    if (pause->tx_pause != 0U) {
      val = val & 4294967294U;
    } else {
      val = val | 1U;
    }
    goto ldv_51072;
    case 1: ;
    if (pause->tx_pause != 0U) {
      val = val & 4294967291U;
    } else {
      val = val | 4U;
    }
    goto ldv_51072;
    case 2: ;
    if (pause->tx_pause != 0U) {
      val = val & 4294967279U;
    } else {
      val = val | 16U;
    }
    goto ldv_51072;
    case 3: ;
    default: ;
    if (pause->tx_pause != 0U) {
      val = val & 4294967231U;
    } else {
      val = val | 64U;
    }
    goto ldv_51072;
    }
    ldv_51072:
    (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 106955532UL, val);
  } else
  if ((unsigned int )(adapter->ahw)->port_type == 2U) {
    if (pause->rx_pause == 0U || pause->autoneg != 0U) {
      return (-95);
    } else {
    }
    if (port < 0 || port > 2) {
      return (-5);
    } else {
    }
    tmp___4 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 106954904UL, & err);
    val = (__u32 )tmp___4;
    if (err == -5) {
      return (err);
    } else {
    }
    if (port == 0) {
      if (pause->tx_pause != 0U) {
        val = val & 4294967294U;
      } else {
        val = val | 1U;
      }
    } else
    if (pause->tx_pause != 0U) {
      val = val & 4294967287U;
    } else {
      val = val | 8U;
    }
    (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 106954904UL, val);
  } else {
    dev_err((struct device const *)(& netdev->dev), "Unknown board type: %x\n",
            (int )(adapter->ahw)->port_type);
  }
  return (0);
}
}
static int qlcnic_reg_test(struct net_device *dev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u32 data_read ;
  int err ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = 0;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    tmp___0 = qlcnic_83xx_reg_test(adapter);
    return (tmp___0);
  } else {
  }
  tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 101711872UL, & err);
  data_read = (u32 )tmp___2;
  if (err == -5) {
    return (err);
  } else {
  }
  if ((data_read & 65535U) != (u32 )(adapter->pdev)->vendor) {
    return (1);
  } else {
  }
  return (0);
}
}
static int qlcnic_eeprom_test(struct net_device *dev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_82xx_check(adapter);
  if ((int )tmp___0) {
    return (0);
  } else {
  }
  tmp___1 = qlcnic_83xx_flash_test(adapter);
  return (tmp___1);
}
}
static int qlcnic_get_sset_count(struct net_device *dev , int sset )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  switch (sset) {
  case 0: ;
  return (6);
  case 1:
  tmp___0 = qlcnic_dev_statistics_len(adapter);
  return (tmp___0);
  default: ;
  return (-95);
  }
}
}
static int qlcnic_irq_test(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_cmd_args cmd ;
  int ret ;
  int drv_sds_rings ;
  int drv_tx_rings ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  drv_sds_rings = (int )adapter->drv_sds_rings;
  drv_tx_rings = (int )adapter->drv_tx_rings;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    tmp___0 = qlcnic_83xx_interrupt_test(netdev);
    return (tmp___0);
  } else {
  }
  tmp___2 = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp___2 != 0) {
    return (-5);
  } else {
  }
  ret = qlcnic_diag_alloc_res(netdev, 1);
  if (ret != 0) {
    goto clear_diag_irq;
  } else {
  }
  ahw->diag_cnt = 0;
  ret = qlcnic_alloc_mbx_args(& cmd, adapter, 17U);
  if (ret != 0) {
    goto free_diag_res;
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )ahw->pci_func;
  ret = qlcnic_issue_cmd(adapter, & cmd);
  if (ret != 0) {
    goto done;
  } else {
  }
  usleep_range(1000UL, 12000UL);
  ret = ahw->diag_cnt == 0;
  done:
  qlcnic_free_mbx_args(& cmd);
  free_diag_res:
  qlcnic_diag_free_res(netdev, drv_sds_rings);
  clear_diag_irq:
  adapter->drv_sds_rings = (u8 )drv_sds_rings;
  adapter->drv_tx_rings = (u8 )drv_tx_rings;
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (ret);
}
}
static void qlcnic_create_loopback_buff(unsigned char *data , u8 *mac )
{
  unsigned char random_data[4U] ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  random_data[0] = 168U;
  random_data[1] = 6U;
  random_data[2] = 69U;
  random_data[3] = 0U;
  memset((void *)data, 78, 64UL);
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)data, (void const *)mac, __len);
  } else {
    __ret = memcpy((void *)data, (void const *)mac, __len);
  }
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)data + 6U, (void const *)mac, __len___0);
  } else {
    __ret___0 = memcpy((void *)data + 6U, (void const *)mac, __len___0);
  }
  __len___1 = 4UL;
  if (__len___1 > 63UL) {
    __ret___1 = memcpy((void *)data + 12U, (void const *)(& random_data), __len___1);
  } else {
    __ret___1 = memcpy((void *)data + 12U, (void const *)(& random_data),
                                 __len___1);
  }
  return;
}
}
int qlcnic_check_loopback_buff(unsigned char *data , u8 *mac )
{
  unsigned char buff[64U] ;
  int tmp ;
  {
  qlcnic_create_loopback_buff((unsigned char *)(& buff), mac);
  tmp = memcmp((void const *)data, (void const *)(& buff), 64UL);
  return (tmp);
}
}
int qlcnic_do_lb_test(struct qlcnic_adapter *adapter , u8 mode )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct sk_buff *skb ;
  int i ;
  int loop ;
  int cnt ;
  int tmp ;
  {
  recv_ctx = adapter->recv_ctx;
  sds_ring = recv_ctx->sds_rings;
  cnt = 0;
  i = 0;
  goto ldv_51141;
  ldv_51140:
  skb = netdev_alloc_skb(adapter->netdev, 64U);
  qlcnic_create_loopback_buff(skb->data, (u8 *)(& adapter->mac_addr));
  skb_put(skb, 64U);
  (adapter->ahw)->diag_cnt = 0;
  qlcnic_xmit_frame(skb, adapter->netdev);
  loop = 0;
  ldv_51139:
  msleep(1U);
  qlcnic_process_rcv_ring_diag(sds_ring);
  tmp = loop;
  loop = loop + 1;
  if (tmp > 20) {
    goto ldv_51138;
  } else {
  }
  if ((adapter->ahw)->diag_cnt == 0) {
    goto ldv_51139;
  } else {
  }
  ldv_51138:
  dev_kfree_skb_any(skb);
  if ((adapter->ahw)->diag_cnt == 0) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "LB Test: packet #%d was not received\n",
             i + 1);
  } else {
    cnt = cnt + 1;
  }
  i = i + 1;
  ldv_51141: ;
  if (i <= 15) {
    goto ldv_51140;
  } else {
  }
  if (cnt != i) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "LB Test: failed, TX[%d], RX[%d]\n",
            i, cnt);
    if ((unsigned int )mode != 1U) {
      dev_warn((struct device const *)(& (adapter->pdev)->dev), "WARNING: Please check loopback cable\n");
    } else {
    }
    return (-1);
  } else {
  }
  return (0);
}
}
static int qlcnic_loopback_test(struct net_device *netdev , u8 mode )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int drv_tx_rings ;
  int drv_sds_rings ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_hardware_context *ahw ;
  int loop ;
  int ret ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  drv_tx_rings = (int )adapter->drv_tx_rings;
  drv_sds_rings = (int )adapter->drv_sds_rings;
  ahw = adapter->ahw;
  loop = 0;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    tmp___0 = qlcnic_83xx_loopback_test(netdev, (int )mode);
    return (tmp___0);
  } else {
  }
  if ((ahw->capabilities & 134217728U) == 0U) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Firmware do not support loopback test\n");
    return (-95);
  } else {
  }
  dev_warn((struct device const *)(& (adapter->pdev)->dev), "%s loopback test in progress\n",
           (unsigned int )mode == 1U ? (char *)"internal" : (char *)"external");
  if ((unsigned int )ahw->op_mode == 2U) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "Loopback test not supported in nonprivileged mode\n");
    return (0);
  } else {
  }
  tmp___2 = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp___2 != 0) {
    return (-16);
  } else {
  }
  ret = qlcnic_diag_alloc_res(netdev, 2);
  if (ret != 0) {
    goto clear_it;
  } else {
  }
  sds_ring = (adapter->recv_ctx)->sds_rings;
  ret = qlcnic_set_lb_mode(adapter, (int )mode);
  if (ret != 0) {
    goto free_res;
  } else {
  }
  ahw->diag_cnt = 0;
  ldv_51156:
  msleep(500U);
  qlcnic_process_rcv_ring_diag(sds_ring);
  tmp___3 = loop;
  loop = loop + 1;
  if (tmp___3 > 10) {
    netdev_info((struct net_device const *)netdev, "Firmware didn\'t sent link up event to loopback request\n");
    ret = -110;
    goto free_res;
  } else
  if ((adapter->ahw)->diag_cnt != 0) {
    ret = (adapter->ahw)->diag_cnt;
    goto free_res;
  } else {
  }
  if ((unsigned int )ahw->loopback_state != 3U) {
    goto ldv_51156;
  } else {
  }
  ret = qlcnic_do_lb_test(adapter, (int )mode);
  qlcnic_clear_lb_mode(adapter, (int )mode);
  free_res:
  qlcnic_diag_free_res(netdev, drv_sds_rings);
  clear_it:
  adapter->drv_sds_rings = (u8 )drv_sds_rings;
  adapter->drv_tx_rings = (u8 )drv_tx_rings;
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (ret);
}
}
static void qlcnic_diag_test(struct net_device *dev , struct ethtool_test *eth_test ,
                             u64 *data )
{
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  memset((void *)data, 0, 48UL);
  tmp = qlcnic_reg_test(dev);
  *data = (u64 )tmp;
  if (*data != 0ULL) {
    eth_test->flags = eth_test->flags | 2U;
  } else {
  }
  tmp___0 = qlcnic_test_link(dev);
  *(data + 1UL) = (unsigned long long )tmp___0;
  if (*(data + 1UL) != 0ULL) {
    eth_test->flags = eth_test->flags | 2U;
  } else {
  }
  if ((int )eth_test->flags & 1) {
    tmp___1 = qlcnic_irq_test(dev);
    *(data + 2UL) = (u64 )tmp___1;
    if (*(data + 2UL) != 0ULL) {
      eth_test->flags = eth_test->flags | 2U;
    } else {
    }
    tmp___2 = qlcnic_loopback_test(dev, 1);
    *(data + 3UL) = (u64 )tmp___2;
    if (*(data + 3UL) != 0ULL) {
      eth_test->flags = eth_test->flags | 2U;
    } else {
    }
    if ((eth_test->flags & 4U) != 0U) {
      tmp___3 = qlcnic_loopback_test(dev, 2);
      *(data + 4UL) = (u64 )tmp___3;
      if (*(data + 4UL) != 0ULL) {
        eth_test->flags = eth_test->flags | 2U;
      } else {
      }
      eth_test->flags = eth_test->flags | 8U;
    } else {
    }
    tmp___4 = qlcnic_eeprom_test(dev);
    *(data + 5UL) = (u64 )tmp___4;
    if (*(data + 5UL) != 0ULL) {
      eth_test->flags = eth_test->flags | 2U;
    } else {
    }
  } else {
  }
  return;
}
}
static void qlcnic_get_strings(struct net_device *dev , u32 stringset , u8 *data )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int index ;
  int i ;
  int num_stats ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  bool tmp___0 ;
  size_t __len___5 ;
  void *__ret___5 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  switch (stringset) {
  case 0U:
  __len = 192UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)data, (void const *)(& qlcnic_gstrings_test), __len);
  } else {
    __ret = memcpy((void *)data, (void const *)(& qlcnic_gstrings_test),
                             __len);
  }
  goto ldv_51182;
  case 1U:
  num_stats = 5;
  i = 0;
  goto ldv_51190;
  ldv_51189:
  index = 0;
  goto ldv_51187;
  ldv_51186:
  sprintf((char *)data, "tx_queue_%d %s", i, (char const *)(& qlcnic_tx_queue_stats_strings) + (unsigned long )index);
  data = data + 32UL;
  index = index + 1;
  ldv_51187: ;
  if (index < num_stats) {
    goto ldv_51186;
  } else {
  }
  i = i + 1;
  ldv_51190: ;
  if ((int )adapter->drv_tx_rings > i) {
    goto ldv_51189;
  } else {
  }
  index = 0;
  goto ldv_51198;
  ldv_51197:
  __len___0 = 32UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_gstrings_stats[index].stat_string),
                         __len___0);
  } else {
    __ret___0 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_gstrings_stats[index].stat_string),
                                 __len___0);
  }
  index = index + 1;
  ldv_51198: ;
  if ((unsigned int )index <= 21U) {
    goto ldv_51197;
  } else {
  }
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    num_stats = 5;
    i = 0;
    goto ldv_51206;
    ldv_51205:
    __len___1 = 32UL;
    if (__len___1 > 63UL) {
      __ret___1 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_tx_stats_strings) + (unsigned long )i,
                           __len___1);
    } else {
      __ret___1 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_tx_stats_strings) + (unsigned long )i,
                                   __len___1);
    }
    i = i + 1;
    index = index + 1;
    ldv_51206: ;
    if (i < num_stats) {
      goto ldv_51205;
    } else {
    }
    num_stats = 40;
    i = 0;
    goto ldv_51214;
    ldv_51213:
    __len___2 = 32UL;
    if (__len___2 > 63UL) {
      __ret___2 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_mac_stats_strings) + (unsigned long )i,
                           __len___2);
    } else {
      __ret___2 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_mac_stats_strings) + (unsigned long )i,
                                   __len___2);
    }
    i = i + 1;
    index = index + 1;
    ldv_51214: ;
    if (i < num_stats) {
      goto ldv_51213;
    } else {
    }
    num_stats = 17;
    i = 0;
    goto ldv_51222;
    ldv_51221:
    __len___3 = 32UL;
    if (__len___3 > 63UL) {
      __ret___3 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_rx_stats_strings) + (unsigned long )i,
                           __len___3);
    } else {
      __ret___3 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_rx_stats_strings) + (unsigned long )i,
                                   __len___3);
    }
    i = i + 1;
    index = index + 1;
    ldv_51222: ;
    if (i < num_stats) {
      goto ldv_51221;
    } else {
    }
    return;
  } else {
    num_stats = 40;
    i = 0;
    goto ldv_51230;
    ldv_51229:
    __len___4 = 32UL;
    if (__len___4 > 63UL) {
      __ret___4 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_mac_stats_strings) + (unsigned long )i,
                           __len___4);
    } else {
      __ret___4 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_83xx_mac_stats_strings) + (unsigned long )i,
                                   __len___4);
    }
    i = i + 1;
    index = index + 1;
    ldv_51230: ;
    if (i < num_stats) {
      goto ldv_51229;
    } else {
    }
  }
  if ((adapter->flags & 64U) == 0U) {
    return;
  } else {
  }
  num_stats = 14;
  i = 0;
  goto ldv_51238;
  ldv_51237:
  __len___5 = 32UL;
  if (__len___5 > 63UL) {
    __ret___5 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_device_gstrings_stats) + (unsigned long )i,
                         __len___5);
  } else {
    __ret___5 = memcpy((void *)data + (unsigned long )(index * 32), (void const *)(& qlcnic_device_gstrings_stats) + (unsigned long )i,
                                 __len___5);
  }
  index = index + 1;
  i = i + 1;
  ldv_51238: ;
  if (i < num_stats) {
    goto ldv_51237;
  } else {
  }
  }
  ldv_51182: ;
  return;
}
}
static u64 *qlcnic_fill_stats(u64 *data , void *stats , int type )
{
  struct qlcnic_mac_statistics *mac_stats ;
  u64 *tmp ;
  u64 *tmp___0 ;
  u64 *tmp___1 ;
  u64 *tmp___2 ;
  u64 *tmp___3 ;
  u64 *tmp___4 ;
  u64 *tmp___5 ;
  u64 *tmp___6 ;
  u64 *tmp___7 ;
  u64 *tmp___8 ;
  u64 *tmp___9 ;
  u64 *tmp___10 ;
  u64 *tmp___11 ;
  u64 *tmp___12 ;
  u64 *tmp___13 ;
  u64 *tmp___14 ;
  u64 *tmp___15 ;
  u64 *tmp___16 ;
  u64 *tmp___17 ;
  u64 *tmp___18 ;
  u64 *tmp___19 ;
  u64 *tmp___20 ;
  u64 *tmp___21 ;
  u64 *tmp___22 ;
  u64 *tmp___23 ;
  u64 *tmp___24 ;
  u64 *tmp___25 ;
  u64 *tmp___26 ;
  u64 *tmp___27 ;
  u64 *tmp___28 ;
  u64 *tmp___29 ;
  u64 *tmp___30 ;
  u64 *tmp___31 ;
  struct __qlcnic_esw_statistics *esw_stats ;
  u64 *tmp___32 ;
  u64 *tmp___33 ;
  u64 *tmp___34 ;
  u64 *tmp___35 ;
  u64 *tmp___36 ;
  u64 *tmp___37 ;
  u64 *tmp___38 ;
  {
  if (type == 1) {
    mac_stats = (struct qlcnic_mac_statistics *)stats;
    tmp = data;
    data = data + 1;
    *tmp = mac_stats->mac_tx_frames != 0xffffffffffffffffULL ? mac_stats->mac_tx_frames : 0ULL;
    tmp___0 = data;
    data = data + 1;
    *tmp___0 = mac_stats->mac_tx_bytes != 0xffffffffffffffffULL ? mac_stats->mac_tx_bytes : 0ULL;
    tmp___1 = data;
    data = data + 1;
    *tmp___1 = mac_stats->mac_tx_mcast_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_mcast_pkts : 0ULL;
    tmp___2 = data;
    data = data + 1;
    *tmp___2 = mac_stats->mac_tx_bcast_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_bcast_pkts : 0ULL;
    tmp___3 = data;
    data = data + 1;
    *tmp___3 = mac_stats->mac_tx_pause_cnt != 0xffffffffffffffffULL ? mac_stats->mac_tx_pause_cnt : 0ULL;
    tmp___4 = data;
    data = data + 1;
    *tmp___4 = mac_stats->mac_tx_ctrl_pkt != 0xffffffffffffffffULL ? mac_stats->mac_tx_ctrl_pkt : 0ULL;
    tmp___5 = data;
    data = data + 1;
    *tmp___5 = mac_stats->mac_tx_lt_64b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_lt_64b_pkts : 0ULL;
    tmp___6 = data;
    data = data + 1;
    *tmp___6 = mac_stats->mac_tx_lt_127b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_lt_127b_pkts : 0ULL;
    tmp___7 = data;
    data = data + 1;
    *tmp___7 = mac_stats->mac_tx_lt_255b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_lt_255b_pkts : 0ULL;
    tmp___8 = data;
    data = data + 1;
    *tmp___8 = mac_stats->mac_tx_lt_511b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_lt_511b_pkts : 0ULL;
    tmp___9 = data;
    data = data + 1;
    *tmp___9 = mac_stats->mac_tx_lt_1023b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_lt_1023b_pkts : 0ULL;
    tmp___10 = data;
    data = data + 1;
    *tmp___10 = mac_stats->mac_tx_lt_1518b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_lt_1518b_pkts : 0ULL;
    tmp___11 = data;
    data = data + 1;
    *tmp___11 = mac_stats->mac_tx_gt_1518b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_tx_gt_1518b_pkts : 0ULL;
    tmp___12 = data;
    data = data + 1;
    *tmp___12 = mac_stats->mac_rx_frames != 0xffffffffffffffffULL ? mac_stats->mac_rx_frames : 0ULL;
    tmp___13 = data;
    data = data + 1;
    *tmp___13 = mac_stats->mac_rx_bytes != 0xffffffffffffffffULL ? mac_stats->mac_rx_bytes : 0ULL;
    tmp___14 = data;
    data = data + 1;
    *tmp___14 = mac_stats->mac_rx_mcast_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_mcast_pkts : 0ULL;
    tmp___15 = data;
    data = data + 1;
    *tmp___15 = mac_stats->mac_rx_bcast_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_bcast_pkts : 0ULL;
    tmp___16 = data;
    data = data + 1;
    *tmp___16 = mac_stats->mac_rx_pause_cnt != 0xffffffffffffffffULL ? mac_stats->mac_rx_pause_cnt : 0ULL;
    tmp___17 = data;
    data = data + 1;
    *tmp___17 = mac_stats->mac_rx_ctrl_pkt != 0xffffffffffffffffULL ? mac_stats->mac_rx_ctrl_pkt : 0ULL;
    tmp___18 = data;
    data = data + 1;
    *tmp___18 = mac_stats->mac_rx_lt_64b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_lt_64b_pkts : 0ULL;
    tmp___19 = data;
    data = data + 1;
    *tmp___19 = mac_stats->mac_rx_lt_127b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_lt_127b_pkts : 0ULL;
    tmp___20 = data;
    data = data + 1;
    *tmp___20 = mac_stats->mac_rx_lt_255b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_lt_255b_pkts : 0ULL;
    tmp___21 = data;
    data = data + 1;
    *tmp___21 = mac_stats->mac_rx_lt_511b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_lt_511b_pkts : 0ULL;
    tmp___22 = data;
    data = data + 1;
    *tmp___22 = mac_stats->mac_rx_lt_1023b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_lt_1023b_pkts : 0ULL;
    tmp___23 = data;
    data = data + 1;
    *tmp___23 = mac_stats->mac_rx_lt_1518b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_lt_1518b_pkts : 0ULL;
    tmp___24 = data;
    data = data + 1;
    *tmp___24 = mac_stats->mac_rx_gt_1518b_pkts != 0xffffffffffffffffULL ? mac_stats->mac_rx_gt_1518b_pkts : 0ULL;
    tmp___25 = data;
    data = data + 1;
    *tmp___25 = mac_stats->mac_rx_length_error != 0xffffffffffffffffULL ? mac_stats->mac_rx_length_error : 0ULL;
    tmp___26 = data;
    data = data + 1;
    *tmp___26 = mac_stats->mac_rx_length_small != 0xffffffffffffffffULL ? mac_stats->mac_rx_length_small : 0ULL;
    tmp___27 = data;
    data = data + 1;
    *tmp___27 = mac_stats->mac_rx_length_large != 0xffffffffffffffffULL ? mac_stats->mac_rx_length_large : 0ULL;
    tmp___28 = data;
    data = data + 1;
    *tmp___28 = mac_stats->mac_rx_jabber != 0xffffffffffffffffULL ? mac_stats->mac_rx_jabber : 0ULL;
    tmp___29 = data;
    data = data + 1;
    *tmp___29 = mac_stats->mac_rx_dropped != 0xffffffffffffffffULL ? mac_stats->mac_rx_dropped : 0ULL;
    tmp___30 = data;
    data = data + 1;
    *tmp___30 = mac_stats->mac_rx_crc_error != 0xffffffffffffffffULL ? mac_stats->mac_rx_crc_error : 0ULL;
    tmp___31 = data;
    data = data + 1;
    *tmp___31 = mac_stats->mac_align_error != 0xffffffffffffffffULL ? mac_stats->mac_align_error : 0ULL;
  } else
  if (type == 2) {
    esw_stats = (struct __qlcnic_esw_statistics *)stats;
    tmp___32 = data;
    data = data + 1;
    *tmp___32 = esw_stats->unicast_frames != 0xffffffffffffffffULL ? esw_stats->unicast_frames : 0ULL;
    tmp___33 = data;
    data = data + 1;
    *tmp___33 = esw_stats->multicast_frames != 0xffffffffffffffffULL ? esw_stats->multicast_frames : 0ULL;
    tmp___34 = data;
    data = data + 1;
    *tmp___34 = esw_stats->broadcast_frames != 0xffffffffffffffffULL ? esw_stats->broadcast_frames : 0ULL;
    tmp___35 = data;
    data = data + 1;
    *tmp___35 = esw_stats->dropped_frames != 0xffffffffffffffffULL ? esw_stats->dropped_frames : 0ULL;
    tmp___36 = data;
    data = data + 1;
    *tmp___36 = esw_stats->errors != 0xffffffffffffffffULL ? esw_stats->errors : 0ULL;
    tmp___37 = data;
    data = data + 1;
    *tmp___37 = esw_stats->local_frames != 0xffffffffffffffffULL ? esw_stats->local_frames : 0ULL;
    tmp___38 = data;
    data = data + 1;
    *tmp___38 = esw_stats->numbytes != 0xffffffffffffffffULL ? esw_stats->numbytes : 0ULL;
  } else {
  }
  return (data);
}
}
void qlcnic_update_stats(struct qlcnic_adapter *adapter )
{
  struct qlcnic_host_tx_ring *tx_ring ;
  int ring ;
  {
  ring = 0;
  goto ldv_51253;
  ldv_51252:
  tx_ring = adapter->tx_ring + (unsigned long )ring;
  adapter->stats.xmit_on = adapter->stats.xmit_on + tx_ring->tx_stats.xmit_on;
  adapter->stats.xmit_off = adapter->stats.xmit_off + tx_ring->tx_stats.xmit_off;
  adapter->stats.xmitcalled = adapter->stats.xmitcalled + tx_ring->tx_stats.xmit_called;
  adapter->stats.xmitfinished = adapter->stats.xmitfinished + tx_ring->tx_stats.xmit_finished;
  adapter->stats.txbytes = adapter->stats.txbytes + tx_ring->tx_stats.tx_bytes;
  ring = ring + 1;
  ldv_51253: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_51252;
  } else {
  }
  return;
}
}
static u64 *qlcnic_fill_tx_queue_stats(u64 *data , void *stats )
{
  struct qlcnic_host_tx_ring *tx_ring ;
  u64 *tmp ;
  u64 *tmp___0 ;
  u64 *tmp___1 ;
  u64 *tmp___2 ;
  u64 *tmp___3 ;
  {
  tx_ring = (struct qlcnic_host_tx_ring *)stats;
  tmp = data;
  data = data + 1;
  *tmp = tx_ring->tx_stats.xmit_on != 0xffffffffffffffffULL ? tx_ring->tx_stats.xmit_on : 0ULL;
  tmp___0 = data;
  data = data + 1;
  *tmp___0 = tx_ring->tx_stats.xmit_off != 0xffffffffffffffffULL ? tx_ring->tx_stats.xmit_off : 0ULL;
  tmp___1 = data;
  data = data + 1;
  *tmp___1 = tx_ring->tx_stats.xmit_called != 0xffffffffffffffffULL ? tx_ring->tx_stats.xmit_called : 0ULL;
  tmp___2 = data;
  data = data + 1;
  *tmp___2 = tx_ring->tx_stats.xmit_finished != 0xffffffffffffffffULL ? tx_ring->tx_stats.xmit_finished : 0ULL;
  tmp___3 = data;
  data = data + 1;
  *tmp___3 = tx_ring->tx_stats.tx_bytes != 0xffffffffffffffffULL ? tx_ring->tx_stats.tx_bytes : 0ULL;
  return (data);
}
}
static void qlcnic_get_ethtool_stats(struct net_device *dev , struct ethtool_stats *stats ,
                                     u64 *data )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_esw_statistics port_stats ;
  struct qlcnic_mac_statistics mac_stats ;
  int index ;
  int ret ;
  int length ;
  int size ;
  int tx_size ;
  int ring ;
  char *p ;
  int tmp___0 ;
  u64 *tmp___1 ;
  bool tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tx_size = (int )((unsigned int )adapter->drv_tx_rings * 5U);
  memset((void *)data, 0, (unsigned long )tx_size * 8UL);
  ring = 0;
  index = 0;
  goto ldv_51279;
  ldv_51278:
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    data = qlcnic_fill_tx_queue_stats(data, (void *)tx_ring);
    qlcnic_update_stats(adapter);
  } else {
  }
  ring = ring + 1;
  ldv_51279: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_51278;
  } else {
  }
  memset((void *)data, 0, (unsigned long )stats->n_stats * 8UL);
  length = 22;
  index = 0;
  goto ldv_51284;
  ldv_51283:
  p = (char *)adapter + (unsigned long )qlcnic_gstrings_stats[index].stat_offset;
  size = qlcnic_gstrings_stats[index].sizeof_stat;
  tmp___1 = data;
  data = data + 1;
  *tmp___1 = size == 8 ? *((u64 *)p) : (u64 )*((u32 *)p);
  index = index + 1;
  ldv_51284: ;
  if (index < length) {
    goto ldv_51283;
  } else {
  }
  tmp___2 = qlcnic_83xx_check(adapter);
  if ((int )tmp___2) {
    if ((unsigned int )(adapter->ahw)->linkup != 0U) {
      qlcnic_83xx_get_stats(adapter, data);
    } else {
    }
    return;
  } else {
    memset((void *)(& mac_stats), 0, 312UL);
    qlcnic_get_mac_stats(adapter, & mac_stats);
    data = qlcnic_fill_stats(data, (void *)(& mac_stats), 1);
  }
  if ((adapter->flags & 64U) == 0U) {
    return;
  } else {
  }
  memset((void *)(& port_stats), 0, 176UL);
  ret = qlcnic_get_port_stats(adapter, (int )(adapter->ahw)->pci_func, 0, & port_stats.rx);
  if (ret != 0) {
    return;
  } else {
  }
  data = qlcnic_fill_stats(data, (void *)(& port_stats.rx), 2);
  ret = qlcnic_get_port_stats(adapter, (int )(adapter->ahw)->pci_func, 1, & port_stats.tx);
  if (ret != 0) {
    return;
  } else {
  }
  qlcnic_fill_stats(data, (void *)(& port_stats.tx), 2);
  return;
}
}
static int qlcnic_set_led(struct net_device *dev , enum ethtool_phys_id_state state )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int drv_sds_rings ;
  int err ;
  int active ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  drv_sds_rings = (int )adapter->drv_sds_rings;
  err = -5;
  active = 1;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    tmp___0 = qlcnic_83xx_set_led(dev, state);
    return (tmp___0);
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode == 2U) {
    netdev_warn((struct net_device const *)dev, "LED test not supported for non privilege function\n");
    return (-95);
  } else {
  }
  switch ((unsigned int )state) {
  case 1U:
  tmp___2 = test_and_set_bit(7L, (unsigned long volatile *)(& adapter->state));
  if (tmp___2 != 0) {
    return (-16);
  } else {
  }
  tmp___3 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___3 != 0) {
    goto ldv_51295;
  } else {
  }
  tmp___5 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___5 == 0) {
    tmp___4 = qlcnic_diag_alloc_res(dev, 3);
    if (tmp___4 != 0) {
      goto ldv_51295;
    } else {
    }
    set_bit(6L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  tmp___6 = (*((adapter->nic_ops)->config_led))(adapter, 1U, 15U);
  if (tmp___6 == 0) {
    err = 0;
    goto ldv_51295;
  } else {
  }
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to set LED blink state.\n");
  goto ldv_51295;
  case 0U:
  active = 0;
  tmp___7 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___7 != 0) {
    goto ldv_51295;
  } else {
  }
  tmp___9 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___9 == 0) {
    tmp___8 = qlcnic_diag_alloc_res(dev, 3);
    if (tmp___8 != 0) {
      goto ldv_51295;
    } else {
    }
    set_bit(6L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  tmp___10 = (*((adapter->nic_ops)->config_led))(adapter, 0U, 15U);
  if (tmp___10 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to reset LED blink state.\n");
  } else {
  }
  goto ldv_51295;
  default: ;
  return (-22);
  }
  ldv_51295:
  tmp___11 = test_and_clear_bit(6L, (unsigned long volatile *)(& adapter->state));
  if (tmp___11 != 0) {
    qlcnic_diag_free_res(dev, drv_sds_rings);
  } else {
  }
  if (active == 0 || err != 0) {
    clear_bit(7L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  return (err);
}
}
static void qlcnic_get_wol(struct net_device *dev , struct ethtool_wolinfo *wol )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u32 wol_cfg ;
  int err ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = 0;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    return;
  } else {
  }
  wol->supported = 0U;
  wol->wolopts = 0U;
  tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323460UL, & err);
  wol_cfg = (u32 )tmp___1;
  if (err == -5) {
    return;
  } else {
  }
  if ((int )((unsigned long )wol_cfg >> (int )adapter->portnum) & 1) {
    wol->supported = wol->supported | 32U;
  } else {
  }
  tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323464UL, & err);
  wol_cfg = (u32 )tmp___2;
  if ((int )((unsigned long )wol_cfg >> (int )adapter->portnum) & 1) {
    wol->wolopts = wol->wolopts | 32U;
  } else {
  }
  return;
}
}
static int qlcnic_set_wol(struct net_device *dev , struct ethtool_wolinfo *wol )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u32 wol_cfg ;
  int err ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = 0;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    return (-95);
  } else {
  }
  if ((wol->wolopts & 4294967263U) != 0U) {
    return (-22);
  } else {
  }
  tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323460UL, & err);
  wol_cfg = (u32 )tmp___1;
  if (err == -5) {
    return (err);
  } else {
  }
  if (((u32 )(1 << (int )adapter->portnum) & wol_cfg) == 0U) {
    return (-95);
  } else {
  }
  tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323464UL, & err);
  wol_cfg = (u32 )tmp___2;
  if (err == -5) {
    return (err);
  } else {
  }
  if ((wol->wolopts & 32U) != 0U) {
    wol_cfg = (u32 )(1UL << (int )adapter->portnum) | wol_cfg;
  } else {
    wol_cfg = ~ ((u32 )(1UL << (int )adapter->portnum)) & wol_cfg;
  }
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 136323464UL, wol_cfg);
  return (0);
}
}
static int qlcnic_set_intr_coalesce(struct net_device *netdev , struct ethtool_coalesce *ethcoal )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    return (-22);
  } else {
  }
  if ((((((((((((((((((((ethcoal->rx_coalesce_usecs > 65535U || ethcoal->rx_max_coalesced_frames > 65535U) || ethcoal->tx_coalesce_usecs > 65535U) || ethcoal->tx_max_coalesced_frames > 65535U) || ethcoal->rx_coalesce_usecs_irq != 0U) || ethcoal->rx_max_coalesced_frames_irq != 0U) || ethcoal->tx_coalesce_usecs_irq != 0U) || ethcoal->tx_max_coalesced_frames_irq != 0U) || ethcoal->stats_block_coalesce_usecs != 0U) || ethcoal->use_adaptive_rx_coalesce != 0U) || ethcoal->use_adaptive_tx_coalesce != 0U) || ethcoal->pkt_rate_low != 0U) || ethcoal->rx_coalesce_usecs_low != 0U) || ethcoal->rx_max_coalesced_frames_low != 0U) || ethcoal->tx_coalesce_usecs_low != 0U) || ethcoal->tx_max_coalesced_frames_low != 0U) || ethcoal->pkt_rate_high != 0U) || ethcoal->rx_coalesce_usecs_high != 0U) || ethcoal->rx_max_coalesced_frames_high != 0U) || ethcoal->tx_coalesce_usecs_high != 0U) || ethcoal->tx_max_coalesced_frames_high != 0U) {
    return (-22);
  } else {
  }
  err = qlcnic_config_intr_coalesce(adapter, ethcoal);
  return (err);
}
}
static int qlcnic_get_intr_coalesce(struct net_device *netdev , struct ethtool_coalesce *ethcoal )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  if ((unsigned int )adapter->is_up != 777U) {
    return (-22);
  } else {
  }
  ethcoal->rx_coalesce_usecs = (__u32 )(adapter->ahw)->coal.rx_time_us;
  ethcoal->rx_max_coalesced_frames = (__u32 )(adapter->ahw)->coal.rx_packets;
  ethcoal->tx_coalesce_usecs = (__u32 )(adapter->ahw)->coal.tx_time_us;
  ethcoal->tx_max_coalesced_frames = (__u32 )(adapter->ahw)->coal.tx_packets;
  return (0);
}
}
static u32 qlcnic_get_msglevel(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  return ((adapter->ahw)->msg_enable);
}
}
static void qlcnic_set_msglevel(struct net_device *netdev , u32 msglvl )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  (adapter->ahw)->msg_enable = msglvl;
  return;
}
}
int qlcnic_enable_fw_dump_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_fw_dump *fw_dump ;
  u32 val ;
  int tmp ;
  bool tmp___0 ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  tmp___0 = qlcnic_84xx_check(adapter);
  if ((int )tmp___0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    val = val & 4294967291U;
    writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    qlcnic_83xx_unlock_driver(adapter);
  } else {
    fw_dump->enable = 1;
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "FW dump enabled\n");
  return (0);
}
}
static int qlcnic_disable_fw_dump_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_fw_dump *fw_dump ;
  u32 val ;
  int tmp ;
  bool tmp___0 ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  tmp___0 = qlcnic_84xx_check(adapter);
  if ((int )tmp___0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    val = val | 4U;
    writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    qlcnic_83xx_unlock_driver(adapter);
  } else {
    fw_dump->enable = 0;
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "FW dump disabled\n");
  return (0);
}
}
bool qlcnic_check_fw_dump_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_fw_dump *fw_dump ;
  bool state ;
  u32 val ;
  bool tmp ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  tmp = qlcnic_84xx_check(adapter);
  if ((int )tmp) {
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    state = (val & 4U) == 0U;
  } else {
    state = fw_dump->enable;
  }
  return (state);
}
}
static int qlcnic_get_dump_flag(struct net_device *netdev , struct ethtool_dump *dump )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_fw_dump *fw_dump ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  fw_dump = & (adapter->ahw)->fw_dump;
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0)) {
    netdev_err((struct net_device const *)adapter->netdev, "FW Dump not supported\n");
    return (-524);
  } else {
  }
  if ((unsigned int )fw_dump->clr != 0U) {
    dump->len = fw_dump->tmpl_hdr_size + fw_dump->size;
  } else {
    dump->len = 0U;
  }
  tmp___0 = qlcnic_check_fw_dump_state(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    dump->flag = 0U;
  } else {
    dump->flag = fw_dump->cap_mask;
  }
  dump->version = adapter->fw_version;
  return (0);
}
}
static int qlcnic_get_dump_data(struct net_device *netdev , struct ethtool_dump *dump ,
                                void *buffer )
{
  int i ;
  int copy_sz ;
  u32 *hdr_ptr ;
  __le32 *data ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_fw_dump *fw_dump ;
  __le32 *tmp___0 ;
  u32 *tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  fw_dump = & (adapter->ahw)->fw_dump;
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0)) {
    netdev_err((struct net_device const *)netdev, "FW Dump not supported\n");
    return (-524);
  } else {
  }
  if ((unsigned int )fw_dump->clr == 0U) {
    netdev_info((struct net_device const *)netdev, "Dump not available\n");
    return (-22);
  } else {
  }
  copy_sz = (int )fw_dump->tmpl_hdr_size;
  hdr_ptr = (u32 *)fw_dump->tmpl_hdr;
  data = (__le32 *)buffer;
  i = 0;
  goto ldv_51366;
  ldv_51365:
  tmp___0 = data;
  data = data + 1;
  tmp___1 = hdr_ptr;
  hdr_ptr = hdr_ptr + 1;
  *tmp___0 = *tmp___1;
  i = i + 1;
  ldv_51366: ;
  if ((unsigned long )i < (unsigned long )copy_sz / 4UL) {
    goto ldv_51365;
  } else {
  }
  __len = (size_t )fw_dump->size;
  __ret = memcpy(buffer + (unsigned long )copy_sz, (void const *)fw_dump->data,
                           __len);
  dump->len = fw_dump->size + (u32 )copy_sz;
  dump->flag = fw_dump->cap_mask;
  vfree((void const *)fw_dump->data);
  fw_dump->data = (void *)0;
  fw_dump->clr = 0U;
  netdev_info((struct net_device const *)netdev, "extracted the FW dump Successfully\n");
  return (0);
}
}
static int qlcnic_set_dump_mask(struct qlcnic_adapter *adapter , u32 mask )
{
  struct qlcnic_fw_dump *fw_dump ;
  struct net_device *netdev ;
  bool tmp ;
  int tmp___0 ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  netdev = adapter->netdev;
  tmp = qlcnic_check_fw_dump_state(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    netdev_info((struct net_device const *)netdev, "Can not change driver mask to 0x%x. FW dump not enabled\n",
                mask);
    return (-95);
  } else {
  }
  fw_dump->cap_mask = mask;
  qlcnic_store_cap_mask(adapter, fw_dump->tmpl_hdr, mask);
  netdev_info((struct net_device const *)netdev, "Driver mask changed to: 0x%x\n",
              mask);
  return (0);
}
}
static int qlcnic_set_dump(struct net_device *netdev , struct ethtool_dump *val )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_fw_dump *fw_dump ;
  bool valid_mask ;
  int i ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  fw_dump = & (adapter->ahw)->fw_dump;
  valid_mask = 0;
  ret = 0;
  switch (val->flag) {
  case 3735944941U: ;
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0)) {
    netdev_err((struct net_device const *)netdev, "FW dump not supported\n");
    ret = -95;
    goto ldv_51387;
  } else {
  }
  tmp___0 = qlcnic_check_fw_dump_state(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    netdev_info((struct net_device const *)netdev, "FW dump not enabled\n");
    ret = -95;
    goto ldv_51387;
  } else {
  }
  if ((unsigned int )fw_dump->clr != 0U) {
    netdev_info((struct net_device const *)netdev, "Previous dump not cleared, not forcing dump\n");
    goto ldv_51387;
  } else {
  }
  netdev_info((struct net_device const *)netdev, "Forcing a FW dump\n");
  qlcnic_dev_request_reset(adapter, val->flag);
  goto ldv_51387;
  case 195952365U: ;
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0)) {
    netdev_err((struct net_device const *)netdev, "FW dump not supported\n");
    ret = -95;
    goto ldv_51387;
  } else {
  }
  ret = qlcnic_disable_fw_dump_state(adapter);
  goto ldv_51387;
  case 182320877U: ;
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0)) {
    netdev_err((struct net_device const *)netdev, "FW dump not supported\n");
    ret = -95;
    goto ldv_51387;
  } else {
  }
  ret = qlcnic_enable_fw_dump_state(adapter);
  goto ldv_51387;
  case 3735936685U:
  netdev_info((struct net_device const *)netdev, "Forcing a FW reset\n");
  qlcnic_dev_request_reset(adapter, val->flag);
  adapter->flags = adapter->flags & 4294959103U;
  goto ldv_51387;
  case 2916089872U: ;
  case 2916089888U:
  tmp___2 = constant_test_bit(16L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___2 != 0) {
    netdev_info((struct net_device const *)netdev, "Device is in non-operational state\n");
  } else {
  }
  goto ldv_51387;
  default: ;
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0)) {
    netdev_err((struct net_device const *)netdev, "FW dump not supported\n");
    ret = -95;
    goto ldv_51387;
  } else {
  }
  i = 0;
  goto ldv_51398;
  ldv_51397: ;
  if (val->flag == (__u32 )qlcnic_fw_dump_level[i]) {
    valid_mask = 1;
    goto ldv_51396;
  } else {
  }
  i = i + 1;
  ldv_51398: ;
  if ((unsigned int )i <= 6U) {
    goto ldv_51397;
  } else {
  }
  ldv_51396: ;
  if ((int )valid_mask) {
    ret = qlcnic_set_dump_mask(adapter, val->flag);
  } else {
    netdev_info((struct net_device const *)netdev, "Invalid dump level: 0x%x\n",
                val->flag);
    ret = -22;
  }
  }
  ldv_51387: ;
  return (ret);
}
}
struct ethtool_ops const qlcnic_ethtool_ops =
     {& qlcnic_get_settings, & qlcnic_set_settings, & qlcnic_get_drvinfo, & qlcnic_get_regs_len,
    & qlcnic_get_regs, & qlcnic_get_wol, & qlcnic_set_wol, & qlcnic_get_msglevel,
    & qlcnic_set_msglevel, 0, & ethtool_op_get_link, & qlcnic_get_eeprom_len, & qlcnic_get_eeprom,
    0, & qlcnic_get_intr_coalesce, & qlcnic_set_intr_coalesce, & qlcnic_get_ringparam,
    & qlcnic_set_ringparam, & qlcnic_get_pauseparam, & qlcnic_set_pauseparam, & qlcnic_diag_test,
    & qlcnic_get_strings, & qlcnic_set_led, & qlcnic_get_ethtool_stats, 0, 0, 0, 0,
    & qlcnic_get_sset_count, 0, 0, 0, 0, 0, 0, 0, 0, & qlcnic_get_channels, & qlcnic_set_channels,
    & qlcnic_get_dump_flag, & qlcnic_get_dump_data, & qlcnic_set_dump, 0, 0, 0, 0,
    0};
struct ethtool_ops const qlcnic_sriov_vf_ethtool_ops =
     {& qlcnic_get_settings, 0, & qlcnic_get_drvinfo, & qlcnic_get_regs_len, & qlcnic_get_regs,
    & qlcnic_get_wol, 0, & qlcnic_get_msglevel, & qlcnic_set_msglevel, 0, & ethtool_op_get_link,
    & qlcnic_get_eeprom_len, & qlcnic_get_eeprom, 0, & qlcnic_get_intr_coalesce, & qlcnic_set_intr_coalesce,
    & qlcnic_get_ringparam, & qlcnic_set_ringparam, & qlcnic_get_pauseparam, 0, 0,
    & qlcnic_get_strings, 0, & qlcnic_get_ethtool_stats, 0, 0, 0, 0, & qlcnic_get_sset_count,
    0, 0, 0, 0, 0, 0, 0, 0, & qlcnic_get_channels, 0, 0, 0, 0, 0, 0, 0, 0, 0};
struct ethtool_ops const qlcnic_ethtool_failed_ops =
     {& qlcnic_get_settings, 0, & qlcnic_get_drvinfo, 0, 0, 0, 0, & qlcnic_get_msglevel,
    & qlcnic_set_msglevel, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & qlcnic_set_dump, 0, 0, 0, 0, 0};
void ldv_initialize_ethtool_ops_22(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(3264UL);
  qlcnic_ethtool_failed_ops_group0 = (struct net_device *)tmp;
  return;
}
}
void ldv_initialize_ethtool_ops_24(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  {
  tmp = ldv_zalloc(36UL);
  qlcnic_ethtool_ops_group4 = (struct ethtool_channels *)tmp;
  tmp___0 = ldv_zalloc(20UL);
  qlcnic_ethtool_ops_group1 = (struct ethtool_wolinfo *)tmp___0;
  tmp___1 = ldv_zalloc(44UL);
  qlcnic_ethtool_ops_group0 = (struct ethtool_cmd *)tmp___1;
  tmp___2 = ldv_zalloc(92UL);
  qlcnic_ethtool_ops_group2 = (struct ethtool_coalesce *)tmp___2;
  tmp___3 = ldv_zalloc(36UL);
  qlcnic_ethtool_ops_group5 = (struct ethtool_ringparam *)tmp___3;
  tmp___4 = ldv_zalloc(16UL);
  qlcnic_ethtool_ops_group6 = (struct ethtool_dump *)tmp___4;
  tmp___5 = ldv_zalloc(16UL);
  qlcnic_ethtool_ops_group3 = (struct ethtool_pauseparam *)tmp___5;
  tmp___6 = ldv_zalloc(3264UL);
  qlcnic_ethtool_ops_group7 = (struct net_device *)tmp___6;
  return;
}
}
void ldv_initialize_ethtool_ops_23(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(92UL);
  qlcnic_sriov_vf_ethtool_ops_group0 = (struct ethtool_coalesce *)tmp;
  tmp___0 = ldv_zalloc(36UL);
  qlcnic_sriov_vf_ethtool_ops_group1 = (struct ethtool_ringparam *)tmp___0;
  tmp___1 = ldv_zalloc(3264UL);
  qlcnic_sriov_vf_ethtool_ops_group2 = (struct net_device *)tmp___1;
  return;
}
}
void ldv_main_exported_22(void)
{
  struct ethtool_cmd *ldvarg158 ;
  void *tmp ;
  u32 ldvarg157 ;
  u32 tmp___0 ;
  struct ethtool_dump *ldvarg159 ;
  void *tmp___1 ;
  struct ethtool_drvinfo *ldvarg156 ;
  void *tmp___2 ;
  int tmp___3 ;
  {
  tmp = ldv_zalloc(44UL);
  ldvarg158 = (struct ethtool_cmd *)tmp;
  tmp___0 = __VERIFIER_nondet_u32();
  ldvarg157 = tmp___0;
  tmp___1 = ldv_zalloc(16UL);
  ldvarg159 = (struct ethtool_dump *)tmp___1;
  tmp___2 = ldv_zalloc(196UL);
  ldvarg156 = (struct ethtool_drvinfo *)tmp___2;
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_22 == 1) {
    qlcnic_set_dump(qlcnic_ethtool_failed_ops_group0, ldvarg159);
    ldv_state_variable_22 = 1;
  } else {
  }
  goto ldv_51419;
  case 1: ;
  if (ldv_state_variable_22 == 1) {
    qlcnic_get_settings(qlcnic_ethtool_failed_ops_group0, ldvarg158);
    ldv_state_variable_22 = 1;
  } else {
  }
  goto ldv_51419;
  case 2: ;
  if (ldv_state_variable_22 == 1) {
    qlcnic_set_msglevel(qlcnic_ethtool_failed_ops_group0, ldvarg157);
    ldv_state_variable_22 = 1;
  } else {
  }
  goto ldv_51419;
  case 3: ;
  if (ldv_state_variable_22 == 1) {
    qlcnic_get_drvinfo(qlcnic_ethtool_failed_ops_group0, ldvarg156);
    ldv_state_variable_22 = 1;
  } else {
  }
  goto ldv_51419;
  case 4: ;
  if (ldv_state_variable_22 == 1) {
    qlcnic_get_msglevel(qlcnic_ethtool_failed_ops_group0);
    ldv_state_variable_22 = 1;
  } else {
  }
  goto ldv_51419;
  default:
  ldv_stop();
  }
  ldv_51419: ;
  return;
}
}
void ldv_main_exported_24(void)
{
  struct ethtool_regs *ldvarg125 ;
  void *tmp ;
  u32 ldvarg130 ;
  u32 tmp___0 ;
  enum ethtool_phys_id_state ldvarg135 ;
  u8 *ldvarg129 ;
  void *tmp___1 ;
  void *ldvarg123 ;
  void *tmp___2 ;
  u64 *ldvarg126 ;
  void *tmp___3 ;
  struct ethtool_test *ldvarg132 ;
  void *tmp___4 ;
  struct ethtool_drvinfo *ldvarg128 ;
  void *tmp___5 ;
  u32 ldvarg133 ;
  u32 tmp___6 ;
  struct ethtool_eeprom *ldvarg122 ;
  void *tmp___7 ;
  void *ldvarg124 ;
  void *tmp___8 ;
  int ldvarg134 ;
  int tmp___9 ;
  struct ethtool_stats *ldvarg127 ;
  void *tmp___10 ;
  u64 *ldvarg131 ;
  void *tmp___11 ;
  u8 *ldvarg121 ;
  void *tmp___12 ;
  int tmp___13 ;
  {
  tmp = ldv_zalloc(12UL);
  ldvarg125 = (struct ethtool_regs *)tmp;
  tmp___0 = __VERIFIER_nondet_u32();
  ldvarg130 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg129 = (u8 *)tmp___1;
  tmp___2 = ldv_zalloc(1UL);
  ldvarg123 = tmp___2;
  tmp___3 = ldv_zalloc(8UL);
  ldvarg126 = (u64 *)tmp___3;
  tmp___4 = ldv_zalloc(16UL);
  ldvarg132 = (struct ethtool_test *)tmp___4;
  tmp___5 = ldv_zalloc(196UL);
  ldvarg128 = (struct ethtool_drvinfo *)tmp___5;
  tmp___6 = __VERIFIER_nondet_u32();
  ldvarg133 = tmp___6;
  tmp___7 = ldv_zalloc(16UL);
  ldvarg122 = (struct ethtool_eeprom *)tmp___7;
  tmp___8 = ldv_zalloc(1UL);
  ldvarg124 = tmp___8;
  tmp___9 = __VERIFIER_nondet_int();
  ldvarg134 = tmp___9;
  tmp___10 = ldv_zalloc(8UL);
  ldvarg127 = (struct ethtool_stats *)tmp___10;
  tmp___11 = ldv_zalloc(8UL);
  ldvarg131 = (u64 *)tmp___11;
  tmp___12 = ldv_zalloc(1UL);
  ldvarg121 = (u8 *)tmp___12;
  memset((void *)(& ldvarg135), 0, 4UL);
  tmp___13 = __VERIFIER_nondet_int();
  switch (tmp___13) {
  case 0: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_dump(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group6);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 1: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_ringparam(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group5);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 2: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_led(qlcnic_ethtool_ops_group7, ldvarg135);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 3: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_pauseparam(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group3);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 4: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_channels(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group4);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 5: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_sset_count(qlcnic_ethtool_ops_group7, ldvarg134);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 6: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_settings(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group0);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 7: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_intr_coalesce(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group2);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 8: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_msglevel(qlcnic_ethtool_ops_group7, ldvarg133);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 9: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_eeprom_len(qlcnic_ethtool_ops_group7);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 10: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_diag_test(qlcnic_ethtool_ops_group7, ldvarg132, ldvarg131);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 11: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_strings(qlcnic_ethtool_ops_group7, ldvarg130, ldvarg129);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 12: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_channels(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group4);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 13: ;
  if (ldv_state_variable_24 == 1) {
    ethtool_op_get_link(qlcnic_ethtool_ops_group7);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 14: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_drvinfo(qlcnic_ethtool_ops_group7, ldvarg128);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 15: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_pauseparam(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group3);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 16: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_ethtool_stats(qlcnic_ethtool_ops_group7, ldvarg127, ldvarg126);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 17: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_intr_coalesce(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group2);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 18: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_regs(qlcnic_ethtool_ops_group7, ldvarg125, ldvarg124);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 19: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_wol(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group1);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 20: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_settings(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group0);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 21: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_dump_data(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group6, ldvarg123);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 22: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_eeprom(qlcnic_ethtool_ops_group7, ldvarg122, ldvarg121);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 23: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_wol(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group1);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 24: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_dump_flag(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group6);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 25: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_msglevel(qlcnic_ethtool_ops_group7);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 26: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_get_regs_len(qlcnic_ethtool_ops_group7);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  case 27: ;
  if (ldv_state_variable_24 == 1) {
    qlcnic_set_ringparam(qlcnic_ethtool_ops_group7, qlcnic_ethtool_ops_group5);
    ldv_state_variable_24 = 1;
  } else {
  }
  goto ldv_51444;
  default:
  ldv_stop();
  }
  ldv_51444: ;
  return;
}
}
void ldv_main_exported_23(void)
{
  void *ldvarg169 ;
  void *tmp ;
  struct ethtool_wolinfo *ldvarg166 ;
  void *tmp___0 ;
  struct ethtool_eeprom *ldvarg168 ;
  void *tmp___1 ;
  struct ethtool_channels *ldvarg174 ;
  void *tmp___2 ;
  u64 *ldvarg171 ;
  void *tmp___3 ;
  struct ethtool_regs *ldvarg170 ;
  void *tmp___4 ;
  struct ethtool_pauseparam *ldvarg180 ;
  void *tmp___5 ;
  u32 ldvarg177 ;
  u32 tmp___6 ;
  int ldvarg179 ;
  int tmp___7 ;
  struct ethtool_stats *ldvarg172 ;
  void *tmp___8 ;
  struct ethtool_drvinfo *ldvarg173 ;
  void *tmp___9 ;
  struct ethtool_cmd *ldvarg178 ;
  void *tmp___10 ;
  u32 ldvarg176 ;
  u32 tmp___11 ;
  u8 *ldvarg175 ;
  void *tmp___12 ;
  u8 *ldvarg167 ;
  void *tmp___13 ;
  int tmp___14 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg169 = tmp;
  tmp___0 = ldv_zalloc(20UL);
  ldvarg166 = (struct ethtool_wolinfo *)tmp___0;
  tmp___1 = ldv_zalloc(16UL);
  ldvarg168 = (struct ethtool_eeprom *)tmp___1;
  tmp___2 = ldv_zalloc(36UL);
  ldvarg174 = (struct ethtool_channels *)tmp___2;
  tmp___3 = ldv_zalloc(8UL);
  ldvarg171 = (u64 *)tmp___3;
  tmp___4 = ldv_zalloc(12UL);
  ldvarg170 = (struct ethtool_regs *)tmp___4;
  tmp___5 = ldv_zalloc(16UL);
  ldvarg180 = (struct ethtool_pauseparam *)tmp___5;
  tmp___6 = __VERIFIER_nondet_u32();
  ldvarg177 = tmp___6;
  tmp___7 = __VERIFIER_nondet_int();
  ldvarg179 = tmp___7;
  tmp___8 = ldv_zalloc(8UL);
  ldvarg172 = (struct ethtool_stats *)tmp___8;
  tmp___9 = ldv_zalloc(196UL);
  ldvarg173 = (struct ethtool_drvinfo *)tmp___9;
  tmp___10 = ldv_zalloc(44UL);
  ldvarg178 = (struct ethtool_cmd *)tmp___10;
  tmp___11 = __VERIFIER_nondet_u32();
  ldvarg176 = tmp___11;
  tmp___12 = ldv_zalloc(1UL);
  ldvarg175 = (u8 *)tmp___12;
  tmp___13 = ldv_zalloc(1UL);
  ldvarg167 = (u8 *)tmp___13;
  tmp___14 = __VERIFIER_nondet_int();
  switch (tmp___14) {
  case 0: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_ringparam(qlcnic_sriov_vf_ethtool_ops_group2, qlcnic_sriov_vf_ethtool_ops_group1);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 1: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_pauseparam(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg180);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 2: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_sset_count(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg179);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 3: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_settings(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg178);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 4: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_set_intr_coalesce(qlcnic_sriov_vf_ethtool_ops_group2, qlcnic_sriov_vf_ethtool_ops_group0);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 5: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_set_msglevel(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg177);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 6: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_eeprom_len(qlcnic_sriov_vf_ethtool_ops_group2);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 7: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_strings(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg176, ldvarg175);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 8: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_channels(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg174);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 9: ;
  if (ldv_state_variable_23 == 1) {
    ethtool_op_get_link(qlcnic_sriov_vf_ethtool_ops_group2);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 10: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_drvinfo(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg173);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 11: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_ethtool_stats(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg172, ldvarg171);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 12: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_intr_coalesce(qlcnic_sriov_vf_ethtool_ops_group2, qlcnic_sriov_vf_ethtool_ops_group0);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 13: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_regs(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg170, ldvarg169);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 14: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_eeprom(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg168, ldvarg167);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 15: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_wol(qlcnic_sriov_vf_ethtool_ops_group2, ldvarg166);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 16: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_msglevel(qlcnic_sriov_vf_ethtool_ops_group2);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 17: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_get_regs_len(qlcnic_sriov_vf_ethtool_ops_group2);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  case 18: ;
  if (ldv_state_variable_23 == 1) {
    qlcnic_set_ringparam(qlcnic_sriov_vf_ethtool_ops_group2, qlcnic_sriov_vf_ethtool_ops_group1);
    ldv_state_variable_23 = 1;
  } else {
  }
  goto ldv_51492;
  default:
  ldv_stop();
  }
  ldv_51492: ;
  return;
}
}
void *ldv_kmem_cache_alloc_166(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_174(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_176(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_177(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_178(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_179(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_181(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_182(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_183(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_kmem_cache_alloc_210(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_227(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
extern int pci_reset_function(struct pci_dev * ) ;
__inline static int is_device_dma_capable(struct device *dev )
{
  {
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
extern void debug_dma_alloc_coherent(struct device * , size_t , dma_addr_t , void * ) ;
extern struct device x86_dma_fallback_dev ;
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp )
{
  unsigned long dma_mask ;
  {
  dma_mask = 0UL;
  dma_mask = (unsigned long )dev->coherent_dma_mask;
  if (dma_mask == 0UL) {
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {
  }
  return (dma_mask);
}
}
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp )
{
  unsigned long dma_mask ;
  unsigned long tmp ;
  {
  tmp = dma_alloc_coherent_mask(dev, gfp);
  dma_mask = tmp;
  if ((unsigned long long )dma_mask <= 16777215ULL) {
    gfp = gfp | 1U;
  } else {
  }
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
    gfp = gfp | 4U;
  } else {
  }
  return (gfp);
}
}
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  gfp = gfp & 4294967288U;
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
    dev = & x86_dma_fallback_dev;
  } else {
  }
  tmp___0 = is_device_dma_capable(dev);
  if (tmp___0 == 0) {
    return ((void *)0);
  } else {
  }
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t , dma_addr_t * ,
                                                                gfp_t , struct dma_attrs * ))0)) {
    return ((void *)0);
  } else {
  }
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  return (memory);
}
}
__inline static void *ldv_dma_zalloc_coherent_213(struct device *dev , size_t size ,
                                                  dma_addr_t *dma_handle , gfp_t flag )
{
  void *ret ;
  void *tmp ;
  {
  tmp = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)0);
  ret = tmp;
  return (ret);
}
}
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_218(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_226(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_220(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_216(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_224(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_225(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_221(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_222(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_223(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
int qlcnic_83xx_config_intrpt(struct qlcnic_adapter *adapter , bool op_type ) ;
int qlcnic_get_eswitch_stats(struct qlcnic_adapter *adapter , u8 const eswitch ,
                             u8 const rx_tx , struct __qlcnic_esw_statistics *esw_stats ) ;
int qlcnic_clear_esw_stats(struct qlcnic_adapter *adapter , u8 const func_esw ,
                           u8 const port , u8 const rx_tx ) ;
void qlcnic_dump_mbx(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd ) ;
int qlcnic_is_valid_nic_func(struct qlcnic_adapter *adapter , u8 pci_func ) ;
int qlcnic_get_pci_func_type(struct qlcnic_adapter *adapter , u16 type , u16 *nic ,
                             u16 *fcoe , u16 *iscsi ) ;
__inline static int qlcnic_fw_cmd_create_rx_ctx(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->create_rx_ctx))(adapter);
  return (tmp);
}
}
__inline static int qlcnic_fw_cmd_create_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *ptr ,
                                                int ring )
{
  int tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->create_tx_ctx))(adapter, ptr, ring);
  return (tmp);
}
}
__inline static void qlcnic_fw_cmd_del_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *ptr )
{
  {
  return;
}
}
static struct qlcnic_mailbox_metadata const qlcnic_mbx_tbl[33U] =
  { {7U, 4U, 1U},
        {8U, 2U, 1U},
        {9U, 4U, 1U},
        {10U, 2U, 1U},
        {17U, 4U, 1U},
        {18U, 4U, 1U},
        {19U, 4U, 2U},
        {20U, 5U, 1U},
        {21U, 4U, 1U},
        {22U, 4U, 2U},
        {23U, 4U, 1U},
        {24U, 4U, 2U},
        {25U, 4U, 2U},
        {31U, 4U, 3U},
        {32U, 4U, 1U},
        {33U, 4U, 1U},
        {34U, 4U, 1U},
        {36U, 4U, 3U},
        {37U, 4U, 1U},
        {38U, 4U, 3U},
        {39U, 4U, 1U},
        {40U, 4U, 1U},
        {55U, 4U, 1U},
        {41U, 4U, 3U},
        {42U, 5U, 1U},
        {46U, 4U, 1U},
        {47U, 4U, 4U},
        {48U, 4U, 1U},
        {56U, 4U, 1U},
        {60U, 4U, 2U},
        {57U, 2U, 3U},
        {52U, 1U, 2U},
        {53U, 4U, 1U}};
__inline static u32 qlcnic_get_cmd_signature(struct qlcnic_hardware_context *ahw )
{
  {
  return (((u32 )ahw->pci_func | ((ahw->fw_hal_version << 8) & 65535U)) | 3405643776U);
}
}
int qlcnic_82xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx , struct qlcnic_adapter *adapter ,
                               u32 type )
{
  int i ;
  int size ;
  struct qlcnic_mailbox_metadata const *mbx_tbl ;
  void *tmp ;
  void *tmp___0 ;
  {
  mbx_tbl = (struct qlcnic_mailbox_metadata const *)(& qlcnic_mbx_tbl);
  size = 33;
  i = 0;
  goto ldv_50853;
  ldv_50852: ;
  if ((u32 )(mbx_tbl + (unsigned long )i)->cmd == type) {
    mbx->req.num = (mbx_tbl + (unsigned long )i)->in_args;
    mbx->rsp.num = (mbx_tbl + (unsigned long )i)->out_args;
    tmp = kcalloc((size_t )mbx->req.num, 4UL, 32U);
    mbx->req.arg = (u32 *)tmp;
    if ((unsigned long )mbx->req.arg == (unsigned long )((u32 *)0U)) {
      return (-12);
    } else {
    }
    tmp___0 = kcalloc((size_t )mbx->rsp.num, 4UL, 32U);
    mbx->rsp.arg = (u32 *)tmp___0;
    if ((unsigned long )mbx->rsp.arg == (unsigned long )((u32 *)0U)) {
      kfree((void const *)mbx->req.arg);
      mbx->req.arg = (u32 *)0U;
      return (-12);
    } else {
    }
    memset((void *)mbx->req.arg, 0, (unsigned long )mbx->req.num * 4UL);
    memset((void *)mbx->rsp.arg, 0, (unsigned long )mbx->rsp.num * 4UL);
    *(mbx->req.arg) = type;
    goto ldv_50851;
  } else {
  }
  i = i + 1;
  ldv_50853: ;
  if (i < size) {
    goto ldv_50852;
  } else {
  }
  ldv_50851: ;
  return (0);
}
}
void qlcnic_free_mbx_args(struct qlcnic_cmd_args *cmd )
{
  {
  kfree((void const *)cmd->req.arg);
  cmd->req.arg = (u32 *)0U;
  kfree((void const *)cmd->rsp.arg);
  cmd->rsp.arg = (u32 *)0U;
  return;
}
}
static u32 qlcnic_poll_rsp(struct qlcnic_adapter *adapter )
{
  u32 rsp ;
  int timeout ;
  int err ;
  unsigned long __ms ;
  unsigned long tmp ;
  int tmp___0 ;
  {
  timeout = 0;
  err = 0;
  ldv_50867: ;
  if (1) {
    __const_udelay(4295000UL);
  } else {
    __ms = 1UL;
    goto ldv_50865;
    ldv_50864:
    __const_udelay(4295000UL);
    ldv_50865:
    tmp = __ms;
    __ms = __ms - 1UL;
    if (tmp != 0UL) {
      goto ldv_50864;
    } else {
    }
  }
  timeout = timeout + 1;
  if (timeout > 4000) {
    return (3U);
  } else {
  }
  tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323608UL, & err);
  rsp = (u32 )tmp___0;
  if ((int )rsp < 0) {
    goto ldv_50867;
  } else {
  }
  return (rsp);
}
}
int qlcnic_82xx_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  int i ;
  int err ;
  u32 rsp ;
  u32 signature ;
  struct pci_dev *pdev ;
  struct qlcnic_hardware_context *ahw ;
  char const *fmt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  err = 0;
  pdev = adapter->pdev;
  ahw = adapter->ahw;
  signature = qlcnic_get_cmd_signature(ahw);
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    *(cmd->rsp.arg) = 17U;
    return ((int )*(cmd->rsp.arg));
  } else {
  }
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 136323624UL, signature);
  i = 1;
  goto ldv_50881;
  ldv_50880:
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (unsigned long )((i + 6) * 4) + 136323584UL,
                                           *(cmd->req.arg + (unsigned long )i));
  i = i + 1;
  ldv_50881: ;
  if (i <= 3) {
    goto ldv_50880;
  } else {
  }
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 136323608UL, *(cmd->req.arg) | 2147483648U);
  rsp = qlcnic_poll_rsp(adapter);
  if (rsp == 3U) {
    dev_err((struct device const *)(& pdev->dev), "card response timeout.\n");
    *(cmd->rsp.arg) = 17U;
  } else
  if (rsp == 2U) {
    tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 136323612UL, & err);
    *(cmd->rsp.arg) = (u32 )tmp___0;
    switch (*(cmd->rsp.arg)) {
    case 6U:
    fmt = "CDRP invalid args: [%d]\n";
    goto ldv_50884;
    case 9U: ;
    case 15U:
    fmt = "CDRP command not supported: [%d]\n";
    goto ldv_50884;
    case 10U:
    fmt = "CDRP requested action not permitted: [%d]\n";
    goto ldv_50884;
    case 16U:
    fmt = "CDRP invalid or unknown cmd received: [%d]\n";
    goto ldv_50884;
    case 17U:
    fmt = "CDRP command timeout: [%d]\n";
    goto ldv_50884;
    default:
    fmt = "CDRP command failed: [%d]\n";
    goto ldv_50884;
    }
    ldv_50884:
    dev_err((struct device const *)(& pdev->dev), fmt, *(cmd->rsp.arg));
    qlcnic_dump_mbx(adapter, cmd);
  } else
  if (rsp == 1U) {
    *(cmd->rsp.arg) = 0U;
  } else {
  }
  i = 1;
  goto ldv_50892;
  ldv_50891:
  tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (unsigned long )((i + 6) * 4) + 136323584UL,
                                                    & err);
  *(cmd->rsp.arg + (unsigned long )i) = (u32 )tmp___1;
  i = i + 1;
  ldv_50892: ;
  if ((u32 )i < cmd->rsp.num) {
    goto ldv_50891;
  } else {
  }
  qlcnic_api_unlock(adapter);
  return ((int )*(cmd->rsp.arg));
}
}
int qlcnic_fw_cmd_set_drv_version(struct qlcnic_adapter *adapter , u32 fw_cmd )
{
  struct qlcnic_cmd_args cmd ;
  u32 arg1 ;
  u32 arg2 ;
  u32 arg3 ;
  char drv_string[12U] ;
  int err ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  err = 0;
  memset((void *)(& drv_string), 0, 12UL);
  snprintf((char *)(& drv_string), 12UL, "%d.%d.%d", 5, 3, 60);
  err = qlcnic_alloc_mbx_args(& cmd, adapter, fw_cmd);
  if (err != 0) {
    return (err);
  } else {
  }
  __len = 4UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& arg1), (void const *)(& drv_string), __len);
  } else {
    __ret = memcpy((void *)(& arg1), (void const *)(& drv_string), __len);
  }
  __len___0 = 4UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& arg2), (void const *)(& drv_string) + 4U, __len___0);
  } else {
    __ret___0 = memcpy((void *)(& arg2), (void const *)(& drv_string) + 4U,
                                 __len___0);
  }
  __len___1 = 4UL;
  if (__len___1 > 63UL) {
    __ret___1 = memcpy((void *)(& arg3), (void const *)(& drv_string) + 8U, __len___1);
  } else {
    __ret___1 = memcpy((void *)(& arg3), (void const *)(& drv_string) + 8U,
                                 __len___1);
  }
  *(cmd.req.arg + 1UL) = arg1;
  *(cmd.req.arg + 2UL) = arg2;
  *(cmd.req.arg + 3UL) = arg3;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Failed to set driver version in firmware\n");
    err = -5;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_fw_cmd_set_mtu(struct qlcnic_adapter *adapter , int mtu )
{
  int err ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_recv_context *recv_ctx ;
  {
  err = 0;
  recv_ctx = adapter->recv_ctx;
  if (recv_ctx->state != 2U) {
    return (err);
  } else {
  }
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 18U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )recv_ctx->context_id;
  *(cmd.req.arg + 2UL) = (u32 )mtu;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to set mtu\n");
    err = -5;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_82xx_fw_cmd_create_rx_ctx(struct qlcnic_adapter *adapter )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_hardware_context *ahw ;
  dma_addr_t hostrq_phys_addr ;
  dma_addr_t cardrsp_phys_addr ;
  struct net_device *netdev ;
  u32 temp_intr_crb_mode ;
  u32 temp_rds_crb_mode ;
  struct qlcnic_cardrsp_rds_ring *prsp_rds ;
  struct qlcnic_cardrsp_sds_ring *prsp_sds ;
  struct qlcnic_hostrq_rds_ring *prq_rds ;
  struct qlcnic_hostrq_sds_ring *prq_sds ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_cardrsp_rx_ctx *prsp ;
  struct qlcnic_hostrq_rx_ctx *prq ;
  u8 i ;
  u8 nrds_rings ;
  u8 nsds_rings ;
  struct qlcnic_cmd_args cmd ;
  size_t rq_size ;
  size_t rsp_size ;
  u32 cap ;
  u32 reg ;
  u32 val ;
  u32 reg2 ;
  u64 phys_addr ;
  u16 temp_u16 ;
  void *addr ;
  int err ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  recv_ctx = adapter->recv_ctx;
  ahw = adapter->ahw;
  netdev = adapter->netdev;
  nrds_rings = adapter->max_rds_rings;
  nsds_rings = adapter->drv_sds_rings;
  rq_size = ((unsigned long )nrds_rings * 24UL + (unsigned long )nsds_rings * 16UL) + 176UL;
  rsp_size = (((unsigned long )nrds_rings + (unsigned long )nsds_rings) + 19UL) * 8UL;
  addr = dma_alloc_attrs(& (adapter->pdev)->dev, rq_size, & hostrq_phys_addr, 208U,
                         (struct dma_attrs *)0);
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  prq = (struct qlcnic_hostrq_rx_ctx *)addr;
  addr = dma_alloc_attrs(& (adapter->pdev)->dev, rsp_size, & cardrsp_phys_addr, 208U,
                         (struct dma_attrs *)0);
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    err = -12;
    goto out_free_rq;
  } else {
  }
  prsp = (struct qlcnic_cardrsp_rx_ctx *)addr;
  prq->host_rsp_dma_addr = cardrsp_phys_addr;
  cap = 2053U;
  cap = cap | 384U;
  tmp = qlcnic_check_multi_tx(adapter);
  if ((int )tmp && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    cap = cap | 4194304U;
  } else {
    temp_u16 = 47U;
    prq->valid_field_offset = temp_u16;
    prq->txrx_sds_binding = (unsigned int )nsds_rings + 255U;
    temp_intr_crb_mode = 1U;
    prq->host_int_crb_mode = temp_intr_crb_mode;
    temp_rds_crb_mode = 0U;
    prq->host_rds_crb_mode = temp_rds_crb_mode;
  }
  prq->capabilities[0] = cap;
  prq->num_rds_rings = (unsigned short )nrds_rings;
  prq->num_sds_rings = (unsigned short )nsds_rings;
  prq->rds_ring_offset = 0U;
  val = prq->rds_ring_offset + (u32 )nrds_rings * 24U;
  prq->sds_ring_offset = val;
  prq_rds = (struct qlcnic_hostrq_rds_ring *)(& prq->data) + (unsigned long )prq->rds_ring_offset;
  i = 0U;
  goto ldv_50954;
  ldv_50953:
  rds_ring = recv_ctx->rds_rings + (unsigned long )i;
  rds_ring->producer = 0U;
  (prq_rds + (unsigned long )i)->host_phys_addr = rds_ring->phys_addr;
  (prq_rds + (unsigned long )i)->ring_size = rds_ring->num_desc;
  (prq_rds + (unsigned long )i)->ring_kind = (unsigned int )i;
  (prq_rds + (unsigned long )i)->buff_size = (unsigned long long )rds_ring->dma_size;
  i = (u8 )((int )i + 1);
  ldv_50954: ;
  if ((int )i < (int )nrds_rings) {
    goto ldv_50953;
  } else {
  }
  prq_sds = (struct qlcnic_hostrq_sds_ring *)(& prq->data) + (unsigned long )prq->sds_ring_offset;
  i = 0U;
  goto ldv_50957;
  ldv_50956:
  sds_ring = recv_ctx->sds_rings + (unsigned long )i;
  sds_ring->consumer = 0U;
  memset((void *)sds_ring->desc_head, 0, (unsigned long )sds_ring->num_desc * 16UL);
  (prq_sds + (unsigned long )i)->host_phys_addr = sds_ring->phys_addr;
  (prq_sds + (unsigned long )i)->ring_size = sds_ring->num_desc;
  tmp___0 = qlcnic_check_multi_tx(adapter);
  if ((int )tmp___0 && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    (prq_sds + (unsigned long )i)->msi_index = (ahw->intr_tbl + (unsigned long )i)->id;
  } else {
    (prq_sds + (unsigned long )i)->msi_index = (unsigned short )i;
  }
  i = (u8 )((int )i + 1);
  ldv_50957: ;
  if ((int )i < (int )nsds_rings) {
    goto ldv_50956;
  } else {
  }
  phys_addr = hostrq_phys_addr;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 7U);
  if (err != 0) {
    goto out_free_rsp;
  } else {
  }
  *(cmd.req.arg + 1UL) = (unsigned int )(phys_addr >> 32ULL);
  *(cmd.req.arg + 2UL) = (unsigned int )phys_addr;
  *(cmd.req.arg + 3UL) = (u32 )rq_size;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to create rx ctx in firmware%d\n",
            err);
    goto out_free_rsp;
  } else {
  }
  prsp_rds = (struct qlcnic_cardrsp_rds_ring *)(& prsp->data) + (unsigned long )prsp->rds_ring_offset;
  i = 0U;
  goto ldv_50961;
  ldv_50960:
  rds_ring = recv_ctx->rds_rings + (unsigned long )i;
  reg = (prsp_rds + (unsigned long )i)->host_producer_crb;
  rds_ring->crb_rcv_producer = ahw->pci_base0 + (unsigned long )reg;
  i = (u8 )((int )i + 1);
  ldv_50961: ;
  if ((int )((unsigned short )i) < (int )prsp->num_rds_rings) {
    goto ldv_50960;
  } else {
  }
  prsp_sds = (struct qlcnic_cardrsp_sds_ring *)(& prsp->data) + (unsigned long )prsp->sds_ring_offset;
  i = 0U;
  goto ldv_50964;
  ldv_50963:
  sds_ring = recv_ctx->sds_rings + (unsigned long )i;
  reg = (prsp_sds + (unsigned long )i)->host_consumer_crb;
  tmp___1 = qlcnic_check_multi_tx(adapter);
  if ((int )tmp___1 && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    reg2 = (ahw->intr_tbl + (unsigned long )i)->src;
  } else {
    reg2 = (prsp_sds + (unsigned long )i)->interrupt_crb;
  }
  sds_ring->crb_intr_mask = ahw->pci_base0 + (unsigned long )reg2;
  sds_ring->crb_sts_consumer = ahw->pci_base0 + (unsigned long )reg;
  i = (u8 )((int )i + 1);
  ldv_50964: ;
  if ((int )((unsigned short )i) < (int )prsp->num_sds_rings) {
    goto ldv_50963;
  } else {
  }
  recv_ctx->state = prsp->host_ctx_state;
  recv_ctx->context_id = prsp->context_id;
  recv_ctx->virt_port = (u16 )prsp->virt_port;
  netdev_info((struct net_device const *)netdev, "Rx Context[%d] Created, state 0x%x\n",
              (int )recv_ctx->context_id, recv_ctx->state);
  qlcnic_free_mbx_args(& cmd);
  out_free_rsp:
  dma_free_attrs(& (adapter->pdev)->dev, rsp_size, (void *)prsp, cardrsp_phys_addr,
                 (struct dma_attrs *)0);
  out_free_rq:
  dma_free_attrs(& (adapter->pdev)->dev, rq_size, (void *)prq, hostrq_phys_addr, (struct dma_attrs *)0);
  return (err);
}
}
void qlcnic_82xx_fw_cmd_del_rx_ctx(struct qlcnic_adapter *adapter )
{
  int err ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_recv_context *recv_ctx ;
  {
  recv_ctx = adapter->recv_ctx;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 8U);
  if (err != 0) {
    return;
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )recv_ctx->context_id;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to destroy rx ctx in firmware\n");
  } else {
  }
  recv_ctx->state = 0U;
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
int qlcnic_82xx_fw_cmd_create_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring ,
                                     int ring )
{
  struct qlcnic_hardware_context *ahw ;
  struct net_device *netdev ;
  struct qlcnic_hostrq_tx_ctx *prq ;
  struct qlcnic_hostrq_cds_ring *prq_cds ;
  struct qlcnic_cardrsp_tx_ctx *prsp ;
  struct qlcnic_cmd_args cmd ;
  u32 temp ;
  u32 intr_mask ;
  u32 temp_int_crb_mode ;
  dma_addr_t rq_phys_addr ;
  dma_addr_t rsp_phys_addr ;
  int temp_nsds_rings ;
  int index ;
  int err ;
  void *rq_addr ;
  void *rsp_addr ;
  size_t rq_size ;
  size_t rsp_size ;
  u64 phys_addr ;
  u16 msix_id ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  ahw = adapter->ahw;
  netdev = adapter->netdev;
  tx_ring->producer = 0U;
  tx_ring->sw_consumer = 0U;
  *(tx_ring->hw_consumer) = 0U;
  rq_size = 200UL;
  rq_addr = dma_zalloc_coherent(& (adapter->pdev)->dev, rq_size, & rq_phys_addr, 208U);
  if ((unsigned long )rq_addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  rsp_size = 144UL;
  rsp_addr = dma_zalloc_coherent(& (adapter->pdev)->dev, rsp_size, & rsp_phys_addr,
                                 208U);
  if ((unsigned long )rsp_addr == (unsigned long )((void *)0)) {
    err = -12;
    goto out_free_rq;
  } else {
  }
  prq = (struct qlcnic_hostrq_tx_ctx *)rq_addr;
  prsp = (struct qlcnic_cardrsp_tx_ctx *)rsp_addr;
  prq->host_rsp_dma_addr = rsp_phys_addr;
  temp = 69U;
  tmp = qlcnic_check_multi_tx(adapter);
  if ((int )tmp && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    temp = temp | 4194304U;
  } else {
  }
  prq->capabilities[0] = temp;
  tmp___0 = qlcnic_check_multi_tx(adapter);
  if ((int )tmp___0 && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    temp_nsds_rings = (int )adapter->drv_sds_rings;
    index = temp_nsds_rings + ring;
    msix_id = (ahw->intr_tbl + (unsigned long )index)->id;
    prq->msi_index = msix_id;
  } else {
    temp_int_crb_mode = 1U;
    prq->host_int_crb_mode = temp_int_crb_mode;
    prq->msi_index = 0U;
  }
  prq->interrupt_ctl = 0U;
  prq->cmd_cons_dma_addr = tx_ring->hw_cons_phys_addr;
  prq_cds = & prq->cds_ring;
  prq_cds->host_phys_addr = tx_ring->phys_addr;
  prq_cds->ring_size = tx_ring->num_desc;
  phys_addr = rq_phys_addr;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 9U);
  if (err != 0) {
    goto out_free_rsp;
  } else {
  }
  *(cmd.req.arg + 1UL) = (unsigned int )(phys_addr >> 32ULL);
  *(cmd.req.arg + 2UL) = (unsigned int )phys_addr;
  *(cmd.req.arg + 3UL) = (u32 )rq_size;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err == 0) {
    tx_ring->state = prsp->host_ctx_state;
    temp = prsp->cds_ring.host_producer_crb;
    tx_ring->crb_cmd_producer = (adapter->ahw)->pci_base0 + (unsigned long )temp;
    tx_ring->ctx_id = prsp->context_id;
    tmp___1 = qlcnic_check_multi_tx(adapter);
    if (((int )tmp___1 && (unsigned int )(adapter->ahw)->diag_test == 0U) && (adapter->flags & 4U) != 0U) {
      index = (int )adapter->drv_sds_rings + ring;
      intr_mask = (ahw->intr_tbl + (unsigned long )index)->src;
      tx_ring->crb_intr_mask = ahw->pci_base0 + (unsigned long )intr_mask;
    } else {
    }
    netdev_info((struct net_device const *)netdev, "Tx Context[0x%x] Created, state 0x%x\n",
                (int )tx_ring->ctx_id, tx_ring->state);
  } else {
    netdev_err((struct net_device const *)netdev, "Failed to create tx ctx in firmware%d\n",
               err);
    err = -5;
  }
  qlcnic_free_mbx_args(& cmd);
  out_free_rsp:
  dma_free_attrs(& (adapter->pdev)->dev, rsp_size, rsp_addr, rsp_phys_addr, (struct dma_attrs *)0);
  out_free_rq:
  dma_free_attrs(& (adapter->pdev)->dev, rq_size, rq_addr, rq_phys_addr, (struct dma_attrs *)0);
  return (err);
}
}
void qlcnic_82xx_fw_cmd_del_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring )
{
  struct qlcnic_cmd_args cmd ;
  int ret ;
  int tmp ;
  {
  ret = qlcnic_alloc_mbx_args(& cmd, adapter, 10U);
  if (ret != 0) {
    return;
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )tx_ring->ctx_id;
  tmp = qlcnic_issue_cmd(adapter, & cmd);
  if (tmp != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to destroy tx ctx in firmware\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
int qlcnic_fw_cmd_set_port(struct qlcnic_adapter *adapter , u32 config )
{
  int err ;
  struct qlcnic_cmd_args cmd ;
  {
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 46U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = config;
  err = qlcnic_issue_cmd(adapter, & cmd);
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_alloc_hw_resources(struct qlcnic_adapter *adapter )
{
  void *addr ;
  int err ;
  int ring ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  __le32 *ptr ;
  struct pci_dev *pdev ;
  void *tmp ;
  {
  pdev = adapter->pdev;
  recv_ctx = adapter->recv_ctx;
  ring = 0;
  goto ldv_51025;
  ldv_51024:
  tx_ring = adapter->tx_ring + (unsigned long )ring;
  tmp = dma_alloc_attrs(& pdev->dev, 4UL, & tx_ring->hw_cons_phys_addr, 208U, (struct dma_attrs *)0);
  ptr = (__le32 *)tmp;
  if ((unsigned long )ptr == (unsigned long )((__le32 *)0U)) {
    return (-12);
  } else {
  }
  tx_ring->hw_consumer = ptr;
  addr = dma_alloc_attrs(& pdev->dev, (unsigned long )tx_ring->num_desc * 64UL, & tx_ring->phys_addr,
                         208U, (struct dma_attrs *)0);
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    err = -12;
    goto err_out_free;
  } else {
  }
  tx_ring->desc_head = (struct cmd_desc_type0 *)addr;
  ring = ring + 1;
  ldv_51025: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_51024;
  } else {
  }
  ring = 0;
  goto ldv_51028;
  ldv_51027:
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  addr = dma_alloc_attrs(& (adapter->pdev)->dev, (unsigned long )rds_ring->num_desc * 16UL,
                         & rds_ring->phys_addr, 208U, (struct dma_attrs *)0);
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    err = -12;
    goto err_out_free;
  } else {
  }
  rds_ring->desc_head = (struct rcv_desc *)addr;
  ring = ring + 1;
  ldv_51028: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_51027;
  } else {
  }
  ring = 0;
  goto ldv_51031;
  ldv_51030:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  addr = dma_alloc_attrs(& (adapter->pdev)->dev, (unsigned long )sds_ring->num_desc * 16UL,
                         & sds_ring->phys_addr, 208U, (struct dma_attrs *)0);
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    err = -12;
    goto err_out_free;
  } else {
  }
  sds_ring->desc_head = (struct status_desc *)addr;
  ring = ring + 1;
  ldv_51031: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_51030;
  } else {
  }
  return (0);
  err_out_free:
  qlcnic_free_hw_resources(adapter);
  return (err);
}
}
int qlcnic_fw_create_ctx(struct qlcnic_adapter *dev )
{
  int i ;
  int err ;
  int ring ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  {
  if ((dev->flags & 4096U) != 0U) {
    pci_reset_function(dev->pdev);
    dev->flags = dev->flags & 4294963199U;
  } else {
  }
  tmp = qlcnic_83xx_check(dev);
  if ((int )tmp && (dev->flags & 4U) != 0U) {
    if ((unsigned int )(dev->ahw)->diag_test != 2U) {
      err = qlcnic_83xx_config_intrpt(dev, 1);
      if (err != 0) {
        return (err);
      } else {
      }
    } else {
    }
  } else {
  }
  tmp___0 = qlcnic_82xx_check(dev);
  if ((int )tmp___0 && (dev->flags & 4U) != 0U) {
    tmp___1 = qlcnic_check_multi_tx(dev);
    if ((int )tmp___1) {
      if ((unsigned int )(dev->ahw)->diag_test == 0U) {
        err = qlcnic_82xx_mq_intrpt(dev, 1);
        if (err != 0) {
          return (err);
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  err = qlcnic_fw_cmd_create_rx_ctx(dev);
  if (err != 0) {
    goto err_out;
  } else {
  }
  ring = 0;
  goto ldv_51044;
  ldv_51043:
  err = qlcnic_fw_cmd_create_tx_ctx(dev, dev->tx_ring + (unsigned long )ring, ring);
  if (err != 0) {
    qlcnic_free_mac_list(dev);
    if (ring == 0) {
      goto err_out;
    } else {
    }
    i = 0;
    goto ldv_51041;
    ldv_51040:
    qlcnic_fw_cmd_del_tx_ctx(dev, dev->tx_ring + (unsigned long )i);
    i = i + 1;
    ldv_51041: ;
    if (i < ring) {
      goto ldv_51040;
    } else {
    }
    goto err_out;
  } else {
  }
  ring = ring + 1;
  ldv_51044: ;
  if ((int )dev->drv_tx_rings > ring) {
    goto ldv_51043;
  } else {
  }
  set_bit(0L, (unsigned long volatile *)(& dev->state));
  return (0);
  err_out:
  tmp___2 = qlcnic_82xx_check(dev);
  if ((int )tmp___2 && (dev->flags & 4U) != 0U) {
    tmp___3 = qlcnic_check_multi_tx(dev);
    if ((int )tmp___3) {
      if ((unsigned int )(dev->ahw)->diag_test == 0U) {
        qlcnic_82xx_config_intrpt(dev, 0);
      } else {
      }
    } else {
    }
  } else {
  }
  tmp___4 = qlcnic_83xx_check(dev);
  if ((int )tmp___4 && (dev->flags & 4U) != 0U) {
    if ((unsigned int )(dev->ahw)->diag_test != 2U) {
      qlcnic_83xx_config_intrpt(dev, 0);
    } else {
    }
  } else {
  }
  return (err);
}
}
void qlcnic_fw_destroy_ctx(struct qlcnic_adapter *adapter )
{
  int ring ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  {
  tmp___3 = test_and_clear_bit(0L, (unsigned long volatile *)(& adapter->state));
  if (tmp___3 != 0) {
    qlcnic_free_mac_list(adapter);
    ring = 0;
    goto ldv_51051;
    ldv_51050:
    qlcnic_fw_cmd_del_tx_ctx(adapter, adapter->tx_ring + (unsigned long )ring);
    ring = ring + 1;
    ldv_51051: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_51050;
    } else {
    }
    tmp = qlcnic_82xx_check(adapter);
    if ((int )tmp && (adapter->flags & 4U) != 0U) {
      tmp___0 = qlcnic_check_multi_tx(adapter);
      if ((int )tmp___0) {
        if ((unsigned int )(adapter->ahw)->diag_test == 0U) {
          qlcnic_82xx_config_intrpt(adapter, 0);
        } else {
        }
      } else {
      }
    } else {
    }
    tmp___1 = qlcnic_83xx_check(adapter);
    if ((int )tmp___1 && (adapter->flags & 4U) != 0U) {
      if ((unsigned int )(adapter->ahw)->diag_test != 2U) {
        qlcnic_83xx_config_intrpt(adapter, 0);
      } else {
      }
    } else {
    }
    __ms = 20UL;
    goto ldv_51055;
    ldv_51054:
    __const_udelay(4295000UL);
    ldv_51055:
    tmp___2 = __ms;
    __ms = __ms - 1UL;
    if (tmp___2 != 0UL) {
      goto ldv_51054;
    } else {
    }
  } else {
  }
  return;
}
}
void qlcnic_free_hw_resources(struct qlcnic_adapter *adapter )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  int ring ;
  {
  recv_ctx = adapter->recv_ctx;
  ring = 0;
  goto ldv_51066;
  ldv_51065:
  tx_ring = adapter->tx_ring + (unsigned long )ring;
  if ((unsigned long )tx_ring->hw_consumer != (unsigned long )((__le32 *)0U)) {
    dma_free_attrs(& (adapter->pdev)->dev, 4UL, (void *)tx_ring->hw_consumer, tx_ring->hw_cons_phys_addr,
                   (struct dma_attrs *)0);
    tx_ring->hw_consumer = (__le32 *)0U;
  } else {
  }
  if ((unsigned long )tx_ring->desc_head != (unsigned long )((struct cmd_desc_type0 *)0)) {
    dma_free_attrs(& (adapter->pdev)->dev, (unsigned long )tx_ring->num_desc * 64UL,
                   (void *)tx_ring->desc_head, tx_ring->phys_addr, (struct dma_attrs *)0);
    tx_ring->desc_head = (struct cmd_desc_type0 *)0;
  } else {
  }
  ring = ring + 1;
  ldv_51066: ;
  if ((int )adapter->drv_tx_rings > ring) {
    goto ldv_51065;
  } else {
  }
  ring = 0;
  goto ldv_51069;
  ldv_51068:
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  if ((unsigned long )rds_ring->desc_head != (unsigned long )((struct rcv_desc *)0)) {
    dma_free_attrs(& (adapter->pdev)->dev, (unsigned long )rds_ring->num_desc * 16UL,
                   (void *)rds_ring->desc_head, rds_ring->phys_addr, (struct dma_attrs *)0);
    rds_ring->desc_head = (struct rcv_desc *)0;
  } else {
  }
  ring = ring + 1;
  ldv_51069: ;
  if ((int )adapter->max_rds_rings > ring) {
    goto ldv_51068;
  } else {
  }
  ring = 0;
  goto ldv_51072;
  ldv_51071:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  if ((unsigned long )sds_ring->desc_head != (unsigned long )((struct status_desc *)0)) {
    dma_free_attrs(& (adapter->pdev)->dev, (unsigned long )sds_ring->num_desc * 16UL,
                   (void *)sds_ring->desc_head, sds_ring->phys_addr, (struct dma_attrs *)0);
    sds_ring->desc_head = (struct status_desc *)0;
  } else {
  }
  ring = ring + 1;
  ldv_51072: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_51071;
  } else {
  }
  return;
}
}
int qlcnic_82xx_config_intrpt(struct qlcnic_adapter *adapter , u8 op_type )
{
  struct qlcnic_hardware_context *ahw ;
  struct net_device *netdev ;
  struct qlcnic_cmd_args cmd ;
  u32 type ;
  u32 val ;
  int i ;
  int err ;
  {
  ahw = adapter->ahw;
  netdev = adapter->netdev;
  err = 0;
  i = 0;
  goto ldv_51087;
  ldv_51086:
  qlcnic_alloc_mbx_args(& cmd, adapter, 57U);
  type = (unsigned int )op_type != 0U ? 1U : 2U;
  val = (u32 )((int )(ahw->intr_tbl + (unsigned long )i)->type << 4) | type;
  if ((unsigned int )(ahw->intr_tbl + (unsigned long )i)->type == 3U) {
    val = (u32 )((int )(ahw->intr_tbl + (unsigned long )i)->id << 16) | val;
  } else {
  }
  *(cmd.req.arg + 1UL) = val;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    netdev_err((struct net_device const *)netdev, "Failed to %s interrupts %d\n",
               (unsigned int )op_type == 1U ? (char *)"Add" : (char *)"Delete", err);
    qlcnic_free_mbx_args(& cmd);
    return (err);
  } else {
  }
  val = *(cmd.rsp.arg + 1UL);
  if ((unsigned int )((unsigned char )val) != 0U) {
    netdev_info((struct net_device const *)netdev, "failed to configure interrupt for %d\n",
                (int )(ahw->intr_tbl + (unsigned long )i)->id);
    goto ldv_51085;
  } else {
  }
  if ((unsigned int )op_type != 0U) {
    (ahw->intr_tbl + (unsigned long )i)->id = (unsigned short )(val >> 16);
    (ahw->intr_tbl + (unsigned long )i)->enabled = 1U;
    (ahw->intr_tbl + (unsigned long )i)->src = *(cmd.rsp.arg + 2UL);
  } else {
    (ahw->intr_tbl + (unsigned long )i)->id = (u16 )i;
    (ahw->intr_tbl + (unsigned long )i)->enabled = 0U;
    (ahw->intr_tbl + (unsigned long )i)->src = 0U;
  }
  qlcnic_free_mbx_args(& cmd);
  ldv_51085:
  i = i + 1;
  ldv_51087: ;
  if ((int )ahw->num_msix > i) {
    goto ldv_51086;
  } else {
  }
  return (err);
}
}
int qlcnic_82xx_get_mac_address(struct qlcnic_adapter *adapter , u8 *mac , u8 function )
{
  int err ;
  int i ;
  struct qlcnic_cmd_args cmd ;
  u32 mac_low ;
  u32 mac_high ;
  {
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 31U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )((int )function | 256);
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err == 0) {
    mac_low = *(cmd.rsp.arg + 1UL);
    mac_high = *(cmd.rsp.arg + 2UL);
    i = 0;
    goto ldv_51100;
    ldv_51099:
    *(mac + (unsigned long )i) = (unsigned char )(mac_high >> (i * -8 + 8));
    i = i + 1;
    ldv_51100: ;
    if (i <= 1) {
      goto ldv_51099;
    } else {
    }
    i = 2;
    goto ldv_51103;
    ldv_51102:
    *(mac + (unsigned long )i) = (unsigned char )(mac_low >> (5 - i) * 8);
    i = i + 1;
    ldv_51103: ;
    if (i <= 5) {
      goto ldv_51102;
    } else {
    }
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get mac address%d\n",
            err);
    err = -5;
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_82xx_get_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info ,
                             u8 func_id )
{
  int err ;
  dma_addr_t nic_dma_t ;
  struct qlcnic_info_le const *nic_info ;
  void *nic_info_addr ;
  struct qlcnic_cmd_args cmd ;
  size_t nic_size ;
  {
  nic_size = 128UL;
  nic_info_addr = dma_zalloc_coherent(& (adapter->pdev)->dev, nic_size, & nic_dma_t,
                                      208U);
  if ((unsigned long )nic_info_addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  nic_info = (struct qlcnic_info_le const *)nic_info_addr;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 33U);
  if (err != 0) {
    goto out_free_dma;
  } else {
  }
  *(cmd.req.arg + 1UL) = (unsigned int )(nic_dma_t >> 32ULL);
  *(cmd.req.arg + 2UL) = (unsigned int )nic_dma_t;
  *(cmd.req.arg + 3UL) = (u32 )((int )func_id << 16) | (u32 )nic_size;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get nic info%d\n",
            err);
    err = -5;
  } else {
    npar_info->pci_func = nic_info->pci_func;
    npar_info->op_mode = nic_info->op_mode;
    npar_info->min_tx_bw = nic_info->min_tx_bw;
    npar_info->max_tx_bw = nic_info->max_tx_bw;
    npar_info->phys_port = nic_info->phys_port;
    npar_info->switch_mode = nic_info->switch_mode;
    npar_info->max_tx_ques = nic_info->max_tx_ques;
    npar_info->max_rx_ques = nic_info->max_rx_ques;
    npar_info->capabilities = nic_info->capabilities;
    npar_info->max_mtu = nic_info->max_mtu;
  }
  qlcnic_free_mbx_args(& cmd);
  out_free_dma:
  dma_free_attrs(& (adapter->pdev)->dev, nic_size, nic_info_addr, nic_dma_t, (struct dma_attrs *)0);
  return (err);
}
}
int qlcnic_82xx_set_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *nic )
{
  int err ;
  dma_addr_t nic_dma_t ;
  void *nic_info_addr ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_info_le *nic_info ;
  size_t nic_size ;
  {
  err = -5;
  nic_size = 128UL;
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    return (err);
  } else {
  }
  nic_info_addr = dma_zalloc_coherent(& (adapter->pdev)->dev, nic_size, & nic_dma_t,
                                      208U);
  if ((unsigned long )nic_info_addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  nic_info = (struct qlcnic_info_le *)nic_info_addr;
  nic_info->pci_func = nic->pci_func;
  nic_info->op_mode = nic->op_mode;
  nic_info->phys_port = nic->phys_port;
  nic_info->switch_mode = nic->switch_mode;
  nic_info->capabilities = nic->capabilities;
  nic_info->max_mac_filters = nic->max_mac_filters;
  nic_info->max_tx_ques = nic->max_tx_ques;
  nic_info->max_rx_ques = nic->max_rx_ques;
  nic_info->min_tx_bw = nic->min_tx_bw;
  nic_info->max_tx_bw = nic->max_tx_bw;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 34U);
  if (err != 0) {
    goto out_free_dma;
  } else {
  }
  *(cmd.req.arg + 1UL) = (unsigned int )(nic_dma_t >> 32ULL);
  *(cmd.req.arg + 2UL) = (unsigned int )nic_dma_t;
  *(cmd.req.arg + 3UL) = (u32 )((int )nic->pci_func << 16) | (u32 )nic_size;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to set nic info%d\n",
            err);
    err = -5;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  out_free_dma:
  dma_free_attrs(& (adapter->pdev)->dev, nic_size, nic_info_addr, nic_dma_t, (struct dma_attrs *)0);
  return (err);
}
}
int qlcnic_82xx_get_pci_info(struct qlcnic_adapter *adapter , struct qlcnic_pci_info *pci_info )
{
  struct qlcnic_hardware_context *ahw ;
  size_t npar_size ;
  size_t pci_size ;
  u16 nic ;
  u16 fcoe ;
  u16 iscsi ;
  struct qlcnic_pci_info_le *npar ;
  struct qlcnic_cmd_args cmd ;
  dma_addr_t pci_info_dma_t ;
  void *pci_info_addr ;
  int err ;
  int i ;
  size_t __len ;
  void *__ret ;
  {
  ahw = adapter->ahw;
  npar_size = 128UL;
  pci_size = (size_t )ahw->max_vnic_func * npar_size;
  nic = 0U;
  fcoe = 0U;
  iscsi = 0U;
  err = 0;
  pci_info_addr = dma_zalloc_coherent(& (adapter->pdev)->dev, pci_size, & pci_info_dma_t,
                                      208U);
  if ((unsigned long )pci_info_addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  npar = (struct qlcnic_pci_info_le *)pci_info_addr;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 32U);
  if (err != 0) {
    goto out_free_dma;
  } else {
  }
  *(cmd.req.arg + 1UL) = (unsigned int )(pci_info_dma_t >> 32ULL);
  *(cmd.req.arg + 2UL) = (unsigned int )pci_info_dma_t;
  *(cmd.req.arg + 3UL) = (u32 )pci_size;
  err = qlcnic_issue_cmd(adapter, & cmd);
  ahw->total_nic_func = 0U;
  if (err == 0) {
    i = 0;
    goto ldv_51150;
    ldv_51149:
    pci_info->id = npar->id;
    pci_info->active = npar->active;
    if ((unsigned int )pci_info->active == 0U) {
      goto ldv_51145;
    } else {
    }
    pci_info->type = npar->type;
    err = qlcnic_get_pci_func_type(adapter, (int )pci_info->type, & nic, & fcoe, & iscsi);
    pci_info->default_port = npar->default_port;
    pci_info->tx_min_bw = npar->tx_min_bw;
    pci_info->tx_max_bw = npar->tx_max_bw;
    __len = 6UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& pci_info->mac), (void const *)(& npar->mac), __len);
    } else {
      __ret = memcpy((void *)(& pci_info->mac), (void const *)(& npar->mac),
                               __len);
    }
    ldv_51145:
    i = i + 1;
    npar = npar + 1;
    pci_info = pci_info + 1;
    ldv_51150: ;
    if ((u32 )i < ahw->max_vnic_func) {
      goto ldv_51149;
    } else {
    }
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get PCI Info%d\n",
            err);
    err = -5;
  }
  ahw->total_nic_func = nic;
  ahw->total_pci_func = (u32 )(((int )nic + (int )fcoe) + (int )iscsi);
  if ((unsigned int )ahw->total_nic_func == 0U || ahw->total_pci_func == 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid function count: total nic func[%x], total pci func[%x]\n",
            "qlcnic_82xx_get_pci_info", (int )ahw->total_nic_func, ahw->total_pci_func);
    err = -5;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  out_free_dma:
  dma_free_attrs(& (adapter->pdev)->dev, pci_size, pci_info_addr, pci_info_dma_t,
                 (struct dma_attrs *)0);
  return (err);
}
}
int qlcnic_config_port_mirroring(struct qlcnic_adapter *adapter , u8 id , u8 enable_mirroring ,
                                 u8 pci_func )
{
  struct device *dev ;
  struct qlcnic_cmd_args cmd ;
  int err ;
  u32 arg1 ;
  {
  dev = & (adapter->pdev)->dev;
  err = -5;
  if ((unsigned int )(adapter->ahw)->op_mode != 0U || ((adapter->eswitch + (unsigned long )id)->flags & 2U) == 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Not a management function\n",
            "qlcnic_config_port_mirroring");
    return (err);
  } else {
  }
  arg1 = (u32 )((int )id | ((unsigned int )enable_mirroring != 0U ? 16 : 0));
  arg1 = (u32 )((int )pci_func << 8) | arg1;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 39U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = arg1;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)dev, "Failed to configure port mirroring for vNIC function %d on eSwitch %d\n",
            (int )pci_func, (int )id);
  } else {
    _dev_info((struct device const *)dev, "Configured port mirroring for vNIC function %d on eSwitch %d\n",
              (int )pci_func, (int )id);
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_get_port_stats(struct qlcnic_adapter *adapter , u8 const func , u8 const rx_tx ,
                          struct __qlcnic_esw_statistics *esw_stats )
{
  size_t stats_size ;
  struct qlcnic_esw_stats_le *stats ;
  dma_addr_t stats_dma_t ;
  void *stats_addr ;
  u32 arg1 ;
  struct qlcnic_cmd_args cmd ;
  int err ;
  {
  stats_size = 88UL;
  if ((unsigned long )esw_stats == (unsigned long )((struct __qlcnic_esw_statistics *)0)) {
    return (-12);
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode != 0U && (int )(adapter->ahw)->pci_func != (int )((unsigned char )func)) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Not privilege to query stats for func=%d",
            (int )func);
    return (-5);
  } else {
  }
  stats_addr = dma_zalloc_coherent(& (adapter->pdev)->dev, stats_size, & stats_dma_t,
                                   208U);
  if ((unsigned long )stats_addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  arg1 = (u32 )((int )func | 4352);
  arg1 = ((u32 )((int )rx_tx << 15) | ((u32 )stats_size << 16U)) | arg1;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 42U);
  if (err != 0) {
    goto out_free_dma;
  } else {
  }
  *(cmd.req.arg + 1UL) = arg1;
  *(cmd.req.arg + 2UL) = (unsigned int )(stats_dma_t >> 32ULL);
  *(cmd.req.arg + 3UL) = (unsigned int )stats_dma_t;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err == 0) {
    stats = (struct qlcnic_esw_stats_le *)stats_addr;
    esw_stats->context_id = stats->context_id;
    esw_stats->version = stats->version;
    esw_stats->size = stats->size;
    esw_stats->multicast_frames = stats->multicast_frames;
    esw_stats->broadcast_frames = stats->broadcast_frames;
    esw_stats->unicast_frames = stats->unicast_frames;
    esw_stats->dropped_frames = stats->dropped_frames;
    esw_stats->local_frames = stats->local_frames;
    esw_stats->errors = stats->errors;
    esw_stats->numbytes = stats->numbytes;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  out_free_dma:
  dma_free_attrs(& (adapter->pdev)->dev, stats_size, stats_addr, stats_dma_t, (struct dma_attrs *)0);
  return (err);
}
}
int qlcnic_get_mac_stats(struct qlcnic_adapter *adapter , struct qlcnic_mac_statistics *mac_stats )
{
  struct qlcnic_mac_statistics_le *stats ;
  struct qlcnic_cmd_args cmd ;
  size_t stats_size ;
  dma_addr_t stats_dma_t ;
  void *stats_addr ;
  int err ;
  {
  stats_size = 312UL;
  if ((unsigned long )mac_stats == (unsigned long )((struct qlcnic_mac_statistics *)0)) {
    return (-12);
  } else {
  }
  stats_addr = dma_zalloc_coherent(& (adapter->pdev)->dev, stats_size, & stats_dma_t,
                                   208U);
  if ((unsigned long )stats_addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 55U);
  if (err != 0) {
    goto out_free_dma;
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )stats_size << 16U;
  *(cmd.req.arg + 2UL) = (unsigned int )(stats_dma_t >> 32ULL);
  *(cmd.req.arg + 3UL) = (unsigned int )stats_dma_t;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err == 0) {
    stats = (struct qlcnic_mac_statistics_le *)stats_addr;
    mac_stats->mac_tx_frames = stats->mac_tx_frames;
    mac_stats->mac_tx_bytes = stats->mac_tx_bytes;
    mac_stats->mac_tx_mcast_pkts = stats->mac_tx_mcast_pkts;
    mac_stats->mac_tx_bcast_pkts = stats->mac_tx_bcast_pkts;
    mac_stats->mac_rx_frames = stats->mac_rx_frames;
    mac_stats->mac_rx_bytes = stats->mac_rx_bytes;
    mac_stats->mac_rx_mcast_pkts = stats->mac_rx_mcast_pkts;
    mac_stats->mac_rx_length_error = stats->mac_rx_length_error;
    mac_stats->mac_rx_length_small = stats->mac_rx_length_small;
    mac_stats->mac_rx_length_large = stats->mac_rx_length_large;
    mac_stats->mac_rx_jabber = stats->mac_rx_jabber;
    mac_stats->mac_rx_dropped = stats->mac_rx_dropped;
    mac_stats->mac_rx_crc_error = stats->mac_rx_crc_error;
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Get mac stats failed, err=%d.\n",
            "qlcnic_get_mac_stats", err);
  }
  qlcnic_free_mbx_args(& cmd);
  out_free_dma:
  dma_free_attrs(& (adapter->pdev)->dev, stats_size, stats_addr, stats_dma_t, (struct dma_attrs *)0);
  return (err);
}
}
int qlcnic_get_eswitch_stats(struct qlcnic_adapter *adapter , u8 const eswitch ,
                             u8 const rx_tx , struct __qlcnic_esw_statistics *esw_stats )
{
  struct __qlcnic_esw_statistics port_stats ;
  u8 i ;
  int ret ;
  int tmp ;
  {
  ret = -5;
  if ((unsigned long )esw_stats == (unsigned long )((struct __qlcnic_esw_statistics *)0)) {
    return (-12);
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    return (-5);
  } else {
  }
  if ((unsigned long )adapter->npars == (unsigned long )((struct qlcnic_npar_info *)0)) {
    return (-5);
  } else {
  }
  memset((void *)esw_stats, 0, 8UL);
  esw_stats->unicast_frames = 0xffffffffffffffffULL;
  esw_stats->multicast_frames = 0xffffffffffffffffULL;
  esw_stats->broadcast_frames = 0xffffffffffffffffULL;
  esw_stats->dropped_frames = 0xffffffffffffffffULL;
  esw_stats->errors = 0xffffffffffffffffULL;
  esw_stats->local_frames = 0xffffffffffffffffULL;
  esw_stats->numbytes = 0xffffffffffffffffULL;
  esw_stats->context_id = (u16 )eswitch;
  i = 0U;
  goto ldv_51201;
  ldv_51200: ;
  if ((int )(adapter->npars + (unsigned long )i)->phy_port != (int )((unsigned char )eswitch)) {
    goto ldv_51199;
  } else {
  }
  memset((void *)(& port_stats), 0, 88UL);
  tmp = qlcnic_get_port_stats(adapter, (int )(adapter->npars + (unsigned long )i)->pci_func,
                              (int )rx_tx, & port_stats);
  if (tmp != 0) {
    goto ldv_51199;
  } else {
  }
  esw_stats->size = port_stats.size;
  esw_stats->version = port_stats.version;
  if (esw_stats->unicast_frames == 0xffffffffffffffffULL && port_stats.unicast_frames != 0xffffffffffffffffULL) {
    esw_stats->unicast_frames = port_stats.unicast_frames;
  } else
  if (esw_stats->unicast_frames != 0xffffffffffffffffULL && port_stats.unicast_frames != 0xffffffffffffffffULL) {
    esw_stats->unicast_frames = esw_stats->unicast_frames + port_stats.unicast_frames;
  } else {
  }
  if (esw_stats->multicast_frames == 0xffffffffffffffffULL && port_stats.multicast_frames != 0xffffffffffffffffULL) {
    esw_stats->multicast_frames = port_stats.multicast_frames;
  } else
  if (esw_stats->multicast_frames != 0xffffffffffffffffULL && port_stats.multicast_frames != 0xffffffffffffffffULL) {
    esw_stats->multicast_frames = esw_stats->multicast_frames + port_stats.multicast_frames;
  } else {
  }
  if (esw_stats->broadcast_frames == 0xffffffffffffffffULL && port_stats.broadcast_frames != 0xffffffffffffffffULL) {
    esw_stats->broadcast_frames = port_stats.broadcast_frames;
  } else
  if (esw_stats->broadcast_frames != 0xffffffffffffffffULL && port_stats.broadcast_frames != 0xffffffffffffffffULL) {
    esw_stats->broadcast_frames = esw_stats->broadcast_frames + port_stats.broadcast_frames;
  } else {
  }
  if (esw_stats->dropped_frames == 0xffffffffffffffffULL && port_stats.dropped_frames != 0xffffffffffffffffULL) {
    esw_stats->dropped_frames = port_stats.dropped_frames;
  } else
  if (esw_stats->dropped_frames != 0xffffffffffffffffULL && port_stats.dropped_frames != 0xffffffffffffffffULL) {
    esw_stats->dropped_frames = esw_stats->dropped_frames + port_stats.dropped_frames;
  } else {
  }
  if (esw_stats->errors == 0xffffffffffffffffULL && port_stats.errors != 0xffffffffffffffffULL) {
    esw_stats->errors = port_stats.errors;
  } else
  if (esw_stats->errors != 0xffffffffffffffffULL && port_stats.errors != 0xffffffffffffffffULL) {
    esw_stats->errors = esw_stats->errors + port_stats.errors;
  } else {
  }
  if (esw_stats->local_frames == 0xffffffffffffffffULL && port_stats.local_frames != 0xffffffffffffffffULL) {
    esw_stats->local_frames = port_stats.local_frames;
  } else
  if (esw_stats->local_frames != 0xffffffffffffffffULL && port_stats.local_frames != 0xffffffffffffffffULL) {
    esw_stats->local_frames = esw_stats->local_frames + port_stats.local_frames;
  } else {
  }
  if (esw_stats->numbytes == 0xffffffffffffffffULL && port_stats.numbytes != 0xffffffffffffffffULL) {
    esw_stats->numbytes = port_stats.numbytes;
  } else
  if (esw_stats->numbytes != 0xffffffffffffffffULL && port_stats.numbytes != 0xffffffffffffffffULL) {
    esw_stats->numbytes = esw_stats->numbytes + port_stats.numbytes;
  } else {
  }
  ret = 0;
  ldv_51199:
  i = (u8 )((int )i + 1);
  ldv_51201: ;
  if ((int )((unsigned short )i) < (int )(adapter->ahw)->total_nic_func) {
    goto ldv_51200;
  } else {
  }
  return (ret);
}
}
int qlcnic_clear_esw_stats(struct qlcnic_adapter *adapter , u8 const func_esw ,
                           u8 const port , u8 const rx_tx )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_cmd_args cmd ;
  int err ;
  u32 arg1 ;
  {
  ahw = adapter->ahw;
  if ((unsigned int )ahw->op_mode != 0U) {
    return (-5);
  } else {
  }
  if ((unsigned int )((unsigned char )func_esw) == 1U) {
    if ((u32 )port >= ahw->max_vnic_func) {
      goto err_ret;
    } else {
    }
  } else
  if ((unsigned int )((unsigned char )func_esw) == 2U) {
    if ((unsigned int )((unsigned char )port) > 1U) {
      goto err_ret;
    } else {
    }
  } else {
    goto err_ret;
  }
  if ((unsigned int )((unsigned char )rx_tx) > 1U) {
    goto err_ret;
  } else {
  }
  arg1 = (u32 )(((int )port | 256) | ((int )func_esw << 12));
  arg1 = ((u32 )((int )rx_tx << 15) | arg1) | 16384U;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 42U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = arg1;
  err = qlcnic_issue_cmd(adapter, & cmd);
  qlcnic_free_mbx_args(& cmd);
  return (err);
  err_ret:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Invalid args func_esw %d port %d rx_ctx %d\n",
          (int )func_esw, (int )port, (int )rx_tx);
  return (-5);
}
}
static int __qlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter , u32 *arg1 ,
                                            u32 *arg2 )
{
  struct device *dev ;
  struct qlcnic_cmd_args cmd ;
  u8 pci_func ;
  int err ;
  {
  dev = & (adapter->pdev)->dev;
  pci_func = (u8 )(*arg1 >> 8);
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 41U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = *arg1;
  err = qlcnic_issue_cmd(adapter, & cmd);
  *arg1 = *(cmd.rsp.arg + 1UL);
  *arg2 = *(cmd.rsp.arg + 2UL);
  qlcnic_free_mbx_args(& cmd);
  if (err == 0) {
    _dev_info((struct device const *)dev, "Get eSwitch port config for vNIC function %d\n",
              (int )pci_func);
  } else {
    dev_err((struct device const *)dev, "Failed to get eswitch port config for vNIC function %d\n",
            (int )pci_func);
  }
  return (err);
}
}
int qlcnic_config_switch_port(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg )
{
  struct device *dev ;
  struct qlcnic_cmd_args cmd ;
  int err ;
  int index ;
  u32 arg1 ;
  u32 arg2 ;
  u8 pci_func ;
  int tmp ;
  {
  dev = & (adapter->pdev)->dev;
  err = -5;
  arg2 = 0U;
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Not a management function\n",
            "qlcnic_config_switch_port");
    return (err);
  } else {
  }
  pci_func = esw_cfg->pci_func;
  index = qlcnic_is_valid_nic_func(adapter, (int )pci_func);
  if (index < 0) {
    return (err);
  } else {
  }
  arg1 = (u32 )(adapter->npars + (unsigned long )index)->phy_port & 1U;
  arg1 = (u32 )((int )pci_func << 8) | arg1;
  tmp = __qlcnic_get_eswitch_port_config(adapter, & arg1, & arg2);
  if (tmp != 0) {
    return (err);
  } else {
  }
  arg1 = arg1 & 4294902015U;
  arg1 = (u32 )((int )pci_func << 8) | arg1;
  arg1 = arg1 & 4294967283U;
  switch ((int )esw_cfg->op_mode) {
  case 0:
  arg1 = arg1 | 208U;
  arg2 = arg2 | 3U;
  if (((adapter->ahw)->capabilities & 2U) != 0U) {
    arg2 = arg2 | 12U;
  } else {
  }
  if ((unsigned int )esw_cfg->discard_tagged == 0U) {
    arg1 = arg1 & 4294967279U;
  } else {
  }
  if ((unsigned int )esw_cfg->promisc_mode == 0U) {
    arg1 = arg1 & 4294967231U;
  } else {
  }
  if ((unsigned int )esw_cfg->mac_override == 0U) {
    arg1 = arg1 & 4294967167U;
  } else {
  }
  if ((unsigned int )esw_cfg->mac_anti_spoof == 0U) {
    arg2 = arg2 & 4294967294U;
  } else {
  }
  if (((int )esw_cfg->offload_flags & 1) == 0) {
    arg2 = arg2 & 4294967281U;
  } else {
  }
  if (((int )esw_cfg->offload_flags & 2) == 0) {
    arg2 = arg2 & 4294967291U;
  } else {
  }
  if (((int )esw_cfg->offload_flags & 4) == 0) {
    arg2 = arg2 & 4294967287U;
  } else {
  }
  goto ldv_51236;
  case 1:
  arg1 = arg1 & 65535U;
  arg1 = arg1 | 36U;
  arg1 = (u32 )((int )esw_cfg->vlan_id << 16) | arg1;
  goto ldv_51236;
  case 2:
  arg1 = arg1 | 40U;
  arg1 = arg1 & 65535U;
  goto ldv_51236;
  default:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid opmode 0x%x\n",
          "qlcnic_config_switch_port", (int )esw_cfg->op_mode);
  return (err);
  }
  ldv_51236:
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 40U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = arg1;
  *(cmd.req.arg + 2UL) = arg2;
  err = qlcnic_issue_cmd(adapter, & cmd);
  qlcnic_free_mbx_args(& cmd);
  if (err != 0) {
    dev_err((struct device const *)dev, "Failed to configure eswitch for vNIC function %d\n",
            (int )pci_func);
  } else {
    _dev_info((struct device const *)dev, "Configured eSwitch for vNIC function %d\n",
              (int )pci_func);
  }
  return (err);
}
}
int qlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg )
{
  u32 arg1 ;
  u32 arg2 ;
  int index ;
  u8 phy_port ;
  int tmp ;
  {
  if ((unsigned int )(adapter->ahw)->op_mode == 0U) {
    index = qlcnic_is_valid_nic_func(adapter, (int )esw_cfg->pci_func);
    if (index < 0) {
      return (-5);
    } else {
    }
    phy_port = (adapter->npars + (unsigned long )index)->phy_port;
  } else {
    phy_port = (adapter->ahw)->physical_port;
  }
  arg1 = (u32 )phy_port;
  arg1 = (u32 )((int )esw_cfg->pci_func << 8) | arg1;
  tmp = __qlcnic_get_eswitch_port_config(adapter, & arg1, & arg2);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  esw_cfg->discard_tagged = (arg1 & 16U) != 0U;
  esw_cfg->host_vlan_tag = (arg1 & 32U) != 0U;
  esw_cfg->promisc_mode = (arg1 & 64U) != 0U;
  esw_cfg->mac_override = (arg1 & 128U) != 0U;
  esw_cfg->vlan_id = (unsigned short )(arg1 >> 16);
  esw_cfg->mac_anti_spoof = (unsigned int )((u8 )arg2) & 1U;
  esw_cfg->offload_flags = (unsigned int )((u8 )(arg2 >> 1)) & 7U;
  return (0);
}
}
void *ldv_kmem_cache_alloc_210(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  ldv_dma_zalloc_coherent_213(dev, size, dma_handle, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_216(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_218(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_220(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_221(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_222(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_223(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_224(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_225(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_226(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_227(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_spin_trylock(void) ;
__inline static __u32 __arch_swab32(__u32 val )
{
  {
  __asm__ ("bswapl %0": "=r" (val): "0" (val));
  return (val);
}
}
__inline static __u32 __fswab32(__u32 val )
{
  __u32 tmp ;
  {
  tmp = __arch_swab32(val);
  return (tmp);
}
}
__inline static void __list_splice(struct list_head const *list , struct list_head *prev ,
                                   struct list_head *next )
{
  struct list_head *first ;
  struct list_head *last ;
  {
  first = list->next;
  last = list->prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
  return;
}
}
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head )
{
  int tmp ;
  {
  tmp = list_empty((struct list_head const *)list);
  if (tmp == 0) {
    __list_splice((struct list_head const *)list, head->prev, head);
    INIT_LIST_HEAD(list);
  } else {
  }
  return;
}
}
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h )
{
  struct hlist_node *first ;
  {
  first = h->first;
  n->next = first;
  if ((unsigned long )first != (unsigned long )((struct hlist_node *)0)) {
    first->pprev = & n->next;
  } else {
  }
  h->first = n;
  n->pprev = & h->first;
  return;
}
}
extern unsigned long __phys_addr(unsigned long ) ;
extern void *memmove(void * , void const * , size_t ) ;
extern int _raw_spin_trylock(raw_spinlock_t * ) ;
__inline static void spin_lock(spinlock_t *lock ) ;
__inline static int ldv_spin_trylock_241(spinlock_t *lock )
{
  int tmp ;
  {
  tmp = _raw_spin_trylock(& lock->ldv_6347.rlock);
  return (tmp);
}
}
__inline static int spin_trylock(spinlock_t *lock ) ;
__inline static void spin_unlock(spinlock_t *lock ) ;
void *ldv_kmem_cache_alloc_254(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_271(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
__inline static void *lowmem_page_address(struct page const *page )
{
  {
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n )
{
  {
  return;
}
}
__inline static __sum16 csum16_add(__sum16 csum , __be16 addend )
{
  u16 res ;
  {
  res = csum;
  res = (int )res + (int )addend;
  return ((__sum16 )(((int )res < (int )addend) + (int )res));
}
}
__inline static __sum16 csum16_sub(__sum16 csum , __be16 addend )
{
  __sum16 tmp ;
  {
  tmp = csum16_add((int )csum, ~ ((int )addend));
  return (tmp);
}
}
__inline static void csum_replace2(__sum16 *sum , __be16 old , __be16 new )
{
  __sum16 tmp ;
  __sum16 tmp___0 ;
  {
  tmp = csum16_sub(~ ((int )*sum), (int )old);
  tmp___0 = csum16_add((int )tmp, (int )new);
  *sum = ~ ((int )tmp___0);
  return;
}
}
extern void debug_dma_map_page(struct device * , struct page * , size_t , size_t ,
                               int , dma_addr_t , bool ) ;
extern void debug_dma_mapping_error(struct device * , dma_addr_t ) ;
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_30470: ;
    goto ldv_30470;
  } else {
  }
  tmp___2 = __phys_addr((unsigned long )ptr);
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
  tmp___3 = __phys_addr((unsigned long )ptr);
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
  return (addr);
}
}
__inline static void dma_unmap_single_attrs___0(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ,
                                                struct dma_attrs *attrs )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_30479: ;
    goto ldv_30479;
  } else {
  }
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t ,
                                                                    size_t , enum dma_data_direction ,
                                                                    struct dma_attrs * ))0)) {
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {
  }
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
  return;
}
}
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = lowmem_page_address((struct page const *)page);
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
  tmp___1 = valid_dma_direction((int )dir);
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
  if (tmp___2 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
    ldv_30513: ;
    goto ldv_30513;
  } else {
  }
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
  return (addr);
}
}
__inline static void dma_unmap_page___0(struct device *dev , dma_addr_t addr , size_t size ,
                                        enum dma_data_direction dir )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
    ldv_30521: ;
    goto ldv_30521;
  } else {
  }
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t ,
                                                                    size_t , enum dma_data_direction ,
                                                                    struct dma_attrs * ))0)) {
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {
  }
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
  return;
}
}
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr )
{
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  debug_dma_mapping_error(dev, dma_addr);
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t ))0)) {
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
    return (tmp___0);
  } else {
  }
  return (dma_addr == 0ULL);
}
}
__inline static unsigned int skb_frag_size(skb_frag_t const *frag )
{
  {
  return ((unsigned int )frag->size);
}
}
extern void consume_skb(struct sk_buff * ) ;
struct sk_buff *ldv_skb_clone_262(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_270(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_264(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_260(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_268(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_269(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
__inline static unsigned int skb_headlen(struct sk_buff const *skb )
{
  {
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
extern unsigned char *skb_pull(struct sk_buff * , unsigned int ) ;
extern unsigned char *__pskb_pull_tail(struct sk_buff * , int ) ;
__inline static void skb_reserve(struct sk_buff *skb , int len )
{
  {
  skb->data = skb->data + (unsigned long )len;
  skb->tail = skb->tail + (sk_buff_data_t )len;
  return;
}
}
__inline static unsigned char *skb_inner_transport_header(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->inner_transport_header);
}
}
__inline static unsigned char *skb_inner_network_header(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->inner_network_header);
}
}
__inline static unsigned char *skb_inner_mac_header(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->inner_mac_header);
}
}
__inline static unsigned char *skb_transport_header(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->transport_header);
}
}
__inline static unsigned char *skb_network_header(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
__inline static int skb_transport_offset(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_transport_header(skb);
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
__inline static u32 skb_network_header_len(struct sk_buff const *skb )
{
  {
  return ((u32 )((int )skb->transport_header - (int )skb->network_header));
}
}
__inline static int skb_network_offset(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_network_header(skb);
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
__inline static int skb_inner_network_offset(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_inner_network_header(skb);
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
struct sk_buff *ldv___netdev_alloc_skb_265(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_266(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_267(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
__inline static struct sk_buff *netdev_alloc_skb___0(struct net_device *dev , unsigned int length )
{
  struct sk_buff *tmp ;
  {
  tmp = ldv___netdev_alloc_skb_265(dev, length, 32U);
  return (tmp);
}
}
__inline static struct page *skb_frag_page(skb_frag_t const *frag )
{
  {
  return ((struct page *)frag->page.p);
}
}
__inline static dma_addr_t skb_frag_dma_map(struct device *dev , skb_frag_t const *frag ,
                                            size_t offset , size_t size , enum dma_data_direction dir )
{
  struct page *tmp ;
  dma_addr_t tmp___0 ;
  {
  tmp = skb_frag_page(frag);
  tmp___0 = dma_map_page(dev, tmp, (size_t )frag->page_offset + offset, size, dir);
  return (tmp___0);
}
}
__inline static void skb_copy_from_linear_data(struct sk_buff const *skb , void *to ,
                                               unsigned int const len )
{
  size_t __len ;
  void *__ret ;
  {
  __len = (size_t )len;
  __ret = memcpy(to, (void const *)skb->data, __len);
  return;
}
}
__inline static void skb_copy_from_linear_data_offset(struct sk_buff const *skb ,
                                                      int const offset , void *to ,
                                                      unsigned int const len )
{
  size_t __len ;
  void *__ret ;
  {
  __len = (size_t )len;
  __ret = memcpy(to, (void const *)skb->data + (unsigned long )offset,
                           __len);
  return;
}
}
__inline static u16 skb_get_queue_mapping(struct sk_buff const *skb )
{
  {
  return ((u16 )skb->queue_mapping);
}
}
__inline static bool skb_is_gso(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_end_pointer(skb);
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
__inline static void skb_checksum_none_assert(struct sk_buff const *skb )
{
  {
  return;
}
}
extern void napi_complete(struct napi_struct * ) ;
__inline static void napi_disable(struct napi_struct *n )
{
  int tmp ;
  {
  __might_sleep("include/linux/netdevice.h", 476, 0);
  set_bit(1L, (unsigned long volatile *)(& n->state));
  goto ldv_39779;
  ldv_39778:
  msleep(1U);
  ldv_39779:
  tmp = test_and_set_bit(0L, (unsigned long volatile *)(& n->state));
  if (tmp != 0) {
    goto ldv_39778;
  } else {
  }
  clear_bit(1L, (unsigned long volatile *)(& n->state));
  return;
}
}
__inline static void napi_enable(struct napi_struct *n )
{
  int tmp ;
  long tmp___0 ;
  {
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& n->state));
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
  if (tmp___0 != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (492), "i" (12UL));
    ldv_39784: ;
    goto ldv_39784;
  } else {
  }
  __asm__ volatile ("": : : "memory");
  clear_bit(0L, (unsigned long volatile *)(& n->state));
  return;
}
}
__inline static void napi_synchronize(struct napi_struct const *n )
{
  int tmp ;
  {
  goto ldv_39789;
  ldv_39788:
  msleep(1U);
  ldv_39789:
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& n->state));
  if (tmp != 0) {
    goto ldv_39788;
  } else {
  }
  return;
}
}
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int ) ,
                           int ) ;
extern void netif_napi_del(struct napi_struct * ) ;
__inline static void netif_tx_stop_all_queues(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40720;
  ldv_40719:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_stop_queue(txq);
  i = i + 1U;
  ldv_40720: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40719;
  } else {
  }
  return;
}
}
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue )
{
  int tmp ;
  {
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& dev_queue->state));
  return (tmp != 0);
}
}
extern int netif_receive_skb(struct sk_buff * ) ;
extern gro_result_t napi_gro_receive(struct napi_struct * , struct sk_buff * ) ;
__inline static bool netif_carrier_ok(struct net_device const *dev )
{
  int tmp ;
  {
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& dev->state));
  return (tmp == 0);
}
}
extern void netif_carrier_on(struct net_device * ) ;
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
__inline static struct sk_buff *__vlan_hwaccel_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                       u16 vlan_tci )
{
  {
  skb->vlan_proto = vlan_proto;
  skb->vlan_tci = (__u16 )((unsigned int )vlan_tci | 4096U);
  return (skb);
}
}
__inline static int __vlan_get_tag(struct sk_buff const *skb , u16 *vlan_tci )
{
  struct vlan_ethhdr *veth ;
  __u16 tmp ;
  {
  veth = (struct vlan_ethhdr *)skb->data;
  if ((unsigned int )veth->h_vlan_proto != 129U && (unsigned int )veth->h_vlan_proto != 43144U) {
    return (-22);
  } else {
  }
  tmp = __fswab16((int )veth->h_vlan_TCI);
  *vlan_tci = tmp;
  return (0);
}
}
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_network_header(skb);
  return ((struct iphdr *)tmp);
}
}
__inline static struct iphdr *inner_ip_hdr(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_inner_network_header(skb);
  return ((struct iphdr *)tmp);
}
}
__inline static struct tcphdr *tcp_hdr(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_transport_header(skb);
  return ((struct tcphdr *)tmp);
}
}
__inline static unsigned int tcp_hdrlen(struct sk_buff const *skb )
{
  struct tcphdr *tmp ;
  {
  tmp = tcp_hdr(skb);
  return ((unsigned int )((int )tmp->doff * 4));
}
}
__inline static struct tcphdr *inner_tcp_hdr(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_inner_transport_header(skb);
  return ((struct tcphdr *)tmp);
}
}
__inline static unsigned int inner_tcp_hdrlen(struct sk_buff const *skb )
{
  struct tcphdr *tmp ;
  {
  tmp = inner_tcp_hdr(skb);
  return ((unsigned int )((int )tmp->doff * 4));
}
}
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_network_header(skb);
  return ((struct ipv6hdr *)tmp);
}
}
__inline static struct ipv6hdr *inner_ipv6_hdr(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_inner_network_header(skb);
  return ((struct ipv6hdr *)tmp);
}
}
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction )
{
  dma_addr_t tmp ;
  {
  tmp = dma_map_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             ptr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
  return (tmp);
}
}
__inline static void pci_unmap_single___0(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                          size_t size , int direction )
{
  {
  dma_unmap_single_attrs___0((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             dma_addr, size, (enum dma_data_direction )direction,
                             (struct dma_attrs *)0);
  return;
}
}
__inline static void pci_unmap_page___0(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                        size_t size , int direction )
{
  {
  dma_unmap_page___0((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                     dma_address, size, (enum dma_data_direction )direction);
  return;
}
}
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr )
{
  int tmp ;
  {
  tmp = dma_mapping_error(& pdev->dev, dma_addr);
  return (tmp);
}
}
int qlcnic_83xx_napi_add(struct qlcnic_adapter *adapter , struct net_device *netdev ) ;
void qlcnic_83xx_napi_del(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_napi_enable(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_napi_disable(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_process_rcv_ring_diag(struct qlcnic_host_sds_ring *sds_ring ) ;
__inline static void qlcnic_dcb_aen_handler(struct qlcnic_dcb *dcb , void *msg )
{
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->aen_handler != (unsigned long )((void (*)(struct qlcnic_dcb * ,
                                                                                                                                               void * ))0)) {
    (*((dcb->ops)->aen_handler))(dcb, msg);
  } else {
  }
  return;
}
}
void qlcnic_advert_link_change(struct qlcnic_adapter *adapter , int linkup ) ;
__inline static void qlcnic_change_filter(struct qlcnic_adapter *adapter , u64 *addr ,
                                          u16 id )
{
  {
  (*(((adapter->ahw)->hw_ops)->change_l2_filter))(adapter, addr, (int )id);
  return;
}
}
__inline static void qlcnic_enable_tx_intr(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring )
{
  {
  if ((unsigned long )((adapter->ahw)->hw_ops)->enable_tx_intr != (unsigned long )((void (*)(struct qlcnic_adapter * ,
                                                                                             struct qlcnic_host_tx_ring * ))0)) {
    (*(((adapter->ahw)->hw_ops)->enable_tx_intr))(adapter, tx_ring);
  } else {
  }
  return;
}
}
static int qlcnic_process_rcv_ring(struct qlcnic_host_sds_ring *sds_ring , int max ) ;
static struct sk_buff *qlcnic_process_rxbuf(struct qlcnic_adapter *adapter , struct qlcnic_host_rds_ring *ring ,
                                            u16 index , u16 cksum ) ;
__inline static u8 qlcnic_mac_hash(u64 mac , u16 vlan )
{
  {
  return ((u8 )(((int )((unsigned char )mac) ^ (int )((unsigned char )(mac >> 40))) ^ (int )((unsigned char )vlan)));
}
}
__inline static u32 qlcnic_get_ref_handle(struct qlcnic_adapter *adapter , u16 handle ,
                                          u8 ring_id )
{
  bool tmp ;
  {
  tmp = qlcnic_83xx_check(adapter);
  if ((int )tmp) {
    return ((u32 )((int )handle | ((int )ring_id << 15)));
  } else {
    return ((u32 )handle);
  }
}
}
__inline static int qlcnic_82xx_is_lb_pkt(u64 sts_data )
{
  {
  return (((sts_data >> 4) & 15ULL) == 0ULL);
}
}
static void qlcnic_delete_rx_list_mac(struct qlcnic_adapter *adapter , struct qlcnic_filter *fil ,
                                      void *addr , u16 vlan_id )
{
  int ret ;
  u8 op ;
  {
  op = (unsigned int )vlan_id != 0U ? 3U : 1U;
  ret = qlcnic_sre_macaddr_change(adapter, (u8 *)addr, (int )vlan_id, (int )op);
  if (ret != 0) {
    return;
  } else {
  }
  op = (unsigned int )vlan_id != 0U ? 4U : 2U;
  ret = qlcnic_sre_macaddr_change(adapter, (u8 *)addr, (int )vlan_id, (int )op);
  if (ret == 0) {
    hlist_del(& fil->fnode);
    adapter->rx_fhash.fnum = (u8 )((int )adapter->rx_fhash.fnum - 1);
  } else {
  }
  return;
}
}
static struct qlcnic_filter *qlcnic_find_mac_filter(struct hlist_head *head , void *addr ,
                                                    u16 vlan_id )
{
  struct qlcnic_filter *tmp_fil ;
  struct hlist_node *n ;
  struct hlist_node *____ptr ;
  struct hlist_node const *__mptr ;
  struct qlcnic_filter *tmp ;
  bool tmp___0 ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node const *__mptr___0 ;
  struct qlcnic_filter *tmp___1 ;
  {
  tmp_fil = (struct qlcnic_filter *)0;
  ____ptr = head->first;
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
    __mptr = (struct hlist_node const *)____ptr;
    tmp = (struct qlcnic_filter *)__mptr;
  } else {
    tmp = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp;
  goto ldv_52845;
  ldv_52844:
  tmp___0 = ether_addr_equal((u8 const *)(& tmp_fil->faddr), (u8 const *)addr);
  if ((int )tmp___0 && (int )tmp_fil->vlan_id == (int )vlan_id) {
    return (tmp_fil);
  } else {
  }
  ____ptr___0 = n;
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
    __mptr___0 = (struct hlist_node const *)____ptr___0;
    tmp___1 = (struct qlcnic_filter *)__mptr___0;
  } else {
    tmp___1 = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp___1;
  ldv_52845: ;
  if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
    n = tmp_fil->fnode.next;
    goto ldv_52844;
  } else {
  }
  return ((struct qlcnic_filter *)0);
}
}
static void qlcnic_add_lb_filter(struct qlcnic_adapter *adapter , struct sk_buff *skb ,
                                 int loopback_pkt , u16 vlan_id )
{
  struct ethhdr *phdr ;
  struct qlcnic_filter *fil ;
  struct qlcnic_filter *tmp_fil ;
  struct hlist_head *head ;
  unsigned long time ;
  u64 src_addr ;
  u8 hindex ;
  u8 op ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  u8 tmp___1 ;
  void *tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  phdr = (struct ethhdr *)skb->data;
  src_addr = 0ULL;
  tmp = qlcnic_sriov_pf_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0 || (unsigned int )vlan_id == 65535U) {
    vlan_id = 0U;
  } else {
  }
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& src_addr), (void const *)(& phdr->h_source), __len);
  } else {
    __ret = memcpy((void *)(& src_addr), (void const *)(& phdr->h_source),
                             __len);
  }
  tmp___1 = qlcnic_mac_hash(src_addr, (int )vlan_id);
  hindex = (u8 )((int )((signed char )tmp___1) & (int )((signed char )((unsigned int )((unsigned char )adapter->fhash.fbucket_size) + 255U)));
  if (loopback_pkt != 0) {
    if ((int )((unsigned short )adapter->rx_fhash.fnum) >= (int )adapter->rx_fhash.fmax) {
      return;
    } else {
    }
    head = adapter->rx_fhash.fhead + (unsigned long )hindex;
    tmp_fil = qlcnic_find_mac_filter(head, (void *)(& src_addr), (int )vlan_id);
    if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
      time = tmp_fil->ftime;
      if ((long )((time - (unsigned long )jiffies) + 5000UL) < 0L) {
        tmp_fil->ftime = jiffies;
      } else {
      }
      return;
    } else {
    }
    tmp___2 = kzalloc(32UL, 32U);
    fil = (struct qlcnic_filter *)tmp___2;
    if ((unsigned long )fil == (unsigned long )((struct qlcnic_filter *)0)) {
      return;
    } else {
    }
    fil->ftime = jiffies;
    __len___0 = 6UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& fil->faddr), (void const *)(& src_addr), __len___0);
    } else {
      __ret___0 = memcpy((void *)(& fil->faddr), (void const *)(& src_addr),
                                   __len___0);
    }
    fil->vlan_id = vlan_id;
    spin_lock(& adapter->rx_mac_learn_lock);
    hlist_add_head(& fil->fnode, head);
    adapter->rx_fhash.fnum = (u8 )((int )adapter->rx_fhash.fnum + 1);
    spin_unlock(& adapter->rx_mac_learn_lock);
  } else {
    head = adapter->fhash.fhead + (unsigned long )hindex;
    spin_lock(& adapter->mac_learn_lock);
    tmp_fil = qlcnic_find_mac_filter(head, (void *)(& src_addr), (int )vlan_id);
    if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
      op = (unsigned int )vlan_id != 0U ? 4U : 2U;
      ret = qlcnic_sre_macaddr_change(adapter, (u8 *)(& src_addr), (int )vlan_id,
                                      (int )op);
      if (ret == 0) {
        hlist_del(& tmp_fil->fnode);
        adapter->fhash.fnum = (u8 )((int )adapter->fhash.fnum - 1);
      } else {
      }
      spin_unlock(& adapter->mac_learn_lock);
      return;
    } else {
    }
    spin_unlock(& adapter->mac_learn_lock);
    head = adapter->rx_fhash.fhead + (unsigned long )hindex;
    spin_lock(& adapter->rx_mac_learn_lock);
    tmp_fil = qlcnic_find_mac_filter(head, (void *)(& src_addr), (int )vlan_id);
    if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
      qlcnic_delete_rx_list_mac(adapter, tmp_fil, (void *)(& src_addr), (int )vlan_id);
    } else {
    }
    spin_unlock(& adapter->rx_mac_learn_lock);
  }
  return;
}
}
void qlcnic_82xx_change_filter(struct qlcnic_adapter *adapter , u64 *uaddr , u16 vlan_id )
{
  struct cmd_desc_type0 *hwdesc ;
  struct qlcnic_nic_req *req ;
  struct qlcnic_mac_req *mac_req ;
  struct qlcnic_vlan_req *vlan_req ;
  struct qlcnic_host_tx_ring *tx_ring ;
  u32 producer ;
  u64 word ;
  size_t __len ;
  void *__ret ;
  {
  tx_ring = adapter->tx_ring;
  producer = tx_ring->producer;
  hwdesc = tx_ring->desc_head + (unsigned long )tx_ring->producer;
  req = (struct qlcnic_nic_req *)hwdesc;
  memset((void *)req, 0, 64UL);
  req->qhdr = 167772160ULL;
  word = ((unsigned long long )adapter->portnum << 16) | 1ULL;
  req->req_hdr = word;
  mac_req = (struct qlcnic_mac_req *)(& req->words);
  mac_req->op = (unsigned int )vlan_id != 0U ? 3U : 1U;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& mac_req->mac_addr), (void const *)uaddr, __len);
  } else {
    __ret = memcpy((void *)(& mac_req->mac_addr), (void const *)uaddr,
                             __len);
  }
  vlan_req = (struct qlcnic_vlan_req *)(& req->words) + 1U;
  vlan_req->vlan_id = vlan_id;
  tx_ring->producer = (producer + 1U) & (tx_ring->num_desc - 1U);
  __asm__ volatile ("mfence": : : "memory");
  return;
}
}
static void qlcnic_send_filter(struct qlcnic_adapter *adapter , struct cmd_desc_type0 *first_desc ,
                               struct sk_buff *skb )
{
  struct vlan_ethhdr *vh ;
  struct ethhdr *phdr ;
  u16 protocol ;
  __u16 tmp ;
  struct qlcnic_filter *fil ;
  struct qlcnic_filter *tmp_fil ;
  struct hlist_head *head ;
  struct hlist_node *n ;
  u64 src_addr ;
  u16 vlan_id ;
  u8 hindex ;
  u8 hval ;
  bool tmp___0 ;
  __u16 tmp___1 ;
  size_t __len ;
  void *__ret ;
  struct hlist_node *____ptr ;
  struct hlist_node const *__mptr ;
  struct qlcnic_filter *tmp___2 ;
  bool tmp___3 ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node const *__mptr___0 ;
  struct qlcnic_filter *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  vh = (struct vlan_ethhdr *)skb->data;
  phdr = (struct ethhdr *)skb->data;
  tmp = __fswab16((int )skb->protocol);
  protocol = tmp;
  src_addr = 0ULL;
  vlan_id = 0U;
  tmp___0 = ether_addr_equal((u8 const *)(& phdr->h_source), (u8 const *)(& adapter->mac_addr));
  if ((int )tmp___0) {
    return;
  } else {
  }
  if ((adapter->flags & 8388608U) != 0U) {
    if ((unsigned int )protocol == 33024U) {
      vh = (struct vlan_ethhdr *)skb->data;
      tmp___1 = __fswab16((int )vh->h_vlan_TCI);
      vlan_id = tmp___1;
    } else
    if (((int )skb->vlan_tci & 4096) != 0) {
      vlan_id = (unsigned int )skb->vlan_tci & 61439U;
    } else {
    }
  } else {
  }
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& src_addr), (void const *)(& phdr->h_source), __len);
  } else {
    __ret = memcpy((void *)(& src_addr), (void const *)(& phdr->h_source),
                             __len);
  }
  hval = qlcnic_mac_hash(src_addr, (int )vlan_id);
  hindex = (u8 )((int )((signed char )((unsigned int )((unsigned char )adapter->fhash.fbucket_size) + 255U)) & (int )((signed char )hval));
  head = adapter->fhash.fhead + (unsigned long )hindex;
  ____ptr = head->first;
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
    __mptr = (struct hlist_node const *)____ptr;
    tmp___2 = (struct qlcnic_filter *)__mptr;
  } else {
    tmp___2 = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp___2;
  goto ldv_52918;
  ldv_52917:
  tmp___3 = ether_addr_equal((u8 const *)(& tmp_fil->faddr), (u8 const *)(& src_addr));
  if ((int )tmp___3 && (int )tmp_fil->vlan_id == (int )vlan_id) {
    if (tmp_fil->ftime + 5000UL < (unsigned long )jiffies) {
      qlcnic_change_filter(adapter, & src_addr, (int )vlan_id);
    } else {
    }
    tmp_fil->ftime = jiffies;
    return;
  } else {
  }
  ____ptr___0 = n;
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
    __mptr___0 = (struct hlist_node const *)____ptr___0;
    tmp___4 = (struct qlcnic_filter *)__mptr___0;
  } else {
    tmp___4 = (struct qlcnic_filter *)0;
  }
  tmp_fil = tmp___4;
  ldv_52918: ;
  if ((unsigned long )tmp_fil != (unsigned long )((struct qlcnic_filter *)0)) {
    n = tmp_fil->fnode.next;
    goto ldv_52917;
  } else {
  }
  tmp___5 = ldv__builtin_expect((int )((unsigned short )adapter->fhash.fnum) >= (int )adapter->fhash.fmax,
                             0L);
  if (tmp___5 != 0L) {
    adapter->stats.mac_filter_limit_overrun = adapter->stats.mac_filter_limit_overrun + 1ULL;
    return;
  } else {
  }
  tmp___6 = kzalloc(32UL, 32U);
  fil = (struct qlcnic_filter *)tmp___6;
  if ((unsigned long )fil == (unsigned long )((struct qlcnic_filter *)0)) {
    return;
  } else {
  }
  qlcnic_change_filter(adapter, & src_addr, (int )vlan_id);
  fil->ftime = jiffies;
  fil->vlan_id = vlan_id;
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& fil->faddr), (void const *)(& src_addr), __len___0);
  } else {
    __ret___0 = memcpy((void *)(& fil->faddr), (void const *)(& src_addr),
                                 __len___0);
  }
  spin_lock(& adapter->mac_learn_lock);
  hlist_add_head(& fil->fnode, head);
  adapter->fhash.fnum = (u8 )((int )adapter->fhash.fnum + 1);
  spin_unlock(& adapter->mac_learn_lock);
  return;
}
}
static int qlcnic_tx_encap_pkt(struct qlcnic_adapter *adapter , struct cmd_desc_type0 *first_desc ,
                               struct sk_buff *skb , struct qlcnic_host_tx_ring *tx_ring )
{
  u8 opcode ;
  u8 inner_hdr_len ;
  u8 outer_hdr_len ;
  u8 total_hdr_len ;
  int copied ;
  int copy_len ;
  int descr_size ;
  u32 producer ;
  struct cmd_desc_type0 *hwdesc ;
  u16 flags ;
  u16 encap_descr ;
  unsigned char *tmp ;
  unsigned int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int _min1 ;
  int _min2 ;
  struct ipv6hdr *tmp___4 ;
  struct iphdr *tmp___5 ;
  struct iphdr *tmp___6 ;
  bool tmp___7 ;
  struct iphdr *tmp___8 ;
  u32 tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___11 ;
  int tmp___12 ;
  {
  opcode = 0U;
  inner_hdr_len = 0U;
  outer_hdr_len = 0U;
  total_hdr_len = 0U;
  producer = tx_ring->producer;
  flags = 0U;
  encap_descr = 0U;
  opcode = 1U;
  encap_descr = 1U;
  tmp___7 = skb_is_gso((struct sk_buff const *)skb);
  if ((int )tmp___7) {
    tmp = skb_inner_transport_header((struct sk_buff const *)skb);
    tmp___0 = inner_tcp_hdrlen((struct sk_buff const *)skb);
    tmp___1 = skb_inner_mac_header((struct sk_buff const *)skb);
    inner_hdr_len = (int )((u8 )((long )(tmp + (unsigned long )tmp___0))) - (int )((u8 )((long )tmp___1));
    tmp___2 = skb_transport_offset((struct sk_buff const *)skb);
    outer_hdr_len = (unsigned int )((u8 )tmp___2) + 16U;
    first_desc->outer_hdr_length = outer_hdr_len;
    total_hdr_len = (int )inner_hdr_len + (int )outer_hdr_len;
    encap_descr = (u16 )((unsigned int )encap_descr | 48U);
    tmp___3 = skb_end_pointer((struct sk_buff const *)skb);
    first_desc->mss = ((struct skb_shared_info *)tmp___3)->gso_size;
    first_desc->hdr_length = inner_hdr_len;
    copied = 0;
    descr_size = 64;
    goto ldv_52944;
    ldv_52943:
    _min1 = descr_size;
    _min2 = (int )total_hdr_len - copied;
    copy_len = _min1 < _min2 ? _min1 : _min2;
    hwdesc = tx_ring->desc_head + (unsigned long )producer;
    (tx_ring->cmd_buf_arr + (unsigned long )producer)->skb = (struct sk_buff *)0;
    skb_copy_from_linear_data_offset((struct sk_buff const *)skb, copied, (void *)hwdesc,
                                     (unsigned int const )copy_len);
    copied = copied + copy_len;
    producer = (producer + 1U) & (tx_ring->num_desc - 1U);
    ldv_52944: ;
    if ((int )total_hdr_len > copied) {
      goto ldv_52943;
    } else {
    }
    tx_ring->producer = producer;
    __asm__ volatile ("mfence": : : "memory");
    adapter->stats.encap_lso_frames = adapter->stats.encap_lso_frames + 1ULL;
    opcode = 8U;
  } else
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 12U) {
    tmp___6 = inner_ip_hdr((struct sk_buff const *)skb);
    if ((unsigned int )*((unsigned char *)tmp___6 + 0UL) == 96U) {
      tmp___4 = inner_ipv6_hdr((struct sk_buff const *)skb);
      if ((unsigned int )tmp___4->nexthdr == 17U) {
        encap_descr = (u16 )((unsigned int )encap_descr | 8U);
      } else {
      }
    } else {
      tmp___5 = inner_ip_hdr((struct sk_buff const *)skb);
      if ((unsigned int )tmp___5->protocol == 17U) {
        encap_descr = (u16 )((unsigned int )encap_descr | 8U);
      } else {
      }
    }
    adapter->stats.encap_tx_csummed = adapter->stats.encap_tx_csummed + 1ULL;
    opcode = 7U;
  } else {
  }
  tmp___8 = ip_hdr((struct sk_buff const *)skb);
  if ((unsigned int )*((unsigned char *)tmp___8 + 0UL) == 96U) {
    encap_descr = (u16 )((unsigned int )encap_descr | 2U);
  } else {
  }
  tmp___9 = skb_network_header_len((struct sk_buff const *)skb);
  encap_descr = ((int )((u16 )(tmp___9 >> 2)) << 6U) | (int )encap_descr;
  tmp___10 = skb_network_offset((struct sk_buff const *)skb);
  encap_descr = (u16 )((int )((short )(tmp___10 << 10)) | (int )((short )encap_descr));
  first_desc->encap_descr = encap_descr;
  tmp___11 = skb_inner_transport_header((struct sk_buff const *)skb);
  first_desc->tcp_hdr_offset = (int )((u8 )((long )tmp___11)) - (int )((u8 )((long )skb->data));
  tmp___12 = skb_inner_network_offset((struct sk_buff const *)skb);
  first_desc->ip_hdr_offset = (u8 )tmp___12;
  first_desc->flags_opcode = (__le16 )((int )first_desc->flags_opcode | (int )((unsigned short )(((int )((short )flags) & 127) | (int )((short )(((int )opcode & 63) << 7)))));
  return (0);
}
}
static int qlcnic_tx_pkt(struct qlcnic_adapter *adapter , struct cmd_desc_type0 *first_desc ,
                         struct sk_buff *skb , struct qlcnic_host_tx_ring *tx_ring )
{
  u8 l4proto ;
  u8 opcode ;
  u8 hdr_len ;
  u16 flags ;
  u16 vlan_tci ;
  int copied ;
  int offset ;
  int copy_len ;
  int size ;
  struct cmd_desc_type0 *hwdesc ;
  struct vlan_ethhdr *vh ;
  u16 protocol ;
  __u16 tmp ;
  u32 producer ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  long tmp___2 ;
  size_t __len ;
  void *__ret ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned char *tmp___5 ;
  int _min1 ;
  int _min2 ;
  __u16 tmp___6 ;
  int _min1___0 ;
  int _min2___0 ;
  struct iphdr *tmp___7 ;
  struct ipv6hdr *tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  {
  opcode = 0U;
  hdr_len = 0U;
  flags = 0U;
  vlan_tci = 0U;
  tmp = __fswab16((int )skb->protocol);
  protocol = tmp;
  producer = tx_ring->producer;
  if ((unsigned int )protocol == 33024U) {
    vh = (struct vlan_ethhdr *)skb->data;
    flags = 16U;
    tmp___0 = __fswab16((int )vh->h_vlan_TCI);
    vlan_tci = tmp___0;
    tmp___1 = __fswab16((int )vh->h_vlan_encapsulated_proto);
    protocol = tmp___1;
  } else
  if (((int )skb->vlan_tci & 4096) != 0) {
    flags = 64U;
    vlan_tci = (unsigned int )skb->vlan_tci & 61439U;
  } else {
  }
  tmp___2 = ldv__builtin_expect((unsigned int )adapter->tx_pvid != 0U, 0L);
  if (tmp___2 != 0L) {
    if ((unsigned int )vlan_tci != 0U && (adapter->flags & 256U) == 0U) {
      return (-5);
    } else {
    }
    if ((unsigned int )vlan_tci != 0U && (adapter->flags & 256U) != 0U) {
      goto set_flags;
    } else {
    }
    flags = 64U;
    vlan_tci = adapter->tx_pvid;
  } else {
  }
  set_flags:
  first_desc->vlan_TCI = vlan_tci;
  first_desc->flags_opcode = (__le16 )((int )first_desc->flags_opcode | (int )((unsigned short )(((int )((short )flags) & 127) | (int )((short )(((int )opcode & 63) << 7)))));
  if ((int )*(skb->data) & 1) {
    flags = (u16 )((unsigned int )flags | 1U);
    __len = 6UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& first_desc->eth_addr), (void const *)skb->data,
                       __len);
    } else {
      __ret = memcpy((void *)(& first_desc->eth_addr), (void const *)skb->data,
                               __len);
    }
  } else {
  }
  opcode = 1U;
  tmp___9 = skb_is_gso((struct sk_buff const *)skb);
  if ((int )tmp___9) {
    tmp___3 = skb_transport_offset((struct sk_buff const *)skb);
    tmp___4 = tcp_hdrlen((struct sk_buff const *)skb);
    hdr_len = (int )((u8 )tmp___3) + (int )((u8 )tmp___4);
    tmp___5 = skb_end_pointer((struct sk_buff const *)skb);
    first_desc->mss = ((struct skb_shared_info *)tmp___5)->gso_size;
    first_desc->hdr_length = hdr_len;
    opcode = (unsigned int )protocol == 34525U ? 6U : 5U;
    copied = 0;
    offset = 2;
    if (((int )flags & 64) != 0) {
      first_desc->hdr_length = (unsigned int )first_desc->hdr_length + 4U;
      first_desc->tcp_hdr_offset = 4U;
      first_desc->ip_hdr_offset = 4U;
      flags = (u16 )((unsigned int )flags | 16U);
      hwdesc = tx_ring->desc_head + (unsigned long )producer;
      (tx_ring->cmd_buf_arr + (unsigned long )producer)->skb = (struct sk_buff *)0;
      _min1 = 64 - offset;
      _min2 = (int )hdr_len + 4;
      copy_len = _min1 < _min2 ? _min1 : _min2;
      vh = (struct vlan_ethhdr *)hwdesc + 2U;
      skb_copy_from_linear_data((struct sk_buff const *)skb, (void *)vh, 12U);
      vh->h_vlan_proto = 129U;
      tmp___6 = __fswab16((int )vlan_tci);
      vh->h_vlan_TCI = tmp___6;
      skb_copy_from_linear_data_offset((struct sk_buff const *)skb, 12, (void *)vh + 16U,
                                       (unsigned int const )(copy_len + -16));
      copied = copy_len + -4;
      offset = 0;
      producer = (producer + 1U) & (tx_ring->num_desc - 1U);
    } else {
    }
    goto ldv_52976;
    ldv_52975:
    size = 64 - offset;
    _min1___0 = size;
    _min2___0 = (int )hdr_len - copied;
    copy_len = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
    hwdesc = tx_ring->desc_head + (unsigned long )producer;
    (tx_ring->cmd_buf_arr + (unsigned long )producer)->skb = (struct sk_buff *)0;
    skb_copy_from_linear_data_offset((struct sk_buff const *)skb, copied, (void *)hwdesc + (unsigned long )offset,
                                     (unsigned int const )copy_len);
    copied = copied + copy_len;
    offset = 0;
    producer = (producer + 1U) & (tx_ring->num_desc - 1U);
    ldv_52976: ;
    if ((int )hdr_len > copied) {
      goto ldv_52975;
    } else {
    }
    tx_ring->producer = producer;
    __asm__ volatile ("mfence": : : "memory");
    adapter->stats.lso_frames = adapter->stats.lso_frames + 1ULL;
  } else
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 12U) {
    if ((unsigned int )protocol == 2048U) {
      tmp___7 = ip_hdr((struct sk_buff const *)skb);
      l4proto = tmp___7->protocol;
      if ((unsigned int )l4proto == 6U) {
        opcode = 2U;
      } else
      if ((unsigned int )l4proto == 17U) {
        opcode = 3U;
      } else {
      }
    } else
    if ((unsigned int )protocol == 34525U) {
      tmp___8 = ipv6_hdr((struct sk_buff const *)skb);
      l4proto = tmp___8->nexthdr;
      if ((unsigned int )l4proto == 6U) {
        opcode = 11U;
      } else
      if ((unsigned int )l4proto == 17U) {
        opcode = 12U;
      } else {
      }
    } else {
    }
  } else {
  }
  tmp___10 = skb_transport_offset((struct sk_buff const *)skb);
  first_desc->tcp_hdr_offset = (int )first_desc->tcp_hdr_offset + (int )((u8 )tmp___10);
  tmp___11 = skb_network_offset((struct sk_buff const *)skb);
  first_desc->ip_hdr_offset = (int )first_desc->ip_hdr_offset + (int )((u8 )tmp___11);
  first_desc->flags_opcode = (__le16 )((int )first_desc->flags_opcode | (int )((unsigned short )(((int )((short )flags) & 127) | (int )((short )(((int )opcode & 63) << 7)))));
  return (0);
}
}
static int qlcnic_map_tx_skb(struct pci_dev *pdev , struct sk_buff *skb , struct qlcnic_cmd_buffer *pbuf )
{
  struct qlcnic_skb_frag *nf ;
  struct skb_frag_struct *frag ;
  int i ;
  int nr_frags ;
  dma_addr_t map ;
  unsigned char *tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  {
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  nr_frags = (int )((struct skb_shared_info *)tmp)->nr_frags;
  nf = (struct qlcnic_skb_frag *)(& pbuf->frag_array);
  tmp___0 = skb_headlen((struct sk_buff const *)skb);
  map = pci_map_single(pdev, (void *)skb->data, (size_t )tmp___0, 1);
  tmp___1 = pci_dma_mapping_error(pdev, map);
  if (tmp___1 != 0) {
    goto out_err;
  } else {
  }
  nf->dma = map;
  tmp___2 = skb_headlen((struct sk_buff const *)skb);
  nf->length = (u64 )tmp___2;
  i = 0;
  goto ldv_52991;
  ldv_52990:
  tmp___3 = skb_end_pointer((struct sk_buff const *)skb);
  frag = (struct skb_frag_struct *)(& ((struct skb_shared_info *)tmp___3)->frags) + (unsigned long )i;
  nf = (struct qlcnic_skb_frag *)(& pbuf->frag_array) + ((unsigned long )i + 1UL);
  tmp___4 = skb_frag_size((skb_frag_t const *)frag);
  map = skb_frag_dma_map(& pdev->dev, (skb_frag_t const *)frag, 0UL, (size_t )tmp___4,
                         1);
  tmp___5 = dma_mapping_error(& pdev->dev, map);
  if (tmp___5 != 0) {
    goto unwind;
  } else {
  }
  nf->dma = map;
  tmp___6 = skb_frag_size((skb_frag_t const *)frag);
  nf->length = (u64 )tmp___6;
  i = i + 1;
  ldv_52991: ;
  if (i < nr_frags) {
    goto ldv_52990;
  } else {
  }
  return (0);
  unwind: ;
  goto ldv_52994;
  ldv_52993:
  nf = (struct qlcnic_skb_frag *)(& pbuf->frag_array) + ((unsigned long )i + 1UL);
  pci_unmap_page___0(pdev, nf->dma, (size_t )nf->length, 1);
  ldv_52994:
  i = i - 1;
  if (i >= 0) {
    goto ldv_52993;
  } else {
  }
  nf = (struct qlcnic_skb_frag *)(& pbuf->frag_array);
  tmp___7 = skb_headlen((struct sk_buff const *)skb);
  pci_unmap_single___0(pdev, nf->dma, (size_t )tmp___7, 1);
  out_err: ;
  return (-12);
}
}
static void qlcnic_unmap_buffers(struct pci_dev *pdev , struct sk_buff *skb , struct qlcnic_cmd_buffer *pbuf )
{
  struct qlcnic_skb_frag *nf ;
  int i ;
  int nr_frags ;
  unsigned char *tmp ;
  unsigned int tmp___0 ;
  {
  nf = (struct qlcnic_skb_frag *)(& pbuf->frag_array);
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  nr_frags = (int )((struct skb_shared_info *)tmp)->nr_frags;
  i = 0;
  goto ldv_53005;
  ldv_53004:
  nf = (struct qlcnic_skb_frag *)(& pbuf->frag_array) + ((unsigned long )i + 1UL);
  pci_unmap_page___0(pdev, nf->dma, (size_t )nf->length, 1);
  i = i + 1;
  ldv_53005: ;
  if (i < nr_frags) {
    goto ldv_53004;
  } else {
  }
  nf = (struct qlcnic_skb_frag *)(& pbuf->frag_array);
  tmp___0 = skb_headlen((struct sk_buff const *)skb);
  pci_unmap_single___0(pdev, nf->dma, (size_t )tmp___0, 1);
  pbuf->skb = (struct sk_buff *)0;
  return;
}
}
__inline static void qlcnic_clear_cmddesc(u64 *desc )
{
  {
  *desc = 0ULL;
  *(desc + 2UL) = 0ULL;
  *(desc + 7UL) = 0ULL;
  return;
}
}
netdev_tx_t qlcnic_xmit_frame(struct sk_buff *skb , struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_cmd_buffer *pbuf ;
  struct qlcnic_skb_frag *buffrag ;
  struct cmd_desc_type0 *hwdesc ;
  struct cmd_desc_type0 *first_desc ;
  struct pci_dev *pdev ;
  struct ethhdr *phdr ;
  int i ;
  int k ;
  int frag_count ;
  int delta ;
  u32 producer ;
  u32 num_txd ;
  u16 protocol ;
  bool l4_is_udp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  u16 tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  __u16 tmp___15 ;
  struct iphdr *tmp___16 ;
  struct ipv6hdr *tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;
  int tmp___20 ;
  long tmp___21 ;
  bool tmp___22 ;
  int tmp___23 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  delta = 0;
  l4_is_udp = 0;
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    netif_tx_stop_all_queues(netdev);
    return (16);
  } else {
  }
  if ((adapter->flags & 512U) != 0U) {
    phdr = (struct ethhdr *)skb->data;
    tmp___1 = ether_addr_equal((u8 const *)(& phdr->h_source), (u8 const *)(& adapter->mac_addr));
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      goto drop_packet;
    } else {
    }
  } else {
  }
  tmp___3 = skb_get_queue_mapping((struct sk_buff const *)skb);
  tx_ring = adapter->tx_ring + (unsigned long )tmp___3;
  num_txd = tx_ring->num_desc;
  tmp___4 = skb_end_pointer((struct sk_buff const *)skb);
  frag_count = (int )((struct skb_shared_info *)tmp___4)->nr_frags + 1;
  tmp___9 = skb_is_gso((struct sk_buff const *)skb);
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10 && frag_count > 14) {
    i = 0;
    goto ldv_53032;
    ldv_53031:
    tmp___5 = skb_end_pointer((struct sk_buff const *)skb);
    tmp___6 = skb_frag_size((skb_frag_t const *)(& ((struct skb_shared_info *)tmp___5)->frags) + (unsigned long )i);
    delta = (int )(tmp___6 + (unsigned int )delta);
    i = i + 1;
    ldv_53032: ;
    if (frag_count + -14 > i) {
      goto ldv_53031;
    } else {
    }
    tmp___7 = __pskb_pull_tail(skb, delta);
    if ((unsigned long )tmp___7 == (unsigned long )((unsigned char *)0U)) {
      goto drop_packet;
    } else {
    }
    tmp___8 = skb_end_pointer((struct sk_buff const *)skb);
    frag_count = (int )((struct skb_shared_info *)tmp___8)->nr_frags + 1;
  } else {
  }
  tmp___12 = qlcnic_tx_avail(tx_ring);
  tmp___13 = ldv__builtin_expect(tmp___12 <= 10U, 0L);
  if (tmp___13 != 0L) {
    netif_tx_stop_queue(tx_ring->txq);
    tmp___11 = qlcnic_tx_avail(tx_ring);
    if (tmp___11 > 10U) {
      netif_tx_start_queue(tx_ring->txq);
    } else {
      tx_ring->tx_stats.xmit_off = tx_ring->tx_stats.xmit_off + 1ULL;
      return (16);
    }
  } else {
  }
  producer = tx_ring->producer;
  pbuf = tx_ring->cmd_buf_arr + (unsigned long )producer;
  pdev = adapter->pdev;
  first_desc = tx_ring->desc_head + (unsigned long )producer;
  hwdesc = tx_ring->desc_head + (unsigned long )producer;
  qlcnic_clear_cmddesc((u64 *)hwdesc);
  tmp___14 = qlcnic_map_tx_skb(pdev, skb, pbuf);
  if (tmp___14 != 0) {
    adapter->stats.tx_dma_map_error = adapter->stats.tx_dma_map_error + 1ULL;
    goto drop_packet;
  } else {
  }
  pbuf->skb = skb;
  pbuf->frag_count = (u32 )frag_count;
  first_desc->nfrags__length = ((unsigned int )frag_count & 255U) | (skb->len << 8);
  first_desc->port_ctxid = (u8 )(((int )((signed char )adapter->portnum) & 15) | (int )((signed char )((int )adapter->portnum << 4)));
  i = 0;
  goto ldv_53040;
  ldv_53039:
  k = i % 4;
  if (k == 0 && i > 0) {
    producer = (producer + 1U) & (num_txd - 1U);
    hwdesc = tx_ring->desc_head + (unsigned long )producer;
    qlcnic_clear_cmddesc((u64 *)hwdesc);
    (tx_ring->cmd_buf_arr + (unsigned long )producer)->skb = (struct sk_buff *)0;
  } else {
  }
  buffrag = (struct qlcnic_skb_frag *)(& pbuf->frag_array) + (unsigned long )i;
  hwdesc->buffer_length[k] = (unsigned short )buffrag->length;
  switch (k) {
  case 0:
  hwdesc->addr_buffer1 = buffrag->dma;
  goto ldv_53035;
  case 1:
  hwdesc->addr_buffer2 = buffrag->dma;
  goto ldv_53035;
  case 2:
  hwdesc->addr_buffer3 = buffrag->dma;
  goto ldv_53035;
  case 3:
  hwdesc->addr_buffer4 = buffrag->dma;
  goto ldv_53035;
  }
  ldv_53035:
  i = i + 1;
  ldv_53040: ;
  if (i < frag_count) {
    goto ldv_53039;
  } else {
  }
  tx_ring->producer = (producer + 1U) & (num_txd - 1U);
  __asm__ volatile ("mfence": : : "memory");
  tmp___15 = __fswab16((int )skb->protocol);
  protocol = tmp___15;
  if ((unsigned int )protocol == 2048U) {
    tmp___16 = ip_hdr((struct sk_buff const *)skb);
    l4_is_udp = (unsigned int )tmp___16->protocol == 17U;
  } else
  if ((unsigned int )protocol == 34525U) {
    tmp___17 = ipv6_hdr((struct sk_buff const *)skb);
    l4_is_udp = (unsigned int )tmp___17->nexthdr == 17U;
  } else {
  }
  if ((unsigned int )*((unsigned char *)skb + 171UL) == 0U || ! l4_is_udp) {
    goto _L;
  } else {
    tmp___22 = qlcnic_encap_tx_offload(adapter);
    if (tmp___22) {
      tmp___23 = 0;
    } else {
      tmp___23 = 1;
    }
    if (tmp___23) {
      _L:
      tmp___18 = qlcnic_tx_pkt(adapter, first_desc, skb, tx_ring);
      tmp___19 = ldv__builtin_expect(tmp___18 != 0, 0L);
      if (tmp___19 != 0L) {
        goto unwind_buff;
      } else {
      }
    } else {
      tmp___20 = qlcnic_tx_encap_pkt(adapter, first_desc, skb, tx_ring);
      tmp___21 = ldv__builtin_expect(tmp___20 != 0, 0L);
      if (tmp___21 != 0L) {
        goto unwind_buff;
      } else {
      }
    }
  }
  if ((int )adapter->drv_mac_learn) {
    qlcnic_send_filter(adapter, first_desc, skb);
  } else {
  }
  tx_ring->tx_stats.tx_bytes = tx_ring->tx_stats.tx_bytes + (u64 )skb->len;
  tx_ring->tx_stats.xmit_called = tx_ring->tx_stats.xmit_called + 1ULL;
  qlcnic_update_cmd_producer(tx_ring);
  return (0);
  unwind_buff:
  qlcnic_unmap_buffers(pdev, skb, pbuf);
  drop_packet:
  adapter->stats.txdropped = adapter->stats.txdropped + 1ULL;
  dev_kfree_skb_any(skb);
  return (0);
}
}
void qlcnic_advert_link_change(struct qlcnic_adapter *adapter , int linkup )
{
  struct net_device *netdev ;
  bool tmp ;
  {
  netdev = adapter->netdev;
  if ((unsigned int )(adapter->ahw)->linkup != 0U && linkup == 0) {
    netdev_info((struct net_device const *)netdev, "NIC Link is down\n");
    (adapter->ahw)->linkup = 0U;
    netif_carrier_off(netdev);
  } else
  if ((unsigned int )(adapter->ahw)->linkup == 0U && linkup != 0) {
    (adapter->ahw)->linkup = 1U;
    tmp = qlcnic_83xx_check(adapter);
    if ((int )tmp && (unsigned int )(adapter->ahw)->lb_mode != 0U) {
      netdev_info((struct net_device const *)netdev, "NIC Link is up for loopback test\n");
      return;
    } else {
    }
    netdev_info((struct net_device const *)netdev, "NIC Link is up\n");
    netif_carrier_on(netdev);
  } else {
  }
  return;
}
}
static int qlcnic_alloc_rx_skb(struct qlcnic_adapter *adapter , struct qlcnic_host_rds_ring *rds_ring ,
                               struct qlcnic_rx_buffer *buffer )
{
  struct sk_buff *skb ;
  dma_addr_t dma ;
  struct pci_dev *pdev ;
  int tmp ;
  {
  pdev = adapter->pdev;
  skb = netdev_alloc_skb___0(adapter->netdev, rds_ring->skb_size);
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    adapter->stats.skb_alloc_failure = adapter->stats.skb_alloc_failure + 1ULL;
    return (-12);
  } else {
  }
  skb_reserve(skb, 0);
  dma = pci_map_single(pdev, (void *)skb->data, (size_t )rds_ring->dma_size, 2);
  tmp = pci_dma_mapping_error(pdev, dma);
  if (tmp != 0) {
    adapter->stats.rx_dma_map_error = adapter->stats.rx_dma_map_error + 1ULL;
    dev_kfree_skb_any(skb);
    return (-12);
  } else {
  }
  buffer->skb = skb;
  buffer->dma = dma;
  return (0);
}
}
static void qlcnic_post_rx_buffers_nodb(struct qlcnic_adapter *adapter , struct qlcnic_host_rds_ring *rds_ring ,
                                        u8 ring_id )
{
  struct rcv_desc *pdesc ;
  struct qlcnic_rx_buffer *buffer ;
  int count ;
  uint32_t producer ;
  uint32_t handle ;
  struct list_head *head ;
  int tmp ;
  struct list_head const *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  {
  count = 0;
  tmp = spin_trylock(& rds_ring->lock);
  if (tmp == 0) {
    return;
  } else {
  }
  producer = rds_ring->producer;
  head = & rds_ring->free_list;
  goto ldv_53071;
  ldv_53070:
  __mptr = (struct list_head const *)head->next;
  buffer = (struct qlcnic_rx_buffer *)__mptr + 0xfffffffffffffff0UL;
  if ((unsigned long )buffer->skb == (unsigned long )((struct sk_buff *)0)) {
    tmp___0 = qlcnic_alloc_rx_skb(adapter, rds_ring, buffer);
    if (tmp___0 != 0) {
      goto ldv_53069;
    } else {
    }
  } else {
  }
  count = count + 1;
  list_del(& buffer->list);
  pdesc = rds_ring->desc_head + (unsigned long )producer;
  handle = qlcnic_get_ref_handle(adapter, (int )buffer->ref_handle, (int )ring_id);
  pdesc->reference_handle = (unsigned short )handle;
  pdesc->buffer_length = rds_ring->dma_size;
  pdesc->addr_buffer = buffer->dma;
  producer = (producer + 1U) & (rds_ring->num_desc - 1U);
  ldv_53071:
  tmp___1 = list_empty((struct list_head const *)head);
  if (tmp___1 == 0) {
    goto ldv_53070;
  } else {
  }
  ldv_53069: ;
  if (count != 0) {
    rds_ring->producer = producer;
    writel((producer - 1U) & (rds_ring->num_desc - 1U), (void volatile *)rds_ring->crb_rcv_producer);
  } else {
  }
  spin_unlock(& rds_ring->lock);
  return;
}
}
static int qlcnic_process_cmd_ring(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring ,
                                   int budget )
{
  u32 sw_consumer ;
  u32 hw_consumer ;
  int i ;
  int done ;
  int count ;
  struct qlcnic_cmd_buffer *buffer ;
  struct pci_dev *pdev ;
  struct net_device *netdev ;
  struct qlcnic_skb_frag *frag ;
  int tmp ;
  u32 tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  count = 0;
  pdev = adapter->pdev;
  netdev = adapter->netdev;
  tmp = spin_trylock(& tx_ring->tx_clean_lock);
  if (tmp == 0) {
    return (1);
  } else {
  }
  sw_consumer = tx_ring->sw_consumer;
  hw_consumer = *(tx_ring->hw_consumer);
  goto ldv_53091;
  ldv_53090:
  buffer = tx_ring->cmd_buf_arr + (unsigned long )sw_consumer;
  if ((unsigned long )buffer->skb != (unsigned long )((struct sk_buff *)0)) {
    frag = (struct qlcnic_skb_frag *)(& buffer->frag_array);
    pci_unmap_single___0(pdev, frag->dma, (size_t )frag->length, 1);
    frag->dma = 0ULL;
    i = 1;
    goto ldv_53087;
    ldv_53086:
    frag = frag + 1;
    pci_unmap_page___0(pdev, frag->dma, (size_t )frag->length, 1);
    frag->dma = 0ULL;
    i = i + 1;
    ldv_53087: ;
    if ((u32 )i < buffer->frag_count) {
      goto ldv_53086;
    } else {
    }
    tx_ring->tx_stats.xmit_finished = tx_ring->tx_stats.xmit_finished + 1ULL;
    dev_kfree_skb_any(buffer->skb);
    buffer->skb = (struct sk_buff *)0;
  } else {
  }
  sw_consumer = (sw_consumer + 1U) & (tx_ring->num_desc - 1U);
  count = count + 1;
  if (count >= budget) {
    goto ldv_53089;
  } else {
  }
  ldv_53091: ;
  if (sw_consumer != hw_consumer) {
    goto ldv_53090;
  } else {
  }
  ldv_53089:
  tx_ring->sw_consumer = sw_consumer;
  if (count != 0) {
    tmp___3 = netif_running((struct net_device const *)netdev);
    if ((int )tmp___3) {
      __asm__ volatile ("mfence": : : "memory");
      tmp___1 = netif_tx_queue_stopped((struct netdev_queue const *)tx_ring->txq);
      if ((int )tmp___1) {
        tmp___2 = netif_carrier_ok((struct net_device const *)netdev);
        if ((int )tmp___2) {
          tmp___0 = qlcnic_tx_avail(tx_ring);
          if (tmp___0 > 10U) {
            netif_tx_wake_queue(tx_ring->txq);
            tx_ring->tx_stats.xmit_on = tx_ring->tx_stats.xmit_on + 1ULL;
          } else {
          }
        } else {
        }
      } else {
      }
      adapter->tx_timeo_cnt = 0U;
    } else {
    }
  } else {
  }
  hw_consumer = *(tx_ring->hw_consumer);
  done = sw_consumer == hw_consumer;
  spin_unlock(& tx_ring->tx_clean_lock);
  return (done);
}
}
static int qlcnic_poll(struct napi_struct *napi , int budget )
{
  int tx_complete ;
  int work_done ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct napi_struct const *__mptr ;
  int tmp ;
  {
  __mptr = (struct napi_struct const *)napi;
  sds_ring = (struct qlcnic_host_sds_ring *)__mptr + 0xffffffffffffffd8UL;
  adapter = sds_ring->adapter;
  tx_ring = sds_ring->tx_ring;
  tx_complete = qlcnic_process_cmd_ring(adapter, tx_ring, budget);
  work_done = qlcnic_process_rcv_ring(sds_ring, budget);
  if (work_done < budget && tx_complete != 0) {
    napi_complete(& sds_ring->napi);
    tmp = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
    if (tmp != 0) {
      qlcnic_enable_sds_intr(adapter, sds_ring);
      qlcnic_enable_tx_intr(adapter, tx_ring);
    } else {
    }
  } else {
  }
  return (work_done);
}
}
static int qlcnic_tx_poll(struct napi_struct *napi , int budget )
{
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_adapter *adapter ;
  int work_done ;
  struct napi_struct const *__mptr ;
  int tmp ;
  {
  __mptr = (struct napi_struct const *)napi;
  tx_ring = (struct qlcnic_host_tx_ring *)__mptr + 0xffffffffffffff80UL;
  adapter = tx_ring->adapter;
  work_done = qlcnic_process_cmd_ring(adapter, tx_ring, budget);
  if (work_done != 0) {
    napi_complete(& tx_ring->napi);
    tmp = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
    if (tmp != 0) {
      qlcnic_enable_tx_intr(adapter, tx_ring);
    } else {
    }
  } else {
  }
  return (work_done);
}
}
static int qlcnic_rx_poll(struct napi_struct *napi , int budget )
{
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  int work_done ;
  struct napi_struct const *__mptr ;
  int tmp ;
  {
  __mptr = (struct napi_struct const *)napi;
  sds_ring = (struct qlcnic_host_sds_ring *)__mptr + 0xffffffffffffffd8UL;
  adapter = sds_ring->adapter;
  work_done = qlcnic_process_rcv_ring(sds_ring, budget);
  if (work_done < budget) {
    napi_complete(& sds_ring->napi);
    tmp = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
    if (tmp != 0) {
      qlcnic_enable_sds_intr(adapter, sds_ring);
    } else {
    }
  } else {
  }
  return (work_done);
}
}
static void qlcnic_handle_linkevent(struct qlcnic_adapter *adapter , struct qlcnic_fw_msg *msg )
{
  u32 cable_OUI ;
  u16 cable_len ;
  u16 link_speed ;
  u8 link_status ;
  u8 module ;
  u8 duplex ;
  u8 autoneg ;
  u8 lb_status ;
  struct net_device *netdev ;
  {
  lb_status = 0U;
  netdev = adapter->netdev;
  (adapter->ahw)->has_link_events = 1U;
  cable_OUI = (u32 )msg->ldv_51620.ldv_51618.body[1];
  cable_len = (u16 )(msg->ldv_51620.ldv_51618.body[1] >> 32);
  link_speed = (u16 )(msg->ldv_51620.ldv_51618.body[1] >> 48);
  link_status = (u8 )msg->ldv_51620.ldv_51618.body[2];
  duplex = (u8 )(msg->ldv_51620.ldv_51618.body[2] >> 16);
  autoneg = (u8 )(msg->ldv_51620.ldv_51618.body[2] >> 24);
  lb_status = (unsigned int )((u8 )(msg->ldv_51620.ldv_51618.body[2] >> 32)) & 3U;
  module = (u8 )(msg->ldv_51620.ldv_51618.body[2] >> 8);
  if ((unsigned int )module == 6U) {
    _dev_info((struct device const *)(& netdev->dev), "unsupported cable: OUI 0x%x, length %d\n",
              cable_OUI, (int )cable_len);
  } else
  if ((unsigned int )module == 7U) {
    _dev_info((struct device const *)(& netdev->dev), "unsupported cable length %d\n",
              (int )cable_len);
  } else {
  }
  if ((unsigned int )link_status == 0U && ((unsigned int )lb_status == 1U || (unsigned int )lb_status == 2U)) {
    (adapter->ahw)->loopback_state = (u8 )((unsigned int )(adapter->ahw)->loopback_state | 1U);
  } else {
  }
  qlcnic_advert_link_change(adapter, (int )link_status);
  if ((unsigned int )duplex == 1U) {
    (adapter->ahw)->link_duplex = 1U;
  } else {
    (adapter->ahw)->link_duplex = 0U;
  }
  (adapter->ahw)->module_type = (u16 )module;
  (adapter->ahw)->link_autoneg = (u16 )autoneg;
  if ((unsigned int )link_status != 0U) {
    (adapter->ahw)->link_speed = link_speed;
  } else {
    (adapter->ahw)->link_speed = 65535U;
    (adapter->ahw)->link_duplex = 255U;
  }
  return;
}
}
static void qlcnic_handle_fw_message(int desc_cnt , int index , struct qlcnic_host_sds_ring *sds_ring )
{
  struct qlcnic_fw_msg msg ;
  struct status_desc *desc ;
  struct qlcnic_adapter *adapter ;
  struct device *dev ;
  int i ;
  int opcode ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  {
  i = 0;
  goto ldv_53147;
  ldv_53146:
  desc = sds_ring->desc_head + (unsigned long )index;
  tmp = i;
  i = i + 1;
  msg.ldv_51620.words[tmp] = desc->status_desc_data[0];
  tmp___0 = i;
  i = i + 1;
  msg.ldv_51620.words[tmp___0] = desc->status_desc_data[1];
  index = (int )((u32 )(index + 1) & (sds_ring->num_desc - 1U));
  desc_cnt = desc_cnt - 1;
  ldv_53147: ;
  if (desc_cnt > 0 && i <= 7) {
    goto ldv_53146;
  } else {
  }
  adapter = sds_ring->adapter;
  dev = & (adapter->pdev)->dev;
  opcode = (int )(msg.ldv_51620.ldv_51618.body[0] >> 32) & 255;
  switch (opcode) {
  case 141:
  qlcnic_handle_linkevent(adapter, & msg);
  goto ldv_53150;
  case 143:
  ret = (int )msg.ldv_51620.ldv_51618.body[1];
  switch (ret) {
  case 0:
  (adapter->ahw)->loopback_state = (u8 )((unsigned int )(adapter->ahw)->loopback_state | 2U);
  goto ldv_53153;
  case 1:
  _dev_info((struct device const *)dev, "loopback already in progress\n");
  (adapter->ahw)->diag_cnt = -115;
  goto ldv_53153;
  case 2:
  _dev_info((struct device const *)dev, "loopback cable is not connected\n");
  (adapter->ahw)->diag_cnt = -19;
  goto ldv_53153;
  default:
  _dev_info((struct device const *)dev, "loopback configure request failed, err %x\n",
            ret);
  (adapter->ahw)->diag_cnt = -5;
  goto ldv_53153;
  }
  ldv_53153: ;
  goto ldv_53150;
  case 144:
  qlcnic_dcb_aen_handler(adapter->dcb, (void *)(& msg));
  goto ldv_53150;
  default: ;
  goto ldv_53150;
  }
  ldv_53150: ;
  return;
}
}
static struct sk_buff *qlcnic_process_rxbuf(struct qlcnic_adapter *adapter , struct qlcnic_host_rds_ring *ring ,
                                            u16 index , u16 cksum )
{
  struct qlcnic_rx_buffer *buffer ;
  struct sk_buff *skb ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  {
  buffer = ring->rx_buf_arr + (unsigned long )index;
  tmp___0 = ldv__builtin_expect((unsigned long )buffer->skb == (unsigned long )((struct sk_buff *)0),
                             0L);
  if (tmp___0 != 0L) {
    __ret_warn_on = 1;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.o.c.prepared",
                         1291);
    } else {
    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return ((struct sk_buff *)0);
  } else {
  }
  pci_unmap_single___0(adapter->pdev, buffer->dma, (size_t )ring->dma_size, 2);
  skb = buffer->skb;
  tmp___1 = ldv__builtin_expect(((adapter->netdev)->features & 17179869184ULL) != 0ULL,
                             1L);
  if (tmp___1 != 0L) {
    tmp___2 = ldv__builtin_expect((unsigned int )cksum == 2U, 1L);
    if (tmp___2 != 0L) {
      tmp___4 = 1;
    } else {
      tmp___3 = ldv__builtin_expect((unsigned int )cksum == 0U, 1L);
      if (tmp___3 != 0L) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
    }
    if (tmp___4 != 0) {
      adapter->stats.csummed = adapter->stats.csummed + 1ULL;
      skb->ip_summed = 1U;
    } else {
      skb_checksum_none_assert((struct sk_buff const *)skb);
    }
  } else {
    skb_checksum_none_assert((struct sk_buff const *)skb);
  }
  buffer->skb = (struct sk_buff *)0;
  return (skb);
}
}
__inline static int qlcnic_check_rx_tagging(struct qlcnic_adapter *adapter , struct sk_buff *skb ,
                                            u16 *vlan_tag )
{
  struct ethhdr *eth_hdr___0 ;
  int tmp ;
  {
  tmp = __vlan_get_tag((struct sk_buff const *)skb, vlan_tag);
  if (tmp == 0) {
    eth_hdr___0 = (struct ethhdr *)skb->data;
    memmove((void *)skb->data + 4U, (void const *)eth_hdr___0, 12UL);
    skb_pull(skb, 4U);
  } else {
  }
  if ((unsigned int )adapter->rx_pvid == 0U) {
    return (0);
  } else {
  }
  if ((int )*vlan_tag == (int )adapter->rx_pvid) {
    *vlan_tag = 65535U;
    return (0);
  } else {
  }
  if ((adapter->flags & 256U) != 0U) {
    return (0);
  } else {
  }
  return (-22);
}
}
static struct qlcnic_rx_buffer *qlcnic_process_rcv(struct qlcnic_adapter *adapter ,
                                                   struct qlcnic_host_sds_ring *sds_ring ,
                                                   int ring , u64 sts_data0 )
{
  struct net_device *netdev ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_rx_buffer *buffer ;
  struct sk_buff *skb ;
  struct qlcnic_host_rds_ring *rds_ring ;
  int index ;
  int length ;
  int cksum ;
  int pkt_offset ;
  int is_lb_pkt ;
  u16 vid ;
  u16 t_vid ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  {
  netdev = adapter->netdev;
  recv_ctx = adapter->recv_ctx;
  vid = 65535U;
  tmp = ldv__builtin_expect((int )adapter->max_rds_rings <= ring, 0L);
  if (tmp != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  index = (int )(sts_data0 >> 28) & 65535;
  tmp___0 = ldv__builtin_expect((u32 )index >= rds_ring->num_desc, 0L);
  if (tmp___0 != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  buffer = rds_ring->rx_buf_arr + (unsigned long )index;
  length = (int )(sts_data0 >> 12) & 65535;
  cksum = (int )(sts_data0 >> 4) & 15;
  pkt_offset = (int )(sts_data0 >> 48) & 31;
  skb = qlcnic_process_rxbuf(adapter, rds_ring, (int )((u16 )index), (int )((u16 )cksum));
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    return (buffer);
  } else {
  }
  if ((int )adapter->rx_mac_learn) {
    t_vid = 0U;
    is_lb_pkt = qlcnic_82xx_is_lb_pkt(sts_data0);
    qlcnic_add_lb_filter(adapter, skb, is_lb_pkt, (int )t_vid);
  } else {
  }
  if ((u32 )length > rds_ring->skb_size) {
    skb_put(skb, rds_ring->skb_size);
  } else {
    skb_put(skb, (unsigned int )length);
  }
  if (pkt_offset != 0) {
    skb_pull(skb, (unsigned int )pkt_offset);
  } else {
  }
  tmp___1 = qlcnic_check_rx_tagging(adapter, skb, & vid);
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
  if (tmp___2 != 0L) {
    adapter->stats.rxdropped = adapter->stats.rxdropped + 1ULL;
    consume_skb(skb);
    return (buffer);
  } else {
  }
  skb->protocol = eth_type_trans(skb, netdev);
  if ((unsigned int )vid != 65535U) {
    __vlan_hwaccel_put_tag(skb, 129, (int )vid);
  } else {
  }
  napi_gro_receive(& sds_ring->napi, skb);
  adapter->stats.rx_pkts = adapter->stats.rx_pkts + 1ULL;
  adapter->stats.rxbytes = adapter->stats.rxbytes + (u64 )length;
  return (buffer);
}
}
static struct qlcnic_rx_buffer *qlcnic_process_lro(struct qlcnic_adapter *adapter ,
                                                   int ring , u64 sts_data0 , u64 sts_data1 )
{
  struct net_device *netdev ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_rx_buffer *buffer ;
  struct sk_buff *skb ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct iphdr *iph ;
  struct ipv6hdr *ipv6h ;
  struct tcphdr *th ;
  bool push ;
  bool timestamp ;
  int index ;
  int l2_hdr_offset ;
  int l4_hdr_offset ;
  int is_lb_pkt ;
  u16 lro_length ;
  u16 length ;
  u16 data_offset ;
  u16 t_vid ;
  u16 vid ;
  u32 seq_number ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  __u16 tmp___5 ;
  __u16 tmp___6 ;
  __u32 tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  {
  netdev = adapter->netdev;
  recv_ctx = adapter->recv_ctx;
  vid = 65535U;
  tmp = ldv__builtin_expect((int )adapter->max_rds_rings <= ring, 0L);
  if (tmp != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  index = (int )sts_data0 & 32767;
  tmp___0 = ldv__builtin_expect((u32 )index >= rds_ring->num_desc, 0L);
  if (tmp___0 != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  buffer = rds_ring->rx_buf_arr + (unsigned long )index;
  timestamp = ((sts_data0 >> 48) & 1ULL) != 0ULL;
  lro_length = (u16 )(sts_data0 >> 16);
  l2_hdr_offset = (int )(sts_data0 >> 32) & 255;
  l4_hdr_offset = (int )(sts_data0 >> 40) & 255;
  push = ((sts_data0 >> 52) & 1ULL) != 0ULL;
  seq_number = (u32 )sts_data1;
  skb = qlcnic_process_rxbuf(adapter, rds_ring, (int )((u16 )index), 2);
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    return (buffer);
  } else {
  }
  if ((int )adapter->rx_mac_learn) {
    t_vid = 0U;
    is_lb_pkt = qlcnic_82xx_is_lb_pkt(sts_data0);
    qlcnic_add_lb_filter(adapter, skb, is_lb_pkt, (int )t_vid);
  } else {
  }
  if ((int )timestamp) {
    data_offset = (unsigned int )((u16 )l4_hdr_offset) + 32U;
  } else {
    data_offset = (unsigned int )((u16 )l4_hdr_offset) + 20U;
  }
  skb_put(skb, (unsigned int )((int )lro_length + (int )data_offset));
  skb_pull(skb, (unsigned int )l2_hdr_offset);
  tmp___1 = qlcnic_check_rx_tagging(adapter, skb, & vid);
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
  if (tmp___2 != 0L) {
    adapter->stats.rxdropped = adapter->stats.rxdropped + 1ULL;
    consume_skb(skb);
    return (buffer);
  } else {
  }
  skb->protocol = eth_type_trans(skb, netdev);
  tmp___6 = __fswab16((int )skb->protocol);
  if ((unsigned int )tmp___6 == 34525U) {
    ipv6h = (struct ipv6hdr *)skb->data;
    th = (struct tcphdr *)skb->data + 40U;
    length = ((int )((u16 )th->doff) << 2U) + (int )lro_length;
    tmp___3 = __fswab16((int )length);
    ipv6h->payload_len = tmp___3;
  } else {
    iph = (struct iphdr *)skb->data;
    th = (struct tcphdr *)skb->data + (unsigned long )((int )iph->ihl << 2);
    length = (((int )((u16 )iph->ihl) << 2U) + ((int )((u16 )th->doff) << 2U)) + (int )lro_length;
    tmp___4 = __fswab16((int )length);
    csum_replace2(& iph->check, (int )iph->tot_len, (int )tmp___4);
    tmp___5 = __fswab16((int )length);
    iph->tot_len = tmp___5;
  }
  th->psh = (unsigned char )push;
  tmp___7 = __fswab32(seq_number);
  th->seq = tmp___7;
  length = (u16 )skb->len;
  if ((adapter->flags & 32768U) != 0U) {
    tmp___8 = skb_end_pointer((struct sk_buff const *)skb);
    ((struct skb_shared_info *)tmp___8)->gso_size = (unsigned short )(sts_data1 >> 32);
    if ((unsigned int )skb->protocol == 56710U) {
      tmp___9 = skb_end_pointer((struct sk_buff const *)skb);
      ((struct skb_shared_info *)tmp___9)->gso_type = 16U;
    } else {
      tmp___10 = skb_end_pointer((struct sk_buff const *)skb);
      ((struct skb_shared_info *)tmp___10)->gso_type = 1U;
    }
  } else {
  }
  if ((unsigned int )vid != 65535U) {
    __vlan_hwaccel_put_tag(skb, 129, (int )vid);
  } else {
  }
  netif_receive_skb(skb);
  adapter->stats.lro_pkts = adapter->stats.lro_pkts + 1ULL;
  adapter->stats.lrobytes = adapter->stats.lrobytes + (u64 )length;
  return (buffer);
}
}
static int qlcnic_process_rcv_ring(struct qlcnic_host_sds_ring *sds_ring , int max )
{
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_adapter *adapter ;
  struct list_head *cur ;
  struct status_desc *desc ;
  struct qlcnic_rx_buffer *rxbuf ;
  int opcode ;
  int desc_cnt ;
  int count ;
  u64 sts_data0 ;
  u64 sts_data1 ;
  u8 ring ;
  u32 consumer ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  struct list_head const *__mptr ;
  int tmp___1 ;
  {
  adapter = sds_ring->adapter;
  count = 0;
  consumer = sds_ring->consumer;
  goto ldv_53250;
  ldv_53249:
  desc = sds_ring->desc_head + (unsigned long )consumer;
  sts_data0 = desc->status_desc_data[0];
  if ((sts_data0 & 72057594037927936ULL) == 0ULL) {
    goto ldv_53235;
  } else {
  }
  desc_cnt = (int )(sts_data0 >> 53) & 7;
  opcode = (int )(sts_data0 >> 58);
  switch (opcode) {
  case 4: ;
  case 63: ;
  case 3:
  ring = (unsigned int )((u8 )(sts_data0 >> 8)) & 15U;
  rxbuf = qlcnic_process_rcv(adapter, sds_ring, (int )ring, sts_data0);
  goto ldv_53239;
  case 18:
  ring = (unsigned int )((u8 )(sts_data0 >> 49)) & 7U;
  sts_data1 = desc->status_desc_data[1];
  rxbuf = qlcnic_process_lro(adapter, (int )ring, sts_data0, sts_data1);
  goto ldv_53239;
  case 5:
  qlcnic_handle_fw_message(desc_cnt, (int )consumer, sds_ring);
  default: ;
  goto skip;
  }
  ldv_53239:
  __ret_warn_on = desc_cnt > 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.o.c.prepared",
                       1541);
  } else {
  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = ldv__builtin_expect((unsigned long )rxbuf != (unsigned long )((struct qlcnic_rx_buffer *)0),
                             1L);
  if (tmp___0 != 0L) {
    list_add_tail(& rxbuf->list, (struct list_head *)(& sds_ring->free_list) + (unsigned long )ring);
  } else {
    adapter->stats.null_rxbuf = adapter->stats.null_rxbuf + 1ULL;
  }
  skip: ;
  goto ldv_53247;
  ldv_53246:
  desc = sds_ring->desc_head + (unsigned long )consumer;
  desc->status_desc_data[0] = 144115188075855872ULL;
  consumer = (consumer + 1U) & (sds_ring->num_desc - 1U);
  desc_cnt = desc_cnt - 1;
  ldv_53247: ;
  if (desc_cnt > 0) {
    goto ldv_53246;
  } else {
  }
  count = count + 1;
  ldv_53250: ;
  if (count < max) {
    goto ldv_53249;
  } else {
  }
  ldv_53235:
  ring = 0U;
  goto ldv_53257;
  ldv_53256:
  rds_ring = (adapter->recv_ctx)->rds_rings + (unsigned long )ring;
  tmp___1 = list_empty((struct list_head const *)(& sds_ring->free_list) + (unsigned long )ring);
  if (tmp___1 == 0) {
    cur = ((struct list_head *)(& sds_ring->free_list) + (unsigned long )ring)->next;
    goto ldv_53254;
    ldv_53253:
    __mptr = (struct list_head const *)cur;
    rxbuf = (struct qlcnic_rx_buffer *)__mptr + 0xfffffffffffffff0UL;
    qlcnic_alloc_rx_skb(adapter, rds_ring, rxbuf);
    cur = cur->next;
    ldv_53254: ;
    if ((unsigned long )((struct list_head *)(& sds_ring->free_list) + (unsigned long )ring) != (unsigned long )cur) {
      goto ldv_53253;
    } else {
    }
    spin_lock(& rds_ring->lock);
    list_splice_tail_init((struct list_head *)(& sds_ring->free_list) + (unsigned long )ring,
                          & rds_ring->free_list);
    spin_unlock(& rds_ring->lock);
  } else {
  }
  qlcnic_post_rx_buffers_nodb(adapter, rds_ring, (int )ring);
  ring = (u8 )((int )ring + 1);
  ldv_53257: ;
  if ((int )adapter->max_rds_rings > (int )ring) {
    goto ldv_53256;
  } else {
  }
  if (count != 0) {
    sds_ring->consumer = consumer;
    writel(consumer, (void volatile *)sds_ring->crb_sts_consumer);
  } else {
  }
  return (count);
}
}
void qlcnic_post_rx_buffers(struct qlcnic_adapter *adapter , struct qlcnic_host_rds_ring *rds_ring ,
                            u8 ring_id )
{
  struct rcv_desc *pdesc ;
  struct qlcnic_rx_buffer *buffer ;
  int count ;
  u32 producer ;
  u32 handle ;
  struct list_head *head ;
  struct list_head const *__mptr ;
  int tmp ;
  int tmp___0 ;
  {
  count = 0;
  producer = rds_ring->producer;
  head = & rds_ring->free_list;
  goto ldv_53274;
  ldv_53273:
  __mptr = (struct list_head const *)head->next;
  buffer = (struct qlcnic_rx_buffer *)__mptr + 0xfffffffffffffff0UL;
  if ((unsigned long )buffer->skb == (unsigned long )((struct sk_buff *)0)) {
    tmp = qlcnic_alloc_rx_skb(adapter, rds_ring, buffer);
    if (tmp != 0) {
      goto ldv_53272;
    } else {
    }
  } else {
  }
  count = count + 1;
  list_del(& buffer->list);
  pdesc = rds_ring->desc_head + (unsigned long )producer;
  pdesc->addr_buffer = buffer->dma;
  handle = qlcnic_get_ref_handle(adapter, (int )buffer->ref_handle, (int )ring_id);
  pdesc->reference_handle = (unsigned short )handle;
  pdesc->buffer_length = rds_ring->dma_size;
  producer = (producer + 1U) & (rds_ring->num_desc - 1U);
  ldv_53274:
  tmp___0 = list_empty((struct list_head const *)head);
  if (tmp___0 == 0) {
    goto ldv_53273;
  } else {
  }
  ldv_53272: ;
  if (count != 0) {
    rds_ring->producer = producer;
    writel((producer - 1U) & (rds_ring->num_desc - 1U), (void volatile *)rds_ring->crb_rcv_producer);
  } else {
  }
  return;
}
}
static void dump_skb(struct sk_buff *skb , struct qlcnic_adapter *adapter )
{
  int i ;
  unsigned char *data ;
  char const *tmp ;
  {
  data = skb->data;
  printk("\016\016\n");
  i = 0;
  goto ldv_53283;
  ldv_53282: ;
  if ((int )(adapter->ahw)->msg_enable & 1) {
    tmp = dev_name((struct device const *)(& (adapter->pdev)->dev));
    printk("\016%s: %s: %02x ", tmp, "dump_skb", (int )*(data + (unsigned long )i));
  } else {
  }
  if ((i & 15) == 8) {
    printk("\016\016\n");
  } else {
  }
  i = i + 1;
  ldv_53283: ;
  if ((unsigned int )i < skb->len) {
    goto ldv_53282;
  } else {
  }
  return;
}
}
static void qlcnic_process_rcv_diag(struct qlcnic_adapter *adapter , int ring , u64 sts_data0 )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct sk_buff *skb ;
  struct qlcnic_host_rds_ring *rds_ring ;
  int index ;
  int length ;
  int cksum ;
  int pkt_offset ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  {
  recv_ctx = adapter->recv_ctx;
  tmp = ldv__builtin_expect((int )adapter->max_rds_rings <= ring, 0L);
  if (tmp != 0L) {
    return;
  } else {
  }
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  index = (int )(sts_data0 >> 28) & 65535;
  length = (int )(sts_data0 >> 12) & 65535;
  tmp___0 = ldv__builtin_expect((u32 )index >= rds_ring->num_desc, 0L);
  if (tmp___0 != 0L) {
    return;
  } else {
  }
  cksum = (int )(sts_data0 >> 4) & 15;
  pkt_offset = (int )(sts_data0 >> 48) & 31;
  skb = qlcnic_process_rxbuf(adapter, rds_ring, (int )((u16 )index), (int )((u16 )cksum));
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    return;
  } else {
  }
  if ((u32 )length > rds_ring->skb_size) {
    skb_put(skb, rds_ring->skb_size);
  } else {
    skb_put(skb, (unsigned int )length);
  }
  if (pkt_offset != 0) {
    skb_pull(skb, (unsigned int )pkt_offset);
  } else {
  }
  tmp___1 = qlcnic_check_loopback_buff(skb->data, (u8 *)(& adapter->mac_addr));
  if (tmp___1 == 0) {
    (adapter->ahw)->diag_cnt = (adapter->ahw)->diag_cnt + 1;
  } else {
    dump_skb(skb, adapter);
  }
  dev_kfree_skb_any(skb);
  adapter->stats.rx_pkts = adapter->stats.rx_pkts + 1ULL;
  adapter->stats.rxbytes = adapter->stats.rxbytes + (u64 )length;
  return;
}
}
void qlcnic_82xx_process_rcv_ring_diag(struct qlcnic_host_sds_ring *sds_ring )
{
  struct qlcnic_adapter *adapter ;
  struct status_desc *desc ;
  u64 sts_data0 ;
  int ring ;
  int opcode ;
  int desc_cnt ;
  u32 consumer ;
  {
  adapter = sds_ring->adapter;
  consumer = sds_ring->consumer;
  desc = sds_ring->desc_head + (unsigned long )consumer;
  sts_data0 = desc->status_desc_data[0];
  if ((sts_data0 & 72057594037927936ULL) == 0ULL) {
    return;
  } else {
  }
  desc_cnt = (int )(sts_data0 >> 53) & 7;
  opcode = (int )(sts_data0 >> 58);
  switch (opcode) {
  case 5:
  qlcnic_handle_fw_message(desc_cnt, (int )consumer, sds_ring);
  goto ldv_53308;
  default:
  ring = (int )(sts_data0 >> 8) & 15;
  qlcnic_process_rcv_diag(adapter, ring, sts_data0);
  goto ldv_53308;
  }
  ldv_53308: ;
  goto ldv_53311;
  ldv_53310:
  desc = sds_ring->desc_head + (unsigned long )consumer;
  desc->status_desc_data[0] = 144115188075855872ULL;
  consumer = (consumer + 1U) & (sds_ring->num_desc - 1U);
  desc_cnt = desc_cnt - 1;
  ldv_53311: ;
  if (desc_cnt > 0) {
    goto ldv_53310;
  } else {
  }
  sds_ring->consumer = consumer;
  writel(consumer, (void volatile *)sds_ring->crb_sts_consumer);
  return;
}
}
int qlcnic_82xx_napi_add(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_tx_ring *tx_ring ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  {
  recv_ctx = adapter->recv_ctx;
  tmp = qlcnic_alloc_sds_rings(recv_ctx, (int )adapter->drv_sds_rings);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  ring = 0;
  goto ldv_53322;
  ldv_53321:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  tmp___0 = qlcnic_check_multi_tx(adapter);
  if ((int )tmp___0 && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    netif_napi_add(netdev, & sds_ring->napi, & qlcnic_rx_poll, 64);
  } else
  if ((int )adapter->drv_sds_rings + -1 == ring) {
    netif_napi_add(netdev, & sds_ring->napi, & qlcnic_poll, 64);
  } else {
    netif_napi_add(netdev, & sds_ring->napi, & qlcnic_rx_poll, 64);
  }
  ring = ring + 1;
  ldv_53322: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53321;
  } else {
  }
  tmp___1 = qlcnic_alloc_tx_rings(adapter, netdev);
  if (tmp___1 != 0) {
    qlcnic_free_sds_rings(recv_ctx);
    return (-12);
  } else {
  }
  tmp___2 = qlcnic_check_multi_tx(adapter);
  if ((int )tmp___2 && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    ring = 0;
    goto ldv_53325;
    ldv_53324:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    netif_napi_add(netdev, & tx_ring->napi, & qlcnic_tx_poll, 64);
    ring = ring + 1;
    ldv_53325: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_53324;
    } else {
    }
  } else {
  }
  return (0);
}
}
void qlcnic_82xx_napi_del(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_tx_ring *tx_ring ;
  bool tmp ;
  {
  recv_ctx = adapter->recv_ctx;
  ring = 0;
  goto ldv_53335;
  ldv_53334:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  netif_napi_del(& sds_ring->napi);
  ring = ring + 1;
  ldv_53335: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53334;
  } else {
  }
  qlcnic_free_sds_rings(adapter->recv_ctx);
  tmp = qlcnic_check_multi_tx(adapter);
  if ((int )tmp && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    ring = 0;
    goto ldv_53338;
    ldv_53337:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    netif_napi_del(& tx_ring->napi);
    ring = ring + 1;
    ldv_53338: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_53337;
    } else {
    }
  } else {
  }
  qlcnic_free_tx_rings(adapter);
  return;
}
}
void qlcnic_82xx_napi_enable(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  bool tmp ;
  {
  recv_ctx = adapter->recv_ctx;
  if ((unsigned int )adapter->is_up != 777U) {
    return;
  } else {
  }
  ring = 0;
  goto ldv_53348;
  ldv_53347:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  napi_enable(& sds_ring->napi);
  qlcnic_enable_sds_intr(adapter, sds_ring);
  ring = ring + 1;
  ldv_53348: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53347;
  } else {
  }
  tmp = qlcnic_check_multi_tx(adapter);
  if (((int )tmp && (adapter->flags & 4U) != 0U) && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    ring = 0;
    goto ldv_53351;
    ldv_53350:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    napi_enable(& tx_ring->napi);
    qlcnic_enable_tx_intr(adapter, tx_ring);
    ring = ring + 1;
    ldv_53351: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_53350;
    } else {
    }
  } else {
  }
  return;
}
}
void qlcnic_82xx_napi_disable(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  bool tmp ;
  {
  recv_ctx = adapter->recv_ctx;
  if ((unsigned int )adapter->is_up != 777U) {
    return;
  } else {
  }
  ring = 0;
  goto ldv_53361;
  ldv_53360:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  qlcnic_disable_sds_intr(adapter, sds_ring);
  napi_synchronize((struct napi_struct const *)(& sds_ring->napi));
  napi_disable(& sds_ring->napi);
  ring = ring + 1;
  ldv_53361: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53360;
  } else {
  }
  if ((adapter->flags & 4U) != 0U && (unsigned int )(adapter->ahw)->diag_test == 0U) {
    tmp = qlcnic_check_multi_tx(adapter);
    if ((int )tmp) {
      ring = 0;
      goto ldv_53364;
      ldv_53363:
      tx_ring = adapter->tx_ring + (unsigned long )ring;
      qlcnic_disable_tx_intr(adapter, tx_ring);
      napi_synchronize((struct napi_struct const *)(& tx_ring->napi));
      napi_disable(& tx_ring->napi);
      ring = ring + 1;
      ldv_53364: ;
      if ((int )adapter->drv_tx_rings > ring) {
        goto ldv_53363;
      } else {
      }
    } else {
    }
  } else {
  }
  return;
}
}
__inline static int qlcnic_83xx_is_lb_pkt(u64 sts_data , int lro_pkt )
{
  {
  if (lro_pkt != 0) {
    return ((sts_data & 70368744177664ULL) != 0ULL);
  } else {
    return ((sts_data & 68719476736ULL) != 0ULL);
  }
}
}
__inline static u8 qlcnic_encap_length(u64 sts_data )
{
  {
  return ((unsigned int )((u8 )sts_data) & 127U);
}
}
static struct qlcnic_rx_buffer *qlcnic_83xx_process_rcv(struct qlcnic_adapter *adapter ,
                                                        struct qlcnic_host_sds_ring *sds_ring ,
                                                        u8 ring , u64 *sts_data )
{
  struct net_device *netdev ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_rx_buffer *buffer ;
  struct sk_buff *skb ;
  struct qlcnic_host_rds_ring *rds_ring ;
  int index ;
  int length ;
  int cksum ;
  int is_lb_pkt ;
  u16 vid ;
  int err ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  u8 tmp___2 ;
  {
  netdev = adapter->netdev;
  recv_ctx = adapter->recv_ctx;
  vid = 65535U;
  tmp = ldv__builtin_expect((int )adapter->max_rds_rings <= (int )ring, 0L);
  if (tmp != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  index = (int )(*sts_data >> 48) & 32767;
  tmp___0 = ldv__builtin_expect((u32 )index >= rds_ring->num_desc, 0L);
  if (tmp___0 != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  buffer = rds_ring->rx_buf_arr + (unsigned long )index;
  length = (int )(*sts_data >> 32) & 16383;
  cksum = (int )(*(sts_data + 1UL) >> 39) & 7;
  skb = qlcnic_process_rxbuf(adapter, rds_ring, (int )((u16 )index), (int )((u16 )cksum));
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    return (buffer);
  } else {
  }
  if ((u32 )length > rds_ring->skb_size) {
    skb_put(skb, rds_ring->skb_size);
  } else {
    skb_put(skb, (unsigned int )length);
  }
  err = qlcnic_check_rx_tagging(adapter, skb, & vid);
  if ((int )adapter->rx_mac_learn) {
    is_lb_pkt = qlcnic_83xx_is_lb_pkt(*(sts_data + 1UL), 0);
    qlcnic_add_lb_filter(adapter, skb, is_lb_pkt, (int )vid);
  } else {
  }
  tmp___1 = ldv__builtin_expect(err != 0, 0L);
  if (tmp___1 != 0L) {
    adapter->stats.rxdropped = adapter->stats.rxdropped + 1ULL;
    consume_skb(skb);
    return (buffer);
  } else {
  }
  skb->protocol = eth_type_trans(skb, netdev);
  tmp___2 = qlcnic_encap_length(*(sts_data + 1UL));
  if ((unsigned int )tmp___2 != 0U && (unsigned int )*((unsigned char *)skb + 124UL) == 4U) {
    skb->encapsulation = 1U;
    adapter->stats.encap_rx_csummed = adapter->stats.encap_rx_csummed + 1ULL;
  } else {
  }
  if ((unsigned int )vid != 65535U) {
    __vlan_hwaccel_put_tag(skb, 129, (int )vid);
  } else {
  }
  napi_gro_receive(& sds_ring->napi, skb);
  adapter->stats.rx_pkts = adapter->stats.rx_pkts + 1ULL;
  adapter->stats.rxbytes = adapter->stats.rxbytes + (u64 )length;
  return (buffer);
}
}
static struct qlcnic_rx_buffer *qlcnic_83xx_process_lro(struct qlcnic_adapter *adapter ,
                                                        u8 ring , u64 *sts_data )
{
  struct net_device *netdev ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_rx_buffer *buffer ;
  struct sk_buff *skb ;
  struct qlcnic_host_rds_ring *rds_ring ;
  struct iphdr *iph ;
  struct ipv6hdr *ipv6h ;
  struct tcphdr *th ;
  bool push ;
  int l2_hdr_offset ;
  int l4_hdr_offset ;
  int index ;
  int is_lb_pkt ;
  u16 lro_length ;
  u16 length ;
  u16 data_offset ;
  u16 gso_size ;
  u16 vid ;
  int err ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  __u16 tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  {
  netdev = adapter->netdev;
  recv_ctx = adapter->recv_ctx;
  vid = 65535U;
  tmp = ldv__builtin_expect((int )adapter->max_rds_rings <= (int )ring, 0L);
  if (tmp != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  index = (int )(*sts_data >> 48) & 32767;
  tmp___0 = ldv__builtin_expect((u32 )index >= rds_ring->num_desc, 0L);
  if (tmp___0 != 0L) {
    return ((struct qlcnic_rx_buffer *)0);
  } else {
  }
  buffer = rds_ring->rx_buf_arr + (unsigned long )index;
  lro_length = (unsigned int )((u16 )(*sts_data >> 32)) & 16383U;
  l2_hdr_offset = (int )(*(sts_data + 1UL) >> 16) & 255;
  l4_hdr_offset = (int )(*(sts_data + 1UL) >> 24) & 255;
  push = ((*(sts_data + 1UL) >> 41) & 1ULL) != 0ULL;
  skb = qlcnic_process_rxbuf(adapter, rds_ring, (int )((u16 )index), 2);
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    return (buffer);
  } else {
  }
  if ((*(sts_data + 1UL) & 1099511627776ULL) != 0ULL) {
    data_offset = (unsigned int )((u16 )l4_hdr_offset) + 32U;
  } else {
    data_offset = (unsigned int )((u16 )l4_hdr_offset) + 20U;
  }
  skb_put(skb, (unsigned int )((int )lro_length + (int )data_offset));
  skb_pull(skb, (unsigned int )l2_hdr_offset);
  err = qlcnic_check_rx_tagging(adapter, skb, & vid);
  if ((int )adapter->rx_mac_learn) {
    is_lb_pkt = qlcnic_83xx_is_lb_pkt(*(sts_data + 1UL), 1);
    qlcnic_add_lb_filter(adapter, skb, is_lb_pkt, (int )vid);
  } else {
  }
  tmp___1 = ldv__builtin_expect(err != 0, 0L);
  if (tmp___1 != 0L) {
    adapter->stats.rxdropped = adapter->stats.rxdropped + 1ULL;
    consume_skb(skb);
    return (buffer);
  } else {
  }
  skb->protocol = eth_type_trans(skb, netdev);
  tmp___5 = __fswab16((int )skb->protocol);
  if ((unsigned int )tmp___5 == 34525U) {
    ipv6h = (struct ipv6hdr *)skb->data;
    th = (struct tcphdr *)skb->data + 40U;
    length = ((int )((u16 )th->doff) << 2U) + (int )lro_length;
    tmp___2 = __fswab16((int )length);
    ipv6h->payload_len = tmp___2;
  } else {
    iph = (struct iphdr *)skb->data;
    th = (struct tcphdr *)skb->data + (unsigned long )((int )iph->ihl << 2);
    length = (((int )((u16 )iph->ihl) << 2U) + ((int )((u16 )th->doff) << 2U)) + (int )lro_length;
    tmp___3 = __fswab16((int )length);
    csum_replace2(& iph->check, (int )iph->tot_len, (int )tmp___3);
    tmp___4 = __fswab16((int )length);
    iph->tot_len = tmp___4;
  }
  th->psh = (unsigned char )push;
  length = (u16 )skb->len;
  if ((adapter->flags & 32768U) != 0U) {
    gso_size = (u16 )*sts_data;
    tmp___6 = skb_end_pointer((struct sk_buff const *)skb);
    ((struct skb_shared_info *)tmp___6)->gso_size = gso_size;
    if ((unsigned int )skb->protocol == 56710U) {
      tmp___7 = skb_end_pointer((struct sk_buff const *)skb);
      ((struct skb_shared_info *)tmp___7)->gso_type = 16U;
    } else {
      tmp___8 = skb_end_pointer((struct sk_buff const *)skb);
      ((struct skb_shared_info *)tmp___8)->gso_type = 1U;
    }
  } else {
  }
  if ((unsigned int )vid != 65535U) {
    __vlan_hwaccel_put_tag(skb, 129, (int )vid);
  } else {
  }
  netif_receive_skb(skb);
  adapter->stats.lro_pkts = adapter->stats.lro_pkts + 1ULL;
  adapter->stats.lrobytes = adapter->stats.lrobytes + (u64 )length;
  return (buffer);
}
}
static int qlcnic_83xx_process_rcv_ring(struct qlcnic_host_sds_ring *sds_ring , int max )
{
  struct qlcnic_host_rds_ring *rds_ring ;
  struct qlcnic_adapter *adapter ;
  struct list_head *cur ;
  struct status_desc *desc ;
  struct qlcnic_rx_buffer *rxbuf ;
  u8 ring ;
  u64 sts_data[2U] ;
  int count ;
  int opcode ;
  u32 consumer ;
  long tmp ;
  struct list_head const *__mptr ;
  int tmp___0 ;
  {
  adapter = sds_ring->adapter;
  rxbuf = (struct qlcnic_rx_buffer *)0;
  count = 0;
  consumer = sds_ring->consumer;
  goto ldv_53435;
  ldv_53434:
  desc = sds_ring->desc_head + (unsigned long )consumer;
  sts_data[1] = desc->status_desc_data[1];
  opcode = (int )(sts_data[1] >> 42) & 15;
  if (opcode == 0) {
    goto ldv_53428;
  } else {
  }
  sts_data[0] = desc->status_desc_data[0];
  ring = (u8 )(sts_data[0] >> 63);
  switch (opcode) {
  case 1:
  rxbuf = qlcnic_83xx_process_rcv(adapter, sds_ring, (int )ring, (u64 *)(& sts_data));
  goto ldv_53430;
  case 2:
  rxbuf = qlcnic_83xx_process_lro(adapter, (int )ring, (u64 *)(& sts_data));
  goto ldv_53430;
  default:
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Unknown opcode: 0x%x\n",
            opcode);
  goto skip;
  }
  ldv_53430:
  tmp = ldv__builtin_expect((unsigned long )rxbuf != (unsigned long )((struct qlcnic_rx_buffer *)0),
                         1L);
  if (tmp != 0L) {
    list_add_tail(& rxbuf->list, (struct list_head *)(& sds_ring->free_list) + (unsigned long )ring);
  } else {
    adapter->stats.null_rxbuf = adapter->stats.null_rxbuf + 1ULL;
  }
  skip:
  desc = sds_ring->desc_head + (unsigned long )consumer;
  desc->status_desc_data[1] = 0ULL;
  consumer = (consumer + 1U) & (sds_ring->num_desc - 1U);
  count = count + 1;
  ldv_53435: ;
  if (count < max) {
    goto ldv_53434;
  } else {
  }
  ldv_53428:
  ring = 0U;
  goto ldv_53442;
  ldv_53441:
  rds_ring = (adapter->recv_ctx)->rds_rings + (unsigned long )ring;
  tmp___0 = list_empty((struct list_head const *)(& sds_ring->free_list) + (unsigned long )ring);
  if (tmp___0 == 0) {
    cur = ((struct list_head *)(& sds_ring->free_list) + (unsigned long )ring)->next;
    goto ldv_53439;
    ldv_53438:
    __mptr = (struct list_head const *)cur;
    rxbuf = (struct qlcnic_rx_buffer *)__mptr + 0xfffffffffffffff0UL;
    qlcnic_alloc_rx_skb(adapter, rds_ring, rxbuf);
    cur = cur->next;
    ldv_53439: ;
    if ((unsigned long )((struct list_head *)(& sds_ring->free_list) + (unsigned long )ring) != (unsigned long )cur) {
      goto ldv_53438;
    } else {
    }
    spin_lock(& rds_ring->lock);
    list_splice_tail_init((struct list_head *)(& sds_ring->free_list) + (unsigned long )ring,
                          & rds_ring->free_list);
    spin_unlock(& rds_ring->lock);
  } else {
  }
  qlcnic_post_rx_buffers_nodb(adapter, rds_ring, (int )ring);
  ring = (u8 )((int )ring + 1);
  ldv_53442: ;
  if ((int )adapter->max_rds_rings > (int )ring) {
    goto ldv_53441;
  } else {
  }
  if (count != 0) {
    sds_ring->consumer = consumer;
    writel(consumer, (void volatile *)sds_ring->crb_sts_consumer);
  } else {
  }
  return (count);
}
}
static int qlcnic_83xx_msix_sriov_vf_poll(struct napi_struct *napi , int budget )
{
  int tx_complete ;
  int work_done ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct napi_struct const *__mptr ;
  {
  __mptr = (struct napi_struct const *)napi;
  sds_ring = (struct qlcnic_host_sds_ring *)__mptr + 0xffffffffffffffd8UL;
  adapter = sds_ring->adapter;
  tx_ring = adapter->tx_ring;
  tx_complete = qlcnic_process_cmd_ring(adapter, tx_ring, budget);
  work_done = qlcnic_83xx_process_rcv_ring(sds_ring, budget);
  if (work_done < budget && tx_complete != 0) {
    napi_complete(& sds_ring->napi);
    qlcnic_enable_sds_intr(adapter, sds_ring);
  } else {
  }
  return (work_done);
}
}
static int qlcnic_83xx_poll(struct napi_struct *napi , int budget )
{
  int tx_complete ;
  int work_done ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct napi_struct const *__mptr ;
  {
  __mptr = (struct napi_struct const *)napi;
  sds_ring = (struct qlcnic_host_sds_ring *)__mptr + 0xffffffffffffffd8UL;
  adapter = sds_ring->adapter;
  tx_ring = adapter->tx_ring;
  tx_complete = qlcnic_process_cmd_ring(adapter, tx_ring, budget);
  work_done = qlcnic_83xx_process_rcv_ring(sds_ring, budget);
  if (work_done < budget && tx_complete != 0) {
    napi_complete(& sds_ring->napi);
    qlcnic_enable_sds_intr(adapter, sds_ring);
  } else {
  }
  return (work_done);
}
}
static int qlcnic_83xx_msix_tx_poll(struct napi_struct *napi , int budget )
{
  int work_done ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_adapter *adapter ;
  struct napi_struct const *__mptr ;
  int tmp ;
  {
  budget = 128;
  __mptr = (struct napi_struct const *)napi;
  tx_ring = (struct qlcnic_host_tx_ring *)__mptr + 0xffffffffffffff80UL;
  adapter = tx_ring->adapter;
  work_done = qlcnic_process_cmd_ring(adapter, tx_ring, budget);
  if (work_done != 0) {
    napi_complete(& tx_ring->napi);
    tmp = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
    if (tmp != 0) {
      qlcnic_enable_tx_intr(adapter, tx_ring);
    } else {
    }
  } else {
  }
  return (work_done);
}
}
static int qlcnic_83xx_rx_poll(struct napi_struct *napi , int budget )
{
  int work_done ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  struct napi_struct const *__mptr ;
  int tmp ;
  {
  __mptr = (struct napi_struct const *)napi;
  sds_ring = (struct qlcnic_host_sds_ring *)__mptr + 0xffffffffffffffd8UL;
  adapter = sds_ring->adapter;
  work_done = qlcnic_83xx_process_rcv_ring(sds_ring, budget);
  if (work_done < budget) {
    napi_complete(& sds_ring->napi);
    tmp = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
    if (tmp != 0) {
      qlcnic_enable_sds_intr(adapter, sds_ring);
    } else {
    }
  } else {
  }
  return (work_done);
}
}
void qlcnic_83xx_napi_enable(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  {
  recv_ctx = adapter->recv_ctx;
  if ((unsigned int )adapter->is_up != 777U) {
    return;
  } else {
  }
  ring = 0;
  goto ldv_53492;
  ldv_53491:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  napi_enable(& sds_ring->napi);
  if ((adapter->flags & 4U) != 0U) {
    qlcnic_enable_sds_intr(adapter, sds_ring);
  } else {
  }
  ring = ring + 1;
  ldv_53492: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53491;
  } else {
  }
  if ((adapter->flags & 4U) != 0U && (adapter->flags & 65536U) == 0U) {
    ring = 0;
    goto ldv_53495;
    ldv_53494:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    napi_enable(& tx_ring->napi);
    qlcnic_enable_tx_intr(adapter, tx_ring);
    ring = ring + 1;
    ldv_53495: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_53494;
    } else {
    }
  } else {
  }
  return;
}
}
void qlcnic_83xx_napi_disable(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_tx_ring *tx_ring ;
  {
  recv_ctx = adapter->recv_ctx;
  if ((unsigned int )adapter->is_up != 777U) {
    return;
  } else {
  }
  ring = 0;
  goto ldv_53505;
  ldv_53504:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  if ((adapter->flags & 4U) != 0U) {
    qlcnic_disable_sds_intr(adapter, sds_ring);
  } else {
  }
  napi_synchronize((struct napi_struct const *)(& sds_ring->napi));
  napi_disable(& sds_ring->napi);
  ring = ring + 1;
  ldv_53505: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53504;
  } else {
  }
  if ((adapter->flags & 4U) != 0U && (adapter->flags & 65536U) == 0U) {
    ring = 0;
    goto ldv_53508;
    ldv_53507:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    qlcnic_disable_tx_intr(adapter, tx_ring);
    napi_synchronize((struct napi_struct const *)(& tx_ring->napi));
    napi_disable(& tx_ring->napi);
    ring = ring + 1;
    ldv_53508: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_53507;
    } else {
    }
  } else {
  }
  return;
}
}
int qlcnic_83xx_napi_add(struct qlcnic_adapter *adapter , struct net_device *netdev )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_tx_ring *tx_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  int tmp ;
  int tmp___0 ;
  {
  recv_ctx = adapter->recv_ctx;
  tmp = qlcnic_alloc_sds_rings(recv_ctx, (int )adapter->drv_sds_rings);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  ring = 0;
  goto ldv_53519;
  ldv_53518:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  if ((adapter->flags & 4U) != 0U) {
    if ((adapter->flags & 65536U) == 0U) {
      netif_napi_add(netdev, & sds_ring->napi, & qlcnic_83xx_rx_poll, 64);
    } else {
      netif_napi_add(netdev, & sds_ring->napi, & qlcnic_83xx_msix_sriov_vf_poll, 64);
    }
  } else {
    netif_napi_add(netdev, & sds_ring->napi, & qlcnic_83xx_poll, 64);
  }
  ring = ring + 1;
  ldv_53519: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53518;
  } else {
  }
  tmp___0 = qlcnic_alloc_tx_rings(adapter, netdev);
  if (tmp___0 != 0) {
    qlcnic_free_sds_rings(recv_ctx);
    return (-12);
  } else {
  }
  if ((adapter->flags & 4U) != 0U && (adapter->flags & 65536U) == 0U) {
    ring = 0;
    goto ldv_53522;
    ldv_53521:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    netif_napi_add(netdev, & tx_ring->napi, & qlcnic_83xx_msix_tx_poll, 64);
    ring = ring + 1;
    ldv_53522: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_53521;
    } else {
    }
  } else {
  }
  return (0);
}
}
void qlcnic_83xx_napi_del(struct qlcnic_adapter *adapter )
{
  int ring ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_host_tx_ring *tx_ring ;
  {
  recv_ctx = adapter->recv_ctx;
  ring = 0;
  goto ldv_53532;
  ldv_53531:
  sds_ring = recv_ctx->sds_rings + (unsigned long )ring;
  netif_napi_del(& sds_ring->napi);
  ring = ring + 1;
  ldv_53532: ;
  if ((int )adapter->drv_sds_rings > ring) {
    goto ldv_53531;
  } else {
  }
  qlcnic_free_sds_rings(adapter->recv_ctx);
  if ((adapter->flags & 4U) != 0U && (adapter->flags & 65536U) == 0U) {
    ring = 0;
    goto ldv_53535;
    ldv_53534:
    tx_ring = adapter->tx_ring + (unsigned long )ring;
    netif_napi_del(& tx_ring->napi);
    ring = ring + 1;
    ldv_53535: ;
    if ((int )adapter->drv_tx_rings > ring) {
      goto ldv_53534;
    } else {
    }
  } else {
  }
  qlcnic_free_tx_rings(adapter);
  return;
}
}
static void qlcnic_83xx_process_rcv_diag(struct qlcnic_adapter *adapter , int ring ,
                                         u64 *sts_data )
{
  struct qlcnic_recv_context *recv_ctx ;
  struct sk_buff *skb ;
  struct qlcnic_host_rds_ring *rds_ring ;
  int index ;
  int length ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  {
  recv_ctx = adapter->recv_ctx;
  tmp = ldv__builtin_expect((int )adapter->max_rds_rings <= ring, 0L);
  if (tmp != 0L) {
    return;
  } else {
  }
  rds_ring = recv_ctx->rds_rings + (unsigned long )ring;
  index = (int )(*sts_data >> 48) & 32767;
  tmp___0 = ldv__builtin_expect((u32 )index >= rds_ring->num_desc, 0L);
  if (tmp___0 != 0L) {
    return;
  } else {
  }
  length = (int )(*sts_data >> 32) & 16383;
  skb = qlcnic_process_rxbuf(adapter, rds_ring, (int )((u16 )index), 2);
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    return;
  } else {
  }
  if ((u32 )length > rds_ring->skb_size) {
    skb_put(skb, rds_ring->skb_size);
  } else {
    skb_put(skb, (unsigned int )length);
  }
  tmp___1 = qlcnic_check_loopback_buff(skb->data, (u8 *)(& adapter->mac_addr));
  if (tmp___1 == 0) {
    (adapter->ahw)->diag_cnt = (adapter->ahw)->diag_cnt + 1;
  } else {
    dump_skb(skb, adapter);
  }
  dev_kfree_skb_any(skb);
  return;
}
}
void qlcnic_83xx_process_rcv_ring_diag(struct qlcnic_host_sds_ring *sds_ring )
{
  struct qlcnic_adapter *adapter ;
  struct status_desc *desc ;
  u64 sts_data[2U] ;
  int ring ;
  int opcode ;
  u32 consumer ;
  {
  adapter = sds_ring->adapter;
  consumer = sds_ring->consumer;
  desc = sds_ring->desc_head + (unsigned long )consumer;
  sts_data[0] = desc->status_desc_data[0];
  sts_data[1] = desc->status_desc_data[1];
  opcode = (int )(sts_data[1] >> 42) & 15;
  if (opcode == 0) {
    return;
  } else {
  }
  ring = 0;
  qlcnic_83xx_process_rcv_diag(adapter, ring, (u64 *)(& sts_data));
  desc = sds_ring->desc_head + (unsigned long )consumer;
  desc->status_desc_data[0] = 144115188075855872ULL;
  consumer = (consumer + 1U) & (sds_ring->num_desc - 1U);
  sds_ring->consumer = consumer;
  writel(consumer, (void volatile *)sds_ring->crb_sts_consumer);
  return;
}
}
__inline static int spin_trylock(spinlock_t *lock )
{
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;
  {
  tmp = ldv_spin_trylock_241(lock);
  ldv_func_res = tmp;
  tmp___0 = ldv_spin_trylock();
  return (tmp___0);
  return (ldv_func_res);
}
}
void *ldv_kmem_cache_alloc_254(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_260(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_262(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_264(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_265(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_266(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_267(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_268(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_269(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_270(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_271(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
extern int __dynamic_dev_dbg(struct _ddebug * , struct device const * , char const *
                             , ...) ;
extern int kstrtoull(char const * , unsigned int , unsigned long long * ) ;
__inline static int kstrtoul(char const *s , unsigned int base , unsigned long *res )
{
  int tmp ;
  {
  tmp = kstrtoull(s, base, (unsigned long long *)res);
  return (tmp);
}
}
__inline static long PTR_ERR(void const *ptr )
{
  {
  return ((long )ptr);
}
}
__inline static bool IS_ERR(void const *ptr )
{
  long tmp ;
  {
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
  return (tmp != 0L);
}
}
extern int sysfs_create_bin_file(struct kobject * , struct bin_attribute const * ) ;
extern void sysfs_remove_bin_file(struct kobject * , struct bin_attribute const * ) ;
void *ldv_kmem_cache_alloc_298(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_315(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
extern int device_create_file(struct device * , struct device_attribute const * ) ;
extern void device_remove_file(struct device * , struct device_attribute const * ) ;
extern int device_create_bin_file(struct device * , struct bin_attribute const * ) ;
extern void device_remove_bin_file(struct device * , struct bin_attribute const * ) ;
struct sk_buff *ldv_skb_clone_306(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_314(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_308(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_304(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_312(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_313(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_309(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_310(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_311(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void qlcnic_83xx_add_sysfs(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_remove_sysfs(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_config_led(struct qlcnic_adapter *adapter , u32 state , u32 beacon ) ;
int qlcnic_83xx_erase_flash_sector(struct qlcnic_adapter *adapter , u32 sector_start_addr ) ;
int qlcnic_83xx_flash_bulk_write(struct qlcnic_adapter *adapter , u32 addr , u32 *p_data ,
                                 int count ) ;
int qlcnic_83xx_flash_write32(struct qlcnic_adapter *adapter , u32 addr , u32 *p_data ) ;
int qlcnic_83xx_lock_flash(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_unlock_flash(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_lockless_flash_read32(struct qlcnic_adapter *adapter , u32 flash_addr ,
                                      u8 *p_data , int count ) ;
int qlcnic_83xx_enable_flash_write(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_disable_flash_write(struct qlcnic_adapter *adapter ) ;
__inline static void qlcnic_read_crb(struct qlcnic_adapter *adapter , char *buf ,
                                     loff_t offset , size_t size )
{
  {
  (*(((adapter->ahw)->hw_ops)->read_crb))(adapter, buf, offset, size);
  return;
}
}
__inline static void qlcnic_write_crb(struct qlcnic_adapter *adapter , char *buf ,
                                      loff_t offset , size_t size )
{
  {
  (*(((adapter->ahw)->hw_ops)->write_crb))(adapter, buf, offset, size);
  return;
}
}
__inline static void qlcnic_get_beacon_state(struct qlcnic_adapter *adapter )
{
  {
  (*(((adapter->ahw)->hw_ops)->get_beacon_state))(adapter);
  return;
}
}
__inline static int qlcnic_config_led(struct qlcnic_adapter *adapter , u32 state ,
                                      u32 rate )
{
  int tmp ;
  {
  tmp = (*((adapter->nic_ops)->config_led))(adapter, state, rate);
  return (tmp);
}
}
extern struct device *hwmon_device_register_with_groups(struct device * , char const * ,
                                                        void * , struct attribute_group const ** ) ;
extern void hwmon_device_unregister(struct device * ) ;
int qlcnicvf_config_bridged_mode(struct qlcnic_adapter *adapter , u32 enable )
{
  {
  return (-95);
}
}
int qlcnicvf_config_led(struct qlcnic_adapter *adapter , u32 state , u32 rate )
{
  {
  return (-95);
}
}
static ssize_t qlcnic_store_bridged_mode(struct device *dev , struct device_attribute *attr ,
                                         char const *buf , size_t len )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  unsigned long new ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  ret = -22;
  if (((adapter->ahw)->capabilities & 256U) == 0U) {
    goto err_out;
  } else {
  }
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    goto err_out;
  } else {
  }
  tmp___1 = kstrtoul(buf, 2U, & new);
  if (tmp___1 != 0) {
    goto err_out;
  } else {
  }
  tmp___2 = qlcnic_config_bridged_mode(adapter, new != 0UL);
  if (tmp___2 == 0) {
    ret = (int )len;
  } else {
  }
  err_out: ;
  return ((ssize_t )ret);
}
}
static ssize_t qlcnic_show_bridged_mode(struct device *dev , struct device_attribute *attr ,
                                        char *buf )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int bridged_mode ;
  int tmp___0 ;
  {
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  bridged_mode = 0;
  if (((adapter->ahw)->capabilities & 256U) != 0U) {
    bridged_mode = (adapter->flags & 16U) != 0U;
  } else {
  }
  tmp___0 = sprintf(buf, "%d\n", bridged_mode);
  return ((ssize_t )tmp___0);
}
}
static ssize_t qlcnic_store_diag_mode(struct device *dev , struct device_attribute *attr ,
                                      char const *buf , size_t len )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  unsigned long new ;
  int tmp___0 ;
  {
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = kstrtoul(buf, 2U, & new);
  if (tmp___0 != 0) {
    return (-22L);
  } else {
  }
  if ((new != 0UL) ^ ((adapter->flags & 32U) != 0U)) {
    adapter->flags = adapter->flags ^ 32U;
  } else {
  }
  return ((ssize_t )len);
}
}
static ssize_t qlcnic_show_diag_mode(struct device *dev , struct device_attribute *attr ,
                                     char *buf )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = sprintf(buf, "%d\n", (adapter->flags & 32U) != 0U);
  return ((ssize_t )tmp___0);
}
}
static int qlcnic_validate_beacon(struct qlcnic_adapter *adapter , u16 beacon , u8 *state ,
                                  u8 *rate )
{
  char const *tmp ;
  {
  *rate = (unsigned char )beacon;
  *state = (unsigned char )((int )beacon >> 8);
  if ((int )(adapter->ahw)->msg_enable & 1) {
    tmp = dev_name((struct device const *)(& (adapter->pdev)->dev));
    printk("\016%s: %s: rate %x state %x\n", tmp, "qlcnic_validate_beacon", (int )*rate,
           (int )*state);
  } else {
  }
  if ((unsigned int )*state == 0U) {
    *rate = 15U;
    return (0);
  } else
  if ((unsigned int )*state > 2U) {
    return (-22);
  } else {
  }
  if ((unsigned int )*rate == 0U || (unsigned int )*rate > 15U) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_store_beacon(struct qlcnic_adapter *adapter , char const *buf ,
                                    size_t len )
{
  struct qlcnic_hardware_context *ahw ;
  unsigned long h_beacon ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  ahw = adapter->ahw;
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    return (-5);
  } else {
  }
  tmp___0 = kstrtoul(buf, 2U, & h_beacon);
  if (tmp___0 != 0) {
    return (-22);
  } else {
  }
  qlcnic_get_beacon_state(adapter);
  if ((unsigned long )ahw->beacon_state == h_beacon) {
    return ((int )len);
  } else {
  }
  rtnl_lock();
  if ((unsigned int )ahw->beacon_state == 0U) {
    tmp___1 = test_and_set_bit(7L, (unsigned long volatile *)(& adapter->state));
    if (tmp___1 != 0) {
      rtnl_unlock();
      return (-16);
    } else {
    }
  } else {
  }
  if (h_beacon != 0UL) {
    err = qlcnic_83xx_config_led(adapter, 1U, (u32 )h_beacon);
  } else {
    err = qlcnic_83xx_config_led(adapter, 0U, h_beacon == 0UL);
  }
  if (err == 0) {
    ahw->beacon_state = (u8 )h_beacon;
  } else {
  }
  if ((unsigned int )ahw->beacon_state == 0U) {
    clear_bit(7L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  rtnl_unlock();
  return ((int )len);
}
}
static int qlcnic_82xx_store_beacon(struct qlcnic_adapter *adapter , char const *buf ,
                                    size_t len )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  int drv_sds_rings ;
  u16 beacon ;
  u8 b_state ;
  u8 b_rate ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  ahw = adapter->ahw;
  drv_sds_rings = (int )adapter->drv_sds_rings;
  if (len != 2UL) {
    return (-1);
  } else {
  }
  __len = 2UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& beacon), (void const *)buf, __len);
  } else {
    __ret = memcpy((void *)(& beacon), (void const *)buf, __len);
  }
  err = qlcnic_validate_beacon(adapter, (int )beacon, & b_state, & b_rate);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_get_beacon_state(adapter);
  if ((int )ahw->beacon_state == (int )b_state) {
    return ((int )len);
  } else {
  }
  rtnl_lock();
  if ((unsigned int )ahw->beacon_state == 0U) {
    tmp = test_and_set_bit(7L, (unsigned long volatile *)(& adapter->state));
    if (tmp != 0) {
      rtnl_unlock();
      return (-16);
    } else {
    }
  } else {
  }
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    err = -5;
    goto out;
  } else {
  }
  tmp___1 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___1 == 0) {
    err = qlcnic_diag_alloc_res(adapter->netdev, 3);
    if (err != 0) {
      goto out;
    } else {
    }
    set_bit(6L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  err = qlcnic_config_led(adapter, (u32 )b_state, (u32 )b_rate);
  if (err == 0) {
    err = (int )len;
    ahw->beacon_state = b_state;
  } else {
  }
  tmp___2 = test_and_clear_bit(6L, (unsigned long volatile *)(& adapter->state));
  if (tmp___2 != 0) {
    qlcnic_diag_free_res(adapter->netdev, drv_sds_rings);
  } else {
  }
  out: ;
  if ((unsigned int )ahw->beacon_state == 0U) {
    clear_bit(7L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  rtnl_unlock();
  return (err);
}
}
static ssize_t qlcnic_store_beacon(struct device *dev , struct device_attribute *attr ,
                                   char const *buf , size_t len )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = 0;
  if ((unsigned int )(adapter->ahw)->op_mode == 2U) {
    dev_warn((struct device const *)dev, "LED test not supported in non privileged mode\n");
    return (-95L);
  } else {
  }
  tmp___1 = qlcnic_82xx_check(adapter);
  if ((int )tmp___1) {
    err = qlcnic_82xx_store_beacon(adapter, buf, len);
  } else {
    tmp___0 = qlcnic_83xx_check(adapter);
    if ((int )tmp___0) {
      err = qlcnic_83xx_store_beacon(adapter, buf, len);
    } else {
      return (-5L);
    }
  }
  return ((ssize_t )err);
}
}
static ssize_t qlcnic_show_beacon(struct device *dev , struct device_attribute *attr ,
                                  char *buf )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = sprintf(buf, "%d\n", (int )(adapter->ahw)->beacon_state);
  return ((ssize_t )tmp___0);
}
}
static int qlcnic_sysfs_validate_crb(struct qlcnic_adapter *adapter , loff_t offset ,
                                     size_t size )
{
  size_t crb_size ;
  {
  crb_size = 4UL;
  if ((adapter->flags & 32U) == 0U) {
    return (-5);
  } else {
  }
  if ((unsigned long long )offset <= 100663295ULL) {
    if ((unsigned long long )offset <= 75499519ULL && (unsigned long long )offset > 75497471ULL) {
      crb_size = 8UL;
    } else {
      return (-22);
    }
  } else {
  }
  if (size != crb_size || ((unsigned long long )(crb_size - 1UL) & (unsigned long long )offset) != 0ULL) {
    return (-22);
  } else {
  }
  return (0);
}
}
static ssize_t qlcnic_sysfs_read_crb(struct file *filp , struct kobject *kobj , struct bin_attribute *attr ,
                                     char *buf , loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int ret ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  ret = qlcnic_sysfs_validate_crb(adapter, offset, size);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  qlcnic_read_crb(adapter, buf, offset, size);
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_write_crb(struct file *filp , struct kobject *kobj , struct bin_attribute *attr ,
                                      char *buf , loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int ret ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  ret = qlcnic_sysfs_validate_crb(adapter, offset, size);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  qlcnic_write_crb(adapter, buf, offset, size);
  return ((ssize_t )size);
}
}
static int qlcnic_sysfs_validate_mem(struct qlcnic_adapter *adapter , loff_t offset ,
                                     size_t size )
{
  {
  if ((adapter->flags & 32U) == 0U) {
    return (-5);
  } else {
  }
  if (size != 8UL || (offset & 7LL) != 0LL) {
    return (-5);
  } else {
  }
  return (0);
}
}
static ssize_t qlcnic_sysfs_read_mem(struct file *filp , struct kobject *kobj , struct bin_attribute *attr ,
                                     char *buf , loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u64 data ;
  int ret ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  ret = qlcnic_sysfs_validate_mem(adapter, offset, size);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  tmp___0 = qlcnic_pci_mem_read_2M(adapter, (u64 )offset, & data);
  if (tmp___0 != 0) {
    return (-5L);
  } else {
  }
  __len = size;
  __ret = memcpy((void *)buf, (void const *)(& data), __len);
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_write_mem(struct file *filp , struct kobject *kobj , struct bin_attribute *attr ,
                                      char *buf , loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  u64 data ;
  int ret ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  ret = qlcnic_sysfs_validate_mem(adapter, offset, size);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  __len = size;
  __ret = memcpy((void *)(& data), (void const *)buf, __len);
  tmp___0 = qlcnic_pci_mem_write_2M(adapter, (u64 )offset, data);
  if (tmp___0 != 0) {
    return (-5L);
  } else {
  }
  return ((ssize_t )size);
}
}
int qlcnic_is_valid_nic_func(struct qlcnic_adapter *adapter , u8 pci_func )
{
  int i ;
  {
  i = 0;
  goto ldv_53156;
  ldv_53155: ;
  if ((int )(adapter->npars + (unsigned long )i)->pci_func == (int )pci_func) {
    return (i);
  } else {
  }
  i = i + 1;
  ldv_53156: ;
  if ((int )(adapter->ahw)->total_nic_func > i) {
    goto ldv_53155;
  } else {
  }
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid nic function\n",
          "qlcnic_is_valid_nic_func");
  return (-22);
}
}
static int validate_pm_config(struct qlcnic_adapter *adapter , struct qlcnic_pm_func_cfg *pm_cfg ,
                              int count )
{
  u8 src_pci_func ;
  u8 s_esw_id ;
  u8 d_esw_id ;
  u8 dest_pci_func ;
  int i ;
  int src_index ;
  int dest_index ;
  {
  i = 0;
  goto ldv_53172;
  ldv_53171:
  src_pci_func = (pm_cfg + (unsigned long )i)->pci_func;
  dest_pci_func = (pm_cfg + (unsigned long )i)->dest_npar;
  src_index = qlcnic_is_valid_nic_func(adapter, (int )src_pci_func);
  if (src_index < 0) {
    return (-1);
  } else {
  }
  dest_index = qlcnic_is_valid_nic_func(adapter, (int )dest_pci_func);
  if (dest_index < 0) {
    return (-1);
  } else {
  }
  s_esw_id = (adapter->npars + (unsigned long )src_index)->phy_port;
  d_esw_id = (adapter->npars + (unsigned long )dest_index)->phy_port;
  if ((int )s_esw_id != (int )d_esw_id) {
    return (-1);
  } else {
  }
  i = i + 1;
  ldv_53172: ;
  if (i < count) {
    goto ldv_53171;
  } else {
  }
  return (0);
}
}
static ssize_t qlcnic_sysfs_write_pm_config(struct file *filp , struct kobject *kobj ,
                                            struct bin_attribute *attr , char *buf ,
                                            loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_pm_func_cfg *pm_cfg ;
  u32 id ;
  u32 action ;
  u32 pci_func ;
  int count ;
  int rem ;
  int i ;
  int ret ;
  int index ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  count = (int )(size / 8UL);
  rem = (int )size & 7;
  if (rem != 0) {
    return (-1L);
  } else {
  }
  pm_cfg = (struct qlcnic_pm_func_cfg *)buf;
  ret = validate_pm_config(adapter, pm_cfg, count);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  i = 0;
  goto ldv_53196;
  ldv_53195:
  pci_func = (u32 )(pm_cfg + (unsigned long )i)->pci_func;
  action = (unsigned int )(pm_cfg + (unsigned long )i)->action != 0U;
  index = qlcnic_is_valid_nic_func(adapter, (int )((u8 )pci_func));
  if (index < 0) {
    return (-1L);
  } else {
  }
  id = (u32 )(adapter->npars + (unsigned long )index)->phy_port;
  ret = qlcnic_config_port_mirroring(adapter, (int )((u8 )id), (int )((u8 )action),
                                     (int )((u8 )pci_func));
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  i = i + 1;
  ldv_53196: ;
  if (i < count) {
    goto ldv_53195;
  } else {
  }
  i = 0;
  goto ldv_53199;
  ldv_53198:
  pci_func = (u32 )(pm_cfg + (unsigned long )i)->pci_func;
  index = qlcnic_is_valid_nic_func(adapter, (int )((u8 )pci_func));
  if (index < 0) {
    return (-1L);
  } else {
  }
  id = (u32 )(adapter->npars + (unsigned long )index)->phy_port;
  (adapter->npars + (unsigned long )index)->enable_pm = (unsigned int )(pm_cfg + (unsigned long )i)->action != 0U;
  (adapter->npars + (unsigned long )index)->dest_npar = (u8 )id;
  i = i + 1;
  ldv_53199: ;
  if (i < count) {
    goto ldv_53198;
  } else {
  }
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_read_pm_config(struct file *filp , struct kobject *kobj ,
                                           struct bin_attribute *attr , char *buf ,
                                           loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_pm_func_cfg *pm_cfg ;
  u8 pci_func ;
  u32 count ;
  int i ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  memset((void *)buf, 0, size);
  pm_cfg = (struct qlcnic_pm_func_cfg *)buf;
  count = (u32 )(size / 8UL);
  i = 0;
  goto ldv_53221;
  ldv_53220:
  pci_func = (adapter->npars + (unsigned long )i)->pci_func;
  if ((u32 )pci_func >= count) {
    descriptor.modname = "qlcnic";
    descriptor.function = "qlcnic_sysfs_read_pm_config";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.o.c.prepared";
    descriptor.format = "%s: Total nic functions[%d], App sent function count[%d]\n";
    descriptor.lineno = 623U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device const *)dev, "%s: Total nic functions[%d], App sent function count[%d]\n",
                        "qlcnic_sysfs_read_pm_config", (int )(adapter->ahw)->total_nic_func,
                        count);
    } else {
    }
    goto ldv_53219;
  } else {
  }
  if (! (adapter->npars + (unsigned long )i)->eswitch_status) {
    goto ldv_53219;
  } else {
  }
  (pm_cfg + (unsigned long )pci_func)->action = (adapter->npars + (unsigned long )i)->enable_pm;
  (pm_cfg + (unsigned long )pci_func)->dest_npar = 0U;
  (pm_cfg + (unsigned long )pci_func)->pci_func = (u8 )i;
  ldv_53219:
  i = i + 1;
  ldv_53221: ;
  if ((int )(adapter->ahw)->total_nic_func > i) {
    goto ldv_53220;
  } else {
  }
  return ((ssize_t )size);
}
}
static int validate_esw_config(struct qlcnic_adapter *adapter , struct qlcnic_esw_func_cfg *esw_cfg ,
                               int count )
{
  struct qlcnic_hardware_context *ahw ;
  int i ;
  int ret ;
  u32 op_mode ;
  u8 pci_func ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  ahw = adapter->ahw;
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    op_mode = readl((void const volatile *)ahw->pci_base0 + 20U);
  } else {
    op_mode = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 37UL));
  }
  i = 0;
  goto ldv_53239;
  ldv_53238:
  pci_func = (esw_cfg + (unsigned long )i)->pci_func;
  if ((u32 )pci_func >= ahw->max_vnic_func) {
    return (-1);
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode == 0U) {
    tmp___0 = qlcnic_is_valid_nic_func(adapter, (int )pci_func);
    if (tmp___0 < 0) {
      return (-1);
    } else {
    }
  } else {
  }
  switch ((int )(esw_cfg + (unsigned long )i)->op_mode) {
  case 0:
  tmp___1 = qlcnic_82xx_check(adapter);
  if ((int )tmp___1) {
    ret = (int )(op_mode >> (int )pci_func * 4) & 15;
  } else {
    ret = (int )(op_mode >> (int )pci_func * 2) & 3;
    (esw_cfg + (unsigned long )i)->offload_flags = 0U;
  }
  if (ret != 2) {
    if ((unsigned int )(esw_cfg + (unsigned long )i)->mac_anti_spoof != 0U) {
      return (-1);
    } else {
    }
    if ((unsigned int )(esw_cfg + (unsigned long )i)->mac_override != 1U) {
      return (-1);
    } else {
    }
    if ((unsigned int )(esw_cfg + (unsigned long )i)->promisc_mode != 1U) {
      return (-1);
    } else {
    }
  } else {
  }
  goto ldv_53234;
  case 1: ;
  if ((unsigned int )(esw_cfg + (unsigned long )i)->vlan_id <= 1U || (unsigned int )(esw_cfg + (unsigned long )i)->vlan_id > 4094U) {
    return (-1);
  } else {
  }
  if ((unsigned int )(esw_cfg + (unsigned long )i)->op_type == 0U) {
    return (-1);
  } else {
  }
  goto ldv_53234;
  case 2: ;
  if ((unsigned int )(esw_cfg + (unsigned long )i)->op_type == 0U) {
    return (-1);
  } else {
  }
  goto ldv_53234;
  default: ;
  return (-1);
  }
  ldv_53234:
  i = i + 1;
  ldv_53239: ;
  if (i < count) {
    goto ldv_53238;
  } else {
  }
  return (0);
}
}
static ssize_t qlcnic_sysfs_write_esw_config(struct file *file , struct kobject *kobj ,
                                             struct bin_attribute *attr , char *buf ,
                                             loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_esw_func_cfg *esw_cfg ;
  struct qlcnic_npar_info *npar ;
  int count ;
  int rem ;
  int i ;
  int ret ;
  int index ;
  u8 op_mode ;
  u8 pci_func ;
  int tmp___0 ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  op_mode = 0U;
  count = (int )(size / 16UL);
  rem = (int )size & 15;
  if (rem != 0) {
    return (-1L);
  } else {
  }
  esw_cfg = (struct qlcnic_esw_func_cfg *)buf;
  ret = validate_esw_config(adapter, esw_cfg, count);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  i = 0;
  goto ldv_53268;
  ldv_53267: ;
  if ((unsigned int )(adapter->ahw)->op_mode == 0U) {
    tmp___0 = qlcnic_config_switch_port(adapter, esw_cfg + (unsigned long )i);
    if (tmp___0 != 0) {
      return (-1L);
    } else {
    }
  } else {
  }
  if ((int )(adapter->ahw)->pci_func != (int )(esw_cfg + (unsigned long )i)->pci_func) {
    goto ldv_53262;
  } else {
  }
  op_mode = (esw_cfg + (unsigned long )i)->op_mode;
  qlcnic_get_eswitch_port_config(adapter, esw_cfg + (unsigned long )i);
  (esw_cfg + (unsigned long )i)->op_mode = op_mode;
  (esw_cfg + (unsigned long )i)->pci_func = (adapter->ahw)->pci_func;
  switch ((int )(esw_cfg + (unsigned long )i)->op_mode) {
  case 0:
  qlcnic_set_eswitch_port_features(adapter, esw_cfg + (unsigned long )i);
  rtnl_lock();
  qlcnic_set_netdev_features(adapter, esw_cfg + (unsigned long )i);
  rtnl_unlock();
  goto ldv_53264;
  case 1:
  qlcnic_set_vlan_config(adapter, esw_cfg + (unsigned long )i);
  goto ldv_53264;
  case 2:
  (esw_cfg + (unsigned long )i)->vlan_id = 0U;
  qlcnic_set_vlan_config(adapter, esw_cfg + (unsigned long )i);
  goto ldv_53264;
  }
  ldv_53264: ;
  ldv_53262:
  i = i + 1;
  ldv_53268: ;
  if (i < count) {
    goto ldv_53267;
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    goto out;
  } else {
  }
  i = 0;
  goto ldv_53276;
  ldv_53275:
  pci_func = (esw_cfg + (unsigned long )i)->pci_func;
  index = qlcnic_is_valid_nic_func(adapter, (int )pci_func);
  if (index < 0) {
    return (-1L);
  } else {
  }
  npar = adapter->npars + (unsigned long )index;
  switch ((int )(esw_cfg + (unsigned long )i)->op_mode) {
  case 0:
  npar->promisc_mode = (esw_cfg + (unsigned long )i)->promisc_mode;
  npar->mac_override = (esw_cfg + (unsigned long )i)->mac_override;
  npar->offload_flags = (esw_cfg + (unsigned long )i)->offload_flags;
  npar->mac_anti_spoof = (esw_cfg + (unsigned long )i)->mac_anti_spoof;
  npar->discard_tagged = (esw_cfg + (unsigned long )i)->discard_tagged;
  goto ldv_53272;
  case 1:
  npar->pvid = (esw_cfg + (unsigned long )i)->vlan_id;
  goto ldv_53272;
  case 2:
  npar->pvid = 0U;
  goto ldv_53272;
  }
  ldv_53272:
  i = i + 1;
  ldv_53276: ;
  if (i < count) {
    goto ldv_53275;
  } else {
  }
  out: ;
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_read_esw_config(struct file *file , struct kobject *kobj ,
                                            struct bin_attribute *attr , char *buf ,
                                            loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_esw_func_cfg *esw_cfg ;
  u8 pci_func ;
  u32 count ;
  int i ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  int tmp___1 ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  memset((void *)buf, 0, size);
  esw_cfg = (struct qlcnic_esw_func_cfg *)buf;
  count = (u32 )(size / 16UL);
  i = 0;
  goto ldv_53298;
  ldv_53297:
  pci_func = (adapter->npars + (unsigned long )i)->pci_func;
  if ((u32 )pci_func >= count) {
    descriptor.modname = "qlcnic";
    descriptor.function = "qlcnic_sysfs_read_esw_config";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.o.c.prepared";
    descriptor.format = "%s: Total nic functions[%d], App sent function count[%d]\n";
    descriptor.lineno = 798U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device const *)dev, "%s: Total nic functions[%d], App sent function count[%d]\n",
                        "qlcnic_sysfs_read_esw_config", (int )(adapter->ahw)->total_nic_func,
                        count);
    } else {
    }
    goto ldv_53296;
  } else {
  }
  if (! (adapter->npars + (unsigned long )i)->eswitch_status) {
    goto ldv_53296;
  } else {
  }
  (esw_cfg + (unsigned long )pci_func)->pci_func = pci_func;
  tmp___1 = qlcnic_get_eswitch_port_config(adapter, esw_cfg + (unsigned long )pci_func);
  if (tmp___1 != 0) {
    return (-1L);
  } else {
  }
  ldv_53296:
  i = i + 1;
  ldv_53298: ;
  if ((int )(adapter->ahw)->total_nic_func > i) {
    goto ldv_53297;
  } else {
  }
  return ((ssize_t )size);
}
}
static int validate_npar_config(struct qlcnic_adapter *adapter , struct qlcnic_npar_func_cfg *np_cfg ,
                                int count )
{
  u8 pci_func ;
  u8 i ;
  int tmp ;
  {
  i = 0U;
  goto ldv_53308;
  ldv_53307:
  pci_func = (np_cfg + (unsigned long )i)->pci_func;
  tmp = qlcnic_is_valid_nic_func(adapter, (int )pci_func);
  if (tmp < 0) {
    return (-1);
  } else {
  }
  if ((unsigned int )(np_cfg + (unsigned long )i)->min_bw > 100U || (unsigned int )(np_cfg + (unsigned long )i)->max_bw > 100U) {
    return (-1);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_53308: ;
  if ((int )i < count) {
    goto ldv_53307;
  } else {
  }
  return (0);
}
}
static ssize_t qlcnic_sysfs_write_npar_config(struct file *file , struct kobject *kobj ,
                                              struct bin_attribute *attr , char *buf ,
                                              loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_info nic_info ;
  struct qlcnic_npar_func_cfg *np_cfg ;
  int i ;
  int count ;
  int rem ;
  int ret ;
  int index ;
  u8 pci_func ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  count = (int )(size / 16UL);
  rem = (int )size & 15;
  if (rem != 0) {
    return (-1L);
  } else {
  }
  np_cfg = (struct qlcnic_npar_func_cfg *)buf;
  ret = validate_npar_config(adapter, np_cfg, count);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  i = 0;
  goto ldv_53331;
  ldv_53330:
  pci_func = (np_cfg + (unsigned long )i)->pci_func;
  memset((void *)(& nic_info), 0, 72UL);
  ret = qlcnic_get_nic_info(adapter, & nic_info, (int )pci_func);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  nic_info.pci_func = (u16 )pci_func;
  nic_info.min_tx_bw = (np_cfg + (unsigned long )i)->min_bw;
  nic_info.max_tx_bw = (np_cfg + (unsigned long )i)->max_bw;
  ret = qlcnic_set_nic_info(adapter, & nic_info);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  index = qlcnic_is_valid_nic_func(adapter, (int )pci_func);
  if (index < 0) {
    return (-1L);
  } else {
  }
  (adapter->npars + (unsigned long )index)->min_bw = nic_info.min_tx_bw;
  (adapter->npars + (unsigned long )index)->max_bw = nic_info.max_tx_bw;
  i = i + 1;
  ldv_53331: ;
  if (i < count) {
    goto ldv_53330;
  } else {
  }
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_read_npar_config(struct file *file , struct kobject *kobj ,
                                             struct bin_attribute *attr , char *buf ,
                                             loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_npar_func_cfg *np_cfg ;
  struct qlcnic_info nic_info ;
  u8 pci_func ;
  int i ;
  int ret ;
  u32 count ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  int tmp___1 ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  memset((void *)(& nic_info), 0, 72UL);
  memset((void *)buf, 0, size);
  np_cfg = (struct qlcnic_npar_func_cfg *)buf;
  count = (u32 )(size / 16UL);
  i = 0;
  goto ldv_53355;
  ldv_53354: ;
  if ((u32 )(adapter->npars + (unsigned long )i)->pci_func >= count) {
    descriptor.modname = "qlcnic";
    descriptor.function = "qlcnic_sysfs_read_npar_config";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.o.c.prepared";
    descriptor.format = "%s: Total nic functions[%d], App sent function count[%d]\n";
    descriptor.lineno = 897U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device const *)dev, "%s: Total nic functions[%d], App sent function count[%d]\n",
                        "qlcnic_sysfs_read_npar_config", (int )(adapter->ahw)->total_nic_func,
                        count);
    } else {
    }
    goto ldv_53353;
  } else {
  }
  if (! (adapter->npars + (unsigned long )i)->eswitch_status) {
    goto ldv_53353;
  } else {
  }
  pci_func = (adapter->npars + (unsigned long )i)->pci_func;
  tmp___1 = qlcnic_is_valid_nic_func(adapter, (int )pci_func);
  if (tmp___1 < 0) {
    goto ldv_53353;
  } else {
  }
  ret = qlcnic_get_nic_info(adapter, & nic_info, (int )pci_func);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  (np_cfg + (unsigned long )pci_func)->pci_func = pci_func;
  (np_cfg + (unsigned long )pci_func)->op_mode = (unsigned char )nic_info.op_mode;
  (np_cfg + (unsigned long )pci_func)->port_num = nic_info.phys_port;
  (np_cfg + (unsigned long )pci_func)->fw_capab = nic_info.capabilities;
  (np_cfg + (unsigned long )pci_func)->min_bw = nic_info.min_tx_bw;
  (np_cfg + (unsigned long )pci_func)->max_bw = nic_info.max_tx_bw;
  (np_cfg + (unsigned long )pci_func)->max_tx_queues = nic_info.max_tx_ques;
  (np_cfg + (unsigned long )pci_func)->max_rx_queues = nic_info.max_rx_ques;
  ldv_53353:
  i = i + 1;
  ldv_53355: ;
  if ((int )(adapter->ahw)->total_nic_func > i) {
    goto ldv_53354;
  } else {
  }
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_get_port_stats(struct file *file , struct kobject *kobj ,
                                           struct bin_attribute *attr , char *buf ,
                                           loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_esw_statistics port_stats ;
  int ret ;
  bool tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    return (-2L);
  } else {
  }
  if (size != 176UL) {
    return (-1L);
  } else {
  }
  if ((loff_t )(adapter->ahw)->max_vnic_func <= offset) {
    return (-1L);
  } else {
  }
  memset((void *)(& port_stats), 0, size);
  ret = qlcnic_get_port_stats(adapter, (int )((u8 const )offset), 0, & port_stats.rx);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  ret = qlcnic_get_port_stats(adapter, (int )((u8 const )offset), 1, & port_stats.tx);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  __len = size;
  __ret = memcpy((void *)buf, (void const *)(& port_stats), __len);
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_get_esw_stats(struct file *file , struct kobject *kobj ,
                                          struct bin_attribute *attr , char *buf ,
                                          loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_esw_statistics esw_stats ;
  int ret ;
  bool tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    return (-2L);
  } else {
  }
  if (size != 176UL) {
    return (-1L);
  } else {
  }
  if (offset > 1LL) {
    return (-1L);
  } else {
  }
  memset((void *)(& esw_stats), 0, size);
  ret = qlcnic_get_eswitch_stats(adapter, (int )((u8 const )offset), 0, & esw_stats.rx);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  ret = qlcnic_get_eswitch_stats(adapter, (int )((u8 const )offset), 1, & esw_stats.tx);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  __len = size;
  __ret = memcpy((void *)buf, (void const *)(& esw_stats), __len);
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_clear_esw_stats(struct file *file , struct kobject *kobj ,
                                            struct bin_attribute *attr , char *buf ,
                                            loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int ret ;
  bool tmp___0 ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    return (-2L);
  } else {
  }
  if (offset > 1LL) {
    return (-1L);
  } else {
  }
  ret = qlcnic_clear_esw_stats(adapter, 2, (int )((u8 )offset), 0);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  ret = qlcnic_clear_esw_stats(adapter, 2, (int )((u8 )offset), 1);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_clear_port_stats(struct file *file , struct kobject *kobj ,
                                             struct bin_attribute *attr , char *buf ,
                                             loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int ret ;
  bool tmp___0 ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = qlcnic_83xx_check(adapter);
  if ((int )tmp___0) {
    return (-2L);
  } else {
  }
  if ((loff_t )(adapter->ahw)->max_vnic_func <= offset) {
    return (-1L);
  } else {
  }
  ret = qlcnic_clear_esw_stats(adapter, 1, (int )((u8 )offset), 0);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  ret = qlcnic_clear_esw_stats(adapter, 1, (int )((u8 )offset), 1);
  if (ret != 0) {
    return ((ssize_t )ret);
  } else {
  }
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_sysfs_read_pci_config(struct file *file , struct kobject *kobj ,
                                            struct bin_attribute *attr , char *buf ,
                                            loff_t offset , size_t size )
{
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_pci_func_cfg *pci_cfg ;
  struct qlcnic_pci_info *pci_info ;
  int i ;
  int ret ;
  u32 count ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = kcalloc(size, 20UL, 208U);
  pci_info = (struct qlcnic_pci_info *)tmp___0;
  if ((unsigned long )pci_info == (unsigned long )((struct qlcnic_pci_info *)0)) {
    return (-12L);
  } else {
  }
  ret = qlcnic_get_pci_info(adapter, pci_info);
  if (ret != 0) {
    kfree((void const *)pci_info);
    return ((ssize_t )ret);
  } else {
  }
  pci_cfg = (struct qlcnic_pci_func_cfg *)buf;
  count = (u32 )(size / 16UL);
  i = 0;
  goto ldv_53438;
  ldv_53437:
  (pci_cfg + (unsigned long )i)->pci_func = (u8 )(pci_info + (unsigned long )i)->id;
  (pci_cfg + (unsigned long )i)->func_type = (pci_info + (unsigned long )i)->type;
  (pci_cfg + (unsigned long )i)->func_state = 0U;
  (pci_cfg + (unsigned long )i)->port_num = (pci_info + (unsigned long )i)->default_port;
  (pci_cfg + (unsigned long )i)->min_bw = (pci_info + (unsigned long )i)->tx_min_bw;
  (pci_cfg + (unsigned long )i)->max_bw = (pci_info + (unsigned long )i)->tx_max_bw;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& (pci_cfg + (unsigned long )i)->def_mac_addr), (void const *)(& (pci_info + (unsigned long )i)->mac),
                     __len);
  } else {
    __ret = memcpy((void *)(& (pci_cfg + (unsigned long )i)->def_mac_addr),
                             (void const *)(& (pci_info + (unsigned long )i)->mac),
                             __len);
  }
  i = i + 1;
  ldv_53438: ;
  if ((u32 )i < count) {
    goto ldv_53437;
  } else {
  }
  kfree((void const *)pci_info);
  return ((ssize_t )size);
}
}
static ssize_t qlcnic_83xx_sysfs_flash_read_handler(struct file *filp , struct kobject *kobj ,
                                                    struct bin_attribute *attr , char *buf ,
                                                    loff_t offset , size_t size )
{
  unsigned char *p_read_buf ;
  int ret ;
  int count ;
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  if (size == 0UL) {
    return (-1L);
  } else {
  }
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-1L);
  } else {
  }
  count = (int )(size / 4UL);
  if ((size & 3UL) != 0UL) {
    count = count + 1;
  } else {
  }
  tmp___0 = kcalloc(size, 1UL, 208U);
  p_read_buf = (unsigned char *)tmp___0;
  if ((unsigned long )p_read_buf == (unsigned long )((unsigned char *)0U)) {
    return (-12L);
  } else {
  }
  tmp___1 = qlcnic_83xx_lock_flash(adapter);
  if (tmp___1 != 0) {
    kfree((void const *)p_read_buf);
    return (-5L);
  } else {
  }
  ret = qlcnic_83xx_lockless_flash_read32(adapter, (u32 )offset, p_read_buf, count);
  if (ret != 0) {
    qlcnic_83xx_unlock_flash(adapter);
    kfree((void const *)p_read_buf);
    return ((ssize_t )ret);
  } else {
  }
  qlcnic_83xx_unlock_flash(adapter);
  __len = size;
  __ret = memcpy((void *)buf, (void const *)p_read_buf, __len);
  kfree((void const *)p_read_buf);
  return ((ssize_t )size);
}
}
static int qlcnic_83xx_sysfs_flash_bulk_write(struct qlcnic_adapter *adapter , char *buf ,
                                              loff_t offset , size_t size )
{
  int i ;
  int ret ;
  int count ;
  unsigned char *p_cache ;
  unsigned char *p_src ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  {
  tmp = kcalloc(size, 1UL, 208U);
  p_cache = (unsigned char *)tmp;
  if ((unsigned long )p_cache == (unsigned long )((unsigned char *)0U)) {
    return (-12);
  } else {
  }
  __len = size;
  __ret = memcpy((void *)p_cache, (void const *)buf, __len);
  p_src = p_cache;
  count = (int )(size / 4UL);
  tmp___0 = qlcnic_83xx_lock_flash(adapter);
  if (tmp___0 != 0) {
    kfree((void const *)p_cache);
    return (-5);
  } else {
  }
  if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
    ret = qlcnic_83xx_enable_flash_write(adapter);
    if (ret != 0) {
      kfree((void const *)p_cache);
      qlcnic_83xx_unlock_flash(adapter);
      return (-5);
    } else {
    }
  } else {
  }
  i = 0;
  goto ldv_53473;
  ldv_53472:
  ret = qlcnic_83xx_flash_bulk_write(adapter, (u32 )offset, (u32 *)p_src, 64);
  if (ret != 0) {
    if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
      ret = qlcnic_83xx_disable_flash_write(adapter);
      if (ret != 0) {
        kfree((void const *)p_cache);
        qlcnic_83xx_unlock_flash(adapter);
        return (-5);
      } else {
      }
    } else {
    }
    kfree((void const *)p_cache);
    qlcnic_83xx_unlock_flash(adapter);
    return (-5);
  } else {
  }
  p_src = p_src + 256UL;
  offset = (loff_t )((unsigned long long )offset + 256ULL);
  i = i + 1;
  ldv_53473: ;
  if (count / 64 > i) {
    goto ldv_53472;
  } else {
  }
  if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
    ret = qlcnic_83xx_disable_flash_write(adapter);
    if (ret != 0) {
      kfree((void const *)p_cache);
      qlcnic_83xx_unlock_flash(adapter);
      return (-5);
    } else {
    }
  } else {
  }
  kfree((void const *)p_cache);
  qlcnic_83xx_unlock_flash(adapter);
  return (0);
}
}
static int qlcnic_83xx_sysfs_flash_write(struct qlcnic_adapter *adapter , char *buf ,
                                         loff_t offset , size_t size )
{
  int i ;
  int ret ;
  int count ;
  unsigned char *p_cache ;
  unsigned char *p_src ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  {
  tmp = kcalloc(size, 1UL, 208U);
  p_cache = (unsigned char *)tmp;
  if ((unsigned long )p_cache == (unsigned long )((unsigned char *)0U)) {
    return (-12);
  } else {
  }
  __len = size;
  __ret = memcpy((void *)p_cache, (void const *)buf, __len);
  p_src = p_cache;
  count = (int )(size / 4UL);
  tmp___0 = qlcnic_83xx_lock_flash(adapter);
  if (tmp___0 != 0) {
    kfree((void const *)p_cache);
    return (-5);
  } else {
  }
  if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
    ret = qlcnic_83xx_enable_flash_write(adapter);
    if (ret != 0) {
      kfree((void const *)p_cache);
      qlcnic_83xx_unlock_flash(adapter);
      return (-5);
    } else {
    }
  } else {
  }
  i = 0;
  goto ldv_53490;
  ldv_53489:
  ret = qlcnic_83xx_flash_write32(adapter, (u32 )offset, (u32 *)p_src);
  if (ret != 0) {
    if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
      ret = qlcnic_83xx_disable_flash_write(adapter);
      if (ret != 0) {
        kfree((void const *)p_cache);
        qlcnic_83xx_unlock_flash(adapter);
        return (-5);
      } else {
      }
    } else {
    }
    kfree((void const *)p_cache);
    qlcnic_83xx_unlock_flash(adapter);
    return (-5);
  } else {
  }
  p_src = p_src + 4UL;
  offset = (loff_t )((unsigned long long )offset + 4ULL);
  i = i + 1;
  ldv_53490: ;
  if (i < count) {
    goto ldv_53489;
  } else {
  }
  if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
    ret = qlcnic_83xx_disable_flash_write(adapter);
    if (ret != 0) {
      kfree((void const *)p_cache);
      qlcnic_83xx_unlock_flash(adapter);
      return (-5);
    } else {
    }
  } else {
  }
  kfree((void const *)p_cache);
  qlcnic_83xx_unlock_flash(adapter);
  return (0);
}
}
static ssize_t qlcnic_83xx_sysfs_flash_write_handler(struct file *filp , struct kobject *kobj ,
                                                     struct bin_attribute *attr ,
                                                     char *buf , loff_t offset , size_t size )
{
  int ret ;
  int flash_mode ;
  unsigned long data ;
  struct device *dev ;
  struct kobject const *__mptr ;
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  __mptr = (struct kobject const *)kobj;
  dev = (struct device *)__mptr + 0xfffffffffffffff0UL;
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-1L);
  } else {
  }
  ret = kstrtoul((char const *)buf, 16U, & data);
  switch (data) {
  case 0xffffffffdeadbeefUL:
  flash_mode = 1;
  ret = qlcnic_83xx_erase_flash_sector(adapter, (u32 )offset);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s failed at %d\n",
            "qlcnic_83xx_sysfs_flash_write_handler", 1288);
    return (-5L);
  } else {
  }
  goto ldv_53509;
  case 0xffffffffcadcadcaUL:
  flash_mode = 3;
  goto ldv_53509;
  case 0xffffffffdacdacdaUL:
  flash_mode = 2;
  goto ldv_53509;
  default: ;
  if (flash_mode == 3) {
    ret = qlcnic_83xx_sysfs_flash_bulk_write(adapter, buf, offset, size);
    if (ret != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "%s failed at %d\n",
              "qlcnic_83xx_sysfs_flash_write_handler", 1307);
      return (-5L);
    } else {
    }
  } else {
  }
  if (flash_mode == 2) {
    ret = qlcnic_83xx_sysfs_flash_write(adapter, buf, offset, size);
    if (ret != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "%s failed at %d\n",
              "qlcnic_83xx_sysfs_flash_write_handler", 1318);
      return (-5L);
    } else {
    }
  } else {
  }
  }
  ldv_53509: ;
  return ((ssize_t )size);
}
}
static struct device_attribute dev_attr_bridged_mode = {{"bridged_mode", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qlcnic_show_bridged_mode, & qlcnic_store_bridged_mode};
static struct device_attribute dev_attr_diag_mode = {{"diag_mode", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & qlcnic_show_diag_mode, & qlcnic_store_diag_mode};
static struct device_attribute dev_attr_beacon = {{"beacon", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & qlcnic_show_beacon,
    & qlcnic_store_beacon};
static struct bin_attribute bin_attr_crb = {{"crb", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qlcnic_sysfs_read_crb,
    & qlcnic_sysfs_write_crb, 0};
static struct bin_attribute bin_attr_mem = {{"mem", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qlcnic_sysfs_read_mem,
    & qlcnic_sysfs_write_mem, 0};
static struct bin_attribute bin_attr_npar_config = {{"npar_config", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qlcnic_sysfs_read_npar_config, & qlcnic_sysfs_write_npar_config, 0};
static struct bin_attribute bin_attr_pci_config = {{"pci_config", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qlcnic_sysfs_read_pci_config, (ssize_t (*)(struct file * , struct kobject * ,
                                                         struct bin_attribute * ,
                                                         char * , loff_t , size_t ))0,
    0};
static struct bin_attribute bin_attr_port_stats = {{"port_stats", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qlcnic_sysfs_get_port_stats, & qlcnic_sysfs_clear_port_stats, 0};
static struct bin_attribute bin_attr_esw_stats = {{"esw_stats", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qlcnic_sysfs_get_esw_stats, & qlcnic_sysfs_clear_esw_stats, 0};
static struct bin_attribute bin_attr_esw_config = {{"esw_config", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qlcnic_sysfs_read_esw_config, & qlcnic_sysfs_write_esw_config, 0};
static struct bin_attribute bin_attr_pm_config = {{"pm_config", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    0UL, 0, & qlcnic_sysfs_read_pm_config, & qlcnic_sysfs_write_pm_config, 0};
static struct bin_attribute bin_attr_flash = {{"flash", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, 0UL, 0, & qlcnic_83xx_sysfs_flash_read_handler,
    & qlcnic_83xx_sysfs_flash_write_handler, 0};
static ssize_t qlcnic_hwmon_show_temp(struct device *dev , struct device_attribute *dev_attr ,
                                      char *buf )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  unsigned int temperature ;
  unsigned int value ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = dev_get_drvdata((struct device const *)dev);
  adapter = (struct qlcnic_adapter *)tmp;
  temperature = 0U;
  value = 0U;
  tmp___1 = qlcnic_83xx_check(adapter);
  if ((int )tmp___1) {
    value = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 42UL));
  } else {
    tmp___0 = qlcnic_82xx_check(adapter);
    if ((int )tmp___0) {
      value = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 18UL));
    } else {
    }
  }
  temperature = value >> 16;
  temperature = temperature * 1000U;
  tmp___2 = sprintf(buf, "%u\n", temperature);
  return ((ssize_t )tmp___2);
}
}
static struct sensor_device_attribute sensor_dev_attr_temp1_input = {{{"temp1_input", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
     & qlcnic_hwmon_show_temp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const * , size_t ))0}, 1};
static struct attribute *qlcnic_hwmon_attrs[2U] = { & sensor_dev_attr_temp1_input.dev_attr.attr, (struct attribute *)0};
static struct attribute_group const qlcnic_hwmon_group = {0, 0, (struct attribute **)(& qlcnic_hwmon_attrs), 0};
static struct attribute_group const *qlcnic_hwmon_groups[2U] = { & qlcnic_hwmon_group, (struct attribute_group const *)0};
void qlcnic_register_hwmon_dev(struct qlcnic_adapter *adapter )
{
  struct device *dev ;
  struct device *hwmon_dev ;
  bool tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  {
  dev = & (adapter->pdev)->dev;
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    (adapter->ahw)->hwmon_dev = (struct device *)0;
    return;
  } else {
  }
  hwmon_dev = hwmon_device_register_with_groups(dev, (char const *)(& qlcnic_driver_name),
                                                (void *)adapter, (struct attribute_group const **)(& qlcnic_hwmon_groups));
  tmp___1 = IS_ERR((void const *)hwmon_dev);
  if ((int )tmp___1) {
    tmp___0 = PTR_ERR((void const *)hwmon_dev);
    dev_err((struct device const *)dev, "Cannot register with hwmon, err=%ld\n",
            tmp___0);
    hwmon_dev = (struct device *)0;
  } else {
  }
  (adapter->ahw)->hwmon_dev = hwmon_dev;
  return;
}
}
void qlcnic_unregister_hwmon_dev(struct qlcnic_adapter *adapter )
{
  struct device *hwmon_dev ;
  {
  hwmon_dev = (adapter->ahw)->hwmon_dev;
  if ((unsigned long )hwmon_dev != (unsigned long )((struct device *)0)) {
    hwmon_device_unregister(hwmon_dev);
    (adapter->ahw)->hwmon_dev = (struct device *)0;
  } else {
  }
  return;
}
}
void qlcnic_create_sysfs_entries(struct qlcnic_adapter *adapter )
{
  struct device *dev ;
  int tmp ;
  {
  dev = & (adapter->pdev)->dev;
  if (((adapter->ahw)->capabilities & 256U) != 0U) {
    tmp = device_create_file(dev, (struct device_attribute const *)(& dev_attr_bridged_mode));
    if (tmp != 0) {
      dev_warn((struct device const *)dev, "failed to create bridged_mode sysfs entry\n");
    } else {
    }
  } else {
  }
  return;
}
}
void qlcnic_remove_sysfs_entries(struct qlcnic_adapter *adapter )
{
  struct device *dev ;
  {
  dev = & (adapter->pdev)->dev;
  if (((adapter->ahw)->capabilities & 256U) != 0U) {
    device_remove_file(dev, (struct device_attribute const *)(& dev_attr_bridged_mode));
  } else {
  }
  return;
}
}
static void qlcnic_create_diag_entries(struct qlcnic_adapter *adapter )
{
  struct device *dev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  {
  dev = & (adapter->pdev)->dev;
  tmp = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_port_stats));
  if (tmp != 0) {
    _dev_info((struct device const *)dev, "failed to create port stats sysfs entry");
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode == 2U) {
    return;
  } else {
  }
  tmp___0 = device_create_file(dev, (struct device_attribute const *)(& dev_attr_diag_mode));
  if (tmp___0 != 0) {
    _dev_info((struct device const *)dev, "failed to create diag_mode sysfs entry\n");
  } else {
  }
  tmp___1 = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_crb));
  if (tmp___1 != 0) {
    _dev_info((struct device const *)dev, "failed to create crb sysfs entry\n");
  } else {
  }
  tmp___2 = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_mem));
  if (tmp___2 != 0) {
    _dev_info((struct device const *)dev, "failed to create mem sysfs entry\n");
  } else {
  }
  tmp___3 = constant_test_bit(16L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___3 != 0) {
    return;
  } else {
  }
  tmp___4 = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_pci_config));
  if (tmp___4 != 0) {
    _dev_info((struct device const *)dev, "failed to create pci config sysfs entry");
  } else {
  }
  tmp___5 = device_create_file(dev, (struct device_attribute const *)(& dev_attr_beacon));
  if (tmp___5 != 0) {
    _dev_info((struct device const *)dev, "failed to create beacon sysfs entry");
  } else {
  }
  if ((adapter->flags & 64U) == 0U) {
    return;
  } else {
  }
  tmp___6 = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_esw_config));
  if (tmp___6 != 0) {
    _dev_info((struct device const *)dev, "failed to create esw config sysfs entry");
  } else {
  }
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    return;
  } else {
  }
  tmp___7 = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_npar_config));
  if (tmp___7 != 0) {
    _dev_info((struct device const *)dev, "failed to create npar config sysfs entry");
  } else {
  }
  tmp___8 = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_pm_config));
  if (tmp___8 != 0) {
    _dev_info((struct device const *)dev, "failed to create pm config sysfs entry");
  } else {
  }
  tmp___9 = device_create_bin_file(dev, (struct bin_attribute const *)(& bin_attr_esw_stats));
  if (tmp___9 != 0) {
    _dev_info((struct device const *)dev, "failed to create eswitch stats sysfs entry");
  } else {
  }
  return;
}
}
static void qlcnic_remove_diag_entries(struct qlcnic_adapter *adapter )
{
  struct device *dev ;
  int tmp ;
  {
  dev = & (adapter->pdev)->dev;
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_port_stats));
  if ((unsigned int )(adapter->ahw)->op_mode == 2U) {
    return;
  } else {
  }
  device_remove_file(dev, (struct device_attribute const *)(& dev_attr_diag_mode));
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_crb));
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_mem));
  tmp = constant_test_bit(16L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    return;
  } else {
  }
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_pci_config));
  device_remove_file(dev, (struct device_attribute const *)(& dev_attr_beacon));
  if ((adapter->flags & 64U) == 0U) {
    return;
  } else {
  }
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_esw_config));
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    return;
  } else {
  }
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_npar_config));
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_pm_config));
  device_remove_bin_file(dev, (struct bin_attribute const *)(& bin_attr_esw_stats));
  return;
}
}
void qlcnic_82xx_add_sysfs(struct qlcnic_adapter *adapter )
{
  {
  qlcnic_create_diag_entries(adapter);
  return;
}
}
void qlcnic_82xx_remove_sysfs(struct qlcnic_adapter *adapter )
{
  {
  qlcnic_remove_diag_entries(adapter);
  return;
}
}
void qlcnic_83xx_add_sysfs(struct qlcnic_adapter *adapter )
{
  struct device *dev ;
  int tmp ;
  {
  dev = & (adapter->pdev)->dev;
  qlcnic_create_diag_entries(adapter);
  tmp = sysfs_create_bin_file(& dev->kobj, (struct bin_attribute const *)(& bin_attr_flash));
  if (tmp != 0) {
    _dev_info((struct device const *)dev, "failed to create flash sysfs entry\n");
  } else {
  }
  return;
}
}
void qlcnic_83xx_remove_sysfs(struct qlcnic_adapter *adapter )
{
  struct device *dev ;
  {
  dev = & (adapter->pdev)->dev;
  qlcnic_remove_diag_entries(adapter);
  sysfs_remove_bin_file(& dev->kobj, (struct bin_attribute const *)(& bin_attr_flash));
  return;
}
}
extern int ldv_probe_16(void) ;
extern int ldv_release_14(void) ;
extern int ldv_release_11(void) ;
extern int ldv_probe_11(void) ;
extern int ldv_release_16(void) ;
extern int ldv_release_12(void) ;
extern int ldv_release_18(void) ;
extern int ldv_release_10(void) ;
extern int ldv_release_13(void) ;
extern int ldv_probe_10(void) ;
extern int ldv_probe_17(void) ;
extern int ldv_probe_15(void) ;
extern int ldv_release_17(void) ;
extern int ldv_probe_13(void) ;
extern int ldv_probe_12(void) ;
extern int ldv_probe_14(void) ;
extern int ldv_release_15(void) ;
extern int ldv_probe_18(void) ;
void ldv_initialize_bin_attribute_10(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_flash_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_flash_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_flash_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_initialize_device_attribute_21(void)
{
  void *tmp ;
  void *tmp___0 ;
  {
  tmp = ldv_zalloc(1416UL);
  dev_attr_bridged_mode_group0 = (struct device *)tmp;
  tmp___0 = ldv_zalloc(48UL);
  dev_attr_bridged_mode_group1 = (struct device_attribute *)tmp___0;
  return;
}
}
void ldv_initialize_bin_attribute_12(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_esw_config_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_esw_config_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_esw_config_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_initialize_bin_attribute_18(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_crb_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_crb_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_crb_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_initialize_device_attribute_20(void)
{
  void *tmp ;
  void *tmp___0 ;
  {
  tmp = ldv_zalloc(1416UL);
  dev_attr_diag_mode_group0 = (struct device *)tmp;
  tmp___0 = ldv_zalloc(48UL);
  dev_attr_diag_mode_group1 = (struct device_attribute *)tmp___0;
  return;
}
}
void ldv_initialize_bin_attribute_16(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_npar_config_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_npar_config_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_npar_config_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_initialize_bin_attribute_13(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_esw_stats_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_esw_stats_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_esw_stats_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_initialize_device_attribute_19(void)
{
  void *tmp ;
  void *tmp___0 ;
  {
  tmp = ldv_zalloc(1416UL);
  dev_attr_beacon_group0 = (struct device *)tmp;
  tmp___0 = ldv_zalloc(48UL);
  dev_attr_beacon_group1 = (struct device_attribute *)tmp___0;
  return;
}
}
void ldv_initialize_bin_attribute_17(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_mem_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_mem_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_mem_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_initialize_bin_attribute_14(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_port_stats_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_port_stats_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_port_stats_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_initialize_bin_attribute_11(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ldv_zalloc(512UL);
  bin_attr_pm_config_group2 = (struct file *)tmp;
  tmp___0 = ldv_zalloc(296UL);
  bin_attr_pm_config_group1 = (struct kobject *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  bin_attr_pm_config_group0 = (struct bin_attribute *)tmp___1;
  return;
}
}
void ldv_main_exported_11(void)
{
  loff_t ldvarg152 ;
  loff_t tmp ;
  loff_t ldvarg155 ;
  loff_t tmp___0 ;
  char *ldvarg151 ;
  void *tmp___1 ;
  size_t ldvarg153 ;
  size_t tmp___2 ;
  char *ldvarg154 ;
  void *tmp___3 ;
  size_t ldvarg150 ;
  size_t tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_loff_t();
  ldvarg152 = tmp;
  tmp___0 = __VERIFIER_nondet_loff_t();
  ldvarg155 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg151 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_size_t();
  ldvarg153 = tmp___2;
  tmp___3 = ldv_zalloc(1UL);
  ldvarg154 = (char *)tmp___3;
  tmp___4 = __VERIFIER_nondet_size_t();
  ldvarg150 = tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_11 == 2) {
    qlcnic_sysfs_write_pm_config(bin_attr_pm_config_group2, bin_attr_pm_config_group1,
                                 bin_attr_pm_config_group0, ldvarg154, ldvarg155,
                                 ldvarg153);
    ldv_state_variable_11 = 2;
  } else {
  }
  goto ldv_53663;
  case 1: ;
  if (ldv_state_variable_11 == 2) {
    qlcnic_sysfs_read_pm_config(bin_attr_pm_config_group2, bin_attr_pm_config_group1,
                                bin_attr_pm_config_group0, ldvarg151, ldvarg152, ldvarg150);
    ldv_state_variable_11 = 2;
  } else {
  }
  goto ldv_53663;
  case 2: ;
  if (ldv_state_variable_11 == 2) {
    ldv_release_11();
    ldv_state_variable_11 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53663;
  case 3: ;
  if (ldv_state_variable_11 == 1) {
    ldv_probe_11();
    ldv_state_variable_11 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53663;
  default:
  ldv_stop();
  }
  ldv_53663: ;
  return;
}
}
void ldv_main_exported_21(void)
{
  char *ldvarg38 ;
  void *tmp ;
  char *ldvarg36 ;
  void *tmp___0 ;
  size_t ldvarg37 ;
  size_t tmp___1 ;
  int tmp___2 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg38 = (char *)tmp;
  tmp___0 = ldv_zalloc(1UL);
  ldvarg36 = (char *)tmp___0;
  tmp___1 = __VERIFIER_nondet_size_t();
  ldvarg37 = tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_21 == 1) {
    qlcnic_store_bridged_mode(dev_attr_bridged_mode_group0, dev_attr_bridged_mode_group1,
                              (char const *)ldvarg38, ldvarg37);
    ldv_state_variable_21 = 1;
  } else {
  }
  goto ldv_53675;
  case 1: ;
  if (ldv_state_variable_21 == 1) {
    qlcnic_show_bridged_mode(dev_attr_bridged_mode_group0, dev_attr_bridged_mode_group1,
                             ldvarg36);
    ldv_state_variable_21 = 1;
  } else {
  }
  goto ldv_53675;
  default:
  ldv_stop();
  }
  ldv_53675: ;
  return;
}
}
void ldv_main_exported_9(void)
{
  struct device_attribute *ldvarg231 ;
  void *tmp ;
  struct device *ldvarg229 ;
  void *tmp___0 ;
  char *ldvarg230 ;
  void *tmp___1 ;
  int tmp___2 ;
  {
  tmp = ldv_zalloc(48UL);
  ldvarg231 = (struct device_attribute *)tmp;
  tmp___0 = ldv_zalloc(1416UL);
  ldvarg229 = (struct device *)tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg230 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_9 == 1) {
    qlcnic_hwmon_show_temp(ldvarg229, ldvarg231, ldvarg230);
    ldv_state_variable_9 = 1;
  } else {
  }
  goto ldv_53685;
  default:
  ldv_stop();
  }
  ldv_53685: ;
  return;
}
}
void ldv_main_exported_17(void)
{
  loff_t ldvarg50 ;
  loff_t tmp ;
  char *ldvarg49 ;
  void *tmp___0 ;
  char *ldvarg52 ;
  void *tmp___1 ;
  loff_t ldvarg53 ;
  loff_t tmp___2 ;
  size_t ldvarg51 ;
  size_t tmp___3 ;
  size_t ldvarg48 ;
  size_t tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_loff_t();
  ldvarg50 = tmp;
  tmp___0 = ldv_zalloc(1UL);
  ldvarg49 = (char *)tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg52 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_loff_t();
  ldvarg53 = tmp___2;
  tmp___3 = __VERIFIER_nondet_size_t();
  ldvarg51 = tmp___3;
  tmp___4 = __VERIFIER_nondet_size_t();
  ldvarg48 = tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_17 == 2) {
    qlcnic_sysfs_write_mem(bin_attr_mem_group2, bin_attr_mem_group1, bin_attr_mem_group0,
                           ldvarg52, ldvarg53, ldvarg51);
    ldv_state_variable_17 = 2;
  } else {
  }
  goto ldv_53697;
  case 1: ;
  if (ldv_state_variable_17 == 2) {
    qlcnic_sysfs_read_mem(bin_attr_mem_group2, bin_attr_mem_group1, bin_attr_mem_group0,
                          ldvarg49, ldvarg50, ldvarg48);
    ldv_state_variable_17 = 2;
  } else {
  }
  goto ldv_53697;
  case 2: ;
  if (ldv_state_variable_17 == 2) {
    ldv_release_17();
    ldv_state_variable_17 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53697;
  case 3: ;
  if (ldv_state_variable_17 == 1) {
    ldv_probe_17();
    ldv_state_variable_17 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53697;
  default:
  ldv_stop();
  }
  ldv_53697: ;
  return;
}
}
void ldv_main_exported_12(void)
{
  size_t ldvarg232 ;
  size_t tmp ;
  size_t ldvarg235 ;
  size_t tmp___0 ;
  char *ldvarg236 ;
  void *tmp___1 ;
  char *ldvarg233 ;
  void *tmp___2 ;
  loff_t ldvarg234 ;
  loff_t tmp___3 ;
  loff_t ldvarg237 ;
  loff_t tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_size_t();
  ldvarg232 = tmp;
  tmp___0 = __VERIFIER_nondet_size_t();
  ldvarg235 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg236 = (char *)tmp___1;
  tmp___2 = ldv_zalloc(1UL);
  ldvarg233 = (char *)tmp___2;
  tmp___3 = __VERIFIER_nondet_loff_t();
  ldvarg234 = tmp___3;
  tmp___4 = __VERIFIER_nondet_loff_t();
  ldvarg237 = tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_12 == 2) {
    qlcnic_sysfs_write_esw_config(bin_attr_esw_config_group2, bin_attr_esw_config_group1,
                                  bin_attr_esw_config_group0, ldvarg236, ldvarg237,
                                  ldvarg235);
    ldv_state_variable_12 = 2;
  } else {
  }
  goto ldv_53712;
  case 1: ;
  if (ldv_state_variable_12 == 2) {
    qlcnic_sysfs_read_esw_config(bin_attr_esw_config_group2, bin_attr_esw_config_group1,
                                 bin_attr_esw_config_group0, ldvarg233, ldvarg234,
                                 ldvarg232);
    ldv_state_variable_12 = 2;
  } else {
  }
  goto ldv_53712;
  case 2: ;
  if (ldv_state_variable_12 == 2) {
    ldv_release_12();
    ldv_state_variable_12 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53712;
  case 3: ;
  if (ldv_state_variable_12 == 1) {
    ldv_probe_12();
    ldv_state_variable_12 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53712;
  default:
  ldv_stop();
  }
  ldv_53712: ;
  return;
}
}
void ldv_main_exported_20(void)
{
  char *ldvarg114 ;
  void *tmp ;
  size_t ldvarg113 ;
  size_t tmp___0 ;
  char *ldvarg112 ;
  void *tmp___1 ;
  int tmp___2 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg114 = (char *)tmp;
  tmp___0 = __VERIFIER_nondet_size_t();
  ldvarg113 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg112 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_20 == 1) {
    qlcnic_store_diag_mode(dev_attr_diag_mode_group0, dev_attr_diag_mode_group1, (char const *)ldvarg114,
                           ldvarg113);
    ldv_state_variable_20 = 1;
  } else {
  }
  goto ldv_53724;
  case 1: ;
  if (ldv_state_variable_20 == 1) {
    qlcnic_show_diag_mode(dev_attr_diag_mode_group0, dev_attr_diag_mode_group1, ldvarg112);
    ldv_state_variable_20 = 1;
  } else {
  }
  goto ldv_53724;
  default:
  ldv_stop();
  }
  ldv_53724: ;
  return;
}
}
void ldv_main_exported_15(void)
{
  loff_t ldvarg243 ;
  loff_t tmp ;
  char *ldvarg239 ;
  void *tmp___0 ;
  struct bin_attribute *ldvarg241 ;
  void *tmp___1 ;
  struct file *ldvarg240 ;
  void *tmp___2 ;
  size_t ldvarg238 ;
  size_t tmp___3 ;
  struct kobject *ldvarg242 ;
  void *tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_loff_t();
  ldvarg243 = tmp;
  tmp___0 = ldv_zalloc(1UL);
  ldvarg239 = (char *)tmp___0;
  tmp___1 = ldv_zalloc(72UL);
  ldvarg241 = (struct bin_attribute *)tmp___1;
  tmp___2 = ldv_zalloc(512UL);
  ldvarg240 = (struct file *)tmp___2;
  tmp___3 = __VERIFIER_nondet_size_t();
  ldvarg238 = tmp___3;
  tmp___4 = ldv_zalloc(296UL);
  ldvarg242 = (struct kobject *)tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_15 == 2) {
    qlcnic_sysfs_read_pci_config(ldvarg240, ldvarg242, ldvarg241, ldvarg239, ldvarg243,
                                 ldvarg238);
    ldv_state_variable_15 = 2;
  } else {
  }
  goto ldv_53737;
  case 1: ;
  if (ldv_state_variable_15 == 2) {
    ldv_release_15();
    ldv_state_variable_15 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53737;
  case 2: ;
  if (ldv_state_variable_15 == 1) {
    ldv_probe_15();
    ldv_state_variable_15 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53737;
  default:
  ldv_stop();
  }
  ldv_53737: ;
  return;
}
}
void ldv_main_exported_14(void)
{
  size_t ldvarg115 ;
  size_t tmp ;
  size_t ldvarg118 ;
  size_t tmp___0 ;
  loff_t ldvarg117 ;
  loff_t tmp___1 ;
  char *ldvarg119 ;
  void *tmp___2 ;
  loff_t ldvarg120 ;
  loff_t tmp___3 ;
  char *ldvarg116 ;
  void *tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_size_t();
  ldvarg115 = tmp;
  tmp___0 = __VERIFIER_nondet_size_t();
  ldvarg118 = tmp___0;
  tmp___1 = __VERIFIER_nondet_loff_t();
  ldvarg117 = tmp___1;
  tmp___2 = ldv_zalloc(1UL);
  ldvarg119 = (char *)tmp___2;
  tmp___3 = __VERIFIER_nondet_loff_t();
  ldvarg120 = tmp___3;
  tmp___4 = ldv_zalloc(1UL);
  ldvarg116 = (char *)tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_14 == 2) {
    qlcnic_sysfs_clear_port_stats(bin_attr_port_stats_group2, bin_attr_port_stats_group1,
                                  bin_attr_port_stats_group0, ldvarg119, ldvarg120,
                                  ldvarg118);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_53751;
  case 1: ;
  if (ldv_state_variable_14 == 2) {
    qlcnic_sysfs_get_port_stats(bin_attr_port_stats_group2, bin_attr_port_stats_group1,
                                bin_attr_port_stats_group0, ldvarg116, ldvarg117,
                                ldvarg115);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_53751;
  case 2: ;
  if (ldv_state_variable_14 == 2) {
    ldv_release_14();
    ldv_state_variable_14 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53751;
  case 3: ;
  if (ldv_state_variable_14 == 1) {
    ldv_probe_14();
    ldv_state_variable_14 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53751;
  default:
  ldv_stop();
  }
  ldv_53751: ;
  return;
}
}
void ldv_main_exported_18(void)
{
  loff_t ldvarg90 ;
  loff_t tmp ;
  char *ldvarg89 ;
  void *tmp___0 ;
  char *ldvarg92 ;
  void *tmp___1 ;
  size_t ldvarg88 ;
  size_t tmp___2 ;
  size_t ldvarg91 ;
  size_t tmp___3 ;
  loff_t ldvarg93 ;
  loff_t tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_loff_t();
  ldvarg90 = tmp;
  tmp___0 = ldv_zalloc(1UL);
  ldvarg89 = (char *)tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg92 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_size_t();
  ldvarg88 = tmp___2;
  tmp___3 = __VERIFIER_nondet_size_t();
  ldvarg91 = tmp___3;
  tmp___4 = __VERIFIER_nondet_loff_t();
  ldvarg93 = tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_18 == 2) {
    qlcnic_sysfs_write_crb(bin_attr_crb_group2, bin_attr_crb_group1, bin_attr_crb_group0,
                           ldvarg92, ldvarg93, ldvarg91);
    ldv_state_variable_18 = 2;
  } else {
  }
  goto ldv_53766;
  case 1: ;
  if (ldv_state_variable_18 == 2) {
    qlcnic_sysfs_read_crb(bin_attr_crb_group2, bin_attr_crb_group1, bin_attr_crb_group0,
                          ldvarg89, ldvarg90, ldvarg88);
    ldv_state_variable_18 = 2;
  } else {
  }
  goto ldv_53766;
  case 2: ;
  if (ldv_state_variable_18 == 2) {
    ldv_release_18();
    ldv_state_variable_18 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53766;
  case 3: ;
  if (ldv_state_variable_18 == 1) {
    ldv_probe_18();
    ldv_state_variable_18 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53766;
  default:
  ldv_stop();
  }
  ldv_53766: ;
  return;
}
}
void ldv_main_exported_19(void)
{
  char *ldvarg291 ;
  void *tmp ;
  size_t ldvarg292 ;
  size_t tmp___0 ;
  char *ldvarg293 ;
  void *tmp___1 ;
  int tmp___2 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg291 = (char *)tmp;
  tmp___0 = __VERIFIER_nondet_size_t();
  ldvarg292 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg293 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_19 == 1) {
    qlcnic_store_beacon(dev_attr_beacon_group0, dev_attr_beacon_group1, (char const *)ldvarg293,
                        ldvarg292);
    ldv_state_variable_19 = 1;
  } else {
  }
  goto ldv_53778;
  case 1: ;
  if (ldv_state_variable_19 == 1) {
    qlcnic_show_beacon(dev_attr_beacon_group0, dev_attr_beacon_group1, ldvarg291);
    ldv_state_variable_19 = 1;
  } else {
  }
  goto ldv_53778;
  default:
  ldv_stop();
  }
  ldv_53778: ;
  return;
}
}
void ldv_main_exported_10(void)
{
  size_t ldvarg139 ;
  size_t tmp ;
  loff_t ldvarg141 ;
  loff_t tmp___0 ;
  char *ldvarg137 ;
  void *tmp___1 ;
  char *ldvarg140 ;
  void *tmp___2 ;
  loff_t ldvarg138 ;
  loff_t tmp___3 ;
  size_t ldvarg136 ;
  size_t tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_size_t();
  ldvarg139 = tmp;
  tmp___0 = __VERIFIER_nondet_loff_t();
  ldvarg141 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg137 = (char *)tmp___1;
  tmp___2 = ldv_zalloc(1UL);
  ldvarg140 = (char *)tmp___2;
  tmp___3 = __VERIFIER_nondet_loff_t();
  ldvarg138 = tmp___3;
  tmp___4 = __VERIFIER_nondet_size_t();
  ldvarg136 = tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_10 == 2) {
    qlcnic_83xx_sysfs_flash_write_handler(bin_attr_flash_group2, bin_attr_flash_group1,
                                          bin_attr_flash_group0, ldvarg140, ldvarg141,
                                          ldvarg139);
    ldv_state_variable_10 = 2;
  } else {
  }
  goto ldv_53791;
  case 1: ;
  if (ldv_state_variable_10 == 2) {
    qlcnic_83xx_sysfs_flash_read_handler(bin_attr_flash_group2, bin_attr_flash_group1,
                                         bin_attr_flash_group0, ldvarg137, ldvarg138,
                                         ldvarg136);
    ldv_state_variable_10 = 2;
  } else {
  }
  goto ldv_53791;
  case 2: ;
  if (ldv_state_variable_10 == 2) {
    ldv_release_10();
    ldv_state_variable_10 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53791;
  case 3: ;
  if (ldv_state_variable_10 == 1) {
    ldv_probe_10();
    ldv_state_variable_10 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53791;
  default:
  ldv_stop();
  }
  ldv_53791: ;
  return;
}
}
void ldv_main_exported_13(void)
{
  size_t ldvarg160 ;
  size_t tmp ;
  char *ldvarg161 ;
  void *tmp___0 ;
  loff_t ldvarg162 ;
  loff_t tmp___1 ;
  size_t ldvarg163 ;
  size_t tmp___2 ;
  loff_t ldvarg165 ;
  loff_t tmp___3 ;
  char *ldvarg164 ;
  void *tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_size_t();
  ldvarg160 = tmp;
  tmp___0 = ldv_zalloc(1UL);
  ldvarg161 = (char *)tmp___0;
  tmp___1 = __VERIFIER_nondet_loff_t();
  ldvarg162 = tmp___1;
  tmp___2 = __VERIFIER_nondet_size_t();
  ldvarg163 = tmp___2;
  tmp___3 = __VERIFIER_nondet_loff_t();
  ldvarg165 = tmp___3;
  tmp___4 = ldv_zalloc(1UL);
  ldvarg164 = (char *)tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_13 == 2) {
    qlcnic_sysfs_clear_esw_stats(bin_attr_esw_stats_group2, bin_attr_esw_stats_group1,
                                 bin_attr_esw_stats_group0, ldvarg164, ldvarg165,
                                 ldvarg163);
    ldv_state_variable_13 = 2;
  } else {
  }
  goto ldv_53806;
  case 1: ;
  if (ldv_state_variable_13 == 2) {
    qlcnic_sysfs_get_esw_stats(bin_attr_esw_stats_group2, bin_attr_esw_stats_group1,
                               bin_attr_esw_stats_group0, ldvarg161, ldvarg162, ldvarg160);
    ldv_state_variable_13 = 2;
  } else {
  }
  goto ldv_53806;
  case 2: ;
  if (ldv_state_variable_13 == 2) {
    ldv_release_13();
    ldv_state_variable_13 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53806;
  case 3: ;
  if (ldv_state_variable_13 == 1) {
    ldv_probe_13();
    ldv_state_variable_13 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53806;
  default:
  ldv_stop();
  }
  ldv_53806: ;
  return;
}
}
void ldv_main_exported_16(void)
{
  loff_t ldvarg99 ;
  loff_t tmp ;
  size_t ldvarg100 ;
  size_t tmp___0 ;
  char *ldvarg101 ;
  void *tmp___1 ;
  size_t ldvarg97 ;
  size_t tmp___2 ;
  loff_t ldvarg102 ;
  loff_t tmp___3 ;
  char *ldvarg98 ;
  void *tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_loff_t();
  ldvarg99 = tmp;
  tmp___0 = __VERIFIER_nondet_size_t();
  ldvarg100 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg101 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_size_t();
  ldvarg97 = tmp___2;
  tmp___3 = __VERIFIER_nondet_loff_t();
  ldvarg102 = tmp___3;
  tmp___4 = ldv_zalloc(1UL);
  ldvarg98 = (char *)tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_16 == 2) {
    qlcnic_sysfs_write_npar_config(bin_attr_npar_config_group2, bin_attr_npar_config_group1,
                                   bin_attr_npar_config_group0, ldvarg101, ldvarg102,
                                   ldvarg100);
    ldv_state_variable_16 = 2;
  } else {
  }
  goto ldv_53821;
  case 1: ;
  if (ldv_state_variable_16 == 2) {
    qlcnic_sysfs_read_npar_config(bin_attr_npar_config_group2, bin_attr_npar_config_group1,
                                  bin_attr_npar_config_group0, ldvarg98, ldvarg99,
                                  ldvarg97);
    ldv_state_variable_16 = 2;
  } else {
  }
  goto ldv_53821;
  case 2: ;
  if (ldv_state_variable_16 == 2) {
    ldv_release_16();
    ldv_state_variable_16 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_53821;
  case 3: ;
  if (ldv_state_variable_16 == 1) {
    ldv_probe_16();
    ldv_state_variable_16 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_53821;
  default:
  ldv_stop();
  }
  ldv_53821: ;
  return;
}
}
void *ldv_kmem_cache_alloc_298(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_304(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_306(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_308(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_309(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_310(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_311(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_312(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_313(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_314(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_315(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_vzalloc_360(unsigned long ldv_func_arg1 ) ;
void *ldv_vzalloc_361(unsigned long ldv_func_arg1 ) ;
extern int kobject_uevent_env(struct kobject * , enum kobject_action , char ** ) ;
void *ldv_kmem_cache_alloc_342(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_359(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_350(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_358(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_352(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_348(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_356(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_357(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_353(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_354(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_355(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
int qlcnic_83xx_get_fw_version(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_get_minidump_template(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_cache_tmpl_hdr_values(struct qlcnic_fw_dump *fw_dump ) ;
void qlcnic_83xx_set_sys_info(void *t_hdr , int idx , u32 value ) ;
void qlcnic_83xx_store_cap_mask(void *tmpl_hdr , u32 mask ) ;
int qlcnic_ms_mem_write128(struct qlcnic_adapter *adapter , u64 addr , u32 *data ,
                           u32 count ) ;
__inline static u32 qlcnic_get_saved_state(struct qlcnic_adapter *adapter , void *t_hdr ,
                                           u32 index )
{
  u32 tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->get_saved_state))(t_hdr, index);
  return (tmp);
}
}
__inline static void qlcnic_set_saved_state(struct qlcnic_adapter *adapter , void *t_hdr ,
                                            u32 index , u32 value )
{
  {
  (*(((adapter->ahw)->hw_ops)->set_saved_state))(t_hdr, index, value);
  return;
}
}
__inline static void qlcnic_cache_tmpl_hdr_values(struct qlcnic_adapter *adapter ,
                                                  struct qlcnic_fw_dump *fw_dump )
{
  {
  (*(((adapter->ahw)->hw_ops)->cache_tmpl_hdr_values))(fw_dump);
  return;
}
}
__inline static u32 qlcnic_get_cap_size(struct qlcnic_adapter *adapter , void *tmpl_hdr ,
                                        int index )
{
  u32 tmp ;
  {
  tmp = (*(((adapter->ahw)->hw_ops)->get_cap_size))(tmpl_hdr, index);
  return (tmp);
}
}
__inline static void qlcnic_set_sys_info(struct qlcnic_adapter *adapter , void *tmpl_hdr ,
                                         int idx , u32 value )
{
  {
  (*(((adapter->ahw)->hw_ops)->set_sys_info))(tmpl_hdr, idx, value);
  return;
}
}
static u32 const qlcnic_ms_read_data[4U] = { 1090519208U, 1090519212U, 1090519224U, 1090519228U};
void qlcnic_82xx_cache_tmpl_hdr_values(struct qlcnic_fw_dump *fw_dump )
{
  struct qlcnic_82xx_dump_template_hdr *hdr ;
  {
  hdr = (struct qlcnic_82xx_dump_template_hdr *)fw_dump->tmpl_hdr;
  fw_dump->tmpl_hdr_size = hdr->size;
  fw_dump->version = hdr->version;
  fw_dump->num_entries = hdr->num_entries;
  fw_dump->offset = hdr->offset;
  hdr->drv_cap_mask = hdr->cap_mask;
  fw_dump->cap_mask = hdr->cap_mask;
  fw_dump->use_pex_dma = ((int )hdr->capabilities & 1) != 0;
  return;
}
}
void qlcnic_82xx_set_sys_info(void *t_hdr , int idx , u32 value )
{
  struct qlcnic_82xx_dump_template_hdr *hdr ;
  {
  hdr = (struct qlcnic_82xx_dump_template_hdr *)t_hdr;
  hdr->sys_info[idx] = value;
  return;
}
}
void qlcnic_82xx_store_cap_mask(void *tmpl_hdr , u32 mask )
{
  struct qlcnic_82xx_dump_template_hdr *hdr ;
  {
  hdr = (struct qlcnic_82xx_dump_template_hdr *)tmpl_hdr;
  hdr->drv_cap_mask = mask;
  return;
}
}
void qlcnic_83xx_cache_tmpl_hdr_values(struct qlcnic_fw_dump *fw_dump )
{
  struct qlcnic_83xx_dump_template_hdr *hdr ;
  {
  hdr = (struct qlcnic_83xx_dump_template_hdr *)fw_dump->tmpl_hdr;
  fw_dump->tmpl_hdr_size = hdr->size;
  fw_dump->version = hdr->version;
  fw_dump->num_entries = hdr->num_entries;
  fw_dump->offset = hdr->offset;
  hdr->drv_cap_mask = hdr->cap_mask;
  fw_dump->cap_mask = hdr->cap_mask;
  fw_dump->use_pex_dma = (fw_dump->version & 1048575U) > 131072U;
  return;
}
}
void qlcnic_83xx_set_sys_info(void *t_hdr , int idx , u32 value )
{
  struct qlcnic_83xx_dump_template_hdr *hdr ;
  {
  hdr = (struct qlcnic_83xx_dump_template_hdr *)t_hdr;
  hdr->sys_info[idx] = value;
  return;
}
}
void qlcnic_83xx_store_cap_mask(void *tmpl_hdr , u32 mask )
{
  struct qlcnic_83xx_dump_template_hdr *hdr ;
  {
  hdr = (struct qlcnic_83xx_dump_template_hdr *)tmpl_hdr;
  hdr->drv_cap_mask = mask;
  return;
}
}
static u32 qlcnic_dump_crb(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                           __le32 *buffer )
{
  int i ;
  u32 addr ;
  u32 data ;
  struct __crb *crb ;
  int tmp ;
  __le32 *tmp___0 ;
  __le32 *tmp___1 ;
  {
  crb = & entry->region.crb;
  addr = crb->addr;
  i = 0;
  goto ldv_53037;
  ldv_53036:
  tmp = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp;
  tmp___0 = buffer;
  buffer = buffer + 1;
  *tmp___0 = addr;
  tmp___1 = buffer;
  buffer = buffer + 1;
  *tmp___1 = data;
  addr = (u32 )crb->stride + addr;
  i = i + 1;
  ldv_53037: ;
  if ((u32 )i < crb->no_ops) {
    goto ldv_53036;
  } else {
  }
  return (crb->no_ops * 8U);
}
}
static u32 qlcnic_dump_ctrl(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                            __le32 *buffer )
{
  void *hdr ;
  struct __ctrl *ctr ;
  int i ;
  int k ;
  int timeout ;
  u32 addr ;
  u32 data ;
  u32 temp ;
  u8 no_ops ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  hdr = (adapter->ahw)->fw_dump.tmpl_hdr;
  ctr = & entry->region.ctrl;
  timeout = 0;
  addr = ctr->addr;
  no_ops = (u8 )ctr->no_ops;
  i = 0;
  goto ldv_53071;
  ldv_53070:
  k = 0;
  k = 0;
  goto ldv_53068;
  ldv_53067: ;
  if ((((int )ctr->opcode >> k) & 1) == 0) {
    goto ldv_53053;
  } else {
  }
  switch (1 << k) {
  case 1:
  qlcnic_ind_wr(adapter, addr, ctr->val1);
  goto ldv_53055;
  case 2:
  tmp = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp;
  qlcnic_ind_wr(adapter, addr, data);
  goto ldv_53055;
  case 4:
  tmp___0 = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp___0;
  qlcnic_ind_wr(adapter, addr, ctr->val2 & data);
  goto ldv_53055;
  case 8:
  tmp___1 = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp___1;
  qlcnic_ind_wr(adapter, addr, ctr->val3 | data);
  goto ldv_53055;
  case 16: ;
  goto ldv_53062;
  ldv_53061:
  tmp___2 = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp___2;
  if ((ctr->val2 & data) == ctr->val1) {
    goto ldv_53060;
  } else {
  }
  usleep_range(1000UL, 2000UL);
  timeout = timeout + 1;
  ldv_53062: ;
  if ((int )ctr->timeout >= timeout) {
    goto ldv_53061;
  } else {
  }
  ldv_53060: ;
  if ((int )ctr->timeout < timeout) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Timed out, aborting poll CRB\n");
    return (4294967274U);
  } else {
  }
  goto ldv_53055;
  case 32:
  temp = (u32 )ctr->index_a;
  if (temp != 0U) {
    addr = qlcnic_get_saved_state(adapter, hdr, temp);
  } else {
  }
  tmp___3 = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp___3;
  qlcnic_set_saved_state(adapter, hdr, (u32 )ctr->index_v, data);
  goto ldv_53055;
  case 64:
  temp = (u32 )ctr->index_v;
  if (temp != 0U) {
    data = qlcnic_get_saved_state(adapter, hdr, temp);
  } else {
    data = ctr->val1;
  }
  temp = (u32 )ctr->index_a;
  if (temp != 0U) {
    addr = qlcnic_get_saved_state(adapter, hdr, temp);
  } else {
  }
  qlcnic_ind_wr(adapter, addr, data);
  goto ldv_53055;
  case 128:
  data = qlcnic_get_saved_state(adapter, hdr, (u32 )ctr->index_v);
  data = data << (int )ctr->shl_val;
  data = data >> (int )ctr->shr_val;
  if (ctr->val2 != 0U) {
    data = ctr->val2 & data;
  } else {
  }
  data = ctr->val3 | data;
  data = ctr->val1 + data;
  qlcnic_set_saved_state(adapter, hdr, (u32 )ctr->index_v, data);
  goto ldv_53055;
  default:
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Unknown opcode\n");
  goto ldv_53055;
  }
  ldv_53055: ;
  ldv_53053:
  k = k + 1;
  ldv_53068: ;
  if (k <= 7) {
    goto ldv_53067;
  } else {
  }
  addr = (u32 )ctr->stride + addr;
  i = i + 1;
  ldv_53071: ;
  if ((int )no_ops > i) {
    goto ldv_53070;
  } else {
  }
  return (0U);
}
}
static u32 qlcnic_dump_mux(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                           __le32 *buffer )
{
  int loop ;
  u32 val ;
  u32 data ;
  struct __mux *mux ;
  int tmp ;
  __le32 *tmp___0 ;
  __le32 *tmp___1 ;
  {
  data = 0U;
  mux = & entry->region.mux;
  val = mux->val;
  loop = 0;
  goto ldv_53083;
  ldv_53082:
  qlcnic_ind_wr(adapter, mux->addr, val);
  tmp = qlcnic_ind_rd(adapter, mux->read_addr);
  data = (u32 )tmp;
  tmp___0 = buffer;
  buffer = buffer + 1;
  *tmp___0 = val;
  tmp___1 = buffer;
  buffer = buffer + 1;
  *tmp___1 = data;
  val = mux->val_stride + val;
  loop = loop + 1;
  ldv_53083: ;
  if ((u32 )loop < mux->no_ops) {
    goto ldv_53082;
  } else {
  }
  return (mux->no_ops * 8U);
}
}
static u32 qlcnic_dump_que(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                           __le32 *buffer )
{
  int i ;
  int loop ;
  u32 cnt ;
  u32 addr ;
  u32 data ;
  u32 que_id ;
  struct __queue *que ;
  int tmp ;
  __le32 *tmp___0 ;
  {
  que_id = 0U;
  que = & entry->region.que;
  addr = que->read_addr;
  cnt = (u32 )que->read_addr_cnt;
  loop = 0;
  goto ldv_53101;
  ldv_53100:
  qlcnic_ind_wr(adapter, que->sel_addr, que_id);
  addr = que->read_addr;
  i = 0;
  goto ldv_53098;
  ldv_53097:
  tmp = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp;
  tmp___0 = buffer;
  buffer = buffer + 1;
  *tmp___0 = data;
  addr = (u32 )que->read_addr_stride + addr;
  i = i + 1;
  ldv_53098: ;
  if ((u32 )i < cnt) {
    goto ldv_53097;
  } else {
  }
  que_id = (u32 )que->stride + que_id;
  loop = loop + 1;
  ldv_53101: ;
  if ((u32 )loop < que->no_ops) {
    goto ldv_53100;
  } else {
  }
  return ((que->no_ops * cnt) * 4U);
}
}
static u32 qlcnic_dump_ocm(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                           __le32 *buffer )
{
  int i ;
  u32 data ;
  void *addr ;
  struct __ocm *ocm ;
  __le32 *tmp ;
  {
  ocm = & entry->region.ocm;
  addr = (adapter->ahw)->pci_base0 + (unsigned long )ocm->read_addr;
  i = 0;
  goto ldv_53113;
  ldv_53112:
  data = readl((void const volatile *)addr);
  tmp = buffer;
  buffer = buffer + 1;
  *tmp = data;
  addr = addr + (unsigned long )ocm->read_addr_stride;
  i = i + 1;
  ldv_53113: ;
  if ((u32 )i < ocm->no_ops) {
    goto ldv_53112;
  } else {
  }
  return (ocm->no_ops * 4U);
}
}
static u32 qlcnic_read_rom(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                           __le32 *buffer )
{
  int i ;
  int count ;
  u32 fl_addr ;
  u32 size ;
  u32 val ;
  u32 lck_val ;
  u32 addr ;
  struct __mem *rom ;
  int tmp ;
  __le32 *tmp___0 ;
  {
  count = 0;
  rom = & entry->region.mem;
  fl_addr = rom->addr;
  size = rom->size / 4U;
  lock_try:
  lck_val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 21UL));
  if (lck_val == 0U && count <= 999) {
    usleep_range(10000UL, 11000UL);
    count = count + 1;
    goto lock_try;
  } else {
  }
  writel((unsigned int )(adapter->ahw)->pci_func, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 3UL));
  i = 0;
  goto ldv_53130;
  ldv_53129:
  addr = fl_addr & 4294901760U;
  qlcnic_ind_wr(adapter, 1108410416U, addr);
  addr = (u32 )((int )((unsigned short )fl_addr) + 1108672512);
  tmp = qlcnic_ind_rd(adapter, addr);
  val = (u32 )tmp;
  fl_addr = fl_addr + 4U;
  tmp___0 = buffer;
  buffer = buffer + 1;
  *tmp___0 = val;
  i = i + 1;
  ldv_53130: ;
  if ((u32 )i < size) {
    goto ldv_53129;
  } else {
  }
  readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 22UL));
  return (rom->size);
}
}
static u32 qlcnic_dump_l1_cache(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                                __le32 *buffer )
{
  int i ;
  u32 cnt ;
  u32 val ;
  u32 data ;
  u32 addr ;
  struct __cache *l1 ;
  int tmp ;
  __le32 *tmp___0 ;
  {
  l1 = & entry->region.cache;
  val = (u32 )l1->init_tag_val;
  i = 0;
  goto ldv_53147;
  ldv_53146:
  qlcnic_ind_wr(adapter, l1->addr, val);
  qlcnic_ind_wr(adapter, l1->ctrl_addr, (u32 )((unsigned short )l1->ctrl_val));
  addr = l1->read_addr;
  cnt = (u32 )l1->read_addr_num;
  goto ldv_53144;
  ldv_53143:
  tmp = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp;
  tmp___0 = buffer;
  buffer = buffer + 1;
  *tmp___0 = data;
  addr = (u32 )l1->read_addr_stride + addr;
  cnt = cnt - 1U;
  ldv_53144: ;
  if (cnt != 0U) {
    goto ldv_53143;
  } else {
  }
  val = (u32 )l1->stride + val;
  i = i + 1;
  ldv_53147: ;
  if ((u32 )i < l1->no_ops) {
    goto ldv_53146;
  } else {
  }
  return ((l1->no_ops * (u32 )l1->read_addr_num) * 4U);
}
}
static u32 qlcnic_dump_l2_cache(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                                __le32 *buffer )
{
  int i ;
  u32 cnt ;
  u32 val ;
  u32 data ;
  u32 addr ;
  u8 poll_mask ;
  u8 poll_to ;
  u8 time_out ;
  struct __cache *l2 ;
  int tmp ;
  int tmp___0 ;
  __le32 *tmp___1 ;
  {
  time_out = 0U;
  l2 = & entry->region.cache;
  val = (u32 )l2->init_tag_val;
  poll_mask = (unsigned char )(l2->ctrl_val >> 16);
  poll_to = (unsigned char )((int )((unsigned short )(l2->ctrl_val >> 16)) >> 8);
  i = 0;
  goto ldv_53171;
  ldv_53170:
  qlcnic_ind_wr(adapter, l2->addr, val);
  if ((unsigned int )((unsigned short )l2->ctrl_val) != 0U) {
    qlcnic_ind_wr(adapter, l2->ctrl_addr, (u32 )((unsigned short )l2->ctrl_val));
  } else {
  }
  if ((unsigned int )poll_mask == 0U) {
    goto skip_poll;
  } else {
  }
  ldv_53165:
  tmp = qlcnic_ind_rd(adapter, l2->ctrl_addr);
  data = (u32 )tmp;
  if (((u32 )poll_mask & data) == 0U) {
    goto ldv_53164;
  } else {
  }
  usleep_range(1000UL, 2000UL);
  time_out = (u8 )((int )time_out + 1);
  if ((int )time_out <= (int )poll_to) {
    goto ldv_53165;
  } else {
  }
  ldv_53164: ;
  if ((int )time_out > (int )poll_to) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Timeout exceeded in %s, aborting dump\n",
            "qlcnic_dump_l2_cache");
    return (4294967274U);
  } else {
  }
  skip_poll:
  addr = l2->read_addr;
  cnt = (u32 )l2->read_addr_num;
  goto ldv_53168;
  ldv_53167:
  tmp___0 = qlcnic_ind_rd(adapter, addr);
  data = (u32 )tmp___0;
  tmp___1 = buffer;
  buffer = buffer + 1;
  *tmp___1 = data;
  addr = (u32 )l2->read_addr_stride + addr;
  cnt = cnt - 1U;
  ldv_53168: ;
  if (cnt != 0U) {
    goto ldv_53167;
  } else {
  }
  val = (u32 )l2->stride + val;
  i = i + 1;
  ldv_53171: ;
  if ((u32 )i < l2->no_ops) {
    goto ldv_53170;
  } else {
  }
  return ((l2->no_ops * (u32 )l2->read_addr_num) * 4U);
}
}
static u32 qlcnic_read_memory_test_agent(struct qlcnic_adapter *adapter , struct __mem *mem ,
                                         __le32 *buffer , int *ret )
{
  u32 addr ;
  u32 data ;
  u32 test ;
  int i ;
  int reg_read ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __le32 *tmp___2 ;
  {
  reg_read = (int )mem->size;
  addr = mem->addr;
  if ((addr & 15U) != 0U || ((unsigned int )reg_read & 15U) != 0U) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Unaligned memory addr:0x%x size:0x%x\n",
              addr, reg_read);
    *ret = -22;
    return (0U);
  } else {
  }
  mutex_lock_nested(& (adapter->ahw)->mem_lock, 0U);
  goto ldv_53193;
  ldv_53192:
  qlcnic_ind_wr(adapter, 1090519188U, addr);
  qlcnic_ind_wr(adapter, 1090519192U, 0U);
  qlcnic_ind_wr(adapter, 1090519184U, 3U);
  i = 0;
  goto ldv_53186;
  ldv_53185:
  tmp = qlcnic_ind_rd(adapter, 1090519184U);
  test = (u32 )tmp;
  if ((test & 8U) == 0U) {
    goto ldv_53184;
  } else {
  }
  i = i + 1;
  ldv_53186: ;
  if (i <= 999) {
    goto ldv_53185;
  } else {
  }
  ldv_53184: ;
  if (i == 1000) {
    tmp___0 = __printk_ratelimit("qlcnic_read_memory_test_agent");
    if (tmp___0 != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "failed to read through agent\n");
      *ret = -5;
      goto out;
    } else {
    }
  } else {
  }
  i = 0;
  goto ldv_53190;
  ldv_53189:
  tmp___1 = qlcnic_ind_rd(adapter, qlcnic_ms_read_data[i]);
  data = (u32 )tmp___1;
  tmp___2 = buffer;
  buffer = buffer + 1;
  *tmp___2 = data;
  i = i + 1;
  ldv_53190: ;
  if (i <= 3) {
    goto ldv_53189;
  } else {
  }
  addr = addr + 16U;
  reg_read = reg_read + -16;
  ret = ret + 16UL;
  ldv_53193: ;
  if (reg_read != 0) {
    goto ldv_53192;
  } else {
  }
  out:
  mutex_unlock(& (adapter->ahw)->mem_lock);
  return (mem->size);
}
}
static int qlcnic_start_pex_dma(struct qlcnic_adapter *adapter , struct __mem *mem )
{
  struct device *dev ;
  u32 dma_no ;
  u32 dma_base_addr ;
  u32 temp_addr ;
  int i ;
  int ret ;
  int dma_sts ;
  void *tmpl_hdr ;
  {
  dev = & (adapter->pdev)->dev;
  tmpl_hdr = (adapter->ahw)->fw_dump.tmpl_hdr;
  dma_no = qlcnic_get_saved_state(adapter, tmpl_hdr, 8U);
  dma_base_addr = (dma_no + 30514U) * 65536U;
  temp_addr = dma_base_addr;
  ret = qlcnic_ind_wr(adapter, temp_addr, mem->desc_card_addr);
  if (ret != 0) {
    return (ret);
  } else {
  }
  temp_addr = dma_base_addr + 4U;
  ret = qlcnic_ind_wr(adapter, temp_addr, 0U);
  if (ret != 0) {
    return (ret);
  } else {
  }
  temp_addr = dma_base_addr + 8U;
  ret = qlcnic_ind_wr(adapter, temp_addr, mem->start_dma_cmd);
  if (ret != 0) {
    return (ret);
  } else {
  }
  temp_addr = dma_base_addr + 8U;
  i = 0;
  goto ldv_53209;
  ldv_53208:
  dma_sts = qlcnic_ind_rd(adapter, temp_addr);
  if ((dma_sts & 2) != 0) {
    usleep_range(250UL, 500UL);
  } else {
    goto ldv_53207;
  }
  i = i + 1;
  ldv_53209: ;
  if (i <= 399) {
    goto ldv_53208;
  } else {
  }
  ldv_53207: ;
  if (i > 399) {
    _dev_info((struct device const *)dev, "PEX DMA operation timed out");
    ret = -5;
  } else {
  }
  return (ret);
}
}
static u32 qlcnic_read_memory_pexdma(struct qlcnic_adapter *adapter , struct __mem *mem ,
                                     __le32 *buffer , int *ret )
{
  struct qlcnic_fw_dump *fw_dump ;
  u32 temp ;
  u32 dma_base_addr ;
  u32 size ;
  u32 read_size ;
  struct qlcnic_pex_dma_descriptor *dma_descr ;
  struct device *dev ;
  dma_addr_t dma_phys_addr ;
  void *dma_buffer ;
  void *tmpl_hdr ;
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  size = 0U;
  read_size = 0U;
  dev = & (adapter->pdev)->dev;
  tmpl_hdr = fw_dump->tmpl_hdr;
  temp = qlcnic_get_saved_state(adapter, tmpl_hdr, 8U);
  dma_base_addr = (temp + 30514U) * 65536U;
  tmp = qlcnic_ind_rd(adapter, dma_base_addr + 8U);
  temp = (u32 )tmp;
  if ((int )temp >= 0) {
    _dev_info((struct device const *)dev, "%s: DMA engine is not available\n", "qlcnic_read_memory_pexdma");
    *ret = -5;
    return (0U);
  } else {
  }
  tmp___0 = kzalloc(48UL, 208U);
  dma_descr = (struct qlcnic_pex_dma_descriptor *)tmp___0;
  if ((unsigned long )dma_descr == (unsigned long )((struct qlcnic_pex_dma_descriptor *)0)) {
    *ret = -12;
    return (0U);
  } else {
  }
  dma_phys_addr = fw_dump->phys_addr;
  dma_buffer = fw_dump->dma_buffer;
  temp = 0U;
  temp = mem->dma_desc_cmd & 65295U;
  temp = ((u32 )((int )(adapter->ahw)->pci_func << 4) & 255U) | temp;
  dma_descr->dma_desc_cmd = temp << 16;
  dma_descr->dma_bus_addr_low = (unsigned int )dma_phys_addr;
  dma_descr->dma_bus_addr_high = (unsigned int )(dma_phys_addr >> 32ULL);
  dma_descr->src_addr_high = 0U;
  goto ldv_53232;
  ldv_53231: ;
  if (mem->size - read_size > 65535U) {
    size = 65536U;
  } else {
    size = mem->size - read_size;
  }
  dma_descr->src_addr_low = mem->addr + read_size;
  dma_descr->read_data_size = size;
  temp = 3U;
  *ret = qlcnic_ms_mem_write128(adapter, (u64 )mem->desc_card_addr, (u32 *)dma_descr,
                                temp);
  if (*ret != 0) {
    _dev_info((struct device const *)dev, "Failed to write DMA descriptor to MS memory at address 0x%x\n",
              mem->desc_card_addr);
    goto free_dma_descr;
  } else {
  }
  *ret = qlcnic_start_pex_dma(adapter, mem);
  if (*ret != 0) {
    _dev_info((struct device const *)dev, "Failed to start PEX DMA operation\n");
    goto free_dma_descr;
  } else {
  }
  __len = (size_t )size;
  __ret = memcpy((void *)buffer, (void const *)dma_buffer, __len);
  buffer = buffer + (unsigned long )(size / 4U);
  read_size = read_size + size;
  ldv_53232: ;
  if (mem->size > read_size) {
    goto ldv_53231;
  } else {
  }
  free_dma_descr:
  kfree((void const *)dma_descr);
  return (read_size);
}
}
static u32 qlcnic_read_memory(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                              __le32 *buffer )
{
  struct qlcnic_fw_dump *fw_dump ;
  struct device *dev ;
  struct __mem *mem ;
  u32 data_size ;
  int ret ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  dev = & (adapter->pdev)->dev;
  mem = & entry->region.mem;
  ret = 0;
  if ((int )fw_dump->use_pex_dma) {
    data_size = qlcnic_read_memory_pexdma(adapter, mem, buffer, & ret);
    if (ret != 0) {
      _dev_info((struct device const *)dev, "Failed to read memory dump using PEX DMA: mask[0x%x]\n",
                (int )entry->hdr.mask);
    } else {
      return (data_size);
    }
  } else {
  }
  data_size = qlcnic_read_memory_test_agent(adapter, mem, buffer, & ret);
  if (ret != 0) {
    _dev_info((struct device const *)dev, "Failed to read memory dump using test agent method: mask[0x%x]\n",
              (int )entry->hdr.mask);
    return (0U);
  } else {
    return (data_size);
  }
}
}
static u32 qlcnic_dump_nop(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                           __le32 *buffer )
{
  {
  entry->hdr.flags = (u8 )((unsigned int )entry->hdr.flags | 128U);
  return (0U);
}
}
static int qlcnic_valid_dump_entry(struct device *dev , struct qlcnic_dump_entry *entry ,
                                   u32 size )
{
  int ret ;
  {
  ret = 1;
  if (entry->hdr.cap_size != size) {
    dev_err((struct device const *)dev, "Invalid entry, Type:%d\tMask:%d\tSize:%dCap_size:%d\n",
            entry->hdr.type, (int )entry->hdr.mask, size, entry->hdr.cap_size);
    ret = 0;
  } else {
  }
  return (ret);
}
}
static u32 qlcnic_read_pollrdmwr(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                                 __le32 *buffer )
{
  struct __pollrdmwr *poll ;
  u32 data ;
  u32 wait_count ;
  u32 poll_wait___0 ;
  u32 temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __le32 *tmp___2 ;
  __le32 *tmp___3 ;
  {
  poll = & entry->region.pollrdmwr;
  poll_wait___0 = poll->poll_wait;
  qlcnic_ind_wr(adapter, poll->addr1, poll->val1);
  wait_count = 0U;
  goto ldv_53267;
  ldv_53266:
  tmp = qlcnic_ind_rd(adapter, poll->addr1);
  data = (u32 )tmp;
  if ((poll->poll_mask & data) != 0U) {
    goto ldv_53265;
  } else {
  }
  wait_count = wait_count + 1U;
  ldv_53267: ;
  if (wait_count < poll_wait___0) {
    goto ldv_53266;
  } else {
  }
  ldv_53265: ;
  if (wait_count == poll_wait___0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Timeout exceeded in %s, aborting dump\n",
            "qlcnic_read_pollrdmwr");
    return (0U);
  } else {
  }
  tmp___0 = qlcnic_ind_rd(adapter, poll->addr2);
  data = (u32 )tmp___0 & poll->mod_mask;
  qlcnic_ind_wr(adapter, poll->addr2, data);
  qlcnic_ind_wr(adapter, poll->addr1, poll->val2);
  wait_count = 0U;
  goto ldv_53271;
  ldv_53270:
  tmp___1 = qlcnic_ind_rd(adapter, poll->addr1);
  temp = (u32 )tmp___1;
  if ((poll->poll_mask & temp) != 0U) {
    goto ldv_53269;
  } else {
  }
  wait_count = wait_count + 1U;
  ldv_53271: ;
  if (wait_count < poll_wait___0) {
    goto ldv_53270;
  } else {
  }
  ldv_53269:
  tmp___2 = buffer;
  buffer = buffer + 1;
  *tmp___2 = poll->addr2;
  tmp___3 = buffer;
  buffer = buffer + 1;
  *tmp___3 = data;
  return (8U);
}
}
static u32 qlcnic_read_pollrd(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                              __le32 *buffer )
{
  struct __pollrd *pollrd ;
  u32 data ;
  u32 wait_count ;
  u32 poll_wait___0 ;
  u32 sel_val ;
  int i ;
  int tmp ;
  int tmp___0 ;
  __le32 *tmp___1 ;
  __le32 *tmp___2 ;
  {
  pollrd = & entry->region.pollrd;
  poll_wait___0 = pollrd->poll_wait;
  sel_val = pollrd->sel_val;
  i = 0;
  goto ldv_53288;
  ldv_53287:
  qlcnic_ind_wr(adapter, pollrd->sel_addr, sel_val);
  wait_count = 0U;
  goto ldv_53285;
  ldv_53284:
  tmp = qlcnic_ind_rd(adapter, pollrd->sel_addr);
  data = (u32 )tmp;
  if ((pollrd->poll_mask & data) != 0U) {
    goto ldv_53283;
  } else {
  }
  wait_count = wait_count + 1U;
  ldv_53285: ;
  if (wait_count < poll_wait___0) {
    goto ldv_53284;
  } else {
  }
  ldv_53283: ;
  if (wait_count == poll_wait___0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Timeout exceeded in %s, aborting dump\n",
            "qlcnic_read_pollrd");
    return (0U);
  } else {
  }
  tmp___0 = qlcnic_ind_rd(adapter, pollrd->read_addr);
  data = (u32 )tmp___0;
  tmp___1 = buffer;
  buffer = buffer + 1;
  *tmp___1 = sel_val;
  tmp___2 = buffer;
  buffer = buffer + 1;
  *tmp___2 = data;
  sel_val = (u32 )pollrd->sel_val_stride + sel_val;
  i = i + 1;
  ldv_53288: ;
  if ((int )pollrd->no_ops > i) {
    goto ldv_53287;
  } else {
  }
  return ((u32 )pollrd->no_ops * 8U);
}
}
static u32 qlcnic_read_mux2(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                            __le32 *buffer )
{
  struct __mux2 *mux2 ;
  u32 data ;
  u32 t_sel_val ;
  u32 sel_val1 ;
  u32 sel_val2 ;
  int i ;
  int tmp ;
  __le32 *tmp___0 ;
  __le32 *tmp___1 ;
  int tmp___2 ;
  __le32 *tmp___3 ;
  __le32 *tmp___4 ;
  {
  mux2 = & entry->region.mux2;
  sel_val1 = mux2->sel_val1;
  sel_val2 = mux2->sel_val2;
  i = 0;
  goto ldv_53302;
  ldv_53301:
  qlcnic_ind_wr(adapter, mux2->sel_addr1, sel_val1);
  t_sel_val = mux2->sel_val_mask & sel_val1;
  qlcnic_ind_wr(adapter, mux2->sel_addr2, t_sel_val);
  tmp = qlcnic_ind_rd(adapter, mux2->read_addr);
  data = (u32 )tmp;
  tmp___0 = buffer;
  buffer = buffer + 1;
  *tmp___0 = t_sel_val;
  tmp___1 = buffer;
  buffer = buffer + 1;
  *tmp___1 = data;
  qlcnic_ind_wr(adapter, mux2->sel_addr1, sel_val2);
  t_sel_val = mux2->sel_val_mask & sel_val2;
  qlcnic_ind_wr(adapter, mux2->sel_addr2, t_sel_val);
  tmp___2 = qlcnic_ind_rd(adapter, mux2->read_addr);
  data = (u32 )tmp___2;
  tmp___3 = buffer;
  buffer = buffer + 1;
  *tmp___3 = t_sel_val;
  tmp___4 = buffer;
  buffer = buffer + 1;
  *tmp___4 = data;
  sel_val1 = (u32 )mux2->sel_val_stride + sel_val1;
  sel_val2 = (u32 )mux2->sel_val_stride + sel_val2;
  i = i + 1;
  ldv_53302: ;
  if ((u32 )i < mux2->no_ops) {
    goto ldv_53301;
  } else {
  }
  return (mux2->no_ops * 16U);
}
}
static u32 qlcnic_83xx_dump_rom(struct qlcnic_adapter *adapter , struct qlcnic_dump_entry *entry ,
                                __le32 *buffer )
{
  u32 fl_addr ;
  u32 size ;
  struct __mem *rom ;
  int tmp ;
  {
  rom = & entry->region.mem;
  fl_addr = rom->addr;
  size = rom->size / 4U;
  tmp = qlcnic_83xx_lockless_flash_read32(adapter, fl_addr, (u8 *)buffer, (int )size);
  if (tmp == 0) {
    return (rom->size);
  } else {
  }
  return (0U);
}
}
static struct qlcnic_dump_operations const qlcnic_fw_dump_ops[20U] =
  { {0, & qlcnic_dump_nop},
        {1, & qlcnic_dump_crb},
        {2, & qlcnic_dump_mux},
        {3, & qlcnic_dump_que},
        {4, & qlcnic_read_rom},
        {6, & qlcnic_dump_ocm},
        {7, & qlcnic_dump_ctrl},
        {8, & qlcnic_dump_l1_cache},
        {9, & qlcnic_dump_l1_cache},
        {11, & qlcnic_dump_l1_cache},
        {12, & qlcnic_dump_l1_cache},
        {21, & qlcnic_dump_l2_cache},
        {22, & qlcnic_dump_l2_cache},
        {23, & qlcnic_dump_l2_cache},
        {24, & qlcnic_dump_l2_cache},
        {71, & qlcnic_read_rom},
        {72, & qlcnic_read_memory},
        {98, & qlcnic_dump_ctrl},
        {99, & qlcnic_dump_nop},
        {255, & qlcnic_dump_nop}};
static struct qlcnic_dump_operations const qlcnic_83xx_fw_dump_ops[23U] =
  { {0, & qlcnic_dump_nop},
        {1, & qlcnic_dump_crb},
        {2, & qlcnic_dump_mux},
        {3, & qlcnic_dump_que},
        {4, & qlcnic_83xx_dump_rom},
        {6, & qlcnic_dump_ocm},
        {7, & qlcnic_dump_ctrl},
        {8, & qlcnic_dump_l1_cache},
        {9, & qlcnic_dump_l1_cache},
        {11, & qlcnic_dump_l1_cache},
        {12, & qlcnic_dump_l1_cache},
        {21, & qlcnic_dump_l2_cache},
        {22, & qlcnic_dump_l2_cache},
        {23, & qlcnic_dump_l2_cache},
        {24, & qlcnic_dump_l2_cache},
        {35, & qlcnic_read_pollrd},
        {36, & qlcnic_read_mux2},
        {37, & qlcnic_read_pollrdmwr},
        {71, & qlcnic_83xx_dump_rom},
        {72, & qlcnic_read_memory},
        {98, & qlcnic_dump_ctrl},
        {99, & qlcnic_dump_nop},
        {255, & qlcnic_dump_nop}};
static uint32_t qlcnic_temp_checksum(uint32_t *temp_buffer , u32 temp_size )
{
  uint64_t sum ;
  int count ;
  uint32_t *tmp ;
  int tmp___0 ;
  {
  sum = 0ULL;
  count = (int )(temp_size / 4U);
  goto ldv_53321;
  ldv_53320:
  tmp = temp_buffer;
  temp_buffer = temp_buffer + 1;
  sum = (uint64_t )*tmp + sum;
  ldv_53321:
  tmp___0 = count;
  count = count - 1;
  if (tmp___0 > 0) {
    goto ldv_53320;
  } else {
  }
  goto ldv_53324;
  ldv_53323:
  sum = (sum & 4294967295ULL) + (sum >> 32);
  ldv_53324: ;
  if (sum >> 32 != 0ULL) {
    goto ldv_53323;
  } else {
  }
  return (~ ((uint32_t )sum));
}
}
static int qlcnic_fw_flash_get_minidump_temp(struct qlcnic_adapter *adapter , u8 *buffer ,
                                             u32 size )
{
  int ret ;
  bool tmp ;
  int tmp___0 ;
  {
  ret = 0;
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    return (-5);
  } else {
  }
  tmp___0 = qlcnic_83xx_lock_flash(adapter);
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  ret = qlcnic_83xx_lockless_flash_read32(adapter, 5373952U, buffer, (int )(size / 4U));
  qlcnic_83xx_unlock_flash(adapter);
  return (ret);
}
}
static int qlcnic_fw_flash_get_minidump_temp_size(struct qlcnic_adapter *adapter ,
                                                  struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_83xx_dump_template_hdr tmp_hdr ;
  u32 size ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  {
  size = 52U;
  ret = 0;
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    return (-5);
  } else {
  }
  tmp___0 = qlcnic_83xx_lock_flash(adapter);
  if (tmp___0 != 0) {
    return (-5);
  } else {
  }
  ret = qlcnic_83xx_lockless_flash_read32(adapter, 5373952U, (u8 *)(& tmp_hdr), (int )size);
  qlcnic_83xx_unlock_flash(adapter);
  *(cmd->rsp.arg + 2UL) = tmp_hdr.size;
  *(cmd->rsp.arg + 3UL) = tmp_hdr.version;
  return (ret);
}
}
static int qlcnic_fw_get_minidump_temp_size(struct qlcnic_adapter *adapter , u32 *version ,
                                            u32 *temp_size , u8 *use_flash_temp )
{
  int err ;
  struct qlcnic_cmd_args cmd ;
  int tmp ;
  int tmp___0 ;
  {
  err = 0;
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 47U);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    tmp___0 = qlcnic_fw_flash_get_minidump_temp_size(adapter, & cmd);
    if (tmp___0 != 0) {
      qlcnic_free_mbx_args(& cmd);
      return (-5);
    } else {
    }
    *use_flash_temp = 1U;
  } else {
  }
  *temp_size = *(cmd.rsp.arg + 2UL);
  *version = *(cmd.rsp.arg + 3UL);
  qlcnic_free_mbx_args(& cmd);
  if (*temp_size == 0U) {
    return (-5);
  } else {
  }
  return (0);
}
}
static int __qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter , u32 *buffer ,
                                             u32 temp_size )
{
  int err ;
  int i ;
  void *tmp_addr ;
  __le32 *tmp_buf ;
  struct qlcnic_cmd_args cmd ;
  dma_addr_t tmp_addr_t ;
  int tmp ;
  u32 *tmp___0 ;
  __le32 *tmp___1 ;
  {
  err = 0;
  tmp_addr_t = 0ULL;
  tmp_addr = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )temp_size, & tmp_addr_t,
                             208U, (struct dma_attrs *)0);
  if ((unsigned long )tmp_addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 48U);
  if (tmp != 0) {
    err = -12;
    goto free_mem;
  } else {
  }
  *(cmd.req.arg + 1UL) = (unsigned int )tmp_addr_t;
  *(cmd.req.arg + 2UL) = (unsigned int )(tmp_addr_t >> 32ULL);
  *(cmd.req.arg + 3UL) = temp_size;
  err = qlcnic_issue_cmd(adapter, & cmd);
  tmp_buf = (__le32 *)tmp_addr;
  if (err == 0) {
    i = 0;
    goto ldv_53360;
    ldv_53359:
    tmp___0 = buffer;
    buffer = buffer + 1;
    tmp___1 = tmp_buf;
    tmp_buf = tmp_buf + 1;
    *tmp___0 = *tmp___1;
    i = i + 1;
    ldv_53360: ;
    if ((unsigned long )i < (unsigned long )(temp_size / 4U)) {
      goto ldv_53359;
    } else {
    }
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  free_mem:
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )temp_size, tmp_addr, tmp_addr_t,
                 (struct dma_attrs *)0);
  return (err);
}
}
int qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_fw_dump *fw_dump ;
  u32 version ;
  u32 csum ;
  u32 *tmp_buf ;
  u8 use_flash_temp ;
  u32 temp_size ;
  void *temp_buffer ;
  int err ;
  {
  use_flash_temp = 0U;
  temp_size = 0U;
  ahw = adapter->ahw;
  fw_dump = & ahw->fw_dump;
  err = qlcnic_fw_get_minidump_temp_size(adapter, & version, & temp_size, & use_flash_temp);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Can\'t get template size %d\n",
            err);
    return (-5);
  } else {
  }
  fw_dump->tmpl_hdr = ldv_vzalloc_360((unsigned long )temp_size);
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  tmp_buf = (u32 *)fw_dump->tmpl_hdr;
  if ((unsigned int )use_flash_temp != 0U) {
    goto flash_temp;
  } else {
  }
  err = __qlcnic_fw_cmd_get_minidump_temp(adapter, tmp_buf, temp_size);
  if (err != 0) {
    flash_temp:
    err = qlcnic_fw_flash_get_minidump_temp(adapter, (u8 *)tmp_buf, temp_size);
    if (err != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get minidump template header %d\n",
              err);
      vfree((void const *)fw_dump->tmpl_hdr);
      fw_dump->tmpl_hdr = (void *)0;
      return (-5);
    } else {
    }
  } else {
  }
  csum = qlcnic_temp_checksum(tmp_buf, temp_size);
  if (csum != 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Template header checksum validation failed\n");
    vfree((void const *)fw_dump->tmpl_hdr);
    fw_dump->tmpl_hdr = (void *)0;
    return (-5);
  } else {
  }
  qlcnic_cache_tmpl_hdr_values(adapter, fw_dump);
  if ((int )fw_dump->use_pex_dma) {
    fw_dump->dma_buffer = (void *)0;
    temp_buffer = dma_alloc_attrs(& (adapter->pdev)->dev, 65536UL, & fw_dump->phys_addr,
                                  208U, (struct dma_attrs *)0);
    if ((unsigned long )temp_buffer == (unsigned long )((void *)0)) {
      fw_dump->use_pex_dma = 0;
    } else {
      fw_dump->dma_buffer = temp_buffer;
    }
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Default minidump capture mask 0x%x\n",
            fw_dump->cap_mask);
  qlcnic_enable_fw_dump_state(adapter);
  return (0);
}
}
int qlcnic_dump_fw(struct qlcnic_adapter *adapter )
{
  struct qlcnic_fw_dump *fw_dump ;
  struct qlcnic_dump_operations const *fw_dump_ops ;
  struct qlcnic_83xx_dump_template_hdr *hdr_83xx ;
  u32 entry_offset ;
  u32 dump ;
  u32 no_entries ;
  u32 buf_offset ;
  int i ;
  int k ;
  int ops_cnt ;
  int ops_index ;
  int dump_size ;
  struct device *dev ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_dump_entry *entry ;
  void *tmpl_hdr ;
  u32 ocm_window ;
  __le32 *buffer ;
  char mesg[64U] ;
  char *msg[2U] ;
  bool tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  fw_dump = & (adapter->ahw)->fw_dump;
  buf_offset = 0U;
  dump_size = 0;
  dev = & (adapter->pdev)->dev;
  msg[0] = (char *)(& mesg);
  msg[1] = (char *)0;
  ahw = adapter->ahw;
  tmpl_hdr = fw_dump->tmpl_hdr;
  if ((unsigned long )tmpl_hdr == (unsigned long )((void *)0)) {
    return (-5);
  } else {
  }
  tmp = qlcnic_check_fw_dump_state(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Dump not enabled\n");
    return (-5);
  } else {
  }
  if ((unsigned int )fw_dump->clr != 0U) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Previous dump not cleared, not capturing dump\n");
    return (-5);
  } else {
  }
  if ((int )(adapter->ahw)->msg_enable & 1) {
    netdev_info((struct net_device const *)adapter->netdev, "Take FW dump\n");
  } else {
  }
  i = 2;
  k = 1;
  goto ldv_53399;
  ldv_53398: ;
  if ((fw_dump->cap_mask & (u32 )i) != 0U) {
    tmp___1 = qlcnic_get_cap_size(adapter, tmpl_hdr, k);
    dump_size = (int )(tmp___1 + (u32 )dump_size);
  } else {
  }
  i = i << 1;
  k = k + 1;
  ldv_53399: ;
  if ((i & 255) != 0) {
    goto ldv_53398;
  } else {
  }
  if (dump_size == 0) {
    return (-5);
  } else {
  }
  fw_dump->data = ldv_vzalloc_361((unsigned long )dump_size);
  if ((unsigned long )fw_dump->data == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  buffer = (__le32 *)fw_dump->data;
  fw_dump->size = (u32 )dump_size;
  no_entries = fw_dump->num_entries;
  entry_offset = fw_dump->offset;
  qlcnic_set_sys_info(adapter, tmpl_hdr, 0, 328508U);
  qlcnic_set_sys_info(adapter, tmpl_hdr, 1, adapter->fw_version);
  tmp___2 = qlcnic_82xx_check(adapter);
  if ((int )tmp___2) {
    ops_cnt = 20;
    fw_dump_ops = (struct qlcnic_dump_operations const *)(& qlcnic_fw_dump_ops);
  } else {
    hdr_83xx = (struct qlcnic_83xx_dump_template_hdr *)tmpl_hdr;
    ops_cnt = 23;
    fw_dump_ops = (struct qlcnic_dump_operations const *)(& qlcnic_83xx_fw_dump_ops);
    ocm_window = hdr_83xx->ocm_wnd_reg[(int )ahw->pci_func];
    hdr_83xx->saved_state[3] = ocm_window;
    hdr_83xx->saved_state[0] = (u32 )ahw->pci_func;
  }
  i = 0;
  goto ldv_53410;
  ldv_53409:
  entry = (struct qlcnic_dump_entry *)tmpl_hdr + (unsigned long )entry_offset;
  if (((u32 )entry->hdr.mask & fw_dump->cap_mask) == 0U) {
    entry->hdr.flags = (u8 )((unsigned int )entry->hdr.flags | 128U);
    entry_offset = entry->hdr.offset + entry_offset;
    goto ldv_53405;
  } else {
  }
  ops_index = 0;
  goto ldv_53408;
  ldv_53407: ;
  if (entry->hdr.type == (u32 )(fw_dump_ops + (unsigned long )ops_index)->opcode) {
    goto ldv_53406;
  } else {
  }
  ops_index = ops_index + 1;
  ldv_53408: ;
  if (ops_index < ops_cnt) {
    goto ldv_53407;
  } else {
  }
  ldv_53406: ;
  if (ops_index == ops_cnt) {
    _dev_info((struct device const *)dev, "Skipping unknown entry opcode %d\n",
              entry->hdr.type);
    entry->hdr.flags = (u8 )((unsigned int )entry->hdr.flags | 128U);
    entry_offset = entry->hdr.offset + entry_offset;
    goto ldv_53405;
  } else {
  }
  dump = (*((fw_dump_ops + (unsigned long )ops_index)->handler))(adapter, entry, buffer);
  tmp___3 = qlcnic_valid_dump_entry(dev, entry, dump);
  if (tmp___3 == 0) {
    entry->hdr.flags = (u8 )((unsigned int )entry->hdr.flags | 128U);
    entry_offset = entry->hdr.offset + entry_offset;
    goto ldv_53405;
  } else {
  }
  buf_offset = entry->hdr.cap_size + buf_offset;
  entry_offset = entry->hdr.offset + entry_offset;
  buffer = (__le32 *)fw_dump->data + (unsigned long )buf_offset;
  ldv_53405:
  i = i + 1;
  ldv_53410: ;
  if ((u32 )i < no_entries) {
    goto ldv_53409;
  } else {
  }
  fw_dump->clr = 1U;
  snprintf((char *)(& mesg), 64UL, "FW_DUMP=%s", (char *)(& (adapter->netdev)->name));
  netdev_info((struct net_device const *)adapter->netdev, "Dump data %d bytes captured, template header size %d bytes\n",
              fw_dump->size, fw_dump->tmpl_hdr_size);
  kobject_uevent_env(& dev->kobj, 2, (char **)(& msg));
  return (0);
}
}
void qlcnic_83xx_get_minidump_template(struct qlcnic_adapter *adapter )
{
  u32 prev_version ;
  u32 current_version ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_fw_dump *fw_dump ;
  struct pci_dev *pdev ;
  int tmp ;
  int tmp___0 ;
  {
  ahw = adapter->ahw;
  fw_dump = & ahw->fw_dump;
  pdev = adapter->pdev;
  prev_version = adapter->fw_version;
  tmp = qlcnic_83xx_get_fw_version(adapter);
  current_version = (u32 )tmp;
  if ((unsigned long )fw_dump->tmpl_hdr == (unsigned long )((void *)0) || current_version > prev_version) {
    if ((unsigned long )fw_dump->tmpl_hdr != (unsigned long )((void *)0)) {
      vfree((void const *)fw_dump->tmpl_hdr);
    } else {
    }
    tmp___0 = qlcnic_fw_cmd_get_minidump_temp(adapter);
    if (tmp___0 == 0) {
      _dev_info((struct device const *)(& pdev->dev), "Supports FW dump capability\n");
    } else {
    }
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_342(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_348(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_350(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_352(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_353(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_354(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_355(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_356(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_357(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_358(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_359(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_vzalloc_360(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
void *ldv_vzalloc_361(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
__inline static int atomic_read(atomic_t const *v )
{
  {
  return ((int )*((int volatile *)(& v->counter)));
}
}
__inline static void atomic_set(atomic_t *v , int i )
{
  {
  v->counter = i;
  return;
}
}
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long ) ;
__inline static void spin_lock(spinlock_t *lock ) ;
__inline static void spin_unlock(spinlock_t *lock ) ;
__inline static void ldv_spin_unlock_irqrestore_382(spinlock_t *lock , unsigned long flags )
{
  {
  _raw_spin_unlock_irqrestore(& lock->ldv_6347.rlock, flags);
  return;
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
extern void __init_waitqueue_head(wait_queue_head_t * , char const * , struct lock_class_key * ) ;
__inline static void init_completion(struct completion *x )
{
  struct lock_class_key __key ;
  {
  x->done = 0U;
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
  return;
}
}
__inline static void reinit_completion(struct completion *x )
{
  {
  x->done = 0U;
  return;
}
}
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long ) ;
extern void complete(struct completion * ) ;
extern bool queue_work_on(int , struct workqueue_struct * , struct work_struct * ) ;
extern void flush_workqueue(struct workqueue_struct * ) ;
extern bool cancel_work_sync(struct work_struct * ) ;
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work )
{
  bool tmp ;
  {
  tmp = queue_work_on(8192, wq, work);
  return (tmp);
}
}
void *ldv_vzalloc_408(unsigned long ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_390(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_407(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
extern int ___ratelimit(struct ratelimit_state * , char const * ) ;
extern int pci_find_ext_capability(struct pci_dev * , int ) ;
struct sk_buff *ldv_skb_clone_398(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_406(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_400(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_396(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_404(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_405(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_401(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_402(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_403(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern void synchronize_irq(unsigned int ) ;
int qlcnic_83xx_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd ) ;
int qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_get_func_no(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_cam_lock(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_cam_unlock(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_write_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                           size_t size ) ;
void qlcnic_83xx_read_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                          size_t size ) ;
int qlcnic_83xx_rd_reg_indirect(struct qlcnic_adapter *adapter , ulong addr , int *err ) ;
int qlcnic_83xx_nic_set_promisc(struct qlcnic_adapter *adapter , u32 mode ) ;
int qlcnic_83xx_config_hw_lro(struct qlcnic_adapter *adapter , int mode ) ;
int qlcnic_83xx_config_rss(struct qlcnic_adapter *adapter , int enable ) ;
void qlcnic_83xx_change_l2_filter(struct qlcnic_adapter *adapter , u64 *addr , u16 vlan_id ) ;
int qlcnic_83xx_get_pci_info(struct qlcnic_adapter *adapter , struct qlcnic_pci_info *pci_info ) ;
int qlcnic_83xx_set_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *nic ) ;
int qlcnic_83xx_create_rx_ctx(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_create_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx ,
                              int ring ) ;
void qlcnic_83xx_del_rx_ctx(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_del_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring ) ;
int qlcnic_83xx_get_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info ,
                             u8 func_id ) ;
int qlcnic_83xx_setup_link_event(struct qlcnic_adapter *adapter , int enable ) ;
int qlcnic_83xx_sre_macaddr_change(struct qlcnic_adapter *adapter , u8 *addr , u16 vlan_id ,
                                   u8 op ) ;
int qlcnic_83xx_get_mac_address(struct qlcnic_adapter *adapter , u8 *mac , u8 function ) ;
int qlcnic_83xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx , struct qlcnic_adapter *adapter ,
                               u32 type ) ;
int qlcnic_83xx_config_intr_coal(struct qlcnic_adapter *adapter , struct ethtool_coalesce *ethcoal ) ;
int qlcnic_83xx_get_port_info(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_enable_mbx_interrupt(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_disable_mbx_intr(struct qlcnic_adapter *adapter ) ;
irqreturn_t qlcnic_83xx_clear_legacy_intr(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_idc_aen_work(struct work_struct *work ) ;
void qlcnic_83xx_config_ipaddr(struct qlcnic_adapter *adapter , __be32 ip , int mode ) ;
int qlcnic_83xx_read_flash_mfg_id(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_read_flash_descriptor_table(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_flash_read32(struct qlcnic_adapter *adapter , u32 flash_addr , u8 *p_data ,
                             int count ) ;
void qlcnic_83xx_idc_poll_dev_state(struct work_struct *work ) ;
void qlcnic_83xx_idc_exit(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_idc_init(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_idc_reattach_driver(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_set_vnic_opmode(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_check_vnic_state(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_aer_stop_poll_work(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_aer_reset(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_aer_start_poll_work(struct qlcnic_adapter *adapter ) ;
extern u32 qlcnic_83xx_get_saved_state(void * , u32 ) ;
extern void qlcnic_83xx_set_saved_state(void * , u32 , u32 ) ;
extern u32 qlcnic_83xx_get_cap_size(void * , int ) ;
int qlcnic_83xx_init_mailbox_work(struct qlcnic_adapter *adapter ) ;
void qlcnic_83xx_reinit_mbx_work(struct qlcnic_mailbox *mbx ) ;
__inline static void qlcnic_83xx_enable_tx_intr(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring )
{
  {
  writel(0U, (void volatile *)tx_ring->crb_intr_mask);
  return;
}
}
__inline static void qlcnic_83xx_disable_tx_intr(struct qlcnic_adapter *adapter ,
                                                 struct qlcnic_host_tx_ring *tx_ring )
{
  {
  writel(1U, (void volatile *)tx_ring->crb_intr_mask);
  return;
}
}
__inline static void qlcnic_83xx_enable_sds_intr(struct qlcnic_adapter *adapter ,
                                                 struct qlcnic_host_sds_ring *sds_ring )
{
  {
  writel(0U, (void volatile *)sds_ring->crb_intr_mask);
  return;
}
}
__inline static void qlcnic_83xx_disable_sds_intr(struct qlcnic_adapter *adapter ,
                                                  struct qlcnic_host_sds_ring *sds_ring )
{
  {
  writel(1U, (void volatile *)sds_ring->crb_intr_mask);
  return;
}
}
__inline static int qlcnic_get_diag_lock(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = test_and_set_bit(13L, (unsigned long volatile *)(& adapter->state));
  return (tmp);
}
}
__inline static void qlcnic_release_diag_lock(struct qlcnic_adapter *adapter )
{
  {
  clear_bit(13L, (unsigned long volatile *)(& adapter->state));
  return;
}
}
u32 const qlcnic_83xx_reg_tbl[23U] ;
u32 const qlcnic_83xx_ext_reg_tbl[43U] ;
void qlcnic_sriov_vf_set_ops(struct qlcnic_adapter *adapter ) ;
void qlcnic_sriov_handle_bc_event(struct qlcnic_adapter *adapter , u32 event ) ;
void qlcnic_pf_set_interface_id_create_rx_ctx(struct qlcnic_adapter *adapter , u32 *int_id ) ;
void qlcnic_pf_set_interface_id_create_tx_ctx(struct qlcnic_adapter *adapter , u32 *int_id ) ;
void qlcnic_pf_set_interface_id_del_rx_ctx(struct qlcnic_adapter *adapter , u32 *int_id ) ;
void qlcnic_pf_set_interface_id_del_tx_ctx(struct qlcnic_adapter *adapter , u32 *int_id ) ;
void qlcnic_pf_set_interface_id_promisc(struct qlcnic_adapter *adapter , u32 *int_id ) ;
void qlcnic_pf_set_interface_id_ipaddr(struct qlcnic_adapter *adapter , u32 *int_id ) ;
void qlcnic_pf_set_interface_id_macaddr(struct qlcnic_adapter *adapter , u32 *int_id ) ;
static void __qlcnic_83xx_process_aen(struct qlcnic_adapter *adapter ) ;
static int qlcnic_83xx_clear_lb_mode(struct qlcnic_adapter *adapter , u8 mode ) ;
static void qlcnic_83xx_configure_mac(struct qlcnic_adapter *adapter , u8 *mac , u8 type ,
                                      struct qlcnic_cmd_args *cmd ) ;
static int qlcnic_83xx_get_port_config(struct qlcnic_adapter *adapter ) ;
static irqreturn_t qlcnic_83xx_handle_aen(int irq , void *data ) ;
static pci_ers_result_t qlcnic_83xx_io_error_detected(struct pci_dev *pdev , pci_channel_state_t state ) ;
static int qlcnic_83xx_set_port_config(struct qlcnic_adapter *adapter ) ;
static pci_ers_result_t qlcnic_83xx_io_slot_reset(struct pci_dev *pdev ) ;
static void qlcnic_83xx_io_resume(struct pci_dev *pdev ) ;
static int qlcnic_83xx_set_lb_mode(struct qlcnic_adapter *adapter , u8 mode ) ;
static void qlcnic_83xx_set_mac_filter_count(struct qlcnic_adapter *adapter ) ;
static int qlcnic_83xx_resume(struct qlcnic_adapter *adapter ) ;
static int qlcnic_83xx_shutdown(struct pci_dev *pdev ) ;
static void qlcnic_83xx_get_beacon_state(struct qlcnic_adapter *adapter ) ;
static struct qlcnic_mailbox_metadata const qlcnic_83xx_mbx_tbl[53U] =
  { {1U, 6U, 1U},
        {2U, 18U, 34U},
        {7U, 136U, 27U},
        {8U, 2U, 1U},
        {9U, 54U, 18U},
        {10U, 2U, 1U},
        {13U, 2U, 1U},
        {17U, 22U, 12U},
        {18U, 3U, 1U},
        {19U, 4U, 2U},
        {20U, 5U, 1U},
        {21U, 4U, 1U},
        {22U, 4U, 2U},
        {23U, 4U, 1U},
        {24U, 4U, 2U},
        {25U, 4U, 2U},
        {31U, 4U, 3U},
        {32U, 1U, 129U},
        {33U, 2U, 19U},
        {34U, 32U, 1U},
        {36U, 4U, 3U},
        {37U, 4U, 1U},
        {38U, 4U, 3U},
        {39U, 4U, 1U},
        {40U, 4U, 1U},
        {41U, 4U, 3U},
        {42U, 5U, 1U},
        {46U, 4U, 1U},
        {47U, 1U, 4U},
        {48U, 5U, 5U},
        {72U, 2U, 1U},
        {69U, 4U, 3U},
        {67U, 6U, 1U},
        {65U, 14U, 1U},
        {68U, 2U, 1U},
        {73U, 2U, 1U},
        {74U, 2U, 1U},
        {15U, 2U, 80U},
        {102U, 2U, 1U},
        {103U, 2U, 2U},
        {104U, 2U, 4U},
        {99U, 5U, 1U},
        {96U, 3U, 1U},
        {97U, 2U, 1U},
        {105U, 5U, 1U},
        {106U, 1U, 5U},
        {111U, 4U, 1U},
        {11U, 130U, 26U},
        {50U, 4U, 4U},
        {49U, 2U, 1U},
        {52U, 1U, 2U},
        {53U, 1U, 50U},
        {78U, 2U, 1U}};
u32 const qlcnic_83xx_ext_reg_tbl[43U] =
  { 14540U, 14576U, 14588U, 12344U,
        12348U, 13660U, 13664U, 13668U,
        4096U, 4608U, 4612U, 14208U,
        14212U, 14216U, 14220U, 14224U,
        14228U, 14232U, 14236U, 14240U,
        14244U, 14248U, 14252U, 14256U,
        14260U, 14264U, 14268U, 14272U,
        14276U, 14280U, 14284U, 14288U,
        14292U, 14296U, 14300U, 14304U,
        14308U, 14320U, 14324U, 14440U,
        14444U, 13572U, 13476U};
u32 const qlcnic_83xx_reg_tbl[23U] =
  { 13480U, 13484U, 13488U, 13568U,
        13608U, 13624U, 13632U, 13636U,
        13640U, 13644U, 13604U, 13648U,
        13652U, 13656U, 13724U, 13820U,
        13904U, 14140U, 14260U, 13676U,
        13680U, 14416U, 14420U};
static struct qlcnic_hardware_ops qlcnic_83xx_hw_ops =
     {& qlcnic_83xx_read_crb, & qlcnic_83xx_write_crb, & qlcnic_83xx_rd_reg_indirect,
    & qlcnic_83xx_wrt_reg_indirect, 0, & qlcnic_83xx_get_mac_address, & qlcnic_83xx_setup_intr,
    & qlcnic_83xx_alloc_mbx_args, & qlcnic_83xx_issue_cmd, & qlcnic_83xx_get_func_no,
    & qlcnic_83xx_cam_lock, & qlcnic_83xx_cam_unlock, & qlcnic_83xx_add_sysfs, & qlcnic_83xx_remove_sysfs,
    & qlcnic_83xx_process_rcv_ring_diag, & qlcnic_83xx_create_rx_ctx, & qlcnic_83xx_create_tx_ctx,
    & qlcnic_83xx_del_rx_ctx, & qlcnic_83xx_del_tx_ctx, & qlcnic_83xx_setup_link_event,
    & qlcnic_83xx_get_nic_info, & qlcnic_83xx_get_pci_info, & qlcnic_83xx_set_nic_info,
    & qlcnic_83xx_sre_macaddr_change, & qlcnic_83xx_napi_enable, & qlcnic_83xx_napi_disable,
    & qlcnic_83xx_config_intr_coal, & qlcnic_83xx_config_rss, & qlcnic_83xx_config_hw_lro,
    0, 0, & qlcnic_83xx_nic_set_promisc, & qlcnic_83xx_change_l2_filter, & qlcnic_83xx_get_port_info,
    & qlcnic_83xx_set_mac_filter_count, & qlcnic_82xx_free_mac_list, 0, & qlcnic_83xx_io_error_detected,
    & qlcnic_83xx_io_slot_reset, & qlcnic_83xx_io_resume, & qlcnic_83xx_get_beacon_state,
    & qlcnic_83xx_enable_sds_intr, & qlcnic_83xx_disable_sds_intr, & qlcnic_83xx_enable_tx_intr,
    & qlcnic_83xx_disable_tx_intr, & qlcnic_83xx_get_saved_state, & qlcnic_83xx_set_saved_state,
    & qlcnic_83xx_cache_tmpl_hdr_values, & qlcnic_83xx_get_cap_size, & qlcnic_83xx_set_sys_info,
    & qlcnic_83xx_store_cap_mask};
static struct qlcnic_nic_template qlcnic_83xx_ops =
     {& qlcnic_config_bridged_mode, & qlcnic_config_led, 0, 0, & qlcnic_83xx_idc_request_reset,
    & qlcnic_83xx_idc_exit, & qlcnic_83xx_napi_add, & qlcnic_83xx_napi_del, & qlcnic_83xx_config_ipaddr,
    & qlcnic_83xx_clear_legacy_intr, & qlcnic_83xx_shutdown, & qlcnic_83xx_resume};
void qlcnic_83xx_register_map(struct qlcnic_hardware_context *ahw )
{
  {
  ahw->hw_ops = & qlcnic_83xx_hw_ops;
  ahw->reg_tbl = (u32 *)(& qlcnic_83xx_reg_tbl);
  ahw->ext_reg_tbl = (u32 *)(& qlcnic_83xx_ext_reg_tbl);
  return;
}
}
int qlcnic_83xx_get_fw_version(struct qlcnic_adapter *adapter )
{
  u32 fw_major ;
  u32 fw_minor ;
  u32 fw_build ;
  struct pci_dev *pdev ;
  {
  pdev = adapter->pdev;
  fw_major = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 11UL));
  fw_minor = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 12UL));
  fw_build = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 13UL));
  adapter->fw_version = ((fw_major << 24) + (fw_minor << 16)) + fw_build;
  _dev_info((struct device const *)(& pdev->dev), "Driver v%s, firmware version %d.%d.%d\n",
            (char *)"5.3.60", fw_major, fw_minor, fw_build);
  return ((int )adapter->fw_version);
}
}
static int __qlcnic_set_win_base(struct qlcnic_adapter *adapter , u32 addr )
{
  void *base ;
  u32 val ;
  {
  base = (adapter->ahw)->pci_base0 + (unsigned long )(((int )(adapter->ahw)->pci_func + 3584) * 4);
  writel(addr, (void volatile *)base);
  val = readl((void const volatile *)base);
  if (val != addr) {
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_rd_reg_indirect(struct qlcnic_adapter *adapter , ulong addr , int *err )
{
  struct qlcnic_hardware_context *ahw ;
  unsigned int tmp ;
  {
  ahw = adapter->ahw;
  *err = __qlcnic_set_win_base(adapter, (unsigned int )addr);
  if (*err == 0) {
    tmp = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 1UL));
    return ((int )tmp);
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s failed, addr = 0x%lx\n",
            "qlcnic_83xx_rd_reg_indirect", addr);
    return (-5);
  }
}
}
int qlcnic_83xx_wrt_reg_indirect(struct qlcnic_adapter *adapter , ulong addr , u32 data )
{
  int err ;
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  err = __qlcnic_set_win_base(adapter, (unsigned int )addr);
  if (err == 0) {
    writel(data, (void volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 1UL));
    return (0);
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s failed, addr = 0x%x data = 0x%x\n",
            "qlcnic_83xx_wrt_reg_indirect", (int )addr, data);
    return (err);
  }
}
}
static void qlcnic_83xx_enable_legacy(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  adapter->tgt_status_reg = ahw->pci_base0 + 14528UL;
  adapter->tgt_mask_reg = ahw->pci_base0 + 14536UL;
  adapter->isr_int_vec = ahw->pci_base0 + 14532UL;
  (adapter->msix_entries)->vector = (adapter->pdev)->irq;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "using legacy interrupt\n");
  return;
}
}
static int qlcnic_83xx_calculate_msix_vector(struct qlcnic_adapter *adapter )
{
  int num_msix ;
  {
  num_msix = (int )adapter->drv_sds_rings;
  num_msix = num_msix + 1;
  if ((adapter->flags & 65536U) == 0U) {
    num_msix = (int )adapter->drv_tx_rings + num_msix;
  } else {
  }
  return (num_msix);
}
}
int qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  int i ;
  int num_msix ;
  bool tmp ;
  void *tmp___0 ;
  {
  ahw = adapter->ahw;
  if ((adapter->flags & 524288U) != 0U) {
    err = qlcnic_setup_tss_rss_intr(adapter);
    if (err < 0) {
      return (err);
    } else {
    }
    num_msix = (int )ahw->num_msix;
  } else {
    num_msix = qlcnic_83xx_calculate_msix_vector(adapter);
    err = qlcnic_enable_msix(adapter, (u32 )num_msix);
    if (err == -12) {
      return (err);
    } else {
    }
    if ((adapter->flags & 4U) != 0U) {
      num_msix = (int )ahw->num_msix;
    } else {
      tmp = qlcnic_sriov_vf_check(adapter);
      if ((int )tmp) {
        return (-22);
      } else {
      }
      num_msix = 1;
      adapter->drv_sds_rings = 1U;
      adapter->drv_tx_rings = 1U;
    }
  }
  tmp___0 = ldv_vzalloc_408((unsigned long )num_msix * 8UL);
  ahw->intr_tbl = (struct qlcnic_intrpt_config *)tmp___0;
  if ((unsigned long )ahw->intr_tbl == (unsigned long )((struct qlcnic_intrpt_config *)0)) {
    return (-12);
  } else {
  }
  if ((adapter->flags & 4U) == 0U) {
    if ((unsigned int )(adapter->ahw)->pci_func > 7U) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "PCI function number 8 and higher are not supported with legacy interrupt, func 0x%x\n",
              (int )ahw->pci_func);
      return (-95);
    } else {
    }
    qlcnic_83xx_enable_legacy(adapter);
  } else {
  }
  i = 0;
  goto ldv_51556;
  ldv_51555: ;
  if ((adapter->flags & 4U) != 0U) {
    (ahw->intr_tbl + (unsigned long )i)->type = 3U;
  } else {
    (ahw->intr_tbl + (unsigned long )i)->type = 1U;
  }
  (ahw->intr_tbl + (unsigned long )i)->id = (u16 )i;
  (ahw->intr_tbl + (unsigned long )i)->src = 0U;
  i = i + 1;
  ldv_51556: ;
  if (i < num_msix) {
    goto ldv_51555;
  } else {
  }
  return (0);
}
}
__inline static void qlcnic_83xx_clear_legacy_intr_mask(struct qlcnic_adapter *adapter )
{
  {
  writel(0U, (void volatile *)adapter->tgt_mask_reg);
  return;
}
}
__inline static void qlcnic_83xx_set_legacy_intr_mask(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned long )adapter->tgt_mask_reg != (unsigned long )((void *)0)) {
    writel(1U, (void volatile *)adapter->tgt_mask_reg);
  } else {
  }
  return;
}
}
__inline static void qlcnic_83xx_enable_legacy_msix_mbx_intr(struct qlcnic_adapter *adapter )
{
  u32 mask ;
  {
  mask = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 9UL));
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )mask);
  return;
}
}
void qlcnic_83xx_disable_mbx_intr(struct qlcnic_adapter *adapter )
{
  u32 mask ;
  {
  mask = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 9UL));
  writel(1U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )mask);
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 8UL));
  return;
}
}
__inline static void qlcnic_83xx_get_mbx_data(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  int i ;
  {
  if (cmd->op_type == 1U) {
    return;
  } else {
  }
  i = 0;
  goto ldv_51578;
  ldv_51577:
  *(cmd->rsp.arg + (unsigned long )i) = readl((void const volatile *)((adapter->ahw)->pci_base0 + ((unsigned long )(i * 4) + 2048UL)));
  i = i + 1;
  ldv_51578: ;
  if ((u32 )i < cmd->rsp.num) {
    goto ldv_51577;
  } else {
  }
  return;
}
}
irqreturn_t qlcnic_83xx_clear_legacy_intr(struct qlcnic_adapter *adapter )
{
  u32 intr_val ;
  struct qlcnic_hardware_context *ahw ;
  int retries ;
  {
  ahw = adapter->ahw;
  retries = 0;
  intr_val = readl((void const volatile *)adapter->tgt_status_reg);
  if ((int )intr_val >= 0) {
    return (0);
  } else {
  }
  if ((intr_val & 255U) != (u32 )(adapter->ahw)->pci_func) {
    adapter->stats.spurious_intr = adapter->stats.spurious_intr + 1ULL;
    return (0);
  } else {
  }
  __asm__ volatile ("sfence": : : "memory");
  writel(0U, (void volatile *)adapter->isr_int_vec);
  intr_val = readl((void const volatile *)adapter->isr_int_vec);
  ldv_51587:
  intr_val = readl((void const volatile *)adapter->tgt_status_reg);
  if ((intr_val & 255U) != (u32 )ahw->pci_func) {
    goto ldv_51586;
  } else {
  }
  retries = retries + 1;
  if ((intr_val & 1073741824U) != 0U && retries <= 99) {
    goto ldv_51587;
  } else {
  }
  ldv_51586: ;
  return (1);
}
}
__inline static void qlcnic_83xx_notify_mbx_response(struct qlcnic_mailbox *mbx )
{
  {
  atomic_set(& mbx->rsp_status, 1);
  complete(& mbx->completion);
  return;
}
}
static void qlcnic_83xx_poll_process_aen(struct qlcnic_adapter *adapter )
{
  u32 resp ;
  u32 event ;
  u32 rsp_status ;
  struct qlcnic_mailbox *mbx ;
  unsigned long flags ;
  int tmp ;
  {
  rsp_status = 1U;
  mbx = (adapter->ahw)->mailbox;
  ldv_spin_lock();
  resp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 4UL));
  if ((resp & 1U) == 0U) {
    goto out;
  } else {
  }
  event = readl((void const volatile *)(adapter->ahw)->pci_base0 + 2048U);
  if ((event & 32768U) != 0U) {
    __qlcnic_83xx_process_aen(adapter);
  } else {
    tmp = atomic_read((atomic_t const *)(& mbx->rsp_status));
    if ((u32 )tmp != rsp_status) {
      qlcnic_83xx_notify_mbx_response(mbx);
    } else {
    }
  }
  out:
  qlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);
  spin_unlock_irqrestore(& mbx->aen_lock, flags);
  return;
}
}
irqreturn_t qlcnic_83xx_intr(int irq , void *data )
{
  struct qlcnic_adapter *adapter ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_hardware_context *ahw ;
  irqreturn_t tmp ;
  int tmp___0 ;
  {
  adapter = (struct qlcnic_adapter *)data;
  ahw = adapter->ahw;
  tmp = qlcnic_83xx_clear_legacy_intr(adapter);
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {
  }
  qlcnic_83xx_poll_process_aen(adapter);
  if ((unsigned int )ahw->diag_test != 0U) {
    if ((unsigned int )ahw->diag_test == 1U) {
      ahw->diag_cnt = ahw->diag_cnt + 1;
    } else {
    }
    qlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);
    return (1);
  } else {
  }
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    qlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);
  } else {
    sds_ring = (adapter->recv_ctx)->sds_rings;
    napi_schedule(& sds_ring->napi);
  }
  return (1);
}
}
irqreturn_t qlcnic_83xx_tmp_intr(int irq , void *data )
{
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_adapter *adapter ;
  irqreturn_t tmp ;
  {
  sds_ring = (struct qlcnic_host_sds_ring *)data;
  adapter = sds_ring->adapter;
  if ((adapter->flags & 4U) != 0U) {
    goto done;
  } else {
  }
  tmp = (*((adapter->nic_ops)->clear_legacy_intr))(adapter);
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {
  }
  done:
  (adapter->ahw)->diag_cnt = (adapter->ahw)->diag_cnt + 1;
  qlcnic_enable_sds_intr(adapter, sds_ring);
  return (1);
}
}
void qlcnic_83xx_free_mbx_intr(struct qlcnic_adapter *adapter )
{
  u32 num_msix ;
  {
  if ((adapter->flags & 4U) == 0U) {
    qlcnic_83xx_set_legacy_intr_mask(adapter);
  } else {
  }
  qlcnic_83xx_disable_mbx_intr(adapter);
  if ((adapter->flags & 4U) != 0U) {
    num_msix = (u32 )((int )(adapter->ahw)->num_msix + -1);
  } else {
    num_msix = 0U;
  }
  msleep(20U);
  if ((unsigned long )adapter->msix_entries != (unsigned long )((struct msix_entry *)0)) {
    synchronize_irq((adapter->msix_entries + (unsigned long )num_msix)->vector);
    free_irq((adapter->msix_entries + (unsigned long )num_msix)->vector, (void *)adapter);
  } else {
  }
  return;
}
}
int qlcnic_83xx_setup_mbx_intr(struct qlcnic_adapter *adapter )
{
  irqreturn_t (*handler)(int , void * ) ;
  u32 val ;
  int err ;
  unsigned long flags ;
  {
  err = 0;
  flags = 0UL;
  if ((adapter->flags & 2U) == 0U && (adapter->flags & 4U) == 0U) {
    flags = flags | 128UL;
  } else {
  }
  if ((adapter->flags & 4U) != 0U) {
    handler = & qlcnic_83xx_handle_aen;
    val = (adapter->msix_entries + ((unsigned long )(adapter->ahw)->num_msix + 0xffffffffffffffffUL))->vector;
    err = request_irq(val, handler, flags, "qlcnic-MB", (void *)adapter);
    if (err != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "failed to register MBX interrupt\n");
      return (err);
    } else {
    }
  } else {
    handler = & qlcnic_83xx_intr;
    val = (adapter->msix_entries)->vector;
    err = request_irq(val, handler, flags, "qlcnic", (void *)adapter);
    if (err != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "failed to register INTx interrupt\n");
      return (err);
    } else {
    }
    qlcnic_83xx_clear_legacy_intr_mask(adapter);
  }
  qlcnic_83xx_enable_mbx_interrupt(adapter);
  return (err);
}
}
void qlcnic_83xx_get_func_no(struct qlcnic_adapter *adapter )
{
  u32 val ;
  unsigned int tmp ;
  {
  tmp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 2UL));
  val = tmp;
  (adapter->ahw)->pci_func = (u8 )(val >> 24);
  return;
}
}
int qlcnic_83xx_cam_lock(struct qlcnic_adapter *adapter )
{
  void *addr ;
  u32 val ;
  u32 limit ;
  struct qlcnic_hardware_context *ahw ;
  {
  limit = 0U;
  ahw = adapter->ahw;
  addr = ahw->pci_base0 + (unsigned long )(((int )ahw->pci_func + 1800) * 8);
  ldv_51636:
  val = readl((void const volatile *)addr);
  if (val != 0U) {
    writel((unsigned int )ahw->pci_func, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 3UL));
    return (0);
  } else {
  }
  usleep_range(1000UL, 2000UL);
  limit = limit + 1U;
  if (limit <= 10000U) {
    goto ldv_51636;
  } else {
  }
  return (-5);
}
}
void qlcnic_83xx_cam_unlock(struct qlcnic_adapter *adapter )
{
  void *addr ;
  u32 val ;
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  addr = ahw->pci_base0 + (unsigned long )((int )ahw->pci_func * 8 + 14404);
  val = readl((void const volatile *)addr);
  return;
}
}
void qlcnic_83xx_read_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                          size_t size )
{
  int ret ;
  u32 data ;
  int tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  ret = 0;
  tmp = qlcnic_api_lock(adapter);
  if (tmp != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed to acquire lock. addr offset 0x%x\n",
            "qlcnic_83xx_read_crb", (unsigned int )offset);
    return;
  } else {
  }
  tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )((unsigned int )offset),
                                                    & ret);
  data = (u32 )tmp___0;
  qlcnic_api_unlock(adapter);
  if (ret == -5) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed. addr offset 0x%x\n",
            "qlcnic_83xx_read_crb", (unsigned int )offset);
    return;
  } else {
  }
  __len = size;
  __ret = memcpy((void *)buf, (void const *)(& data), __len);
  return;
}
}
void qlcnic_83xx_write_crb(struct qlcnic_adapter *adapter , char *buf , loff_t offset ,
                           size_t size )
{
  u32 data ;
  size_t __len ;
  void *__ret ;
  {
  __len = size;
  __ret = memcpy((void *)(& data), (void const *)buf, __len);
  qlcnic_83xx_wrt_reg_indirect(adapter, (ulong )((unsigned int )offset), data);
  return;
}
}
int qlcnic_83xx_get_port_info(struct qlcnic_adapter *adapter )
{
  int status ;
  {
  status = qlcnic_83xx_get_port_config(adapter);
  if (status != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Get Port Info failed\n");
  } else {
    if (((adapter->ahw)->port_config & 2048U) != 0U) {
      (adapter->ahw)->port_type = 2U;
    } else {
      (adapter->ahw)->port_type = 1U;
    }
    if (((adapter->ahw)->port_config & 32768U) != 0U) {
      (adapter->ahw)->link_autoneg = 1U;
    } else {
    }
  }
  return (status);
}
}
static void qlcnic_83xx_set_mac_filter_count(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  u16 act_pci_fn ;
  u16 count ;
  {
  ahw = adapter->ahw;
  act_pci_fn = ahw->total_nic_func;
  ahw->max_mc_count = 38U;
  if ((unsigned int )act_pci_fn <= 2U) {
    count = (u16 )(4058 / (int )act_pci_fn);
  } else {
    count = (u16 )(2010 / (int )act_pci_fn);
  }
  ahw->max_uc_count = count;
  return;
}
}
void qlcnic_83xx_enable_mbx_interrupt(struct qlcnic_adapter *adapter )
{
  u32 val ;
  {
  if ((adapter->flags & 4U) != 0U) {
    val = (u32 )((((int )(adapter->ahw)->num_msix + -1) << 8) | 4);
  } else {
    val = 4U;
  }
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 8UL));
  qlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);
  return;
}
}
void qlcnic_83xx_check_vf(struct qlcnic_adapter *adapter , struct pci_device_id const *ent )
{
  u32 op_mode ;
  u32 priv_level ;
  struct qlcnic_hardware_context *ahw ;
  bool tmp ;
  int tmp___0 ;
  {
  ahw = adapter->ahw;
  ahw->fw_hal_version = 2U;
  qlcnic_get_func_no(adapter);
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    qlcnic_sriov_vf_set_ops(adapter);
    return;
  } else {
  }
  op_mode = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 37UL));
  if (op_mode == 1431655765U) {
    priv_level = 0U;
  } else {
    priv_level = (op_mode >> (int )ahw->pci_func * 2) & 3U;
  }
  if (priv_level == 2U) {
    ahw->op_mode = 2U;
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d Non Privileged function\n",
              ahw->fw_hal_version);
    adapter->nic_ops = & qlcnic_vf_ops;
  } else {
    tmp___0 = pci_find_ext_capability(adapter->pdev, 16);
    if (tmp___0 != 0) {
      set_bit(11L, (unsigned long volatile *)(& adapter->state));
    } else {
    }
    adapter->nic_ops = & qlcnic_83xx_ops;
  }
  return;
}
}
static void qlcnic_83xx_handle_link_aen(struct qlcnic_adapter *adapter , u32 *data ) ;
static void qlcnic_83xx_handle_idc_comp_aen(struct qlcnic_adapter *adapter , u32 *data ) ;
void qlcnic_dump_mbx(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  int i ;
  {
  if (cmd->op_type == 1U) {
    return;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Host MBX regs(%d)\n",
            cmd->req.num);
  i = 0;
  goto ldv_51699;
  ldv_51698: ;
  if (i != 0 && ((unsigned int )i & 7U) == 0U) {
    printk("\016\n");
  } else {
  }
  printk("\016%08x ", *(cmd->req.arg + (unsigned long )i));
  i = i + 1;
  ldv_51699: ;
  if ((u32 )i < cmd->req.num) {
    goto ldv_51698;
  } else {
  }
  printk("\016\n");
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "FW MBX regs(%d)\n",
            cmd->rsp.num);
  i = 0;
  goto ldv_51702;
  ldv_51701: ;
  if (i != 0 && ((unsigned int )i & 7U) == 0U) {
    printk("\016\n");
  } else {
  }
  printk("\016%08x ", *(cmd->rsp.arg + (unsigned long )i));
  i = i + 1;
  ldv_51702: ;
  if ((u32 )i < cmd->rsp.num) {
    goto ldv_51701;
  } else {
  }
  printk("\016\n");
  return;
}
}
static void qlcnic_83xx_poll_for_mbx_completion(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_hardware_context *ahw ;
  int opcode ;
  unsigned long max_loops ;
  int tmp ;
  {
  ahw = adapter->ahw;
  opcode = (int )((unsigned short )*(cmd->req.arg));
  max_loops = (unsigned long )(cmd->total_cmds * 5000000U);
  goto ldv_51712;
  ldv_51711:
  tmp = atomic_read((atomic_t const *)(& cmd->rsp_status));
  if (tmp == 1) {
    return;
  } else {
  }
  __const_udelay(4295UL);
  max_loops = max_loops - 1UL;
  ldv_51712: ;
  if (max_loops != 0UL) {
    goto ldv_51711;
  } else {
  }
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",
          "qlcnic_83xx_poll_for_mbx_completion", opcode, cmd->type, (int )ahw->pci_func,
          (int )ahw->op_mode);
  flush_workqueue((ahw->mailbox)->work_q);
  return;
}
}
int qlcnic_83xx_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_mailbox *mbx ;
  struct qlcnic_hardware_context *ahw ;
  int cmd_type ;
  int err ;
  int opcode ;
  unsigned long timeout ;
  unsigned long tmp ;
  {
  mbx = (adapter->ahw)->mailbox;
  ahw = adapter->ahw;
  if ((unsigned long )mbx == (unsigned long )((struct qlcnic_mailbox *)0)) {
    return (-5);
  } else {
  }
  opcode = (int )((unsigned short )*(cmd->req.arg));
  cmd_type = (int )cmd->type;
  err = (*((mbx->ops)->enqueue_cmd))(adapter, cmd, & timeout);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Mailbox not available, cmd_op=0x%x, cmd_context=0x%x, pci_func=0x%x, op_mode=0x%x\n",
            "qlcnic_83xx_issue_cmd", opcode, cmd->type, (int )ahw->pci_func, (int )ahw->op_mode);
    return (err);
  } else {
  }
  switch (cmd_type) {
  case 0:
  tmp = wait_for_completion_timeout(& cmd->completion, timeout);
  if (tmp == 0UL) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",
            "qlcnic_83xx_issue_cmd", opcode, cmd_type, (int )ahw->pci_func, (int )ahw->op_mode);
    flush_workqueue(mbx->work_q);
  } else {
  }
  goto ldv_51727;
  case 1: ;
  return (0);
  case 2:
  qlcnic_83xx_poll_for_mbx_completion(adapter, cmd);
  goto ldv_51727;
  default:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid mailbox command, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",
          "qlcnic_83xx_issue_cmd", opcode, cmd_type, (int )ahw->pci_func, (int )ahw->op_mode);
  qlcnic_83xx_detach_mailbox_work(adapter);
  }
  ldv_51727: ;
  return ((int )cmd->rsp_opcode);
}
}
int qlcnic_83xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx , struct qlcnic_adapter *adapter ,
                               u32 type )
{
  int i ;
  int size ;
  u32 temp ;
  struct qlcnic_mailbox_metadata const *mbx_tbl ;
  void *tmp ;
  void *tmp___0 ;
  {
  memset((void *)mbx, 0, 200UL);
  mbx_tbl = (struct qlcnic_mailbox_metadata const *)(& qlcnic_83xx_mbx_tbl);
  size = 53;
  i = 0;
  goto ldv_51743;
  ldv_51742: ;
  if ((u32 )(mbx_tbl + (unsigned long )i)->cmd == type) {
    mbx->op_type = 0U;
    mbx->req.num = (mbx_tbl + (unsigned long )i)->in_args;
    mbx->rsp.num = (mbx_tbl + (unsigned long )i)->out_args;
    tmp = kcalloc((size_t )mbx->req.num, 4UL, 32U);
    mbx->req.arg = (u32 *)tmp;
    if ((unsigned long )mbx->req.arg == (unsigned long )((u32 *)0U)) {
      return (-12);
    } else {
    }
    tmp___0 = kcalloc((size_t )mbx->rsp.num, 4UL, 32U);
    mbx->rsp.arg = (u32 *)tmp___0;
    if ((unsigned long )mbx->rsp.arg == (unsigned long )((u32 *)0U)) {
      kfree((void const *)mbx->req.arg);
      mbx->req.arg = (u32 *)0U;
      return (-12);
    } else {
    }
    memset((void *)mbx->req.arg, 0, (unsigned long )mbx->req.num * 4UL);
    memset((void *)mbx->rsp.arg, 0, (unsigned long )mbx->rsp.num * 4UL);
    temp = (adapter->ahw)->fw_hal_version << 29;
    *(mbx->req.arg) = ((mbx->req.num << 16) | type) | temp;
    mbx->cmd_op = type;
    return (0);
  } else {
  }
  i = i + 1;
  ldv_51743: ;
  if (i < size) {
    goto ldv_51742;
  } else {
  }
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid mailbox command opcode 0x%x\n",
          "qlcnic_83xx_alloc_mbx_args", type);
  return (-22);
}
}
void qlcnic_83xx_idc_aen_work(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  struct qlcnic_cmd_args cmd ;
  int i ;
  int err ;
  struct work_struct const *__mptr ;
  {
  err = 0;
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffb98UL;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 99U);
  if (err != 0) {
    return;
  } else {
  }
  i = 1;
  goto ldv_51756;
  ldv_51755:
  *(cmd.req.arg + (unsigned long )i) = (adapter->ahw)->mbox_aen[i];
  i = i + 1;
  ldv_51756: ;
  if (i <= 4) {
    goto ldv_51755;
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: Mailbox IDC ACK failed.\n",
              "qlcnic_83xx_idc_aen_work");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
static void qlcnic_83xx_handle_idc_comp_aen(struct qlcnic_adapter *adapter , u32 *data )
{
  struct _ddebug descriptor ;
  long tmp ;
  {
  descriptor.modname = "qlcnic";
  descriptor.function = "qlcnic_83xx_handle_idc_comp_aen";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.o.c.prepared";
  descriptor.format = "Completion AEN:0x%x.\n";
  descriptor.lineno = 1077U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device const *)(& (adapter->pdev)->dev),
                      "Completion AEN:0x%x.\n", (int )((unsigned short )*data));
  } else {
  }
  clear_bit(3L, (unsigned long volatile *)(& (adapter->ahw)->idc.status));
  return;
}
}
static void __qlcnic_83xx_process_aen(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  u32 event[5U] ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  {
  ahw = adapter->ahw;
  i = 0;
  goto ldv_51772;
  ldv_51771:
  event[i] = readl((void const volatile *)(ahw->pci_base0 + ((unsigned long )(i * 4) + 2048UL)));
  i = i + 1;
  ldv_51772: ;
  if (i <= 4) {
    goto ldv_51771;
  } else {
  }
  switch ((int )((unsigned short )event[0])) {
  case 32769:
  qlcnic_83xx_handle_link_aen(adapter, (u32 *)(& event));
  goto ldv_51775;
  case 33024:
  qlcnic_83xx_handle_idc_comp_aen(adapter, (u32 *)(& event));
  goto ldv_51775;
  case 33025:
  i = 0;
  goto ldv_51779;
  ldv_51778:
  (adapter->ahw)->mbox_aen[i] = (u32 )((unsigned short )event[i]);
  i = i + 1;
  ldv_51779: ;
  if (i <= 4) {
    goto ldv_51778;
  } else {
  }
  queue_delayed_work(adapter->qlcnic_wq, & adapter->idc_aen_work, 0UL);
  goto ldv_51775;
  case 33026:
  ahw->extend_lb_time = (unsigned int )((u8 )(event[1] >> 8)) & 15U;
  goto ldv_51775;
  case 32770:
  qlcnic_sriov_handle_bc_event(adapter, event[1]);
  goto ldv_51775;
  case 33072:
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "SFP+ Insert AEN:0x%x.\n",
            (int )((unsigned short )event[0]));
  goto ldv_51775;
  case 33073:
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "SFP Removed AEN:0x%x.\n",
            (int )((unsigned short )event[0]));
  goto ldv_51775;
  case 33040:
  qlcnic_dcb_aen_handler(adapter->dcb, (void *)(& event) + 1U);
  goto ldv_51775;
  default:
  descriptor.modname = "qlcnic";
  descriptor.function = "__qlcnic_83xx_process_aen";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/10149/dscv_tempdir/dscv/ri/43_2a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.o.c.prepared";
  descriptor.format = "Unsupported AEN:0x%x.\n";
  descriptor.lineno = 1124U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device const *)(& (adapter->pdev)->dev),
                      "Unsupported AEN:0x%x.\n", (int )((unsigned short )event[0]));
  } else {
  }
  goto ldv_51775;
  }
  ldv_51775:
  writel(0U, (void volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 4UL));
  return;
}
}
static void qlcnic_83xx_process_aen(struct qlcnic_adapter *adapter )
{
  u32 resp ;
  u32 event ;
  u32 rsp_status ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_mailbox *mbx ;
  unsigned long flags ;
  int tmp ;
  {
  rsp_status = 1U;
  ahw = adapter->ahw;
  mbx = ahw->mailbox;
  ldv_spin_lock();
  resp = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 4UL));
  if ((int )resp & 1) {
    event = readl((void const volatile *)ahw->pci_base0 + 2048U);
    if ((event & 32768U) != 0U) {
      __qlcnic_83xx_process_aen(adapter);
    } else {
      tmp = atomic_read((atomic_t const *)(& mbx->rsp_status));
      if ((u32 )tmp != rsp_status) {
        qlcnic_83xx_notify_mbx_response(mbx);
      } else {
      }
    }
  } else {
  }
  spin_unlock_irqrestore(& mbx->aen_lock, flags);
  return;
}
}
static void qlcnic_83xx_mbx_poll_work(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  struct work_struct const *__mptr ;
  int tmp ;
  {
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffab8UL;
  tmp = constant_test_bit(12L, (unsigned long const volatile *)(& adapter->state));
  if (tmp == 0) {
    return;
  } else {
  }
  qlcnic_83xx_process_aen(adapter);
  queue_delayed_work(adapter->qlcnic_wq, & adapter->mbx_poll_work, 25UL);
  return;
}
}
void qlcnic_83xx_enable_mbx_poll(struct qlcnic_adapter *adapter )
{
  int tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  {
  tmp = test_and_set_bit(12L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    return;
  } else {
  }
  __init_work(& adapter->mbx_poll_work.work, 0);
  __constr_expr_0.counter = 137438953408L;
  adapter->mbx_poll_work.work.data = __constr_expr_0;
  lockdep_init_map(& adapter->mbx_poll_work.work.lockdep_map, "(&(&adapter->mbx_poll_work)->work)",
                   & __key, 0);
  INIT_LIST_HEAD(& adapter->mbx_poll_work.work.entry);
  adapter->mbx_poll_work.work.func = & qlcnic_83xx_mbx_poll_work;
  init_timer_key(& adapter->mbx_poll_work.timer, 2U, "(&(&adapter->mbx_poll_work)->timer)",
                 & __key___0);
  adapter->mbx_poll_work.timer.function = & delayed_work_timer_fn;
  adapter->mbx_poll_work.timer.data = (unsigned long )(& adapter->mbx_poll_work);
  queue_delayed_work(adapter->qlcnic_wq, & adapter->mbx_poll_work, 0UL);
  return;
}
}
void qlcnic_83xx_disable_mbx_poll(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = test_and_clear_bit(12L, (unsigned long volatile *)(& adapter->state));
  if (tmp == 0) {
    return;
  } else {
  }
  cancel_delayed_work_sync(& adapter->mbx_poll_work);
  return;
}
}
static int qlcnic_83xx_add_rings(struct qlcnic_adapter *adapter )
{
  int index ;
  int i ;
  int err ;
  int sds_mbx_size ;
  u32 *buf ;
  u32 intrpt_id ;
  u32 intr_mask ;
  u16 context_id ;
  u8 num_sds ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_host_sds_ring *sds ;
  struct qlcnic_sds_mbx sds_mbx ;
  struct qlcnic_add_rings_mbx_out *mbx_out ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_hardware_context *ahw ;
  size_t __len ;
  void *__ret ;
  {
  recv_ctx = adapter->recv_ctx;
  ahw = adapter->ahw;
  sds_mbx_size = 40;
  context_id = recv_ctx->context_id;
  num_sds = (unsigned int )adapter->drv_sds_rings + 248U;
  (*((ahw->hw_ops)->alloc_mbx_args))(& cmd, adapter, 11U);
  *(cmd.req.arg + 1UL) = (u32 )(((int )num_sds << 8) | ((int )context_id << 16));
  index = 2;
  i = 8;
  goto ldv_51835;
  ldv_51834:
  memset((void *)(& sds_mbx), 0, (size_t )sds_mbx_size);
  sds = recv_ctx->sds_rings + (unsigned long )i;
  sds->consumer = 0U;
  memset((void *)sds->desc_head, 0, (unsigned long )sds->num_desc * 16UL);
  sds_mbx.phy_addr_low = (unsigned int )sds->phys_addr;
  sds_mbx.phy_addr_high = (unsigned int )(sds->phys_addr >> 32ULL);
  sds_mbx.sds_ring_size = (u16 )sds->num_desc;
  if ((adapter->flags & 4U) != 0U) {
    intrpt_id = (u32 )(ahw->intr_tbl + (unsigned long )i)->id;
  } else {
    intrpt_id = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 10UL));
  }
  if ((unsigned int )(adapter->ahw)->diag_test != 2U) {
    sds_mbx.intrpt_id = (u16 )intrpt_id;
  } else {
    sds_mbx.intrpt_id = 65535U;
  }
  sds_mbx.intrpt_val = 0U;
  buf = cmd.req.arg + (unsigned long )index;
  __len = (size_t )sds_mbx_size;
  __ret = memcpy((void *)buf, (void const *)(& sds_mbx), __len);
  index = (int )((unsigned int )((unsigned long )sds_mbx_size / 4UL) + (unsigned int )index);
  i = i + 1;
  ldv_51835: ;
  if ((int )adapter->drv_sds_rings > i) {
    goto ldv_51834;
  } else {
  }
  err = (*((ahw->hw_ops)->mbx_cmd))(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to add rings %d\n",
            err);
    goto out;
  } else {
  }
  mbx_out = (struct qlcnic_add_rings_mbx_out *)cmd.rsp.arg + 1U;
  index = 0;
  i = 8;
  goto ldv_51839;
  ldv_51838:
  sds = recv_ctx->sds_rings + (unsigned long )i;
  sds->crb_sts_consumer = ahw->pci_base0 + (unsigned long )mbx_out->host_csmr[index];
  if ((adapter->flags & 4U) != 0U) {
    intr_mask = (ahw->intr_tbl + (unsigned long )i)->src;
  } else {
    intr_mask = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 9UL));
  }
  sds->crb_intr_mask = ahw->pci_base0 + (unsigned long )intr_mask;
  index = index + 1;
  i = i + 1;
  ldv_51839: ;
  if ((int )adapter->drv_sds_rings > i) {
    goto ldv_51838;
  } else {
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
void qlcnic_83xx_del_rx_ctx(struct qlcnic_adapter *adapter )
{
  int err ;
  u32 temp ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_recv_context *recv_ctx ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  {
  temp = 0U;
  recv_ctx = adapter->recv_ctx;
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 8U);
  if (tmp != 0) {
    return;
  } else {
  }
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___0) {
    *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
  } else {
    tmp___1 = qlcnic_sriov_vf_check(adapter);
    if ((int )tmp___1) {
      *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
    } else {
    }
  }
  tmp___2 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___2) {
    qlcnic_pf_set_interface_id_del_rx_ctx(adapter, & temp);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )recv_ctx->context_id | temp;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to destroy rx ctx in firmware\n");
  } else {
  }
  recv_ctx->state = 0U;
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
int qlcnic_83xx_create_rx_ctx(struct qlcnic_adapter *adapter )
{
  int i ;
  int err ;
  int index ;
  int sds_mbx_size ;
  int rds_mbx_size ;
  u8 num_sds ;
  u8 num_rds ;
  u32 *buf ;
  u32 intrpt_id ;
  u32 intr_mask ;
  u32 cap ;
  struct qlcnic_host_sds_ring *sds ;
  struct qlcnic_host_rds_ring *rds ;
  struct qlcnic_sds_mbx sds_mbx ;
  struct qlcnic_rds_mbx rds_mbx ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_rcv_mbx_out *mbx_out ;
  struct qlcnic_recv_context *recv_ctx ;
  struct qlcnic_hardware_context *ahw ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  cap = 0U;
  recv_ctx = adapter->recv_ctx;
  ahw = adapter->ahw;
  num_rds = adapter->max_rds_rings;
  if ((unsigned int )adapter->drv_sds_rings <= 8U) {
    num_sds = adapter->drv_sds_rings;
  } else {
    num_sds = 8U;
  }
  sds_mbx_size = 40;
  rds_mbx_size = 24;
  cap = 1U;
  if ((adapter->flags & 32768U) != 0U) {
    cap = cap | 131072U;
  } else {
  }
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 7U);
  if (err != 0) {
    return (err);
  } else {
  }
  tmp = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp) {
    *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
  } else {
    tmp___0 = qlcnic_sriov_vf_check(adapter);
    if ((int )tmp___0) {
      *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
    } else {
    }
  }
  *(cmd.req.arg + 1UL) = cap;
  *(cmd.req.arg + 5UL) = (u32 )((((int )num_rds << 5) | 1) | ((int )num_sds << 8));
  tmp___1 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___1) {
    qlcnic_pf_set_interface_id_create_rx_ctx(adapter, cmd.req.arg + 6UL);
  } else {
  }
  index = 8;
  i = 0;
  goto ldv_51874;
  ldv_51873:
  memset((void *)(& sds_mbx), 0, (size_t )sds_mbx_size);
  sds = recv_ctx->sds_rings + (unsigned long )i;
  sds->consumer = 0U;
  memset((void *)sds->desc_head, 0, (unsigned long )sds->num_desc * 16UL);
  sds_mbx.phy_addr_low = (unsigned int )sds->phys_addr;
  sds_mbx.phy_addr_high = (unsigned int )(sds->phys_addr >> 32ULL);
  sds_mbx.sds_ring_size = (u16 )sds->num_desc;
  if ((adapter->flags & 4U) != 0U) {
    intrpt_id = (u32 )(ahw->intr_tbl + (unsigned long )i)->id;
  } else {
    intrpt_id = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 10UL));
  }
  if ((unsigned int )(adapter->ahw)->diag_test != 2U) {
    sds_mbx.intrpt_id = (u16 )intrpt_id;
  } else {
    sds_mbx.intrpt_id = 65535U;
  }
  sds_mbx.intrpt_val = 0U;
  buf = cmd.req.arg + (unsigned long )index;
  __len = (size_t )sds_mbx_size;
  __ret = memcpy((void *)buf, (void const *)(& sds_mbx), __len);
  index = (int )((unsigned int )((unsigned long )sds_mbx_size / 4UL) + (unsigned int )index);
  i = i + 1;
  ldv_51874: ;
  if ((int )num_sds > i) {
    goto ldv_51873;
  } else {
  }
  index = 88;
  rds = recv_ctx->rds_rings;
  rds->producer = 0U;
  memset((void *)(& rds_mbx), 0, (size_t )rds_mbx_size);
  rds_mbx.phy_addr_reg_low = (unsigned int )rds->phys_addr;
  rds_mbx.phy_addr_reg_high = (unsigned int )(rds->phys_addr >> 32ULL);
  rds_mbx.reg_ring_sz = (u16 )rds->dma_size;
  rds_mbx.reg_ring_len = (u16 )rds->num_desc;
  rds = recv_ctx->rds_rings + 1UL;
  rds->producer = 0U;
  rds_mbx.phy_addr_jmb_low = (unsigned int )rds->phys_addr;
  rds_mbx.phy_addr_jmb_high = (unsigned int )(rds->phys_addr >> 32ULL);
  rds_mbx.jmb_ring_sz = (u16 )rds->dma_size;
  rds_mbx.jmb_ring_len = (u16 )rds->num_desc;
  buf = cmd.req.arg + (unsigned long )index;
  __len___0 = (size_t )rds_mbx_size;
  __ret___0 = memcpy((void *)buf, (void const *)(& rds_mbx), __len___0);
  err = (*((ahw->hw_ops)->mbx_cmd))(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to create Rx ctx in firmware%d\n",
            err);
    goto out;
  } else {
  }
  mbx_out = (struct qlcnic_rcv_mbx_out *)cmd.rsp.arg + 1U;
  recv_ctx->context_id = mbx_out->ctx_id;
  recv_ctx->state = (u32 )mbx_out->state;
  recv_ctx->virt_port = (u16 )mbx_out->vport_id;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Rx Context[%d] Created, state:0x%x\n",
            (int )recv_ctx->context_id, recv_ctx->state);
  rds = recv_ctx->rds_rings;
  rds->crb_rcv_producer = ahw->pci_base0 + (unsigned long )mbx_out->host_prod[0].reg_buf;
  rds = recv_ctx->rds_rings + 1UL;
  rds->crb_rcv_producer = ahw->pci_base0 + (unsigned long )mbx_out->host_prod[0].jmb_buf;
  i = 0;
  goto ldv_51881;
  ldv_51880:
  sds = recv_ctx->sds_rings + (unsigned long )i;
  sds->crb_sts_consumer = ahw->pci_base0 + (unsigned long )mbx_out->host_csmr[i];
  if ((adapter->flags & 4U) != 0U) {
    intr_mask = (ahw->intr_tbl + (unsigned long )i)->src;
  } else {
    intr_mask = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 9UL));
  }
  sds->crb_intr_mask = ahw->pci_base0 + (unsigned long )intr_mask;
  i = i + 1;
  ldv_51881: ;
  if ((int )num_sds > i) {
    goto ldv_51880;
  } else {
  }
  if ((unsigned int )adapter->drv_sds_rings > 8U) {
    err = qlcnic_83xx_add_rings(adapter);
  } else {
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
void qlcnic_83xx_del_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx_ring )
{
  struct qlcnic_cmd_args cmd ;
  u32 temp ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  temp = 0U;
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 10U);
  if (tmp != 0) {
    return;
  } else {
  }
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___0) {
    *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
  } else {
    tmp___1 = qlcnic_sriov_vf_check(adapter);
    if ((int )tmp___1) {
      *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
    } else {
    }
  }
  tmp___2 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___2) {
    qlcnic_pf_set_interface_id_del_tx_ctx(adapter, & temp);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )tx_ring->ctx_id | temp;
  tmp___3 = qlcnic_issue_cmd(adapter, & cmd);
  if (tmp___3 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to destroy tx ctx in firmware\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
int qlcnic_83xx_create_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_host_tx_ring *tx ,
                              int ring )
{
  int err ;
  u16 msix_id ;
  u32 *buf ;
  u32 intr_mask ;
  u32 temp ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_tx_mbx mbx ;
  struct qlcnic_tx_mbx_out *mbx_out ;
  struct qlcnic_hardware_context *ahw ;
  u32 msix_vector ;
  unsigned int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  size_t __len ;
  void *__ret ;
  {
  temp = 0U;
  ahw = adapter->ahw;
  tx->producer = 0U;
  tx->sw_consumer = 0U;
  *(tx->hw_consumer) = 0U;
  memset((void *)(& mbx), 0, 24UL);
  mbx.phys_addr_low = (unsigned int )tx->phys_addr;
  mbx.phys_addr_high = (unsigned int )(tx->phys_addr >> 32ULL);
  mbx.cnsmr_index_low = (unsigned int )tx->hw_cons_phys_addr;
  mbx.cnsmr_index_high = (unsigned int )(tx->hw_cons_phys_addr >> 32ULL);
  mbx.size = (u16 )tx->num_desc;
  if ((adapter->flags & 4U) != 0U) {
    if ((adapter->flags & 65536U) == 0U) {
      msix_vector = (u32 )((int )adapter->drv_sds_rings + ring);
    } else {
      msix_vector = (u32 )((int )adapter->drv_sds_rings + -1);
    }
    msix_id = (ahw->intr_tbl + (unsigned long )msix_vector)->id;
  } else {
    tmp = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 10UL));
    msix_id = (u16 )tmp;
  }
  if ((unsigned int )(adapter->ahw)->diag_test != 2U) {
    mbx.intr_id = msix_id;
  } else {
    mbx.intr_id = 65535U;
  }
  mbx.src = 0U;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 9U);
  if (err != 0) {
    return (err);
  } else {
  }
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___0) {
    *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
  } else {
    tmp___1 = qlcnic_sriov_vf_check(adapter);
    if ((int )tmp___1) {
      *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
    } else {
    }
  }
  tmp___2 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___2) {
    qlcnic_pf_set_interface_id_create_tx_ctx(adapter, & temp);
  } else {
  }
  *(cmd.req.arg + 1UL) = 1U;
  *(cmd.req.arg + 5UL) = temp | 1U;
  buf = cmd.req.arg + 6UL;
  __len = 24UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)buf, (void const *)(& mbx), __len);
  } else {
    __ret = memcpy((void *)buf, (void const *)(& mbx), __len);
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "Failed to create Tx ctx in firmware 0x%x\n",
               err);
    goto out;
  } else {
  }
  mbx_out = (struct qlcnic_tx_mbx_out *)cmd.rsp.arg + 2U;
  tx->crb_cmd_producer = ahw->pci_base0 + (unsigned long )mbx_out->host_prod;
  tx->ctx_id = mbx_out->ctx_id;
  if ((adapter->flags & 4U) != 0U && (adapter->flags & 65536U) == 0U) {
    intr_mask = (ahw->intr_tbl + (unsigned long )((int )adapter->drv_sds_rings + ring))->src;
    tx->crb_intr_mask = ahw->pci_base0 + (unsigned long )intr_mask;
  } else {
  }
  netdev_info((struct net_device const *)adapter->netdev, "Tx Context[0x%x] Created, state:0x%x\n",
              (int )tx->ctx_id, (int )mbx_out->state);
  out:
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_83xx_diag_alloc_res(struct net_device *netdev , int test , u8 num_sds_ring )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_host_sds_ring *sds_ring ;
  struct qlcnic_host_rds_ring *rds_ring ;
  u16 adapter_state ;
  u8 ring ;
  int ret ;
  bool tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  adapter_state = adapter->is_up;
  netif_device_detach(netdev);
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    __qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_detach(adapter);
  adapter->drv_sds_rings = 1U;
  (adapter->ahw)->diag_test = (u8 )test;
  (adapter->ahw)->linkup = 0U;
  ret = qlcnic_attach(adapter);
  if (ret != 0) {
    netif_device_attach(netdev);
    return (ret);
  } else {
  }
  ret = qlcnic_fw_create_ctx(adapter);
  if (ret != 0) {
    qlcnic_detach(adapter);
    if ((unsigned int )adapter_state == 777U) {
      adapter->drv_sds_rings = num_sds_ring;
      qlcnic_attach(adapter);
    } else {
    }
    netif_device_attach(netdev);
    return (ret);
  } else {
  }
  ring = 0U;
  goto ldv_51920;
  ldv_51919:
  rds_ring = (adapter->recv_ctx)->rds_rings + (unsigned long )ring;
  qlcnic_post_rx_buffers(adapter, rds_ring, (int )ring);
  ring = (u8 )((int )ring + 1);
  ldv_51920: ;
  if ((int )adapter->max_rds_rings > (int )ring) {
    goto ldv_51919;
  } else {
  }
  if ((unsigned int )(adapter->ahw)->diag_test == 1U) {
    ring = 0U;
    goto ldv_51923;
    ldv_51922:
    sds_ring = (adapter->recv_ctx)->sds_rings + (unsigned long )ring;
    qlcnic_enable_sds_intr(adapter, sds_ring);
    ring = (u8 )((int )ring + 1);
    ldv_51923: ;
    if ((int )adapter->drv_sds_rings > (int )ring) {
      goto ldv_51922;
    } else {
    }
  } else {
  }
  if ((unsigned int )(adapter->ahw)->diag_test == 2U) {
    (adapter->ahw)->loopback_state = 0U;
    (*(((adapter->ahw)->hw_ops)->setup_link_event))(adapter, 1);
  } else {
  }
  set_bit(1L, (unsigned long volatile *)(& adapter->state));
  return (0);
}
}
static void qlcnic_83xx_diag_free_res(struct net_device *netdev , u8 drv_sds_rings )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_host_sds_ring *sds_ring ;
  int ring ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  clear_bit(1L, (unsigned long volatile *)(& adapter->state));
  if ((unsigned int )(adapter->ahw)->diag_test == 1U) {
    ring = 0;
    goto ldv_51933;
    ldv_51932:
    sds_ring = (adapter->recv_ctx)->sds_rings + (unsigned long )ring;
    if ((adapter->flags & 4U) != 0U) {
      qlcnic_disable_sds_intr(adapter, sds_ring);
    } else {
    }
    ring = ring + 1;
    ldv_51933: ;
    if ((int )adapter->drv_sds_rings > ring) {
      goto ldv_51932;
    } else {
    }
  } else {
  }
  qlcnic_fw_destroy_ctx(adapter);
  qlcnic_detach(adapter);
  (adapter->ahw)->diag_test = 0U;
  adapter->drv_sds_rings = drv_sds_rings;
  tmp___0 = qlcnic_attach(adapter);
  if (tmp___0 != 0) {
    goto out;
  } else {
  }
  tmp___1 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___1) {
    __qlcnic_up(adapter, netdev);
  } else {
  }
  out:
  netif_device_attach(netdev);
  return;
}
}
static void qlcnic_83xx_get_beacon_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_cmd_args cmd ;
  u8 beacon_state ;
  int err ;
  {
  ahw = adapter->ahw;
  err = 0;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 106U);
  if (err == 0) {
    err = qlcnic_issue_cmd(adapter, & cmd);
    if (err == 0) {
      beacon_state = (u8 )*(cmd.rsp.arg + 4UL);
      if ((unsigned int )beacon_state == 13U) {
        ahw->beacon_state = 0U;
      } else
      if ((unsigned int )beacon_state == 14U) {
        ahw->beacon_state = 1U;
      } else {
      }
    } else {
    }
  } else {
    netdev_err((struct net_device const *)adapter->netdev, "Get beacon state failed, err=%d\n",
               err);
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
int qlcnic_83xx_config_led(struct qlcnic_adapter *adapter , u32 state , u32 beacon )
{
  struct qlcnic_cmd_args cmd ;
  u32 mbx_in ;
  int i ;
  int status ;
  {
  status = 0;
  if (state != 0U) {
    status = qlcnic_alloc_mbx_args(& cmd, adapter, 106U);
    if (status != 0) {
      return (status);
    } else {
    }
    status = qlcnic_issue_cmd(adapter, & cmd);
    if (status != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Get led config failed.\n");
      goto mbx_err;
    } else {
      i = 0;
      goto ldv_51954;
      ldv_51953:
      (adapter->ahw)->mbox_reg[i] = *(cmd.rsp.arg + ((unsigned long )i + 1UL));
      i = i + 1;
      ldv_51954: ;
      if (i <= 3) {
        goto ldv_51953;
      } else {
      }
    }
    qlcnic_free_mbx_args(& cmd);
    mbx_in = 83821823U;
    status = qlcnic_alloc_mbx_args(& cmd, adapter, 105U);
    if (status != 0) {
      return (status);
    } else {
    }
    *(cmd.req.arg + 1UL) = mbx_in;
    *(cmd.req.arg + 2UL) = mbx_in;
    *(cmd.req.arg + 3UL) = mbx_in;
    if (beacon != 0U) {
      *(cmd.req.arg + 4UL) = 14U;
    } else {
    }
    status = qlcnic_issue_cmd(adapter, & cmd);
    if (status != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Set led config failed.\n");
    } else {
    }
    mbx_err:
    qlcnic_free_mbx_args(& cmd);
    return (status);
  } else {
    status = qlcnic_alloc_mbx_args(& cmd, adapter, 105U);
    if (status != 0) {
      return (status);
    } else {
    }
    *(cmd.req.arg + 1UL) = (adapter->ahw)->mbox_reg[0];
    *(cmd.req.arg + 2UL) = (adapter->ahw)->mbox_reg[1];
    *(cmd.req.arg + 3UL) = (adapter->ahw)->mbox_reg[2];
    if (beacon != 0U) {
      *(cmd.req.arg + 4UL) = (adapter->ahw)->mbox_reg[3];
    } else {
    }
    status = qlcnic_issue_cmd(adapter, & cmd);
    if (status != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Restoring led config failed.\n");
    } else {
    }
    qlcnic_free_mbx_args(& cmd);
    return (status);
  }
}
}
int qlcnic_83xx_set_led(struct net_device *netdev , enum ethtool_phys_id_state state )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  int active ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = -5;
  active = 1;
  if ((unsigned int )(adapter->ahw)->op_mode == 2U) {
    netdev_warn((struct net_device const *)netdev, "LED test is not supported in non-privileged mode\n");
    return (-95);
  } else {
  }
  switch ((unsigned int )state) {
  case 1U:
  tmp___0 = test_and_set_bit(7L, (unsigned long volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    return (-16);
  } else {
  }
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___1 != 0) {
    goto ldv_51964;
  } else {
  }
  err = qlcnic_83xx_config_led(adapter, (u32 )active, 0U);
  if (err != 0) {
    netdev_err((struct net_device const *)netdev, "Failed to set LED blink state\n");
  } else {
  }
  goto ldv_51964;
  case 0U:
  active = 0;
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___2 != 0) {
    goto ldv_51964;
  } else {
  }
  err = qlcnic_83xx_config_led(adapter, (u32 )active, 0U);
  if (err != 0) {
    netdev_err((struct net_device const *)netdev, "Failed to reset LED blink state\n");
  } else {
  }
  goto ldv_51964;
  default: ;
  return (-22);
  }
  ldv_51964: ;
  if (active == 0 || err != 0) {
    clear_bit(7L, (unsigned long volatile *)(& adapter->state));
  } else {
  }
  return (err);
}
}
void qlcnic_83xx_initialize_nic(struct qlcnic_adapter *adapter , int enable )
{
  struct qlcnic_cmd_args cmd ;
  int status ;
  bool tmp ;
  {
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    return;
  } else {
  }
  if (enable != 0) {
    status = qlcnic_alloc_mbx_args(& cmd, adapter, 96U);
  } else {
    status = qlcnic_alloc_mbx_args(& cmd, adapter, 97U);
  }
  if (status != 0) {
    return;
  } else {
  }
  *(cmd.req.arg + 1UL) = 2147483649U;
  if ((unsigned long )adapter->dcb != (unsigned long )((struct qlcnic_dcb *)0)) {
    *(cmd.req.arg + 1UL) = *(cmd.req.arg + 1UL) | 2U;
  } else {
  }
  status = qlcnic_issue_cmd(adapter, & cmd);
  if (status != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to %s in NIC IDC function event.\n",
            enable != 0 ? (char *)"register" : (char *)"unregister");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
static int qlcnic_83xx_set_port_config(struct qlcnic_adapter *adapter )
{
  struct qlcnic_cmd_args cmd ;
  int err ;
  {
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 102U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = (adapter->ahw)->port_config;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Set Port Config failed.\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_83xx_get_port_config(struct qlcnic_adapter *adapter )
{
  struct qlcnic_cmd_args cmd ;
  int err ;
  {
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 103U);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Get Port config failed\n");
  } else {
    (adapter->ahw)->port_config = *(cmd.rsp.arg + 1UL);
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_83xx_setup_link_event(struct qlcnic_adapter *adapter , int enable )
{
  int err ;
  u32 temp ;
  struct qlcnic_cmd_args cmd ;
  {
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 72U);
  if (err != 0) {
    return (err);
  } else {
  }
  temp = (u32 )((int )(adapter->recv_ctx)->context_id << 16);
  *(cmd.req.arg + 1UL) = (enable != 0 ? 257U : 256U) | temp;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Setup linkevent mailbox failed\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static void qlcnic_83xx_set_interface_id_promisc(struct qlcnic_adapter *adapter ,
                                                 u32 *interface_id )
{
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  tmp___1 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___1) {
    qlcnic_alloc_lb_filters_mem(adapter);
    qlcnic_pf_set_interface_id_promisc(adapter, interface_id);
    adapter->rx_mac_learn = 1;
  } else {
    tmp = qlcnic_sriov_vf_check(adapter);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      *interface_id = (u32 )((int )(adapter->recv_ctx)->context_id << 16);
    } else {
    }
  }
  return;
}
}
int qlcnic_83xx_nic_set_promisc(struct qlcnic_adapter *adapter , u32 mode )
{
  struct qlcnic_cmd_args *cmd ;
  u32 temp ;
  int err ;
  void *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  cmd = (struct qlcnic_cmd_args *)0;
  temp = 0U;
  if ((adapter->recv_ctx)->state == 0U) {
    return (-5);
  } else {
  }
  tmp = kzalloc(200UL, 32U);
  cmd = (struct qlcnic_cmd_args *)tmp;
  if ((unsigned long )cmd == (unsigned long )((struct qlcnic_cmd_args *)0)) {
    return (-12);
  } else {
  }
  err = qlcnic_alloc_mbx_args(cmd, adapter, 73U);
  if (err != 0) {
    goto out;
  } else {
  }
  cmd->type = 1U;
  qlcnic_83xx_set_interface_id_promisc(adapter, & temp);
  tmp___0 = qlcnic_84xx_check(adapter);
  if ((int )tmp___0) {
    tmp___1 = qlcnic_sriov_pf_check(adapter);
    if ((int )tmp___1) {
      mode = 1U;
    } else {
    }
  } else {
  }
  *(cmd->req.arg + 1UL) = mode | temp;
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err == 0) {
    return (err);
  } else {
  }
  qlcnic_free_mbx_args(cmd);
  out:
  kfree((void const *)cmd);
  return (err);
}
}
int qlcnic_83xx_loopback_test(struct net_device *netdev , u8 mode )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  u8 drv_sds_rings ;
  u8 drv_tx_rings ;
  int ret ;
  int loop ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  drv_sds_rings = adapter->drv_sds_rings;
  drv_tx_rings = adapter->drv_tx_rings;
  ret = 0;
  loop = 0;
  if ((unsigned int )ahw->op_mode == 2U) {
    netdev_warn((struct net_device const *)netdev, "Loopback test not supported in non privileged mode\n");
    return (-524);
  } else {
  }
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    netdev_info((struct net_device const *)netdev, "Device is resetting\n");
    return (-16);
  } else {
  }
  tmp___1 = qlcnic_get_diag_lock(adapter);
  if (tmp___1 != 0) {
    netdev_info((struct net_device const *)netdev, "Device is in diagnostics mode\n");
    return (-16);
  } else {
  }
  netdev_info((struct net_device const *)netdev, "%s loopback test in progress\n",
              (unsigned int )mode == 1U ? (char *)"internal" : (char *)"external");
  ret = qlcnic_83xx_diag_alloc_res(netdev, 2, (int )drv_sds_rings);
  if (ret != 0) {
    goto fail_diag_alloc;
  } else {
  }
  ret = qlcnic_83xx_set_lb_mode(adapter, (int )mode);
  if (ret != 0) {
    goto free_diag_res;
  } else {
  }
  ldv_52014:
  msleep(20U);
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___2 != 0) {
    netdev_info((struct net_device const *)netdev, "Device is resetting, free LB test resources\n");
    ret = -16;
    goto free_diag_res;
  } else {
  }
  tmp___3 = loop;
  loop = loop + 1;
  if (tmp___3 > 250) {
    netdev_info((struct net_device const *)netdev, "Firmware didn\'t sent link up event to loopback request\n");
    ret = -110;
    qlcnic_83xx_clear_lb_mode(adapter, (int )mode);
    goto free_diag_res;
  } else {
  }
  if (((unsigned int )(adapter->ahw)->linkup != 0U && (unsigned int )ahw->has_link_events != 0U) != 1) {
    goto ldv_52014;
  } else {
  }
  ret = qlcnic_do_lb_test(adapter, (int )mode);
  qlcnic_83xx_clear_lb_mode(adapter, (int )mode);
  free_diag_res:
  qlcnic_83xx_diag_free_res(netdev, (int )drv_sds_rings);
  fail_diag_alloc:
  adapter->drv_sds_rings = drv_sds_rings;
  adapter->drv_tx_rings = drv_tx_rings;
  qlcnic_release_diag_lock(adapter);
  return (ret);
}
}
static void qlcnic_extend_lb_idc_cmpltn_wait(struct qlcnic_adapter *adapter , u32 *max_wait_count )
{
  struct qlcnic_hardware_context *ahw ;
  int temp ;
  {
  ahw = adapter->ahw;
  netdev_info((struct net_device const *)adapter->netdev, "Received loopback IDC time extend event for 0x%x seconds\n",
              (int )ahw->extend_lb_time);
  temp = (int )ahw->extend_lb_time * 1000;
  *max_wait_count = *max_wait_count + (u32 )(temp / 20);
  ahw->extend_lb_time = 0U;
  return;
}
}
static int qlcnic_83xx_set_lb_mode(struct qlcnic_adapter *adapter , u8 mode )
{
  struct qlcnic_hardware_context *ahw ;
  struct net_device *netdev ;
  u32 config ;
  u32 max_wait_count ;
  int status ;
  int loop ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  ahw = adapter->ahw;
  netdev = adapter->netdev;
  status = 0;
  loop = 0;
  ahw->extend_lb_time = 0U;
  max_wait_count = 250U;
  status = qlcnic_83xx_get_port_config(adapter);
  if (status != 0) {
    return (status);
  } else {
  }
  config = ahw->port_config;
  if ((config & 4U) != 0U || (config & 8U) != 0U) {
    netdev_err((struct net_device const *)netdev, "Port already in Loopback mode.\n");
    return (-115);
  } else {
  }
  set_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
  if ((unsigned int )mode == 1U) {
    ahw->port_config = ahw->port_config | 4U;
  } else {
  }
  if ((unsigned int )mode == 2U) {
    ahw->port_config = ahw->port_config | 8U;
  } else {
  }
  status = qlcnic_83xx_set_port_config(adapter);
  if (status != 0) {
    netdev_err((struct net_device const *)netdev, "Failed to Set Loopback Mode = 0x%x.\n",
               ahw->port_config);
    ahw->port_config = config;
    clear_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
    return (status);
  } else {
  }
  ldv_52033:
  msleep(20U);
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    netdev_info((struct net_device const *)netdev, "Device is resetting, free LB test resources\n");
    clear_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
    return (-16);
  } else {
  }
  if ((unsigned int )ahw->extend_lb_time != 0U) {
    qlcnic_extend_lb_idc_cmpltn_wait(adapter, & max_wait_count);
  } else {
  }
  tmp___0 = loop;
  loop = loop + 1;
  if ((u32 )tmp___0 > max_wait_count) {
    netdev_err((struct net_device const *)netdev, "%s: Did not receive loopback IDC completion AEN\n",
               "qlcnic_83xx_set_lb_mode");
    clear_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
    qlcnic_83xx_clear_lb_mode(adapter, (int )mode);
    return (-110);
  } else {
  }
  tmp___1 = constant_test_bit(3L, (unsigned long const volatile *)(& ahw->idc.status));
  if (tmp___1 != 0) {
    goto ldv_52033;
  } else {
  }
  qlcnic_sre_macaddr_change(adapter, (u8 *)(& adapter->mac_addr), 0, 1);
  return (status);
}
}
static int qlcnic_83xx_clear_lb_mode(struct qlcnic_adapter *adapter , u8 mode )
{
  struct qlcnic_hardware_context *ahw ;
  u32 config ;
  u32 max_wait_count ;
  struct net_device *netdev ;
  int status ;
  int loop ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  ahw = adapter->ahw;
  config = ahw->port_config;
  netdev = adapter->netdev;
  status = 0;
  loop = 0;
  ahw->extend_lb_time = 0U;
  max_wait_count = 250U;
  set_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
  if ((unsigned int )mode == 1U) {
    ahw->port_config = ahw->port_config & 4294967291U;
  } else {
  }
  if ((unsigned int )mode == 2U) {
    ahw->port_config = ahw->port_config & 4294967287U;
  } else {
  }
  status = qlcnic_83xx_set_port_config(adapter);
  if (status != 0) {
    netdev_err((struct net_device const *)netdev, "Failed to Clear Loopback Mode = 0x%x.\n",
               ahw->port_config);
    ahw->port_config = config;
    clear_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
    return (status);
  } else {
  }
  ldv_52046:
  msleep(20U);
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    netdev_info((struct net_device const *)netdev, "Device is resetting, free LB test resources\n");
    clear_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
    return (-16);
  } else {
  }
  if ((unsigned int )ahw->extend_lb_time != 0U) {
    qlcnic_extend_lb_idc_cmpltn_wait(adapter, & max_wait_count);
  } else {
  }
  tmp___0 = loop;
  loop = loop + 1;
  if ((u32 )tmp___0 > max_wait_count) {
    netdev_err((struct net_device const *)netdev, "%s: Did not receive loopback IDC completion AEN\n",
               "qlcnic_83xx_clear_lb_mode");
    clear_bit(3L, (unsigned long volatile *)(& ahw->idc.status));
    return (-110);
  } else {
  }
  tmp___1 = constant_test_bit(3L, (unsigned long const volatile *)(& ahw->idc.status));
  if (tmp___1 != 0) {
    goto ldv_52046;
  } else {
  }
  qlcnic_sre_macaddr_change(adapter, (u8 *)(& adapter->mac_addr), 0, 2);
  return (status);
}
}
static void qlcnic_83xx_set_interface_id_ipaddr(struct qlcnic_adapter *adapter , u32 *interface_id )
{
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  tmp___1 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___1) {
    qlcnic_pf_set_interface_id_ipaddr(adapter, interface_id);
  } else {
    tmp = qlcnic_sriov_vf_check(adapter);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      *interface_id = (u32 )((int )(adapter->recv_ctx)->context_id << 16);
    } else {
    }
  }
  return;
}
}
void qlcnic_83xx_config_ipaddr(struct qlcnic_adapter *adapter , __be32 ip , int mode )
{
  int err ;
  u32 temp ;
  u32 temp_ip ;
  struct qlcnic_cmd_args cmd ;
  __u32 tmp ;
  __u32 tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  temp = 0U;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 1U);
  if (err != 0) {
    return;
  } else {
  }
  qlcnic_83xx_set_interface_id_ipaddr(adapter, & temp);
  if (mode == 2) {
    *(cmd.req.arg + 1UL) = temp | 1U;
  } else {
    *(cmd.req.arg + 1UL) = temp | 2U;
  }
  tmp = __fswab32(ip);
  tmp___0 = __fswab32(tmp);
  temp_ip = tmp___0;
  __len = 4UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)cmd.req.arg + 2U, (void const *)(& temp_ip), __len);
  } else {
    __ret = memcpy((void *)cmd.req.arg + 2U, (void const *)(& temp_ip),
                             __len);
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->netdev)->dev), "could not notify %s IP 0x%x request\n",
            mode == 2 ? (char *)"Add" : (char *)"Remove", ip);
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
int qlcnic_83xx_config_hw_lro(struct qlcnic_adapter *adapter , int mode )
{
  int err ;
  u32 temp ;
  u32 arg1 ;
  struct qlcnic_cmd_args cmd ;
  int lro_bit_mask ;
  {
  lro_bit_mask = mode != 0 ? 15 : 0;
  if ((adapter->recv_ctx)->state == 0U) {
    return (0);
  } else {
  }
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 74U);
  if (err != 0) {
    return (err);
  } else {
  }
  temp = (u32 )((int )(adapter->recv_ctx)->context_id << 16);
  arg1 = (u32 )lro_bit_mask | temp;
  *(cmd.req.arg + 1UL) = arg1;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "LRO config failed\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_83xx_config_rss(struct qlcnic_adapter *adapter , int enable )
{
  int err ;
  u32 word ;
  struct qlcnic_cmd_args cmd ;
  u64 key[5U] ;
  size_t __len ;
  void *__ret ;
  {
  key[0] = 0xbeac01fa6a42b73bULL;
  key[1] = 0x8030f20c77cb2da3ULL;
  key[2] = 0xae7b30b4d0ca2bcbULL;
  key[3] = 4873897208919303485ULL;
  key[4] = 2691761430505084634ULL;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 65U);
  if (err != 0) {
    return (err);
  } else {
  }
  word = (((unsigned int )enable & 1U) << 8) | 458992U;
  *(cmd.req.arg + 1UL) = (u32 )(adapter->recv_ctx)->context_id;
  *(cmd.req.arg + 2UL) = word;
  __len = 40UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)cmd.req.arg + 4U, (void const *)(& key), __len);
  } else {
    __ret = memcpy((void *)cmd.req.arg + 4U, (void const *)(& key), __len);
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "RSS config failed\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static void qlcnic_83xx_set_interface_id_macaddr(struct qlcnic_adapter *adapter ,
                                                 u32 *interface_id )
{
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  tmp___1 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___1) {
    qlcnic_pf_set_interface_id_macaddr(adapter, interface_id);
  } else {
    tmp = qlcnic_sriov_vf_check(adapter);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      *interface_id = (u32 )((int )(adapter->recv_ctx)->context_id << 16);
    } else {
    }
  }
  return;
}
}
int qlcnic_83xx_sre_macaddr_change(struct qlcnic_adapter *adapter , u8 *addr , u16 vlan_id ,
                                   u8 op )
{
  struct qlcnic_cmd_args *cmd ;
  struct qlcnic_macvlan_mbx mv ;
  u32 *buf ;
  u32 temp ;
  int err ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  {
  cmd = (struct qlcnic_cmd_args *)0;
  temp = 0U;
  if ((adapter->recv_ctx)->state == 0U) {
    return (-5);
  } else {
  }
  tmp = kzalloc(200UL, 32U);
  cmd = (struct qlcnic_cmd_args *)tmp;
  if ((unsigned long )cmd == (unsigned long )((struct qlcnic_cmd_args *)0)) {
    return (-12);
  } else {
  }
  err = qlcnic_alloc_mbx_args(cmd, adapter, 69U);
  if (err != 0) {
    goto out;
  } else {
  }
  cmd->type = 1U;
  if ((unsigned int )vlan_id != 0U) {
    op = (unsigned int )op == 1U || (unsigned int )op == 3U ? 3U : 4U;
  } else {
  }
  *(cmd->req.arg + 1UL) = (u32 )((int )op | 256);
  qlcnic_83xx_set_interface_id_macaddr(adapter, & temp);
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | temp;
  mv.vlan = vlan_id;
  mv.mac_addr0 = *addr;
  mv.mac_addr1 = *(addr + 1UL);
  mv.mac_addr2 = *(addr + 2UL);
  mv.mac_addr3 = *(addr + 3UL);
  mv.mac_addr4 = *(addr + 4UL);
  mv.mac_addr5 = *(addr + 5UL);
  buf = cmd->req.arg + 2UL;
  __len = 8UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)buf, (void const *)(& mv), __len);
  } else {
    __ret = memcpy((void *)buf, (void const *)(& mv), __len);
  }
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err == 0) {
    return (err);
  } else {
  }
  qlcnic_free_mbx_args(cmd);
  out:
  kfree((void const *)cmd);
  return (err);
}
}
void qlcnic_83xx_change_l2_filter(struct qlcnic_adapter *adapter , u64 *addr , u16 vlan_id )
{
  u8 mac[6U] ;
  size_t __len ;
  void *__ret ;
  {
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& mac), (void const *)addr, __len);
  } else {
    __ret = memcpy((void *)(& mac), (void const *)addr, __len);
  }
  qlcnic_83xx_sre_macaddr_change(adapter, (u8 *)(& mac), (int )vlan_id, 1);
  return;
}
}
static void qlcnic_83xx_configure_mac(struct qlcnic_adapter *adapter , u8 *mac , u8 type ,
                                      struct qlcnic_cmd_args *cmd )
{
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  switch ((int )type) {
  case 2: ;
  case 5:
  __len = 4UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)cmd->req.arg + 2U, (void const *)mac, __len);
  } else {
    __ret = memcpy((void *)cmd->req.arg + 2U, (void const *)mac, __len);
  }
  __len___0 = 2UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)cmd->req.arg + 3U, (void const *)mac + 4U, __len___0);
  } else {
    __ret___0 = memcpy((void *)cmd->req.arg + 3U, (void const *)mac + 4U,
                                 __len___0);
  }
  goto ldv_52126;
  }
  ldv_52126:
  *(cmd->req.arg + 1UL) = (u32 )type;
  return;
}
}
int qlcnic_83xx_get_mac_address(struct qlcnic_adapter *adapter , u8 *mac , u8 function )
{
  int err ;
  int i ;
  struct qlcnic_cmd_args cmd ;
  u32 mac_low ;
  u32 mac_high ;
  {
  function = 0U;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 31U);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_83xx_configure_mac(adapter, mac, 1, & cmd);
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err == 0) {
    mac_low = *(cmd.rsp.arg + 1UL);
    mac_high = *(cmd.rsp.arg + 2UL);
    i = 0;
    goto ldv_52138;
    ldv_52137:
    *(mac + (unsigned long )i) = (unsigned char )(mac_high >> (i * -8 + 8));
    i = i + 1;
    ldv_52138: ;
    if (i <= 1) {
      goto ldv_52137;
    } else {
    }
    i = 2;
    goto ldv_52141;
    ldv_52140:
    *(mac + (unsigned long )i) = (unsigned char )(mac_low >> (5 - i) * 8);
    i = i + 1;
    ldv_52141: ;
    if (i <= 5) {
      goto ldv_52140;
    } else {
    }
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get mac address%d\n",
            err);
    err = -5;
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_83xx_set_rx_intr_coal(struct qlcnic_adapter *adapter )
{
  struct qlcnic_nic_intr_coalesce *coal ;
  struct qlcnic_cmd_args cmd ;
  u16 temp ;
  int err ;
  {
  coal = & (adapter->ahw)->coal;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 67U);
  if (err != 0) {
    return (err);
  } else {
  }
  temp = (adapter->recv_ctx)->context_id;
  *(cmd.req.arg + 1UL) = (u32 )(((int )temp << 16) | 1);
  temp = coal->rx_time_us;
  *(cmd.req.arg + 2UL) = (u32 )((int )coal->rx_packets | ((int )temp << 16));
  *(cmd.req.arg + 3UL) = (u32 )coal->flag;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "failed to set interrupt coalescing parameters\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_83xx_set_tx_intr_coal(struct qlcnic_adapter *adapter )
{
  struct qlcnic_nic_intr_coalesce *coal ;
  struct qlcnic_cmd_args cmd ;
  u16 temp ;
  int err ;
  {
  coal = & (adapter->ahw)->coal;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 67U);
  if (err != 0) {
    return (err);
  } else {
  }
  temp = (adapter->tx_ring)->ctx_id;
  *(cmd.req.arg + 1UL) = (u32 )(((int )temp << 16) | 2);
  temp = coal->tx_time_us;
  *(cmd.req.arg + 2UL) = (u32 )((int )coal->tx_packets | ((int )temp << 16));
  *(cmd.req.arg + 3UL) = (u32 )coal->flag;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "failed to set interrupt coalescing  parameters\n");
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_83xx_set_rx_tx_intr_coal(struct qlcnic_adapter *adapter )
{
  int err ;
  {
  err = 0;
  err = qlcnic_83xx_set_rx_intr_coal(adapter);
  if (err != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "failed to set Rx coalescing parameters\n");
  } else {
  }
  err = qlcnic_83xx_set_tx_intr_coal(adapter);
  if (err != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "failed to set Tx coalescing parameters\n");
  } else {
  }
  return (err);
}
}
int qlcnic_83xx_config_intr_coal(struct qlcnic_adapter *adapter , struct ethtool_coalesce *ethcoal )
{
  struct qlcnic_nic_intr_coalesce *coal ;
  u32 rx_coalesce_usecs ;
  u32 rx_max_frames ;
  u32 tx_coalesce_usecs ;
  u32 tx_max_frames ;
  int err ;
  {
  coal = & (adapter->ahw)->coal;
  if ((adapter->recv_ctx)->state == 0U) {
    return (-5);
  } else {
  }
  tx_coalesce_usecs = ethcoal->tx_coalesce_usecs;
  tx_max_frames = ethcoal->tx_max_coalesced_frames;
  rx_coalesce_usecs = ethcoal->rx_coalesce_usecs;
  rx_max_frames = ethcoal->rx_max_coalesced_frames;
  coal->flag = 4U;
  if ((u32 )coal->rx_time_us == rx_coalesce_usecs && (u32 )coal->rx_packets == rx_max_frames) {
    coal->type = 2U;
    coal->tx_time_us = (u16 )tx_coalesce_usecs;
    coal->tx_packets = (u16 )tx_max_frames;
  } else
  if ((u32 )coal->tx_time_us == tx_coalesce_usecs && (u32 )coal->tx_packets == tx_max_frames) {
    coal->type = 1U;
    coal->rx_time_us = (u16 )rx_coalesce_usecs;
    coal->rx_packets = (u16 )rx_max_frames;
  } else {
    coal->type = 3U;
    coal->rx_time_us = (u16 )rx_coalesce_usecs;
    coal->rx_packets = (u16 )rx_max_frames;
    coal->tx_time_us = (u16 )tx_coalesce_usecs;
    coal->tx_packets = (u16 )tx_max_frames;
  }
  switch ((int )coal->type) {
  case 1:
  err = qlcnic_83xx_set_rx_intr_coal(adapter);
  goto ldv_52172;
  case 2:
  err = qlcnic_83xx_set_tx_intr_coal(adapter);
  goto ldv_52172;
  case 3:
  err = qlcnic_83xx_set_rx_tx_intr_coal(adapter);
  goto ldv_52172;
  default:
  err = -22;
  netdev_err((struct net_device const *)adapter->netdev, "Invalid Interrupt coalescing type\n");
  goto ldv_52172;
  }
  ldv_52172: ;
  return (err);
}
}
static void qlcnic_83xx_handle_link_aen(struct qlcnic_adapter *adapter , u32 *data )
{
  struct qlcnic_hardware_context *ahw ;
  u8 link_status ;
  u8 duplex ;
  {
  ahw = adapter->ahw;
  link_status = (unsigned int )((u8 )*(data + 3UL)) & 1U;
  if ((unsigned int )link_status != 0U) {
    ahw->link_speed = (unsigned short )(*(data + 2UL) >> 16);
    duplex = (unsigned char )(*(data + 3UL) >> 16);
    if ((unsigned int )duplex != 0U) {
      ahw->link_duplex = 1U;
    } else {
      ahw->link_duplex = 0U;
    }
  } else {
    ahw->link_speed = 65535U;
    ahw->link_duplex = 255U;
  }
  ahw->link_autoneg = (u16 )((unsigned char )((int )((unsigned short )(*(data + 3UL) >> 16)) >> 8));
  ahw->module_type = (u16 )((unsigned char )((int )((unsigned short )*(data + 3UL)) >> 8));
  ahw->has_link_events = 1U;
  ahw->lb_mode = (unsigned int )((u8 )*(data + 4UL)) & 3U;
  qlcnic_advert_link_change(adapter, (int )link_status);
  return;
}
}
static irqreturn_t qlcnic_83xx_handle_aen(int irq , void *data )
{
  struct qlcnic_adapter *adapter ;
  struct qlcnic_mailbox *mbx ;
  u32 mask ;
  u32 resp ;
  u32 event ;
  unsigned long flags ;
  {
  adapter = (struct qlcnic_adapter *)data;
  mbx = (adapter->ahw)->mailbox;
  ldv_spin_lock();
  resp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 4UL));
  if ((resp & 1U) == 0U) {
    goto out;
  } else {
  }
  event = readl((void const volatile *)(adapter->ahw)->pci_base0 + 2048U);
  if ((event & 32768U) != 0U) {
    __qlcnic_83xx_process_aen(adapter);
  } else {
    qlcnic_83xx_notify_mbx_response(mbx);
  }
  out:
  mask = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 9UL));
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )mask);
  spin_unlock_irqrestore(& mbx->aen_lock, flags);
  return (1);
}
}
int qlcnic_83xx_set_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *nic )
{
  int i ;
  int err ;
  struct qlcnic_cmd_args cmd ;
  {
  err = -5;
  if ((unsigned int )(adapter->ahw)->op_mode != 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Error, invoked by non management func\n",
            "qlcnic_83xx_set_nic_info");
    return (err);
  } else {
  }
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 34U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )((int )nic->pci_func << 16);
  *(cmd.req.arg + 2UL) = 65536U;
  *(cmd.req.arg + 3UL) = (u32 )((int )nic->phys_port | ((int )nic->switch_mode << 16));
  *(cmd.req.arg + 4UL) = nic->capabilities;
  *(cmd.req.arg + 5UL) = (u32 )((int )nic->max_mac_filters | ((int )nic->max_mtu << 16));
  *(cmd.req.arg + 6UL) = (u32 )((int )nic->max_tx_ques | ((int )nic->max_rx_ques << 16));
  *(cmd.req.arg + 7UL) = (u32 )((int )nic->min_tx_bw | ((int )nic->max_tx_bw << 16));
  i = 8;
  goto ldv_52203;
  ldv_52202:
  *(cmd.req.arg + (unsigned long )i) = 0U;
  i = i + 1;
  ldv_52203: ;
  if (i <= 31) {
    goto ldv_52202;
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to set nic info%d\n",
            err);
    err = -5;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_83xx_get_nic_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info ,
                             u8 func_id )
{
  int err ;
  u32 temp ;
  u8 op ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_hardware_context *ahw ;
  size_t __len ;
  void *__ret ;
  {
  op = 0U;
  ahw = adapter->ahw;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 33U);
  if (err != 0) {
    return (err);
  } else {
  }
  if ((int )ahw->pci_func != (int )func_id) {
    temp = (u32 )((int )func_id << 16);
    *(cmd.req.arg + 1UL) = ((unsigned int )op | temp) | 2147483648U;
  } else {
    *(cmd.req.arg + 1UL) = (u32 )((int )ahw->pci_func << 16);
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Failed to get nic info %d\n",
              err);
    goto out;
  } else {
  }
  npar_info->op_type = *(cmd.rsp.arg + 1UL);
  npar_info->pci_func = (u16 )*(cmd.rsp.arg + 2UL);
  npar_info->op_mode = (u16 )(*(cmd.rsp.arg + 2UL) >> 16);
  npar_info->phys_port = (u16 )*(cmd.rsp.arg + 3UL);
  npar_info->switch_mode = (u16 )(*(cmd.rsp.arg + 3UL) >> 16);
  npar_info->capabilities = *(cmd.rsp.arg + 4UL);
  npar_info->max_mac_filters = (u8 )*(cmd.rsp.arg + 5UL);
  npar_info->max_mtu = (u16 )(*(cmd.rsp.arg + 5UL) >> 16);
  npar_info->max_tx_ques = (u16 )*(cmd.rsp.arg + 6UL);
  npar_info->max_rx_ques = (u16 )(*(cmd.rsp.arg + 6UL) >> 16);
  npar_info->min_tx_bw = (u16 )*(cmd.rsp.arg + 7UL);
  npar_info->max_tx_bw = (u16 )(*(cmd.rsp.arg + 7UL) >> 16);
  if ((int )*(cmd.rsp.arg + 8UL) & 1) {
    npar_info->max_bw_reg_offset = (u16 )((*(cmd.rsp.arg + 8UL) & 32766U) >> 1);
  } else {
  }
  if ((*(cmd.rsp.arg + 8UL) & 65536U) != 0U) {
    temp = (*(cmd.rsp.arg + 8UL) & 2147352576U) >> 17;
    npar_info->max_linkspeed_reg_offset = (u16 )temp;
  } else {
  }
  __len = 12UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& ahw->extra_capability), (void const *)cmd.rsp.arg + 16U,
                     __len);
  } else {
    __ret = memcpy((void *)(& ahw->extra_capability), (void const *)cmd.rsp.arg + 16U,
                             __len);
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_get_pci_func_type(struct qlcnic_adapter *adapter , u16 type , u16 *nic ,
                             u16 *fcoe , u16 *iscsi )
{
  struct device *dev ;
  int err ;
  {
  dev = & (adapter->pdev)->dev;
  err = 0;
  switch ((int )type) {
  case 1:
  *nic = (u16 )((int )*nic + 1);
  goto ldv_52229;
  case 2:
  *fcoe = (u16 )((int )*fcoe + 1);
  goto ldv_52229;
  case 3:
  *iscsi = (u16 )((int )*iscsi + 1);
  goto ldv_52229;
  default:
  dev_err((struct device const *)dev, "%s: Unknown PCI type[%x]\n", "qlcnic_get_pci_func_type",
          (int )type);
  err = -5;
  }
  ldv_52229: ;
  return (err);
}
}
int qlcnic_83xx_get_pci_info(struct qlcnic_adapter *adapter , struct qlcnic_pci_info *pci_info )
{
  struct qlcnic_hardware_context *ahw ;
  struct device *dev ;
  u16 nic ;
  u16 fcoe ;
  u16 iscsi ;
  struct qlcnic_cmd_args cmd ;
  int i ;
  int err ;
  int j ;
  u32 temp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  ahw = adapter->ahw;
  dev = & (adapter->pdev)->dev;
  nic = 0U;
  fcoe = 0U;
  iscsi = 0U;
  err = 0;
  j = 0;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 32U);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  ahw->total_nic_func = 0U;
  if (err == 0) {
    ahw->max_pci_func = (unsigned int )((u16 )*(cmd.rsp.arg + 1UL)) & 255U;
    i = 2;
    j = 0;
    goto ldv_52256;
    ldv_52255:
    pci_info->id = (u16 )*(cmd.rsp.arg + (unsigned long )i);
    pci_info->active = (u16 )(*(cmd.rsp.arg + (unsigned long )i) >> 16);
    i = i + 1;
    if ((unsigned int )pci_info->active == 0U) {
      i = i + 7;
      goto ldv_52248;
    } else {
    }
    pci_info->type = (u16 )*(cmd.rsp.arg + (unsigned long )i);
    err = qlcnic_get_pci_func_type(adapter, (int )pci_info->type, & nic, & fcoe, & iscsi);
    temp = *(cmd.rsp.arg + (unsigned long )i) >> 16;
    pci_info->default_port = (u16 )temp;
    i = i + 1;
    pci_info->tx_min_bw = (u16 )*(cmd.rsp.arg + (unsigned long )i);
    temp = *(cmd.rsp.arg + (unsigned long )i) >> 16;
    pci_info->tx_max_bw = (u16 )temp;
    i = i + 2;
    __len = 4UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& pci_info->mac), (void const *)cmd.rsp.arg + (unsigned long )i,
                       __len);
    } else {
      __ret = memcpy((void *)(& pci_info->mac), (void const *)cmd.rsp.arg + (unsigned long )i,
                               __len);
    }
    i = i + 1;
    __len___0 = 2UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& pci_info->mac) + 4U, (void const *)cmd.rsp.arg + (unsigned long )i,
                           __len___0);
    } else {
      __ret___0 = memcpy((void *)(& pci_info->mac) + 4U, (void const *)cmd.rsp.arg + (unsigned long )i,
                                   __len___0);
    }
    i = i + 3;
    ldv_52248:
    j = j + 1;
    pci_info = pci_info + 1;
    ldv_52256: ;
    if ((u32 )j < ahw->max_vnic_func) {
      goto ldv_52255;
    } else {
    }
  } else {
    dev_err((struct device const *)dev, "Failed to get PCI Info, error = %d\n",
            err);
    err = -5;
  }
  ahw->total_nic_func = nic;
  ahw->total_pci_func = (u32 )(((int )nic + (int )fcoe) + (int )iscsi);
  if ((unsigned int )ahw->total_nic_func == 0U || ahw->total_pci_func == 0U) {
    dev_err((struct device const *)dev, "%s: Invalid function count: total nic func[%x], total pci func[%x]\n",
            "qlcnic_83xx_get_pci_info", (int )ahw->total_nic_func, ahw->total_pci_func);
    err = -5;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_83xx_config_intrpt(struct qlcnic_adapter *adapter , bool op_type )
{
  int i ;
  int index ;
  int err ;
  u8 max_ints ;
  u32 val ;
  u32 temp ;
  u32 type ;
  struct qlcnic_cmd_args cmd ;
  bool tmp ;
  int tmp___0 ;
  {
  max_ints = (unsigned int )(adapter->ahw)->num_msix + 255U;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 2U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )max_ints;
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    *(cmd.req.arg + 1UL) = (*(cmd.req.arg + 1UL) | (u32 )((int )(adapter->ahw)->pci_func << 8)) | 65536U;
  } else {
  }
  i = 0;
  index = 2;
  goto ldv_52272;
  ldv_52271:
  type = (int )op_type ? 1U : 2U;
  val = (u32 )((int )((adapter->ahw)->intr_tbl + (unsigned long )i)->type << 4) | type;
  if ((unsigned int )((adapter->ahw)->intr_tbl + (unsigned long )i)->type == 3U) {
    val = (u32 )((int )((adapter->ahw)->intr_tbl + (unsigned long )i)->id << 16) | val;
  } else {
  }
  tmp___0 = index;
  index = index + 1;
  *(cmd.req.arg + (unsigned long )tmp___0) = val;
  i = i + 1;
  ldv_52272: ;
  if ((int )max_ints > i) {
    goto ldv_52271;
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to configure interrupts 0x%x\n",
            err);
    goto out;
  } else {
  }
  max_ints = (u8 )*(cmd.rsp.arg + 1UL);
  i = 0;
  index = 2;
  goto ldv_52277;
  ldv_52276:
  val = *(cmd.rsp.arg + (unsigned long )index);
  if ((unsigned int )((unsigned char )val) != 0U) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Can\'t configure interrupt %d\n",
              (int )((adapter->ahw)->intr_tbl + (unsigned long )i)->id);
    goto ldv_52275;
  } else {
  }
  if ((int )op_type) {
    ((adapter->ahw)->intr_tbl + (unsigned long )i)->id = (unsigned short )(val >> 16);
    ((adapter->ahw)->intr_tbl + (unsigned long )i)->enabled = 1U;
    temp = *(cmd.rsp.arg + ((unsigned long )index + 1UL));
    ((adapter->ahw)->intr_tbl + (unsigned long )i)->src = temp;
  } else {
    ((adapter->ahw)->intr_tbl + (unsigned long )i)->id = (u16 )i;
    ((adapter->ahw)->intr_tbl + (unsigned long )i)->enabled = 0U;
    ((adapter->ahw)->intr_tbl + (unsigned long )i)->src = 0U;
  }
  ldv_52275:
  i = i + 1;
  index = index + 2;
  ldv_52277: ;
  if ((int )max_ints > i) {
    goto ldv_52276;
  } else {
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
int qlcnic_83xx_lock_flash(struct qlcnic_adapter *adapter )
{
  int id ;
  int timeout ;
  u32 status ;
  unsigned int tmp ;
  {
  timeout = 0;
  status = 0U;
  goto ldv_52288;
  ldv_52287:
  status = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 21UL));
  if (status != 0U) {
    goto ldv_52285;
  } else {
  }
  timeout = timeout + 1;
  if (timeout > 9999) {
    tmp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 3UL));
    id = (int )tmp;
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed, lock held by %d\n",
            "qlcnic_83xx_lock_flash", id);
    return (-5);
  } else {
  }
  usleep_range(1000UL, 2000UL);
  ldv_52288: ;
  if (status == 0U) {
    goto ldv_52287;
  } else {
  }
  ldv_52285:
  writel((unsigned int )adapter->portnum, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 3UL));
  return (0);
}
}
void qlcnic_83xx_unlock_flash(struct qlcnic_adapter *adapter )
{
  {
  readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 22UL));
  writel(255U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 3UL));
  return;
}
}
int qlcnic_83xx_lockless_flash_read32(struct qlcnic_adapter *adapter , u32 flash_addr ,
                                      u8 *p_data , int count )
{
  u32 word ;
  u32 range ;
  u32 flash_offset ;
  u32 addr ;
  u32 ret ;
  ulong indirect_add ;
  ulong direct_window ;
  int i ;
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  addr = flash_addr;
  err = 0;
  flash_offset = addr & 65535U;
  if ((addr & 3U) != 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Illegal addr = 0x%x\n",
            addr);
    return (-5);
  } else {
  }
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410416UL, addr);
  range = (u32 )((unsigned long )count) * 4U + flash_offset;
  if (range > 65535U) {
    i = 0;
    goto ldv_52308;
    ldv_52307:
    indirect_add = (ulong )((addr & 65535U) | 1108672512U);
    tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, indirect_add, & err);
    ret = (u32 )tmp;
    if (err == -5) {
      return (err);
    } else {
    }
    word = ret;
    *((u32 *)p_data) = word;
    p_data = p_data + 4UL;
    addr = addr + 4U;
    flash_offset = flash_offset + 4U;
    if (flash_offset > 65535U) {
      direct_window = 1108410416UL;
      qlcnic_83xx_wrt_reg_indirect(adapter, direct_window, addr);
      flash_offset = 0U;
    } else {
    }
    i = i + 1;
    ldv_52308: ;
    if (i < count) {
      goto ldv_52307;
    } else {
    }
  } else {
    i = 0;
    goto ldv_52311;
    ldv_52310:
    indirect_add = (ulong )((addr & 65535U) | 1108672512U);
    tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, indirect_add, & err);
    ret = (u32 )tmp___0;
    if (err == -5) {
      return (err);
    } else {
    }
    word = ret;
    *((u32 *)p_data) = word;
    p_data = p_data + 4UL;
    addr = addr + 4U;
    i = i + 1;
    ldv_52311: ;
    if (i < count) {
      goto ldv_52310;
    } else {
    }
  }
  return (0);
}
}
static int qlcnic_83xx_poll_flash_status_reg(struct qlcnic_adapter *adapter )
{
  u32 status ;
  int retries ;
  int err ;
  int tmp ;
  {
  retries = 5000;
  err = 0;
  ldv_52320:
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 1108344836UL, & err);
  status = (u32 )tmp;
  if (err == -5) {
    return (err);
  } else {
  }
  if ((status & 6U) == 6U) {
    goto ldv_52319;
  } else {
  }
  msleep(1U);
  retries = retries - 1;
  if (retries != 0) {
    goto ldv_52320;
  } else {
  }
  ldv_52319: ;
  if (retries == 0) {
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_enable_flash_write(struct qlcnic_adapter *adapter )
{
  int ret ;
  u32 cmd ;
  {
  cmd = (u32 )(adapter->ahw)->fdt.write_statusreg_cmd;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, cmd | 16580864U);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410380UL, (u32 )(adapter->ahw)->fdt.write_enable_bits);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 5U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_disable_flash_write(struct qlcnic_adapter *adapter )
{
  int ret ;
  {
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, (u32 )((int )(adapter->ahw)->fdt.write_statusreg_cmd | 16580864));
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410380UL, (u32 )(adapter->ahw)->fdt.write_disable_bits);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 5U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_read_flash_mfg_id(struct qlcnic_adapter *adapter )
{
  int ret ;
  int err ;
  u32 mfg_id ;
  int tmp ;
  int tmp___0 ;
  {
  err = 0;
  tmp = qlcnic_83xx_lock_flash(adapter);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, 16580767U);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 63U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    qlcnic_83xx_unlock_flash(adapter);
    return (-5);
  } else {
  }
  tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 1108410392UL, & err);
  mfg_id = (u32 )tmp___0;
  if (err == -5) {
    qlcnic_83xx_unlock_flash(adapter);
    return (err);
  } else {
  }
  adapter->flash_mfg_id = (u8 )mfg_id;
  qlcnic_83xx_unlock_flash(adapter);
  return (0);
}
}
int qlcnic_83xx_read_flash_descriptor_table(struct qlcnic_adapter *adapter )
{
  int count ;
  int fdt_size ;
  int ret ;
  int tmp ;
  {
  ret = 0;
  fdt_size = 128;
  count = (int )((unsigned long )fdt_size / 4UL);
  tmp = qlcnic_83xx_lock_flash(adapter);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  memset((void *)(& (adapter->ahw)->fdt), 0, (size_t )fdt_size);
  ret = qlcnic_83xx_lockless_flash_read32(adapter, 4128768U, (u8 *)(& (adapter->ahw)->fdt),
                                          count);
  qlcnic_83xx_unlock_flash(adapter);
  return (ret);
}
}
int qlcnic_83xx_erase_flash_sector(struct qlcnic_adapter *adapter , u32 sector_start_addr )
{
  u32 reversed_addr ;
  u32 addr1 ;
  u32 addr2 ;
  u32 cmd ;
  int ret ;
  int tmp ;
  {
  ret = -5;
  tmp = qlcnic_83xx_lock_flash(adapter);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
    ret = qlcnic_83xx_enable_flash_write(adapter);
    if (ret != 0) {
      qlcnic_83xx_unlock_flash(adapter);
      dev_err((struct device const *)(& (adapter->pdev)->dev), "%s failed at %d\n",
              "qlcnic_83xx_erase_flash_sector", 2932);
      return (ret);
    } else {
    }
  } else {
  }
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    qlcnic_83xx_unlock_flash(adapter);
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
            "qlcnic_83xx_erase_flash_sector", 2941);
    return (-5);
  } else {
  }
  addr1 = (sector_start_addr & 255U) << 16;
  addr2 = (sector_start_addr & 16711680U) >> 16;
  reversed_addr = addr1 | addr2;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410380UL, reversed_addr);
  cmd = (u32 )((int )(adapter->ahw)->fdt.erase_cmd | 16581376);
  if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
    qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, cmd);
  } else {
    qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, 16581592U);
  }
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 61U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    qlcnic_83xx_unlock_flash(adapter);
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
            "qlcnic_83xx_erase_flash_sector", 2964);
    return (-5);
  } else {
  }
  if ((int )(adapter->ahw)->fdt.mfg_id == (int )((unsigned short )adapter->flash_mfg_id)) {
    ret = qlcnic_83xx_disable_flash_write(adapter);
    if (ret != 0) {
      qlcnic_83xx_unlock_flash(adapter);
      dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
              "qlcnic_83xx_erase_flash_sector", 2973);
      return (ret);
    } else {
    }
  } else {
  }
  qlcnic_83xx_unlock_flash(adapter);
  return (0);
}
}
int qlcnic_83xx_flash_write32(struct qlcnic_adapter *adapter , u32 addr , u32 *p_data )
{
  int ret ;
  u32 addr1 ;
  {
  ret = -5;
  addr1 = (addr >> 2) | 8388608U;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, addr1);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410380UL, *p_data);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 61U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
            "qlcnic_83xx_flash_write32", 2996);
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_flash_bulk_write(struct qlcnic_adapter *adapter , u32 addr , u32 *p_data ,
                                 int count )
{
  u32 temp ;
  int ret ;
  int err ;
  int tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;
  int tmp___3 ;
  {
  ret = -5;
  err = 0;
  if (count <= 1 || count > 64) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid word count\n",
            "qlcnic_83xx_flash_bulk_write");
    return (-5);
  } else {
  }
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 671670292UL, & err);
  temp = (u32 )tmp;
  if (err == -5) {
    return (err);
  } else {
  }
  qlcnic_83xx_wrt_reg_indirect(adapter, 671670292UL, temp | 4U);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, 8388608U);
  tmp___0 = p_data;
  p_data = p_data + 1;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410380UL, *tmp___0);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 67U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
            "qlcnic_83xx_flash_bulk_write", 3032);
    return (-5);
  } else {
  }
  count = count - 1;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, 8388609U);
  goto ldv_52371;
  ldv_52370:
  tmp___1 = p_data;
  p_data = p_data + 1;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410380UL, *tmp___1);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 127U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
            "qlcnic_83xx_flash_bulk_write", 3048);
    return (-5);
  } else {
  }
  count = count - 1;
  ldv_52371: ;
  if (count != 1) {
    goto ldv_52370;
  } else {
  }
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, (addr >> 2) | 8388608U);
  tmp___2 = p_data;
  p_data = p_data + 1;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410380UL, *tmp___2);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 125U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
            "qlcnic_83xx_flash_bulk_write", 3064);
    return (-5);
  } else {
  }
  ret = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 671670288UL, & err);
  if (err == -5) {
    return (err);
  } else {
  }
  if ((ret & 4) != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed at %d\n",
            "qlcnic_83xx_flash_bulk_write", 3074);
    tmp___3 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 671670292UL, & err);
    temp = (u32 )tmp___3;
    if (err == -5) {
      return (err);
    } else {
    }
    qlcnic_83xx_wrt_reg_indirect(adapter, 671670292UL, temp | 4U);
  } else {
  }
  return (0);
}
}
static void qlcnic_83xx_recover_driver_lock(struct qlcnic_adapter *adapter )
{
  u32 val ;
  u32 id ;
  {
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 18UL));
  if ((val & 3U) == 0U) {
    val = val & 4294967232U;
    val = ((u32 )((int )adapter->portnum << 2) | val) | 1U;
    writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 18UL));
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: lock recovery initiated\n",
              "qlcnic_83xx_recover_driver_lock");
    msleep(200U);
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 18UL));
    id = (val >> 2) & 15U;
    if ((u32 )adapter->portnum == id) {
      val = val & 4294967292U;
      val = val | 2U;
      writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 18UL));
      readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 40UL));
      val = val & 4294967232U;
      writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 18UL));
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: lock recovery completed\n",
                "qlcnic_83xx_recover_driver_lock");
    } else {
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: func %d to resume lock recovery process\n",
                "qlcnic_83xx_recover_driver_lock", id);
    }
  } else {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: lock recovery initiated by other functions\n",
              "qlcnic_83xx_recover_driver_lock");
  }
  return;
}
}
int qlcnic_83xx_lock_driver(struct qlcnic_adapter *adapter )
{
  u32 lock_alive_counter ;
  u32 val ;
  u32 id ;
  u32 i ;
  u32 status ;
  u32 temp ;
  int max_attempt ;
  {
  i = 0U;
  status = 0U;
  temp = 0U;
  max_attempt = 0;
  goto ldv_52392;
  ldv_52391:
  status = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 39UL));
  if (status != 0U) {
    goto ldv_52389;
  } else {
  }
  msleep(20U);
  i = i + 1U;
  if (i == 1U) {
    temp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
  } else {
  }
  if (i == 100U) {
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
    if (val == temp) {
      id = val & 255U;
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: lock to be recovered from %d\n",
                "qlcnic_83xx_lock_driver", id);
      qlcnic_83xx_recover_driver_lock(adapter);
      i = 0U;
      max_attempt = max_attempt + 1;
    } else {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed to get lock\n",
              "qlcnic_83xx_lock_driver");
      return (-5);
    }
  } else {
  }
  if (max_attempt == 3) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed to get lock\n",
            "qlcnic_83xx_lock_driver");
    return (-5);
  } else {
  }
  ldv_52392: ;
  if (status == 0U) {
    goto ldv_52391;
  } else {
  }
  ldv_52389:
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
  lock_alive_counter = val >> 8;
  lock_alive_counter = lock_alive_counter + 1U;
  val = (lock_alive_counter << 8) | (u32 )adapter->portnum;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
  return (0);
}
}
void qlcnic_83xx_unlock_driver(struct qlcnic_adapter *adapter )
{
  u32 val ;
  u32 lock_alive_counter ;
  u32 id ;
  {
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
  id = val & 255U;
  lock_alive_counter = val >> 8;
  if ((u32 )adapter->portnum != id) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s:Warning func %d is unlocking lock owned by %d\n",
            "qlcnic_83xx_unlock_driver", (int )adapter->portnum, id);
  } else {
  }
  val = (lock_alive_counter << 8) | 255U;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
  readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 40UL));
  return;
}
}
int qlcnic_ms_mem_write128(struct qlcnic_adapter *adapter , u64 addr , u32 *data ,
                           u32 count )
{
  int i ;
  int j ;
  int ret ;
  u32 temp ;
  u32 *tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;
  int tmp___3 ;
  struct ratelimit_state _rs ;
  int tmp___4 ;
  {
  ret = 0;
  if ((addr & 15ULL) != 0ULL) {
    return (-5);
  } else {
  }
  mutex_lock_nested(& (adapter->ahw)->mem_lock, 0U);
  qlcnic_ind_wr(adapter, 1090519192U, 0U);
  i = 0;
  goto ldv_52417;
  ldv_52416: ;
  if ((addr > 13019119614ULL || addr <= 12884901887ULL) && addr > 268435454ULL) {
    mutex_unlock(& (adapter->ahw)->mem_lock);
    return (-5);
  } else {
  }
  qlcnic_ind_wr(adapter, 1090519188U, (u32 )addr);
  tmp = data;
  data = data + 1;
  qlcnic_ind_wr(adapter, 1090519200U, *tmp);
  tmp___0 = data;
  data = data + 1;
  qlcnic_ind_wr(adapter, 1090519204U, *tmp___0);
  tmp___1 = data;
  data = data + 1;
  qlcnic_ind_wr(adapter, 1090519216U, *tmp___1);
  tmp___2 = data;
  data = data + 1;
  qlcnic_ind_wr(adapter, 1090519220U, *tmp___2);
  qlcnic_ind_wr(adapter, 1090519184U, 6U);
  qlcnic_ind_wr(adapter, 1090519184U, 7U);
  j = 0;
  goto ldv_52412;
  ldv_52411:
  tmp___3 = qlcnic_ind_rd(adapter, 1090519184U);
  temp = (u32 )tmp___3;
  if ((temp & 8U) == 0U) {
    goto ldv_52410;
  } else {
  }
  j = j + 1;
  ldv_52412: ;
  if (j <= 999) {
    goto ldv_52411;
  } else {
  }
  ldv_52410: ;
  if (j > 999) {
    _rs.lock.raw_lock.ldv_1458.head_tail = 0U;
    _rs.lock.magic = 3735899821U;
    _rs.lock.owner_cpu = 4294967295U;
    _rs.lock.owner = (void *)-1;
    _rs.lock.dep_map.key = 0;
    _rs.lock.dep_map.class_cache[0] = 0;
    _rs.lock.dep_map.class_cache[1] = 0;
    _rs.lock.dep_map.name = "_rs.lock";
    _rs.lock.dep_map.cpu = 0;
    _rs.lock.dep_map.ip = 0UL;
    _rs.interval = 1250;
    _rs.burst = 10;
    _rs.printed = 0;
    _rs.missed = 0;
    _rs.begin = 0UL;
    tmp___4 = ___ratelimit(& _rs, "qlcnic_ms_mem_write128");
    if (tmp___4 != 0) {
      printk("\fMS memory write failed\n");
    } else {
    }
    mutex_unlock(& (adapter->ahw)->mem_lock);
    return (-5);
  } else {
  }
  i = i + 1;
  addr = addr + 16ULL;
  ldv_52417: ;
  if ((u32 )i < count) {
    goto ldv_52416;
  } else {
  }
  mutex_unlock(& (adapter->ahw)->mem_lock);
  return (ret);
}
}
int qlcnic_83xx_flash_read32(struct qlcnic_adapter *adapter , u32 flash_addr , u8 *p_data ,
                             int count )
{
  u32 word ;
  u32 addr ;
  u32 ret ;
  ulong indirect_addr ;
  int i ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  addr = flash_addr;
  err = 0;
  tmp = qlcnic_83xx_lock_flash(adapter);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  if ((addr & 3U) != 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Illegal addr = 0x%x\n",
            addr);
    qlcnic_83xx_unlock_flash(adapter);
    return (-5);
  } else {
  }
  i = 0;
  goto ldv_52432;
  ldv_52431:
  tmp___0 = qlcnic_83xx_wrt_reg_indirect(adapter, 1108410416UL, addr);
  if (tmp___0 != 0) {
    qlcnic_83xx_unlock_flash(adapter);
    return (-5);
  } else {
  }
  indirect_addr = (ulong )((addr & 65535U) | 1108672512U);
  tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, indirect_addr, & err);
  ret = (u32 )tmp___1;
  if (err == -5) {
    return (err);
  } else {
  }
  word = ret;
  *((u32 *)p_data) = word;
  p_data = p_data + 4UL;
  addr = addr + 4U;
  i = i + 1;
  ldv_52432: ;
  if (i < count) {
    goto ldv_52431;
  } else {
  }
  qlcnic_83xx_unlock_flash(adapter);
  return (0);
}
}
int qlcnic_83xx_test_link(struct qlcnic_adapter *adapter )
{
  u8 pci_func ;
  int err ;
  u32 config ;
  u32 state ;
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_hardware_context *ahw ;
  bool tmp ;
  {
  config = 0U;
  ahw = adapter->ahw;
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    pci_func = adapter->portnum;
  } else {
    pci_func = ahw->pci_func;
  }
  state = readl((void const volatile *)(ahw->pci_base0 + ((unsigned int )pci_func > 7U ? 13980UL : 13976UL)));
  if (((u32 )(1 << (int )pci_func * 4) & state) == 0U) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "link state down\n");
    return ((int )config);
  } else {
  }
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 104U);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Get Link Status Command failed: 0x%x\n",
              err);
    goto out;
  } else {
    config = *(cmd.rsp.arg + 1UL);
    switch ((config >> 3) & 7U) {
    case 1U:
    ahw->link_speed = 10U;
    goto ldv_52445;
    case 2U:
    ahw->link_speed = 100U;
    goto ldv_52445;
    case 3U:
    ahw->link_speed = 1000U;
    goto ldv_52445;
    case 4U:
    ahw->link_speed = 10000U;
    goto ldv_52445;
    default:
    ahw->link_speed = 0U;
    goto ldv_52445;
    }
    ldv_52445:
    config = *(cmd.rsp.arg + 3UL);
    if ((config & 3U) != 0U) {
      switch ((int )ahw->module_type) {
      case 2: ;
      case 3: ;
      case 4: ;
      case 5:
      ahw->supported_type = 3U;
      goto ldv_52454;
      case 6: ;
      case 7: ;
      case 8:
      ahw->supported_type = 0U;
      goto ldv_52454;
      default:
      ahw->supported_type = 255U;
      }
      ldv_52454: ;
    } else {
    }
    if ((int )config & 1) {
      err = 1;
    } else {
    }
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return ((int )config);
}
}
int qlcnic_83xx_get_settings(struct qlcnic_adapter *adapter , struct ethtool_cmd *ecmd )
{
  u32 config ;
  int status ;
  struct qlcnic_hardware_context *ahw ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  config = 0U;
  status = 0;
  ahw = adapter->ahw;
  tmp___0 = constant_test_bit(16L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    status = qlcnic_83xx_get_port_info(adapter);
    tmp = qlcnic_83xx_test_link(adapter);
    config = (u32 )tmp;
    ahw->module_type = (unsigned int )((u16 )(config >> 4)) & 31U;
  } else {
  }
  ahw->board_type = 131U;
  tmp___1 = netif_running((struct net_device const *)adapter->netdev);
  if ((int )tmp___1 && (unsigned int )ahw->has_link_events != 0U) {
    ethtool_cmd_speed_set(ecmd, (__u32 )ahw->link_speed);
    ecmd->duplex = (__u8 )ahw->link_duplex;
    ecmd->autoneg = (__u8 )ahw->link_autoneg;
  } else {
    ethtool_cmd_speed_set(ecmd, 4294967295U);
    ecmd->duplex = 255U;
    ecmd->autoneg = 0U;
  }
  if ((unsigned int )ahw->port_type == 2U) {
    ecmd->supported = 4096U;
    ecmd->advertising = 4096U;
  } else {
    ecmd->supported = 63U;
    ecmd->advertising = 60U;
  }
  switch ((int )ahw->supported_type) {
  case 3:
  ecmd->supported = ecmd->supported | 1024U;
  ecmd->advertising = ecmd->advertising | 1024U;
  ecmd->port = 3U;
  ecmd->transceiver = 1U;
  goto ldv_52467;
  case 0:
  ecmd->supported = ecmd->supported | 128U;
  ecmd->advertising = ecmd->advertising | 128U;
  ecmd->port = 0U;
  ecmd->transceiver = 0U;
  goto ldv_52467;
  default:
  ecmd->supported = ecmd->supported | 1024U;
  ecmd->advertising = ecmd->advertising | 1024U;
  ecmd->port = 255U;
  ecmd->transceiver = 1U;
  goto ldv_52467;
  }
  ldv_52467:
  ecmd->phy_address = ahw->physical_port;
  return (status);
}
}
int qlcnic_83xx_set_settings(struct qlcnic_adapter *adapter , struct ethtool_cmd *ecmd )
{
  int status ;
  u32 config ;
  __u32 tmp ;
  {
  status = 0;
  config = (adapter->ahw)->port_config;
  if ((unsigned int )ecmd->autoneg != 0U) {
    (adapter->ahw)->port_config = (adapter->ahw)->port_config | 32768U;
  } else {
  }
  tmp = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
  switch (tmp) {
  case 10U:
  (adapter->ahw)->port_config = (adapter->ahw)->port_config | 256U;
  goto ldv_52477;
  case 100U:
  (adapter->ahw)->port_config = (adapter->ahw)->port_config | 512U;
  goto ldv_52477;
  case 1000U:
  (adapter->ahw)->port_config = (adapter->ahw)->port_config | 1024U;
  goto ldv_52477;
  case 10000U:
  (adapter->ahw)->port_config = (adapter->ahw)->port_config | 2048U;
  goto ldv_52477;
  default: ;
  return (-22);
  }
  ldv_52477:
  status = qlcnic_83xx_set_port_config(adapter);
  if (status != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Failed to Set Link Speed and autoneg.\n");
    (adapter->ahw)->port_config = config;
  } else {
  }
  return (status);
}
}
__inline static u64 *qlcnic_83xx_copy_stats(struct qlcnic_cmd_args *cmd , u64 *data ,
                                            int index )
{
  u32 low ;
  u32 hi ;
  u64 val ;
  u64 *tmp ;
  {
  low = *(cmd->rsp.arg + (unsigned long )index);
  hi = *(cmd->rsp.arg + ((unsigned long )index + 1UL));
  val = (unsigned long long )low | ((unsigned long long )hi << 32);
  tmp = data;
  data = data + 1;
  *tmp = val;
  return (data);
}
}
static u64 *qlcnic_83xx_fill_stats(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd ,
                                   u64 *data , int type , int *ret )
{
  int err ;
  int k ;
  int total_regs ;
  {
  *ret = 0;
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Error in get statistics mailbox command\n");
    *ret = -5;
    return (data);
  } else {
  }
  total_regs = (int )cmd->rsp.num;
  switch (type) {
  case 1:
  k = 2;
  goto ldv_52502;
  ldv_52501:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52502: ;
  if (k <= 27) {
    goto ldv_52501;
  } else {
  }
  k = k + 6;
  goto ldv_52505;
  ldv_52504:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52505: ;
  if (k <= 59) {
    goto ldv_52504;
  } else {
  }
  k = k + 6;
  goto ldv_52508;
  ldv_52507:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52508: ;
  if (k <= 79) {
    goto ldv_52507;
  } else {
  }
  goto ldv_52511;
  ldv_52510:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52511: ;
  if (k < total_regs) {
    goto ldv_52510;
  } else {
  }
  goto ldv_52513;
  case 2:
  k = 2;
  goto ldv_52516;
  ldv_52515:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52516: ;
  if (k <= 7) {
    goto ldv_52515;
  } else {
  }
  k = k + 2;
  goto ldv_52519;
  ldv_52518:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52519: ;
  if (k <= 23) {
    goto ldv_52518;
  } else {
  }
  k = k + 2;
  goto ldv_52522;
  ldv_52521:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52522: ;
  if (k < total_regs) {
    goto ldv_52521;
  } else {
  }
  goto ldv_52513;
  case 3:
  k = 2;
  goto ldv_52526;
  ldv_52525:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52526: ;
  if (k <= 9) {
    goto ldv_52525;
  } else {
  }
  k = k + 2;
  goto ldv_52529;
  ldv_52528:
  data = qlcnic_83xx_copy_stats(cmd, data, k);
  k = k + 2;
  ldv_52529: ;
  if (k < total_regs) {
    goto ldv_52528;
  } else {
  }
  goto ldv_52513;
  default:
  dev_warn((struct device const *)(& (adapter->pdev)->dev), "Unknown get statistics mode\n");
  *ret = -5;
  }
  ldv_52513: ;
  return (data);
}
}
void qlcnic_83xx_get_stats(struct qlcnic_adapter *adapter , u64 *data )
{
  struct qlcnic_cmd_args cmd ;
  struct net_device *netdev ;
  int ret ;
  {
  netdev = adapter->netdev;
  ret = 0;
  ret = qlcnic_alloc_mbx_args(& cmd, adapter, 15U);
  if (ret != 0) {
    return;
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )(((int )(adapter->tx_ring)->ctx_id << 16) | 2);
  cmd.rsp.num = 14U;
  data = qlcnic_83xx_fill_stats(adapter, & cmd, data, 3, & ret);
  if (ret != 0) {
    netdev_err((struct net_device const *)netdev, "Error getting Tx stats\n");
    goto out;
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )(((int )adapter->portnum << 16) | 4);
  cmd.rsp.num = 94U;
  memset((void *)cmd.rsp.arg, 0, (unsigned long )cmd.rsp.num * 4UL);
  data = qlcnic_83xx_fill_stats(adapter, & cmd, data, 1, & ret);
  if (ret != 0) {
    netdev_err((struct net_device const *)netdev, "Error getting MAC stats\n");
    goto out;
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )((int )(adapter->recv_ctx)->context_id << 16);
  cmd.rsp.num = 40U;
  memset((void *)cmd.rsp.arg, 0, (unsigned long )cmd.rsp.num * 4UL);
  data = qlcnic_83xx_fill_stats(adapter, & cmd, data, 2, & ret);
  if (ret != 0) {
    netdev_err((struct net_device const *)netdev, "Error getting Rx stats\n");
  } else {
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
int qlcnic_83xx_reg_test(struct qlcnic_adapter *adapter )
{
  u32 major ;
  u32 minor ;
  u32 sub ;
  {
  major = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 11UL));
  minor = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 12UL));
  sub = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 13UL));
  if (adapter->fw_version != ((major << 24) + (minor << 16)) + sub) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: Reg test failed\n",
              "qlcnic_83xx_reg_test");
    return (1);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_get_registers(struct qlcnic_adapter *adapter , u32 *regs_buff )
{
  int i ;
  int j ;
  int tmp ;
  {
  j = 0;
  i = 3;
  goto ldv_52563;
  ldv_52562:
  *(regs_buff + (unsigned long )i) = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + (unsigned long )j));
  i = i + 1;
  j = j + 1;
  ldv_52563: ;
  if ((unsigned int )j <= 22U) {
    goto ldv_52562;
  } else {
  }
  j = 0;
  goto ldv_52568;
  ldv_52567:
  tmp = i;
  i = i + 1;
  *(regs_buff + (unsigned long )tmp) = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + (unsigned long )j));
  j = j + 1;
  ldv_52568: ;
  if ((unsigned int )j <= 42U) {
    goto ldv_52567;
  } else {
  }
  return (i);
}
}
int qlcnic_83xx_interrupt_test(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_cmd_args cmd ;
  u8 val ;
  u8 drv_sds_rings ;
  u8 drv_tx_rings ;
  u32 data ;
  u16 intrpt_id ;
  u16 id ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  drv_sds_rings = adapter->drv_sds_rings;
  drv_tx_rings = adapter->drv_tx_rings;
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    netdev_info((struct net_device const *)netdev, "Device is resetting\n");
    return (-16);
  } else {
  }
  tmp___1 = qlcnic_get_diag_lock(adapter);
  if (tmp___1 != 0) {
    netdev_info((struct net_device const *)netdev, "Device in diagnostics mode\n");
    return (-16);
  } else {
  }
  ret = qlcnic_83xx_diag_alloc_res(netdev, 1, (int )drv_sds_rings);
  if (ret != 0) {
    goto fail_diag_irq;
  } else {
  }
  ahw->diag_cnt = 0;
  ret = qlcnic_alloc_mbx_args(& cmd, adapter, 17U);
  if (ret != 0) {
    goto fail_diag_irq;
  } else {
  }
  if ((adapter->flags & 4U) != 0U) {
    intrpt_id = (ahw->intr_tbl)->id;
  } else {
    tmp___2 = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 10UL));
    intrpt_id = (u16 )tmp___2;
  }
  *(cmd.req.arg + 1UL) = 1U;
  *(cmd.req.arg + 2UL) = (u32 )intrpt_id;
  *(cmd.req.arg + 3UL) = 1U;
  ret = qlcnic_issue_cmd(adapter, & cmd);
  data = *(cmd.rsp.arg + 2UL);
  id = (unsigned short )data;
  val = (unsigned char )(data >> 16);
  if ((int )id != (int )intrpt_id) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Interrupt generated: 0x%x, requested:0x%x\n",
              (int )id, (int )intrpt_id);
  } else {
  }
  if ((unsigned int )val != 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Interrupt test error: 0x%x\n",
            (int )val);
  } else {
  }
  if (ret != 0) {
    goto done;
  } else {
  }
  msleep(20U);
  ret = ahw->diag_cnt == 0;
  done:
  qlcnic_free_mbx_args(& cmd);
  qlcnic_83xx_diag_free_res(netdev, (int )drv_sds_rings);
  fail_diag_irq:
  adapter->drv_sds_rings = drv_sds_rings;
  adapter->drv_tx_rings = drv_tx_rings;
  qlcnic_release_diag_lock(adapter);
  return (ret);
}
}
void qlcnic_83xx_get_pauseparam(struct qlcnic_adapter *adapter , struct ethtool_pauseparam *pause )
{
  struct qlcnic_hardware_context *ahw ;
  int status ;
  u32 config ;
  {
  ahw = adapter->ahw;
  status = 0;
  status = qlcnic_83xx_get_port_config(adapter);
  if (status != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Get Pause Config failed\n",
            "qlcnic_83xx_get_pauseparam");
    return;
  } else {
  }
  config = ahw->port_config;
  if ((config & 32U) != 0U) {
    switch ((int )((unsigned short )(config >> 16))) {
    case 16:
    pause->tx_pause = 1U;
    goto ldv_52594;
    case 32:
    pause->rx_pause = 1U;
    goto ldv_52594;
    case 48: ;
    default:
    pause->tx_pause = 1U;
    pause->rx_pause = 1U;
    }
    ldv_52594: ;
  } else {
  }
  if ((config & 32768U) != 0U) {
    pause->autoneg = 1U;
  } else {
  }
  return;
}
}
int qlcnic_83xx_set_pauseparam(struct qlcnic_adapter *adapter , struct ethtool_pauseparam *pause )
{
  struct qlcnic_hardware_context *ahw ;
  int status ;
  u32 config ;
  {
  ahw = adapter->ahw;
  status = 0;
  status = qlcnic_83xx_get_port_config(adapter);
  if (status != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Get Pause Config failed.\n",
            "qlcnic_83xx_set_pauseparam");
    return (status);
  } else {
  }
  config = ahw->port_config;
  if ((unsigned int )ahw->port_type == 1U) {
    if (pause->autoneg != 0U) {
      ahw->port_config = ahw->port_config | 32768U;
    } else {
    }
    if (pause->autoneg == 0U) {
      ahw->port_config = ahw->port_config & 4294934527U;
    } else {
    }
  } else
  if ((unsigned int )ahw->port_type == 2U && pause->autoneg != 0U) {
    return (-95);
  } else {
  }
  if ((config & 32U) == 0U) {
    ahw->port_config = ahw->port_config | 32U;
  } else {
  }
  if (pause->rx_pause != 0U && pause->tx_pause != 0U) {
    ahw->port_config = ahw->port_config | 3145728U;
  } else
  if (pause->rx_pause != 0U && pause->tx_pause == 0U) {
    ahw->port_config = ahw->port_config & 4293918719U;
    ahw->port_config = ahw->port_config | 2097152U;
  } else
  if (pause->tx_pause != 0U && pause->rx_pause == 0U) {
    ahw->port_config = ahw->port_config & 4292870143U;
    ahw->port_config = ahw->port_config | 1048576U;
  } else
  if (pause->rx_pause == 0U && pause->tx_pause == 0U) {
    ahw->port_config = ahw->port_config & 4291821535U;
  } else {
  }
  status = qlcnic_83xx_set_port_config(adapter);
  if (status != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Set Pause Config failed.\n",
            "qlcnic_83xx_set_pauseparam");
    ahw->port_config = config;
  } else {
  }
  return (status);
}
}
static int qlcnic_83xx_read_flash_status_reg(struct qlcnic_adapter *adapter )
{
  int ret ;
  int err ;
  u32 temp ;
  int tmp ;
  {
  err = 0;
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410376UL, 16580613U);
  qlcnic_83xx_wrt_reg_indirect(adapter, 1108410372UL, 63U);
  ret = qlcnic_83xx_poll_flash_status_reg(adapter);
  if (ret != 0) {
    return (-5);
  } else {
  }
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 1108410392UL, & err);
  temp = (u32 )tmp;
  if (err == -5) {
    return (err);
  } else {
  }
  return ((int )temp & 255);
}
}
int qlcnic_83xx_flash_test(struct qlcnic_adapter *adapter )
{
  int status ;
  {
  status = qlcnic_83xx_read_flash_status_reg(adapter);
  if (status == -5) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: EEPROM test failed.\n",
              "qlcnic_83xx_flash_test");
    return (1);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_shutdown(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  int retval ;
  bool tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  netdev = adapter->netdev;
  netif_device_detach(netdev);
  qlcnic_cancel_idc_work(adapter);
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_83xx_disable_mbx_intr(adapter);
  cancel_delayed_work_sync(& adapter->idc_aen_work);
  retval = pci_save_state(pdev);
  if (retval != 0) {
    return (retval);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_resume(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlc_83xx_idc *idc ;
  int err ;
  {
  ahw = adapter->ahw;
  idc = & ahw->idc;
  err = 0;
  err = qlcnic_83xx_idc_init(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  if ((unsigned int )ahw->nic_mode == 255U) {
    if ((unsigned int )ahw->op_mode == 0U) {
      qlcnic_83xx_set_vnic_opmode(adapter);
    } else {
      err = qlcnic_83xx_check_vnic_state(adapter);
      if (err != 0) {
        return (err);
      } else {
      }
    }
  } else {
  }
  err = qlcnic_83xx_idc_reattach_driver(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_schedule_work(adapter, & qlcnic_83xx_idc_poll_dev_state, (int )idc->delay);
  return (err);
}
}
void qlcnic_83xx_reinit_mbx_work(struct qlcnic_mailbox *mbx )
{
  {
  reinit_completion(& mbx->completion);
  set_bit(2L, (unsigned long volatile *)(& mbx->status));
  return;
}
}
void qlcnic_83xx_free_mailbox(struct qlcnic_mailbox *mbx )
{
  {
  if ((unsigned long )mbx == (unsigned long )((struct qlcnic_mailbox *)0)) {
    return;
  } else {
  }
  destroy_workqueue(mbx->work_q);
  kfree((void const *)mbx);
  return;
}
}
__inline static void qlcnic_83xx_notify_cmd_completion(struct qlcnic_adapter *adapter ,
                                                       struct qlcnic_cmd_args *cmd )
{
  {
  atomic_set(& cmd->rsp_status, 1);
  if (cmd->type == 1U) {
    qlcnic_free_mbx_args(cmd);
    kfree((void const *)cmd);
    return;
  } else {
  }
  complete(& cmd->completion);
  return;
}
}
static void qlcnic_83xx_flush_mbx_queue(struct qlcnic_adapter *adapter )
{
  struct qlcnic_mailbox *mbx ;
  struct list_head *head ;
  struct qlcnic_cmd_args *cmd ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  mbx = (adapter->ahw)->mailbox;
  head = & mbx->cmd_q;
  cmd = (struct qlcnic_cmd_args *)0;
  spin_lock(& mbx->queue_lock);
  goto ldv_52649;
  ldv_52648:
  __mptr = (struct list_head const *)head->next;
  cmd = (struct qlcnic_cmd_args *)__mptr + 0xffffffffffffffa0UL;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: Mailbox command 0x%x\n",
            "qlcnic_83xx_flush_mbx_queue", cmd->cmd_op);
  list_del(& cmd->list);
  mbx->num_cmds = mbx->num_cmds - 1U;
  qlcnic_83xx_notify_cmd_completion(adapter, cmd);
  ldv_52649:
  tmp = list_empty((struct list_head const *)head);
  if (tmp == 0) {
    goto ldv_52648;
  } else {
  }
  spin_unlock(& mbx->queue_lock);
  return;
}
}
static int qlcnic_83xx_check_mbx_status(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_mailbox *mbx ;
  u32 host_mbx_ctrl ;
  int tmp ;
  {
  ahw = adapter->ahw;
  mbx = ahw->mailbox;
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& mbx->status));
  if (tmp == 0) {
    return (-16);
  } else {
  }
  host_mbx_ctrl = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 3UL));
  if (host_mbx_ctrl != 0U) {
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
    ahw->idc.collect_dump = 1;
    return (-5);
  } else {
  }
  return (0);
}
}
__inline static void qlcnic_83xx_signal_mbx_cmd(struct qlcnic_adapter *adapter , u8 issue_cmd )
{
  {
  if ((unsigned int )issue_cmd != 0U) {
    writel(1U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 3UL));
  } else {
    writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 4UL));
  }
  return;
}
}
static void qlcnic_83xx_dequeue_mbx_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_mailbox *mbx ;
  {
  mbx = (adapter->ahw)->mailbox;
  spin_lock(& mbx->queue_lock);
  list_del(& cmd->list);
  mbx->num_cmds = mbx->num_cmds - 1U;
  spin_unlock(& mbx->queue_lock);
  qlcnic_83xx_notify_cmd_completion(adapter, cmd);
  return;
}
}
static void qlcnic_83xx_encode_mbx_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  u32 mbx_cmd ;
  u32 fw_hal_version ;
  u32 hdr_size ;
  u32 total_size ;
  u32 tmp ;
  struct qlcnic_hardware_context *ahw ;
  int i ;
  int j ;
  bool tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;
  {
  ahw = adapter->ahw;
  if (cmd->op_type != 1U) {
    mbx_cmd = *(cmd->req.arg);
    writel(mbx_cmd, (void volatile *)ahw->pci_base0);
    i = 1;
    goto ldv_52679;
    ldv_52678:
    writel(*(cmd->req.arg + (unsigned long )i), (void volatile *)ahw->pci_base0 + (unsigned long )(i * 4));
    i = i + 1;
    ldv_52679: ;
    if ((u32 )i < cmd->req.num) {
      goto ldv_52678;
    } else {
    }
  } else {
    fw_hal_version = ahw->fw_hal_version;
    hdr_size = 4U;
    total_size = (u32 )cmd->pay_size + hdr_size;
    tmp = (total_size << 16) | 49U;
    mbx_cmd = (fw_hal_version << 29) | tmp;
    writel(mbx_cmd, (void volatile *)ahw->pci_base0);
    mbx_cmd = 17U;
    tmp___0 = qlcnic_sriov_pf_check(adapter);
    if ((int )tmp___0) {
      mbx_cmd = (u32 )((int )cmd->func_num << 5) | mbx_cmd;
    } else {
    }
    writel(mbx_cmd, (void volatile *)ahw->pci_base0 + 4U);
    i = 2;
    j = 0;
    goto ldv_52682;
    ldv_52681:
    tmp___1 = cmd->hdr;
    cmd->hdr = cmd->hdr + 1;
    writel(*tmp___1, (void volatile *)ahw->pci_base0 + (unsigned long )(i * 4));
    i = i + 1;
    j = j + 1;
    ldv_52682: ;
    if ((u32 )j < hdr_size) {
      goto ldv_52681;
    } else {
    }
    j = 0;
    goto ldv_52685;
    ldv_52684:
    tmp___2 = cmd->pay;
    cmd->pay = cmd->pay + 1;
    writel(*tmp___2, (void volatile *)ahw->pci_base0 + (unsigned long )(i * 4));
    j = j + 1;
    i = i + 1;
    ldv_52685: ;
    if (cmd->pay_size > j) {
      goto ldv_52684;
    } else {
    }
  }
  return;
}
}
void qlcnic_83xx_detach_mailbox_work(struct qlcnic_adapter *adapter )
{
  struct qlcnic_mailbox *mbx ;
  {
  mbx = (adapter->ahw)->mailbox;
  if ((unsigned long )mbx == (unsigned long )((struct qlcnic_mailbox *)0)) {
    return;
  } else {
  }
  clear_bit(2L, (unsigned long volatile *)(& mbx->status));
  complete(& mbx->completion);
  cancel_work_sync(& mbx->work);
  flush_workqueue(mbx->work_q);
  qlcnic_83xx_flush_mbx_queue(adapter);
  return;
}
}
static int qlcnic_83xx_enqueue_mbx_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd ,
                                       unsigned long *timeout )
{
  struct qlcnic_mailbox *mbx ;
  int tmp ;
  {
  mbx = (adapter->ahw)->mailbox;
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& mbx->status));
  if (tmp != 0) {
    atomic_set(& cmd->rsp_status, 0);
    init_completion(& cmd->completion);
    cmd->rsp_opcode = 3U;
    spin_lock(& mbx->queue_lock);
    list_add_tail(& cmd->list, & mbx->cmd_q);
    mbx->num_cmds = mbx->num_cmds + 1U;
    cmd->total_cmds = mbx->num_cmds;
    *timeout = (unsigned long )(cmd->total_cmds * 1250U);
    queue_work(mbx->work_q, & mbx->work);
    spin_unlock(& mbx->queue_lock);
    return (0);
  } else {
  }
  return (-16);
}
}
static int qlcnic_83xx_check_mac_rcode(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  u8 mac_cmd_rcode ;
  u32 fw_data ;
  {
  if (cmd->cmd_op == 69U) {
    fw_data = readl((void const volatile *)(adapter->ahw)->pci_base0 + 2056U);
    mac_cmd_rcode = (unsigned char )fw_data;
    if (((unsigned int )mac_cmd_rcode == 5U || (unsigned int )mac_cmd_rcode == 12U) || (unsigned int )mac_cmd_rcode == 13U) {
      cmd->rsp_opcode = 0U;
      return (0);
    } else {
    }
  } else {
  }
  return (-22);
}
}
static void qlcnic_83xx_decode_mbx_rsp(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_hardware_context *ahw ;
  struct device *dev ;
  u8 mbx_err_code ;
  u32 fw_data ;
  int tmp ;
  {
  ahw = adapter->ahw;
  dev = & (adapter->pdev)->dev;
  fw_data = readl((void const volatile *)ahw->pci_base0 + 2048U);
  mbx_err_code = (u8 )(fw_data >> 25);
  qlcnic_83xx_get_mbx_data(adapter, cmd);
  switch ((int )mbx_err_code) {
  case 1: ;
  case 26:
  cmd->rsp_opcode = 0U;
  goto ldv_52713;
  default:
  tmp = qlcnic_83xx_check_mac_rcode(adapter, cmd);
  if (tmp == 0) {
    goto ldv_52713;
  } else {
  }
  dev_err((struct device const *)dev, "%s: Mailbox command failed, opcode=0x%x, cmd_type=0x%x, func=0x%x, op_mode=0x%x, error=0x%x\n",
          "qlcnic_83xx_decode_mbx_rsp", cmd->cmd_op, cmd->type, (int )ahw->pci_func,
          (int )ahw->op_mode, (int )mbx_err_code);
  cmd->rsp_opcode = 2U;
  qlcnic_dump_mbx(adapter, cmd);
  }
  ldv_52713: ;
  return;
}
}
__inline static void qlcnic_dump_mailbox_registers(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  u32 offset ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  {
  ahw = adapter->ahw;
  offset = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 9UL));
  tmp = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 4UL));
  tmp___0 = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 3UL));
  tmp___1 = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 8UL));
  tmp___2 = readl((void const volatile *)ahw->pci_base0 + (unsigned long )offset);
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Mbx interrupt mask=0x%x, Mbx interrupt enable=0x%x, Host mbx control=0x%x, Fw mbx control=0x%x",
            tmp___2, tmp___1, tmp___0, tmp);
  return;
}
}
static void qlcnic_83xx_mailbox_worker(struct work_struct *work )
{
  struct qlcnic_mailbox *mbx ;
  struct work_struct const *__mptr ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_mbx_ops *mbx_ops ;
  struct device *dev ;
  atomic_t *rsp_status ;
  struct list_head *head ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_cmd_args *cmd ;
  int tmp ;
  int tmp___0 ;
  struct list_head const *__mptr___0 ;
  unsigned long tmp___1 ;
  {
  __mptr = (struct work_struct const *)work;
  mbx = (struct qlcnic_mailbox *)__mptr + 0xffffffffffffffe8UL;
  adapter = mbx->adapter;
  mbx_ops = mbx->ops;
  dev = & (adapter->pdev)->dev;
  rsp_status = & mbx->rsp_status;
  head = & mbx->cmd_q;
  cmd = (struct qlcnic_cmd_args *)0;
  ahw = adapter->ahw;
  ldv_52737:
  tmp = qlcnic_83xx_check_mbx_status(adapter);
  if (tmp != 0) {
    qlcnic_83xx_flush_mbx_queue(adapter);
    return;
  } else {
  }
  atomic_set(rsp_status, 0);
  spin_lock(& mbx->queue_lock);
  tmp___0 = list_empty((struct list_head const *)head);
  if (tmp___0 != 0) {
    spin_unlock(& mbx->queue_lock);
    return;
  } else {
  }
  __mptr___0 = (struct list_head const *)head->next;
  cmd = (struct qlcnic_cmd_args *)__mptr___0 + 0xffffffffffffffa0UL;
  spin_unlock(& mbx->queue_lock);
  (*(mbx_ops->encode_cmd))(adapter, cmd);
  (*(mbx_ops->nofity_fw))(adapter, 1);
  tmp___1 = wait_for_completion_timeout(& mbx->completion, 1250UL);
  if (tmp___1 != 0UL) {
    (*(mbx_ops->decode_resp))(adapter, cmd);
    (*(mbx_ops->nofity_fw))(adapter, 0);
  } else {
    dev_err((struct device const *)dev, "%s: Mailbox command timeout, opcode=0x%x, cmd_type=0x%x, func=0x%x, op_mode=0x%x\n",
            "qlcnic_83xx_mailbox_worker", cmd->cmd_op, cmd->type, (int )ahw->pci_func,
            (int )ahw->op_mode);
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
    qlcnic_dump_mailbox_registers(adapter);
    qlcnic_83xx_get_mbx_data(adapter, cmd);
    qlcnic_dump_mbx(adapter, cmd);
    qlcnic_83xx_idc_request_reset(adapter, 3735944941U);
    cmd->rsp_opcode = 17U;
  }
  (*(mbx_ops->dequeue_cmd))(adapter, cmd);
  goto ldv_52737;
}
}
static struct qlcnic_mbx_ops qlcnic_83xx_mbx_ops = {& qlcnic_83xx_enqueue_mbx_cmd, & qlcnic_83xx_dequeue_mbx_cmd, & qlcnic_83xx_decode_mbx_rsp,
    & qlcnic_83xx_encode_mbx_cmd, & qlcnic_83xx_signal_mbx_cmd};
int qlcnic_83xx_init_mailbox_work(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_mailbox *mbx ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  char const *__lock_name ;
  struct workqueue_struct *tmp___0 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_0 ;
  {
  ahw = adapter->ahw;
  tmp = kzalloc(376UL, 208U);
  ahw->mailbox = (struct qlcnic_mailbox *)tmp;
  if ((unsigned long )ahw->mailbox == (unsigned long )((struct qlcnic_mailbox *)0)) {
    return (-12);
  } else {
  }
  mbx = ahw->mailbox;
  mbx->ops = & qlcnic_83xx_mbx_ops;
  mbx->adapter = adapter;
  spinlock_check(& mbx->queue_lock);
  __raw_spin_lock_init(& mbx->queue_lock.ldv_6347.rlock, "&(&mbx->queue_lock)->rlock",
                       & __key);
  spinlock_check(& mbx->aen_lock);
  __raw_spin_lock_init(& mbx->aen_lock.ldv_6347.rlock, "&(&mbx->aen_lock)->rlock",
                       & __key___0);
  INIT_LIST_HEAD(& mbx->cmd_q);
  init_completion(& mbx->completion);
  __lock_name = "\"%s\"(\"qlcnic_mailbox\")";
  tmp___0 = __alloc_workqueue_key("%s", 10U, 1, & __key___1, __lock_name, (char *)"qlcnic_mailbox");
  mbx->work_q = tmp___0;
  if ((unsigned long )mbx->work_q == (unsigned long )((struct workqueue_struct *)0)) {
    kfree((void const *)mbx);
    return (-12);
  } else {
  }
  __init_work(& mbx->work, 0);
  __constr_expr_0.counter = 137438953408L;
  mbx->work.data = __constr_expr_0;
  lockdep_init_map(& mbx->work.lockdep_map, "(&mbx->work)", & __key___2, 0);
  INIT_LIST_HEAD(& mbx->work.entry);
  mbx->work.func = & qlcnic_83xx_mailbox_worker;
  set_bit(2L, (unsigned long volatile *)(& mbx->status));
  return (0);
}
}
static pci_ers_result_t qlcnic_83xx_io_error_detected(struct pci_dev *pdev , pci_channel_state_t state )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  if (state == 3U) {
    return (4U);
  } else {
  }
  if (state == 1U) {
    return (5U);
  } else {
  }
  set_bit(5L, (unsigned long volatile *)(& adapter->state));
  set_bit(2L, (unsigned long volatile *)(& adapter->state));
  qlcnic_83xx_aer_stop_poll_work(adapter);
  pci_save_state(pdev);
  pci_disable_device(pdev);
  return (3U);
}
}
static pci_ers_result_t qlcnic_83xx_io_slot_reset(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  err = 0;
  pdev->error_state = 1U;
  err = pci_enable_device(pdev);
  if (err != 0) {
    goto disconnect;
  } else {
  }
  pci_set_power_state(pdev, 0);
  pci_set_master(pdev);
  pci_restore_state(pdev);
  err = qlcnic_83xx_aer_reset(adapter);
  if (err == 0) {
    return (5U);
  } else {
  }
  disconnect:
  clear_bit(5L, (unsigned long volatile *)(& adapter->state));
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (4U);
}
}
static void qlcnic_83xx_io_resume(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  pci_cleanup_aer_uncorrect_error_status(pdev);
  tmp___0 = test_and_clear_bit(5L, (unsigned long volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    qlcnic_83xx_aer_start_poll_work(adapter);
  } else {
  }
  return;
}
}
extern int ldv_release_8(void) ;
int ldv_retval_4 ;
extern int ldv_probe_8(void) ;
extern int ldv_suspend_7(void) ;
extern int ldv_probe_7(void) ;
extern int ldv_release_7(void) ;
void ldv_initialize_qlcnic_hardware_ops_8(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_83xx_hw_ops_group3 = (struct qlcnic_adapter *)tmp;
  tmp___0 = ldv_zalloc(4096UL);
  qlcnic_83xx_hw_ops_group4 = (struct qlcnic_host_sds_ring *)tmp___0;
  tmp___1 = ldv_zalloc(4096UL);
  qlcnic_83xx_hw_ops_group0 = (struct qlcnic_host_tx_ring *)tmp___1;
  tmp___2 = ldv_zalloc(72UL);
  qlcnic_83xx_hw_ops_group1 = (struct qlcnic_info *)tmp___2;
  tmp___3 = ldv_zalloc(2976UL);
  qlcnic_83xx_hw_ops_group5 = (struct pci_dev *)tmp___3;
  tmp___4 = ldv_zalloc(200UL);
  qlcnic_83xx_hw_ops_group2 = (struct qlcnic_cmd_args *)tmp___4;
  return;
}
}
void ldv_initialize_qlcnic_mbx_ops_6(void)
{
  void *tmp ;
  void *tmp___0 ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_83xx_mbx_ops_group0 = (struct qlcnic_adapter *)tmp;
  tmp___0 = ldv_zalloc(200UL);
  qlcnic_83xx_mbx_ops_group1 = (struct qlcnic_cmd_args *)tmp___0;
  return;
}
}
void ldv_initialize_qlcnic_nic_template_7(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_83xx_ops_group0 = (struct qlcnic_adapter *)tmp;
  return;
}
}
void ldv_main_exported_8(void)
{
  struct qlcnic_fw_dump *ldvarg273 ;
  void *tmp ;
  u32 ldvarg253 ;
  u32 tmp___0 ;
  size_t ldvarg279 ;
  size_t tmp___1 ;
  struct qlcnic_pci_info *ldvarg283 ;
  void *tmp___2 ;
  u8 *ldvarg267 ;
  void *tmp___3 ;
  int *ldvarg249 ;
  void *tmp___4 ;
  ulong ldvarg250 ;
  u8 *ldvarg276 ;
  void *tmp___5 ;
  int ldvarg265 ;
  int tmp___6 ;
  void *ldvarg251 ;
  void *tmp___7 ;
  pci_channel_state_t ldvarg270 ;
  int ldvarg282 ;
  int tmp___8 ;
  u32 ldvarg264 ;
  u32 tmp___9 ;
  int ldvarg252 ;
  int tmp___10 ;
  loff_t ldvarg256 ;
  loff_t tmp___11 ;
  u32 ldvarg261 ;
  u32 tmp___12 ;
  int ldvarg245 ;
  int tmp___13 ;
  int ldvarg248 ;
  int tmp___14 ;
  ulong ldvarg254 ;
  void *ldvarg277 ;
  void *tmp___15 ;
  u16 ldvarg275 ;
  u16 tmp___16 ;
  struct ethtool_coalesce *ldvarg259 ;
  void *tmp___17 ;
  void *ldvarg246 ;
  void *tmp___18 ;
  u32 ldvarg272 ;
  u32 tmp___19 ;
  size_t ldvarg255 ;
  size_t tmp___20 ;
  int ldvarg260 ;
  int tmp___21 ;
  u8 ldvarg274 ;
  u8 tmp___22 ;
  u32 ldvarg258 ;
  u32 tmp___23 ;
  loff_t ldvarg280 ;
  loff_t tmp___24 ;
  void *ldvarg262 ;
  void *tmp___25 ;
  void *ldvarg271 ;
  void *tmp___26 ;
  char *ldvarg281 ;
  void *tmp___27 ;
  char *ldvarg257 ;
  void *tmp___28 ;
  u8 ldvarg244 ;
  u8 tmp___29 ;
  u32 ldvarg263 ;
  u32 tmp___30 ;
  u8 ldvarg266 ;
  u8 tmp___31 ;
  u32 ldvarg278 ;
  u32 tmp___32 ;
  u32 ldvarg247 ;
  u32 tmp___33 ;
  u16 ldvarg268 ;
  u16 tmp___34 ;
  u64 *ldvarg269 ;
  void *tmp___35 ;
  int tmp___36 ;
  {
  tmp = ldv_zalloc(72UL);
  ldvarg273 = (struct qlcnic_fw_dump *)tmp;
  tmp___0 = __VERIFIER_nondet_u32();
  ldvarg253 = tmp___0;
  tmp___1 = __VERIFIER_nondet_size_t();
  ldvarg279 = tmp___1;
  tmp___2 = ldv_zalloc(20UL);
  ldvarg283 = (struct qlcnic_pci_info *)tmp___2;
  tmp___3 = ldv_zalloc(1UL);
  ldvarg267 = (u8 *)tmp___3;
  tmp___4 = ldv_zalloc(4UL);
  ldvarg249 = (int *)tmp___4;
  tmp___5 = ldv_zalloc(1UL);
  ldvarg276 = (u8 *)tmp___5;
  tmp___6 = __VERIFIER_nondet_int();
  ldvarg265 = tmp___6;
  tmp___7 = ldv_zalloc(1UL);
  ldvarg251 = tmp___7;
  tmp___8 = __VERIFIER_nondet_int();
  ldvarg282 = tmp___8;
  tmp___9 = __VERIFIER_nondet_u32();
  ldvarg264 = tmp___9;
  tmp___10 = __VERIFIER_nondet_int();
  ldvarg252 = tmp___10;
  tmp___11 = __VERIFIER_nondet_loff_t();
  ldvarg256 = tmp___11;
  tmp___12 = __VERIFIER_nondet_u32();
  ldvarg261 = tmp___12;
  tmp___13 = __VERIFIER_nondet_int();
  ldvarg245 = tmp___13;
  tmp___14 = __VERIFIER_nondet_int();
  ldvarg248 = tmp___14;
  tmp___15 = ldv_zalloc(1UL);
  ldvarg277 = tmp___15;
  tmp___16 = __VERIFIER_nondet_u16();
  ldvarg275 = tmp___16;
  tmp___17 = ldv_zalloc(92UL);
  ldvarg259 = (struct ethtool_coalesce *)tmp___17;
  tmp___18 = ldv_zalloc(1UL);
  ldvarg246 = tmp___18;
  tmp___19 = __VERIFIER_nondet_u32();
  ldvarg272 = tmp___19;
  tmp___20 = __VERIFIER_nondet_size_t();
  ldvarg255 = tmp___20;
  tmp___21 = __VERIFIER_nondet_int();
  ldvarg260 = tmp___21;
  tmp___22 = __VERIFIER_nondet_u8();
  ldvarg274 = tmp___22;
  tmp___23 = __VERIFIER_nondet_u32();
  ldvarg258 = tmp___23;
  tmp___24 = __VERIFIER_nondet_loff_t();
  ldvarg280 = tmp___24;
  tmp___25 = ldv_zalloc(1UL);
  ldvarg262 = tmp___25;
  tmp___26 = ldv_zalloc(1UL);
  ldvarg271 = tmp___26;
  tmp___27 = ldv_zalloc(1UL);
  ldvarg281 = (char *)tmp___27;
  tmp___28 = ldv_zalloc(1UL);
  ldvarg257 = (char *)tmp___28;
  tmp___29 = __VERIFIER_nondet_u8();
  ldvarg244 = tmp___29;
  tmp___30 = __VERIFIER_nondet_u32();
  ldvarg263 = tmp___30;
  tmp___31 = __VERIFIER_nondet_u8();
  ldvarg266 = tmp___31;
  tmp___32 = __VERIFIER_nondet_u32();
  ldvarg278 = tmp___32;
  tmp___33 = __VERIFIER_nondet_u32();
  ldvarg247 = tmp___33;
  tmp___34 = __VERIFIER_nondet_u16();
  ldvarg268 = tmp___34;
  tmp___35 = ldv_zalloc(8UL);
  ldvarg269 = (u64 *)tmp___35;
  memset((void *)(& ldvarg250), 0, 8UL);
  memset((void *)(& ldvarg270), 0, 4UL);
  memset((void *)(& ldvarg254), 0, 8UL);
  tmp___36 = __VERIFIER_nondet_int();
  switch (tmp___36) {
  case 0: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_pci_info(qlcnic_83xx_hw_ops_group3, ldvarg283);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_pci_info(qlcnic_83xx_hw_ops_group3, ldvarg283);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 1: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_enable_tx_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_enable_tx_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 2: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_create_tx_ctx(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0,
                              ldvarg282);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_create_tx_ctx(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0,
                              ldvarg282);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 3: ;
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_read_crb(qlcnic_83xx_hw_ops_group3, ldvarg281, ldvarg280, ldvarg279);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 4: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_store_cap_mask(ldvarg277, ldvarg278);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_store_cap_mask(ldvarg277, ldvarg278);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 5: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_sre_macaddr_change(qlcnic_83xx_hw_ops_group3, ldvarg276, (int )ldvarg275,
                                   (int )ldvarg274);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_sre_macaddr_change(qlcnic_83xx_hw_ops_group3, ldvarg276, (int )ldvarg275,
                                   (int )ldvarg274);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 6: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_82xx_free_mac_list(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_82xx_free_mac_list(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 7: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_cache_tmpl_hdr_values(ldvarg273);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_cache_tmpl_hdr_values(ldvarg273);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 8: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_saved_state(ldvarg271, ldvarg272);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_saved_state(ldvarg271, ldvarg272);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 9: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_set_nic_info(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group1);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_set_nic_info(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group1);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 10: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_io_error_detected(qlcnic_83xx_hw_ops_group5, ldvarg270);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_io_error_detected(qlcnic_83xx_hw_ops_group5, ldvarg270);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 11: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_add_sysfs(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_add_sysfs(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 12: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_change_l2_filter(qlcnic_83xx_hw_ops_group3, ldvarg269, (int )ldvarg268);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_change_l2_filter(qlcnic_83xx_hw_ops_group3, ldvarg269, (int )ldvarg268);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 13: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_mac_address(qlcnic_83xx_hw_ops_group3, ldvarg267, (int )ldvarg266);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_mac_address(qlcnic_83xx_hw_ops_group3, ldvarg267, (int )ldvarg266);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 14: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_set_mac_filter_count(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_set_mac_filter_count(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 15: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_config_hw_lro(qlcnic_83xx_hw_ops_group3, ldvarg265);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_config_hw_lro(qlcnic_83xx_hw_ops_group3, ldvarg265);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 16: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_func_no(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_func_no(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 17: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_set_saved_state(ldvarg262, ldvarg264, ldvarg263);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_set_saved_state(ldvarg262, ldvarg264, ldvarg263);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 18: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_setup_intr(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_setup_intr(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 19: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_cam_lock(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_cam_lock(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 20: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_disable_tx_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_disable_tx_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 21: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_alloc_mbx_args(qlcnic_83xx_hw_ops_group2, qlcnic_83xx_hw_ops_group3,
                               ldvarg261);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_alloc_mbx_args(qlcnic_83xx_hw_ops_group2, qlcnic_83xx_hw_ops_group3,
                               ldvarg261);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 22: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_beacon_state(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_beacon_state(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 23: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_del_tx_ctx(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_del_tx_ctx(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group0);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 24: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_io_slot_reset(qlcnic_83xx_hw_ops_group5);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_io_slot_reset(qlcnic_83xx_hw_ops_group5);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 25: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_setup_link_event(qlcnic_83xx_hw_ops_group3, ldvarg260);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_setup_link_event(qlcnic_83xx_hw_ops_group3, ldvarg260);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 26: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_disable_sds_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group4);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_disable_sds_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group4);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 27: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_config_intr_coal(qlcnic_83xx_hw_ops_group3, ldvarg259);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_config_intr_coal(qlcnic_83xx_hw_ops_group3, ldvarg259);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 28: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_issue_cmd(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group2);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_issue_cmd(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group2);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 29: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_cam_unlock(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_cam_unlock(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 30: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_create_rx_ctx(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_create_rx_ctx(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 31: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_io_resume(qlcnic_83xx_hw_ops_group5);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_io_resume(qlcnic_83xx_hw_ops_group5);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 32: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_nic_set_promisc(qlcnic_83xx_hw_ops_group3, ldvarg258);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_nic_set_promisc(qlcnic_83xx_hw_ops_group3, ldvarg258);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 33: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_napi_enable(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_napi_enable(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 34: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_process_rcv_ring_diag(qlcnic_83xx_hw_ops_group4);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_process_rcv_ring_diag(qlcnic_83xx_hw_ops_group4);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 35: ;
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_write_crb(qlcnic_83xx_hw_ops_group3, ldvarg257, ldvarg256, ldvarg255);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 36: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_wrt_reg_indirect(qlcnic_83xx_hw_ops_group3, ldvarg254, ldvarg253);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_wrt_reg_indirect(qlcnic_83xx_hw_ops_group3, ldvarg254, ldvarg253);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 37: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_cap_size(ldvarg251, ldvarg252);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_cap_size(ldvarg251, ldvarg252);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 38: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_port_info(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_port_info(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 39: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_napi_disable(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_napi_disable(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 40: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_rd_reg_indirect(qlcnic_83xx_hw_ops_group3, ldvarg250, ldvarg249);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_rd_reg_indirect(qlcnic_83xx_hw_ops_group3, ldvarg250, ldvarg249);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 41: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_set_sys_info(ldvarg246, ldvarg248, ldvarg247);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_set_sys_info(ldvarg246, ldvarg248, ldvarg247);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 42: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_remove_sysfs(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_remove_sysfs(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 43: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_enable_sds_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group4);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_enable_sds_intr(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group4);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 44: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_config_rss(qlcnic_83xx_hw_ops_group3, ldvarg245);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_config_rss(qlcnic_83xx_hw_ops_group3, ldvarg245);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 45: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_del_rx_ctx(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_del_rx_ctx(qlcnic_83xx_hw_ops_group3);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 46: ;
  if (ldv_state_variable_8 == 1) {
    qlcnic_83xx_get_nic_info(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group1,
                             (int )ldvarg244);
    ldv_state_variable_8 = 1;
  } else {
  }
  if (ldv_state_variable_8 == 2) {
    qlcnic_83xx_get_nic_info(qlcnic_83xx_hw_ops_group3, qlcnic_83xx_hw_ops_group1,
                             (int )ldvarg244);
    ldv_state_variable_8 = 2;
  } else {
  }
  goto ldv_52830;
  case 47: ;
  if (ldv_state_variable_8 == 2) {
    ldv_release_8();
    ldv_state_variable_8 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_52830;
  case 48: ;
  if (ldv_state_variable_8 == 1) {
    ldv_probe_8();
    ldv_state_variable_8 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_52830;
  default:
  ldv_stop();
  }
  ldv_52830: ;
  return;
}
}
void ldv_main_exported_6(void)
{
  unsigned long *ldvarg223 ;
  void *tmp ;
  u8 ldvarg224 ;
  u8 tmp___0 ;
  int tmp___1 ;
  {
  tmp = ldv_zalloc(8UL);
  ldvarg223 = (unsigned long *)tmp;
  tmp___0 = __VERIFIER_nondet_u8();
  ldvarg224 = tmp___0;
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_6 == 1) {
    qlcnic_83xx_signal_mbx_cmd(qlcnic_83xx_mbx_ops_group0, (int )ldvarg224);
    ldv_state_variable_6 = 1;
  } else {
  }
  goto ldv_52886;
  case 1: ;
  if (ldv_state_variable_6 == 1) {
    qlcnic_83xx_decode_mbx_rsp(qlcnic_83xx_mbx_ops_group0, qlcnic_83xx_mbx_ops_group1);
    ldv_state_variable_6 = 1;
  } else {
  }
  goto ldv_52886;
  case 2: ;
  if (ldv_state_variable_6 == 1) {
    qlcnic_83xx_enqueue_mbx_cmd(qlcnic_83xx_mbx_ops_group0, qlcnic_83xx_mbx_ops_group1,
                                ldvarg223);
    ldv_state_variable_6 = 1;
  } else {
  }
  goto ldv_52886;
  case 3: ;
  if (ldv_state_variable_6 == 1) {
    qlcnic_83xx_encode_mbx_cmd(qlcnic_83xx_mbx_ops_group0, qlcnic_83xx_mbx_ops_group1);
    ldv_state_variable_6 = 1;
  } else {
  }
  goto ldv_52886;
  case 4: ;
  if (ldv_state_variable_6 == 1) {
    qlcnic_83xx_dequeue_mbx_cmd(qlcnic_83xx_mbx_ops_group0, qlcnic_83xx_mbx_ops_group1);
    ldv_state_variable_6 = 1;
  } else {
  }
  goto ldv_52886;
  default:
  ldv_stop();
  }
  ldv_52886: ;
  return;
}
}
void ldv_main_exported_7(void)
{
  __be32 ldvarg46 ;
  struct net_device *ldvarg44 ;
  void *tmp ;
  struct pci_dev *ldvarg40 ;
  void *tmp___0 ;
  u32 ldvarg42 ;
  u32 tmp___1 ;
  u32 ldvarg43 ;
  u32 tmp___2 ;
  u32 ldvarg41 ;
  u32 tmp___3 ;
  u32 ldvarg39 ;
  u32 tmp___4 ;
  int ldvarg45 ;
  int tmp___5 ;
  int tmp___6 ;
  {
  tmp = ldv_zalloc(3264UL);
  ldvarg44 = (struct net_device *)tmp;
  tmp___0 = ldv_zalloc(2976UL);
  ldvarg40 = (struct pci_dev *)tmp___0;
  tmp___1 = __VERIFIER_nondet_u32();
  ldvarg42 = tmp___1;
  tmp___2 = __VERIFIER_nondet_u32();
  ldvarg43 = tmp___2;
  tmp___3 = __VERIFIER_nondet_u32();
  ldvarg41 = tmp___3;
  tmp___4 = __VERIFIER_nondet_u32();
  ldvarg39 = tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  ldvarg45 = tmp___5;
  memset((void *)(& ldvarg46), 0, 4UL);
  tmp___6 = __VERIFIER_nondet_int();
  switch (tmp___6) {
  case 0: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_83xx_config_ipaddr(qlcnic_83xx_ops_group0, ldvarg46, ldvarg45);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_83xx_config_ipaddr(qlcnic_83xx_ops_group0, ldvarg46, ldvarg45);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_83xx_config_ipaddr(qlcnic_83xx_ops_group0, ldvarg46, ldvarg45);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_83xx_config_ipaddr(qlcnic_83xx_ops_group0, ldvarg46, ldvarg45);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 1: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_83xx_napi_add(qlcnic_83xx_ops_group0, ldvarg44);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_83xx_napi_add(qlcnic_83xx_ops_group0, ldvarg44);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_83xx_napi_add(qlcnic_83xx_ops_group0, ldvarg44);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_83xx_napi_add(qlcnic_83xx_ops_group0, ldvarg44);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 2: ;
  if (ldv_state_variable_7 == 4) {
    ldv_retval_4 = qlcnic_83xx_resume(qlcnic_83xx_ops_group0);
    if (ldv_retval_4 == 0) {
      ldv_state_variable_7 = 2;
    } else {
    }
  } else {
  }
  goto ldv_52904;
  case 3: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_config_bridged_mode(qlcnic_83xx_ops_group0, ldvarg43);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_config_bridged_mode(qlcnic_83xx_ops_group0, ldvarg43);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_config_bridged_mode(qlcnic_83xx_ops_group0, ldvarg43);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_config_bridged_mode(qlcnic_83xx_ops_group0, ldvarg43);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 4: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_config_led(qlcnic_83xx_ops_group0, ldvarg42, ldvarg41);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_config_led(qlcnic_83xx_ops_group0, ldvarg42, ldvarg41);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_config_led(qlcnic_83xx_ops_group0, ldvarg42, ldvarg41);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_config_led(qlcnic_83xx_ops_group0, ldvarg42, ldvarg41);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 5: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 6: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_83xx_napi_del(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_83xx_napi_del(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_83xx_napi_del(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_83xx_napi_del(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 7: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_83xx_shutdown(ldvarg40);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_83xx_shutdown(ldvarg40);
    ldv_state_variable_7 = 3;
  } else {
  }
  goto ldv_52904;
  case 8: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_83xx_idc_request_reset(qlcnic_83xx_ops_group0, ldvarg39);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_83xx_idc_request_reset(qlcnic_83xx_ops_group0, ldvarg39);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_83xx_idc_request_reset(qlcnic_83xx_ops_group0, ldvarg39);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_83xx_idc_request_reset(qlcnic_83xx_ops_group0, ldvarg39);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 9: ;
  if (ldv_state_variable_7 == 4) {
    qlcnic_83xx_idc_exit(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 4;
  } else {
  }
  if (ldv_state_variable_7 == 1) {
    qlcnic_83xx_idc_exit(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    qlcnic_83xx_idc_exit(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 3;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    qlcnic_83xx_idc_exit(qlcnic_83xx_ops_group0);
    ldv_state_variable_7 = 2;
  } else {
  }
  goto ldv_52904;
  case 10: ;
  if (ldv_state_variable_7 == 2) {
    ldv_suspend_7();
    ldv_state_variable_7 = 4;
  } else {
  }
  goto ldv_52904;
  case 11: ;
  if (ldv_state_variable_7 == 4) {
    ldv_release_7();
    ldv_state_variable_7 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  if (ldv_state_variable_7 == 3) {
    ldv_release_7();
    ldv_state_variable_7 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  if (ldv_state_variable_7 == 2) {
    ldv_release_7();
    ldv_state_variable_7 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_52904;
  case 12: ;
  if (ldv_state_variable_7 == 1) {
    ldv_probe_7();
    ldv_state_variable_7 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_52904;
  default:
  ldv_stop();
  }
  ldv_52904: ;
  return;
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )
{
  {
  ldv_spin_unlock();
  ldv_spin_unlock_irqrestore_382(lock, flags);
  return;
}
}
void *ldv_kmem_cache_alloc_390(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_396(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_398(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_400(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_401(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_402(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_403(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_404(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_405(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_406(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_407(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_vzalloc_408(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
extern char *strncpy(char * , char const * , __kernel_size_t ) ;
void *ldv_vzalloc_454(unsigned long ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_436(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_453(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
extern void __udelay(unsigned long ) ;
struct sk_buff *ldv_skb_clone_444(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_452(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_446(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_442(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_450(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_451(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_447(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_448(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_449(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
int qlcnic_83xx_idc_ready_state_entry(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_idc_vnic_pf_entry(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_disable_vnic_mode(struct qlcnic_adapter *adapter , int lock ) ;
int qlcnic_83xx_config_vnic_opmode(struct qlcnic_adapter *adapter ) ;
int qlcnic_83xx_configure_opmode(struct qlcnic_adapter *adapter ) ;
__inline static int qlcnic_check_diag_status(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = constant_test_bit(13L, (unsigned long const volatile *)(& adapter->state));
  return (tmp);
}
}
int qlcnic_sriov_vf_init(struct qlcnic_adapter *adapter , int pci_using_dac ) ;
void qlcnic_sriov_pf_reset(struct qlcnic_adapter *adapter ) ;
int qlcnic_sriov_pf_reinit(struct qlcnic_adapter *adapter ) ;
static int qlcnic_83xx_init_default_driver(struct qlcnic_adapter *adapter ) ;
static int qlcnic_83xx_check_heartbeat(struct qlcnic_adapter *p_dev ) ;
static int qlcnic_83xx_restart_hw(struct qlcnic_adapter *adapter ) ;
static int qlcnic_83xx_check_hw_status(struct qlcnic_adapter *p_dev ) ;
static int qlcnic_83xx_get_reset_instruction_template(struct qlcnic_adapter *p_dev ) ;
static void qlcnic_83xx_stop_hw(struct qlcnic_adapter *p_dev ) ;
static char const * const qlc_83xx_idc_states[8U] =
  { "Unknown", "Cold", "Init", "Ready",
        "Need Reset", "Need Quiesce", "Failed", "Quiesce"};
static int qlcnic_83xx_idc_check_driver_presence_reg(struct qlcnic_adapter *adapter )
{
  u32 val ;
  {
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
  if ((val & 65535U) != 0U) {
    return (1);
  } else {
    return (0);
  }
}
}
static void qlcnic_83xx_idc_log_state_history(struct qlcnic_adapter *adapter )
{
  u32 cur ;
  u32 prev ;
  {
  cur = (u32 )(adapter->ahw)->idc.curr_state;
  prev = (u32 )(adapter->ahw)->idc.prev_state;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "current state  = %s,  prev state = %s\n",
            *((adapter->ahw)->idc.name + (unsigned long )cur), *((adapter->ahw)->idc.name + (unsigned long )prev));
  return;
}
}
static int qlcnic_83xx_idc_update_audit_reg(struct qlcnic_adapter *adapter , u8 mode ,
                                            int lock )
{
  u32 val ;
  int seconds ;
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 16UL));
  val = ((u32 )adapter->portnum & 15U) | val;
  val = (u32 )((int )mode << 7) | val;
  if ((unsigned int )mode != 0U) {
    seconds = (int )((unsigned int )((unsigned long )jiffies / 250UL) - (unsigned int )(adapter->ahw)->idc.sec_counter);
  } else {
    seconds = (int )((unsigned long )jiffies / 250UL);
  }
  val = (u32 )(seconds << 8) | val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 16UL));
  (adapter->ahw)->idc.sec_counter = (u64 )((unsigned long )jiffies / 250UL);
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static void qlcnic_83xx_idc_update_minor_version(struct qlcnic_adapter *adapter )
{
  u32 val ;
  {
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 17UL));
  val = (u32 )(~ (3 << (int )adapter->portnum * 2)) & val;
  val = val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 17UL));
  return;
}
}
static int qlcnic_83xx_idc_update_major_version(struct qlcnic_adapter *adapter , int lock )
{
  u32 val ;
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 11UL));
  val = val & 4294967040U;
  val = val | 1U;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 11UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_update_drv_presence_reg(struct qlcnic_adapter *adapter ,
                                                   int status , int lock )
{
  u32 val ;
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
  if (status != 0) {
    val = (u32 )(1 << (int )adapter->portnum) | val;
  } else {
    val = (u32 )(~ (1 << (int )adapter->portnum)) & val;
  }
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
  qlcnic_83xx_idc_update_minor_version(adapter);
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_check_major_version(struct qlcnic_adapter *adapter )
{
  u32 val ;
  u8 version ;
  {
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 11UL));
  version = (u8 )val;
  if ((unsigned int )version != 1U) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s:mismatch. version 0x%x, expected version 0x%x\n",
              "qlcnic_83xx_idc_check_major_version", (int )version, 1);
    return (-5);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_clear_registers(struct qlcnic_adapter *adapter , int lock )
{
  u32 val ;
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 14UL));
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  val = val & 4294967293U;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_update_drv_ack_reg(struct qlcnic_adapter *adapter , int flag ,
                                              int lock )
{
  u32 val ;
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 14UL));
  if (flag != 0) {
    val = (u32 )(1 << (int )adapter->portnum) | val;
  } else {
    val = (u32 )(~ (1 << (int )adapter->portnum)) & val;
  }
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 14UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_check_timeout(struct qlcnic_adapter *adapter , int time_limit )
{
  u64 seconds ;
  {
  seconds = (unsigned long long )((unsigned long )jiffies / 250UL) - (adapter->ahw)->idc.sec_counter;
  if ((u64 )time_limit >= seconds) {
    return (0);
  } else {
    return (-16);
  }
}
}
static int qlcnic_83xx_idc_check_reset_ack_reg(struct qlcnic_adapter *adapter )
{
  int timeout ;
  u32 ack ;
  u32 presence ;
  u32 val ;
  int tmp ;
  int tmp___0 ;
  {
  timeout = 10;
  ack = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 14UL));
  presence = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: ack = 0x%x, presence = 0x%x\n",
            "qlcnic_83xx_idc_check_reset_ack_reg", ack, presence);
  if ((ack & presence) != presence) {
    tmp___0 = qlcnic_83xx_idc_check_timeout(adapter, timeout);
    if (tmp___0 != 0) {
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: ACK wait exceeds time limit\n",
                "qlcnic_83xx_idc_check_reset_ack_reg");
      val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
      val = ~ (ack ^ presence) & val;
      tmp = qlcnic_83xx_lock_driver(adapter);
      if (tmp != 0) {
        return (-16);
      } else {
      }
      writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: updated drv presence reg = 0x%x\n",
                "qlcnic_83xx_idc_check_reset_ack_reg", val);
      qlcnic_83xx_unlock_driver(adapter);
      return (0);
    } else {
      return (1);
    }
  } else {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: Reset ACK received from all functions\n",
              "qlcnic_83xx_idc_check_reset_ack_reg");
    return (0);
  }
}
}
static int qlcnic_83xx_idc_tx_soft_reset(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  int tmp ;
  {
  netdev = adapter->netdev;
  tmp = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    return (-16);
  } else {
  }
  netif_device_detach(netdev);
  qlcnic_down(adapter, netdev);
  qlcnic_up(adapter, netdev);
  netif_device_attach(netdev);
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  netdev_info((struct net_device const *)adapter->netdev, "%s: soft reset complete.\n",
              "qlcnic_83xx_idc_tx_soft_reset");
  return (0);
}
}
static void qlcnic_83xx_idc_detach_driver(struct qlcnic_adapter *adapter )
{
  int i ;
  struct net_device *netdev ;
  bool tmp ;
  {
  netdev = adapter->netdev;
  netif_device_detach(netdev);
  qlcnic_83xx_detach_mailbox_work(adapter);
  qlcnic_83xx_disable_mbx_intr(adapter);
  qlcnic_down(adapter, netdev);
  i = 0;
  goto ldv_51198;
  ldv_51197:
  ((adapter->ahw)->intr_tbl + (unsigned long )i)->id = (u16 )i;
  ((adapter->ahw)->intr_tbl + (unsigned long )i)->enabled = 0U;
  ((adapter->ahw)->intr_tbl + (unsigned long )i)->src = 0U;
  i = i + 1;
  ldv_51198: ;
  if ((int )(adapter->ahw)->num_msix > i) {
    goto ldv_51197;
  } else {
  }
  tmp = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp) {
    qlcnic_sriov_pf_reset(adapter);
  } else {
  }
  return;
}
}
static void qlcnic_83xx_idc_attach_driver(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  int tmp ;
  bool tmp___0 ;
  {
  netdev = adapter->netdev;
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    tmp = qlcnic_up(adapter, netdev);
    if (tmp != 0) {
      goto done;
    } else {
    }
    qlcnic_restore_indev_addr(netdev, 1UL);
  } else {
  }
  done:
  netif_device_attach(netdev);
  return;
}
}
static int qlcnic_83xx_idc_enter_failed_state(struct qlcnic_adapter *adapter , int lock )
{
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  qlcnic_83xx_idc_clear_registers(adapter, 0);
  writel(6U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  qlcnic_83xx_idc_log_state_history(adapter);
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Device will enter failed state\n");
  return (0);
}
}
static int qlcnic_83xx_idc_enter_init_state(struct qlcnic_adapter *adapter , int lock )
{
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  writel(2U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_enter_need_quiesce(struct qlcnic_adapter *adapter , int lock )
{
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  writel(5U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_enter_need_reset_state(struct qlcnic_adapter *adapter ,
                                                  int lock )
{
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  writel(4U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_enter_ready_state(struct qlcnic_adapter *adapter , int lock )
{
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  writel(3U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_find_reset_owner_id(struct qlcnic_adapter *adapter )
{
  u32 reg ;
  u32 reg1 ;
  u32 reg2 ;
  u32 i ;
  u32 j ;
  u32 owner ;
  u32 class ;
  u32 tmp ;
  {
  reg1 = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 35UL));
  reg2 = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 36UL));
  owner = 1U;
  i = 0U;
  j = 0U;
  reg = reg1;
  ldv_51236:
  class = (((u32 )(15 << (int )(j * 4U)) & reg) >> (int )(j * 4U)) & 3U;
  if (class == owner) {
    goto ldv_51235;
  } else {
  }
  if (i == 7U) {
    reg = reg2;
    j = 0U;
  } else {
    j = j + 1U;
  }
  if (i == 15U) {
    if (owner == 1U) {
      owner = 3U;
    } else
    if (owner == 3U) {
      owner = 2U;
    } else
    if (owner == 2U) {
      return (-5);
    } else {
    }
    reg = reg1;
    j = 0U;
    i = 0U;
  } else {
  }
  tmp = i;
  i = i + 1U;
  if (tmp <= 15U) {
    goto ldv_51236;
  } else {
  }
  ldv_51235: ;
  return ((int )i);
}
}
static int qlcnic_83xx_idc_restart_hw(struct qlcnic_adapter *adapter , int lock )
{
  int ret ;
  {
  ret = 0;
  ret = qlcnic_83xx_restart_hw(adapter);
  if (ret != 0) {
    qlcnic_83xx_idc_enter_failed_state(adapter, lock);
  } else {
    qlcnic_83xx_idc_clear_registers(adapter, lock);
    ret = qlcnic_83xx_idc_enter_ready_state(adapter, lock);
  }
  return (ret);
}
}
static int qlcnic_83xx_idc_check_fan_failure(struct qlcnic_adapter *adapter )
{
  u32 status ;
  {
  status = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl));
  if ((int )status < 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "peg halt status1=0x%x\n",
            status);
    if (((status >> 8) & 2097151U) == 22U) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "On board active cooling fan failed. Device has been halted.\n");
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Replace the adapter.\n");
      return (-5);
    } else {
    }
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_idc_reattach_driver(struct qlcnic_adapter *adapter )
{
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  qlcnic_83xx_reinit_mbx_work((adapter->ahw)->mailbox);
  qlcnic_83xx_enable_mbx_interrupt(adapter);
  qlcnic_83xx_initialize_nic(adapter, 1);
  err = qlcnic_sriov_pf_reinit(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_83xx_enable_mbx_interrupt(adapter);
  tmp = qlcnic_83xx_configure_opmode(adapter);
  if (tmp != 0) {
    qlcnic_83xx_idc_enter_failed_state(adapter, 1);
    return (-5);
  } else {
  }
  tmp___0 = (*((adapter->nic_ops)->init_driver))(adapter);
  if (tmp___0 != 0) {
    qlcnic_83xx_idc_enter_failed_state(adapter, 1);
    return (-5);
  } else {
  }
  if ((unsigned int )adapter->portnum == 0U) {
    qlcnic_set_drv_version(adapter);
  } else {
  }
  qlcnic_dcb_get_info(adapter->dcb);
  qlcnic_83xx_idc_attach_driver(adapter);
  return (0);
}
}
static void qlcnic_83xx_idc_update_idc_params(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  qlcnic_83xx_idc_update_drv_presence_reg(adapter, 1, 1);
  qlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);
  set_bit(1L, (unsigned long volatile *)(& (adapter->ahw)->idc.status));
  ahw->idc.quiesce_req = 0U;
  ahw->idc.delay = 250ULL;
  ahw->idc.err_code = 0;
  ahw->idc.collect_dump = 0;
  ahw->reset_context = 0U;
  adapter->tx_timeo_cnt = 0U;
  ahw->idc.delay_reset = 0U;
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return;
}
}
int qlcnic_83xx_idc_ready_state_entry(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  int tmp ;
  {
  ahw = adapter->ahw;
  if ((unsigned int )ahw->idc.prev_state != 3U) {
    qlcnic_83xx_idc_update_idc_params(adapter);
    if ((unsigned int )ahw->idc.prev_state == 4U || (unsigned int )ahw->idc.prev_state == 2U) {
      tmp = qlcnic_83xx_idc_reattach_driver(adapter);
      if (tmp != 0) {
        return (-5);
      } else {
      }
    } else {
    }
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_idc_vnic_pf_entry(struct qlcnic_adapter *adapter )
{
  u32 state ;
  struct qlcnic_hardware_context *ahw ;
  u8 tmp ;
  int tmp___0 ;
  {
  ahw = adapter->ahw;
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 38UL));
  if (state != 1U) {
    tmp = ahw->idc.vnic_wait_limit;
    ahw->idc.vnic_wait_limit = (u8 )((int )ahw->idc.vnic_wait_limit - 1);
    if ((unsigned int )tmp == 0U) {
      qlcnic_83xx_idc_enter_failed_state(adapter, 1);
      return (-5);
    } else {
    }
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "vNIC mode disabled\n");
    return (-5);
  } else
  if ((unsigned int )ahw->idc.vnic_state != 1U) {
    qlcnic_83xx_idc_update_idc_params(adapter);
    if ((unsigned int )ahw->idc.prev_state != 0U) {
      tmp___0 = qlcnic_83xx_idc_reattach_driver(adapter);
      if (tmp___0 != 0) {
        return (-5);
      } else {
      }
    } else {
    }
    (adapter->ahw)->idc.vnic_state = 1U;
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "vNIC mode enabled\n");
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_idc_unknown_state(struct qlcnic_adapter *adapter )
{
  {
  (adapter->ahw)->idc.err_code = -5;
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Device in unknown state\n",
          "qlcnic_83xx_idc_unknown_state");
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (0);
}
}
static int qlcnic_83xx_idc_cold_state_handler(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  qlcnic_83xx_idc_update_drv_presence_reg(adapter, 1, 0);
  qlcnic_83xx_idc_update_audit_reg(adapter, 1, 0);
  if (qlcnic_load_fw_file != 0) {
    qlcnic_83xx_idc_restart_hw(adapter, 0);
  } else {
    tmp = qlcnic_83xx_check_hw_status(adapter);
    if (tmp != 0) {
      qlcnic_83xx_idc_enter_failed_state(adapter, 0);
      return (-5);
    } else {
      qlcnic_83xx_idc_enter_ready_state(adapter, 0);
    }
  }
  return (0);
}
}
static int qlcnic_83xx_idc_init_state(struct qlcnic_adapter *adapter )
{
  int timeout ;
  int ret ;
  u32 owner ;
  int tmp ;
  {
  ret = 0;
  timeout = 30;
  if ((unsigned int )(adapter->ahw)->idc.prev_state == 4U) {
    tmp = qlcnic_83xx_idc_find_reset_owner_id(adapter);
    owner = (u32 )tmp;
    if ((u32 )(adapter->ahw)->pci_func == owner) {
      ret = qlcnic_83xx_idc_restart_hw(adapter, 1);
    } else {
    }
  } else {
    ret = qlcnic_83xx_idc_check_timeout(adapter, timeout);
  }
  return (ret);
}
}
static int qlcnic_83xx_idc_ready_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_mailbox *mbx ;
  int ret ;
  u32 val ;
  int tmp ;
  int tmp___0 ;
  {
  ahw = adapter->ahw;
  mbx = ahw->mailbox;
  ret = 0;
  tmp = (*(ahw->idc.state_entry))(adapter);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  tmp___0 = qlcnic_check_temp(adapter);
  if (tmp___0 != 0) {
    if (ahw->temp == 3U) {
      qlcnic_83xx_idc_check_fan_failure(adapter);
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Error: device temperature %d above limits\n",
              (adapter->ahw)->temp);
      clear_bit(2L, (unsigned long volatile *)(& mbx->status));
      set_bit(2L, (unsigned long volatile *)(& adapter->state));
      qlcnic_83xx_idc_detach_driver(adapter);
      qlcnic_83xx_idc_enter_failed_state(adapter, 1);
      return (-5);
    } else {
    }
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  ret = qlcnic_83xx_check_heartbeat(adapter);
  if (ret != 0) {
    adapter->flags = adapter->flags | 16384U;
    if ((val & 1U) == 0U) {
      clear_bit(2L, (unsigned long volatile *)(& mbx->status));
      set_bit(2L, (unsigned long volatile *)(& adapter->state));
      qlcnic_83xx_idc_enter_need_reset_state(adapter, 1);
    } else {
      netdev_info((struct net_device const *)adapter->netdev, "%s: Auto firmware recovery is disabled\n",
                  "qlcnic_83xx_idc_ready_state");
      qlcnic_83xx_idc_enter_failed_state(adapter, 1);
    }
    return (-5);
  } else {
  }
  if ((val & 2U) != 0U || ahw->idc.collect_dump != 0) {
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
    qlcnic_83xx_idc_enter_need_reset_state(adapter, 1);
    return (ret);
  } else {
  }
  if ((unsigned int )ahw->reset_context != 0U && (val & 1U) == 0U) {
    (adapter->ahw)->reset_context = 0U;
    qlcnic_83xx_idc_tx_soft_reset(adapter);
    return (ret);
  } else {
  }
  if ((unsigned int )(adapter->ahw)->idc.quiesce_req != 0U) {
    qlcnic_83xx_idc_enter_need_quiesce(adapter, 1);
    qlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);
    return (ret);
  } else {
  }
  return (ret);
}
}
static int qlcnic_83xx_idc_need_reset_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_mailbox *mbx ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  {
  mbx = (adapter->ahw)->mailbox;
  ret = 0;
  if ((unsigned int )(adapter->ahw)->idc.prev_state != 4U) {
    qlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);
    set_bit(2L, (unsigned long volatile *)(& adapter->state));
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
    if ((unsigned int )(adapter->ahw)->nic_mode == 255U) {
      qlcnic_83xx_disable_vnic_mode(adapter, 1);
    } else {
    }
    tmp = qlcnic_check_diag_status(adapter);
    if (tmp != 0) {
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: Wait for diag completion\n",
                "qlcnic_83xx_idc_need_reset_state");
      (adapter->ahw)->idc.delay_reset = 1U;
      return (0);
    } else {
      qlcnic_83xx_idc_update_drv_ack_reg(adapter, 1, 1);
      qlcnic_83xx_idc_detach_driver(adapter);
    }
  } else {
  }
  tmp___0 = qlcnic_check_diag_status(adapter);
  if (tmp___0 != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: Wait for diag completion\n",
              "qlcnic_83xx_idc_need_reset_state");
    return (-1);
  } else {
    if ((unsigned int )(adapter->ahw)->idc.delay_reset != 0U) {
      qlcnic_83xx_idc_update_drv_ack_reg(adapter, 1, 1);
      qlcnic_83xx_idc_detach_driver(adapter);
      (adapter->ahw)->idc.delay_reset = 0U;
    } else {
    }
    ret = qlcnic_83xx_idc_check_reset_ack_reg(adapter);
    if (ret != 0) {
      _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: Waiting for reset ACK\n",
                "qlcnic_83xx_idc_need_reset_state");
      return (-1);
    } else {
    }
  }
  qlcnic_83xx_idc_enter_init_state(adapter, 1);
  return (ret);
}
}
static int qlcnic_83xx_idc_need_quiesce_state(struct qlcnic_adapter *adapter )
{
  {
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: TBD\n", "qlcnic_83xx_idc_need_quiesce_state");
  return (0);
}
}
static void qlcnic_83xx_idc_failed_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  u32 val ;
  u32 owner ;
  int tmp ;
  {
  ahw = adapter->ahw;
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  if ((int )val & 1) {
    tmp = qlcnic_83xx_idc_find_reset_owner_id(adapter);
    owner = (u32 )tmp;
    if ((u32 )ahw->pci_func == owner) {
      qlcnic_83xx_stop_hw(adapter);
      qlcnic_dump_fw(adapter);
    } else {
    }
  } else {
  }
  netdev_warn((struct net_device const *)adapter->netdev, "%s: Reboot will be required to recover the adapter!!\n",
              "qlcnic_83xx_idc_failed_state");
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  ahw->idc.err_code = -5;
  return;
}
}
static int qlcnic_83xx_idc_quiesce_state(struct qlcnic_adapter *adapter )
{
  {
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: TBD\n", "qlcnic_83xx_idc_quiesce_state");
  return (0);
}
}
static int qlcnic_83xx_idc_check_state_validity(struct qlcnic_adapter *adapter , u32 state )
{
  u32 cur ;
  u32 prev ;
  u32 next ;
  {
  cur = (u32 )(adapter->ahw)->idc.curr_state;
  prev = (u32 )(adapter->ahw)->idc.prev_state;
  next = state;
  if (next == 0U || next > 7U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: curr %d, prev %d, next state %d is  invalid\n",
            "qlcnic_83xx_idc_check_state_validity", cur, prev, state);
    return (1);
  } else {
  }
  if (cur == 0U && prev == 0U) {
    if (next != 1U && next != 3U) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed, cur %d prev %d next %d\n",
              "qlcnic_83xx_idc_check_state_validity", cur, prev, next);
      return (1);
    } else {
    }
  } else {
  }
  if (next == 2U) {
    if ((prev != 2U && prev != 1U) && prev != 4U) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: failed, cur %d prev %d next %d\n",
              "qlcnic_83xx_idc_check_state_validity", cur, prev, next);
      return (1);
    } else {
    }
  } else {
  }
  return (0);
}
}
static int qlcnic_set_vxlan_port(struct qlcnic_adapter *adapter )
{
  u16 port ;
  struct qlcnic_cmd_args cmd ;
  int ret ;
  {
  port = (adapter->ahw)->vxlan_port;
  ret = 0;
  memset((void *)(& cmd), 0, 200UL);
  ret = qlcnic_alloc_mbx_args(& cmd, adapter, 96U);
  if (ret != 0) {
    return (ret);
  } else {
  }
  *(cmd.req.arg + 1UL) = 536870912U;
  *(cmd.req.arg + 2UL) = (u32 )(((int )port << 16) | 10);
  ret = qlcnic_issue_cmd(adapter, & cmd);
  if (ret != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "Failed to set VXLAN port %d in adapter\n",
               (int )port);
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (ret);
}
}
static int qlcnic_set_vxlan_parsing(struct qlcnic_adapter *adapter , bool state )
{
  u16 vxlan_port ;
  struct qlcnic_cmd_args cmd ;
  int ret ;
  {
  vxlan_port = (adapter->ahw)->vxlan_port;
  ret = 0;
  memset((void *)(& cmd), 0, 200UL);
  ret = qlcnic_alloc_mbx_args(& cmd, adapter, 78U);
  if (ret != 0) {
    return (ret);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )state;
  ret = qlcnic_issue_cmd(adapter, & cmd);
  if (ret != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "Failed to %s VXLAN parsing for port %d\n",
               (int )state ? (char *)"enable" : (char *)"disable", (int )vxlan_port);
  } else {
    netdev_info((struct net_device const *)adapter->netdev, "%s VXLAN parsing for port %d\n",
                (int )state ? (char *)"Enabled" : (char *)"Disabled", (int )vxlan_port);
  }
  qlcnic_free_mbx_args(& cmd);
  return (ret);
}
}
static void qlcnic_83xx_periodic_tasks(struct qlcnic_adapter *adapter )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if ((unsigned int )adapter->fhash.fnum != 0U) {
    qlcnic_prune_lb_filters(adapter);
  } else {
  }
  if ((adapter->flags & 1048576U) != 0U) {
    tmp = qlcnic_set_vxlan_port(adapter);
    if (tmp != 0) {
      return;
    } else {
    }
    tmp___0 = qlcnic_set_vxlan_parsing(adapter, 1);
    if (tmp___0 != 0) {
      return;
    } else {
    }
    adapter->flags = adapter->flags & 4293918719U;
  } else
  if ((adapter->flags & 2097152U) != 0U) {
    tmp___1 = qlcnic_set_vxlan_parsing(adapter, 0);
    if (tmp___1 != 0) {
      return;
    } else {
    }
    (adapter->ahw)->vxlan_port = 0U;
    adapter->flags = adapter->flags & 4292870143U;
  } else {
  }
  return;
}
}
void qlcnic_83xx_idc_poll_dev_state(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  u32 state ;
  struct work_struct const *__mptr ;
  int tmp ;
  int tmp___0 ;
  {
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffc78UL;
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  tmp = qlcnic_83xx_idc_check_state_validity(adapter, state);
  if (tmp != 0) {
    qlcnic_83xx_idc_log_state_history(adapter);
    (adapter->ahw)->idc.curr_state = 0U;
  } else {
    (adapter->ahw)->idc.curr_state = (u8 )state;
  }
  switch ((int )(adapter->ahw)->idc.curr_state) {
  case 3:
  qlcnic_83xx_idc_ready_state(adapter);
  goto ldv_51337;
  case 4:
  qlcnic_83xx_idc_need_reset_state(adapter);
  goto ldv_51337;
  case 5:
  qlcnic_83xx_idc_need_quiesce_state(adapter);
  goto ldv_51337;
  case 6:
  qlcnic_83xx_idc_failed_state(adapter);
  return;
  case 2:
  qlcnic_83xx_idc_init_state(adapter);
  goto ldv_51337;
  case 7:
  qlcnic_83xx_idc_quiesce_state(adapter);
  goto ldv_51337;
  default:
  qlcnic_83xx_idc_unknown_state(adapter);
  return;
  }
  ldv_51337:
  (adapter->ahw)->idc.prev_state = (adapter->ahw)->idc.curr_state;
  qlcnic_83xx_periodic_tasks(adapter);
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& (adapter->ahw)->idc.status));
  if (tmp___0 != 0) {
    qlcnic_schedule_work(adapter, & qlcnic_83xx_idc_poll_dev_state, (int )(adapter->ahw)->idc.delay);
  } else {
  }
  return;
}
}
static void qlcnic_83xx_setup_idc_parameters(struct qlcnic_adapter *adapter )
{
  u32 idc_params ;
  u32 val ;
  int tmp ;
  {
  tmp = qlcnic_83xx_lockless_flash_read32(adapter, 4096032U, (u8 *)(& idc_params),
                                          1);
  if (tmp != 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s:failed to get IDC params from flash\n",
              "qlcnic_83xx_setup_idc_parameters");
    adapter->dev_init_timeo = 30U;
    adapter->reset_ack_timeo = 10U;
  } else {
    adapter->dev_init_timeo = (u8 )idc_params;
    adapter->reset_ack_timeo = (u8 )(idc_params >> 16);
  }
  (adapter->ahw)->idc.curr_state = 0U;
  (adapter->ahw)->idc.prev_state = 0U;
  (adapter->ahw)->idc.delay = 250ULL;
  (adapter->ahw)->idc.err_code = 0;
  (adapter->ahw)->idc.collect_dump = 0;
  (adapter->ahw)->idc.name = (char **)(& qlc_83xx_idc_states);
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  set_bit(1L, (unsigned long volatile *)(& (adapter->ahw)->idc.status));
  if (qlcnic_auto_fw_reset == 0) {
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    val = val | 1U;
    writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  } else {
  }
  return;
}
}
static int qlcnic_83xx_idc_first_to_load_function_handler(struct qlcnic_adapter *adapter )
{
  u32 state ;
  u32 val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = qlcnic_83xx_lock_driver(adapter);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 18UL));
  tmp___0 = qlcnic_83xx_idc_update_major_version(adapter, 0);
  if (tmp___0 != 0) {
    qlcnic_83xx_unlock_driver(adapter);
    return (-5);
  } else {
  }
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  tmp___1 = qlcnic_83xx_idc_check_state_validity(adapter, state);
  if (tmp___1 != 0) {
    qlcnic_83xx_unlock_driver(adapter);
    return (-5);
  } else {
  }
  if (state != 1U && qlcnic_load_fw_file != 0) {
    writel(1U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
    state = 1U;
  } else {
  }
  (adapter->ahw)->idc.curr_state = (u8 )state;
  if (state == 1U) {
    qlcnic_83xx_idc_cold_state_handler(adapter);
  } else {
  }
  if (qlcnic_auto_fw_reset != 0) {
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    val = val & 4294967294U;
    writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  } else {
  }
  qlcnic_83xx_unlock_driver(adapter);
  return (0);
}
}
int qlcnic_83xx_idc_init(struct qlcnic_adapter *adapter )
{
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  ret = -5;
  qlcnic_83xx_setup_idc_parameters(adapter);
  tmp = qlcnic_83xx_get_reset_instruction_template(adapter);
  if (tmp != 0) {
    return (ret);
  } else {
  }
  tmp___2 = qlcnic_83xx_idc_check_driver_presence_reg(adapter);
  if (tmp___2 == 0) {
    tmp___0 = qlcnic_83xx_idc_first_to_load_function_handler(adapter);
    if (tmp___0 != 0) {
      return (-5);
    } else {
    }
  } else {
    tmp___1 = qlcnic_83xx_idc_check_major_version(adapter);
    if (tmp___1 != 0) {
      return (-5);
    } else {
    }
  }
  qlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);
  return (0);
}
}
void qlcnic_83xx_idc_exit(struct qlcnic_adapter *adapter )
{
  int id ;
  u32 val ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  {
  goto ldv_51365;
  ldv_51364:
  usleep_range(10000UL, 11000UL);
  ldv_51365:
  tmp = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    goto ldv_51364;
  } else {
  }
  tmp___0 = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
  id = (int )tmp___0;
  id = id & 255;
  if ((int )adapter->portnum == id) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: wait for lock recovery.. %d\n",
            "qlcnic_83xx_idc_exit", id);
    msleep(20U);
    tmp___1 = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 41UL));
    id = (int )tmp___1;
    id = id & 255;
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
  val = (u32 )(~ (1 << (int )adapter->portnum)) & val;
  writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
  clear_bit(1L, (unsigned long volatile *)(& (adapter->ahw)->idc.status));
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  cancel_delayed_work_sync(& adapter->fw_work);
  return;
}
}
void qlcnic_83xx_idc_request_reset(struct qlcnic_adapter *adapter , u32 key )
{
  u32 val ;
  bool tmp ;
  int tmp___0 ;
  {
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    return;
  } else {
  }
  tmp___0 = qlcnic_83xx_lock_driver(adapter);
  if (tmp___0 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s:failed, please retry\n",
            "qlcnic_83xx_idc_request_reset");
    return;
  } else {
  }
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  if ((int )val & 1) {
    netdev_info((struct net_device const *)adapter->netdev, "%s: Auto firmware recovery is disabled\n",
                "qlcnic_83xx_idc_request_reset");
    qlcnic_83xx_idc_enter_failed_state(adapter, 0);
    qlcnic_83xx_unlock_driver(adapter);
    return;
  } else {
  }
  if (key == 3735936685U) {
    val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
    val = val | 2U;
    writel(val, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  } else
  if (key == 3735944941U) {
    (adapter->ahw)->idc.collect_dump = 1;
  } else {
  }
  qlcnic_83xx_unlock_driver(adapter);
  return;
}
}
static int qlcnic_83xx_copy_bootloader(struct qlcnic_adapter *adapter )
{
  u8 *p_cache ;
  u32 src ;
  u32 size ;
  u64 dest ;
  int ret ;
  unsigned int tmp ;
  void *tmp___0 ;
  {
  ret = -5;
  src = 65536U;
  tmp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 5UL));
  dest = (u64 )tmp;
  size = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 6UL));
  if ((size & 15U) != 0U) {
    size = (size + 16U) & 4294967280U;
  } else {
  }
  tmp___0 = ldv_vzalloc_454((unsigned long )size);
  p_cache = (u8 *)tmp___0;
  if ((unsigned long )p_cache == (unsigned long )((u8 *)0U)) {
    return (-12);
  } else {
  }
  ret = qlcnic_83xx_lockless_flash_read32(adapter, src, p_cache, (int )(size / 4U));
  if (ret != 0) {
    vfree((void const *)p_cache);
    return (ret);
  } else {
  }
  ret = qlcnic_ms_mem_write128(adapter, dest, (u32 *)p_cache, size / 16U);
  if (ret != 0) {
    vfree((void const *)p_cache);
    return (ret);
  } else {
  }
  vfree((void const *)p_cache);
  return (ret);
}
}
static int qlcnic_83xx_copy_fw_file(struct qlcnic_adapter *adapter )
{
  struct qlc_83xx_fw_info *fw_info ;
  struct firmware const *fw ;
  u32 dest ;
  u32 *p_cache ;
  int i ;
  int ret ;
  u8 data[16U] ;
  size_t size ;
  u64 addr ;
  {
  fw_info = (adapter->ahw)->fw_info;
  fw = fw_info->fw;
  ret = -5;
  dest = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 7UL));
  size = (unsigned long )fw->size & 0xfffffffffffffff0UL;
  p_cache = (u32 *)fw->data;
  addr = (unsigned long long )dest;
  ret = qlcnic_ms_mem_write128(adapter, addr, p_cache, (u32 )(size / 16UL));
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "MS memory write failed\n");
    release_firmware(fw);
    fw_info->fw = (struct firmware const *)0;
    return (-5);
  } else {
  }
  if (((unsigned long )fw->size & 15UL) != 0UL) {
    addr = (u64 )((size_t )dest + size);
    i = 0;
    goto ldv_51395;
    ldv_51394:
    data[i] = *(fw->data + ((size_t )i + size));
    i = i + 1;
    ldv_51395: ;
    if ((unsigned long )i < ((unsigned long )fw->size & 15UL)) {
      goto ldv_51394;
    } else {
    }
    goto ldv_51398;
    ldv_51397:
    data[i] = 0U;
    i = i + 1;
    ldv_51398: ;
    if (i <= 15) {
      goto ldv_51397;
    } else {
    }
    ret = qlcnic_ms_mem_write128(adapter, addr, (u32 *)(& data), 1U);
    if (ret != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "MS memory write failed\n");
      release_firmware(fw);
      fw_info->fw = (struct firmware const *)0;
      return (-5);
    } else {
    }
  } else {
  }
  release_firmware(fw);
  fw_info->fw = (struct firmware const *)0;
  return (0);
}
}
static void qlcnic_83xx_dump_pause_control_regs(struct qlcnic_adapter *adapter )
{
  int i ;
  int j ;
  u32 val ;
  u32 val1 ;
  u32 reg ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  val = 0U;
  val1 = 0U;
  reg = 0U;
  err = 0;
  tmp = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 220201604UL, & err);
  val = (u32 )tmp;
  if (err == -5) {
    return;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "SRE-Shim Ctrl:0x%x\n",
            val);
  j = 0;
  goto ldv_51413;
  ldv_51412: ;
  if (j == 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Port 0 RxB Pause Threshold Regs[TC7..TC0]:");
    reg = 186647460U;
  } else
  if (j == 1) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Port 1 RxB Pause Threshold Regs[TC7..TC0]:");
    reg = 186651556U;
  } else {
  }
  i = 0;
  goto ldv_51410;
  ldv_51409:
  tmp___0 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )((u32 )(i * 4) + reg),
                                                    & err);
  val = (u32 )tmp___0;
  if (err == -5) {
    return;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "0x%x  ", val);
  i = i + 1;
  ldv_51410: ;
  if (i <= 7) {
    goto ldv_51409;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "\n");
  j = j + 1;
  ldv_51413: ;
  if (j <= 1) {
    goto ldv_51412;
  } else {
  }
  j = 0;
  goto ldv_51419;
  ldv_51418: ;
  if (j == 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Port 0 RxB TC Max Cell Registers[4..1]:");
    reg = 186647432U;
  } else
  if (j == 1) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Port 1 RxB TC Max Cell Registers[4..1]:");
    reg = 186651528U;
  } else {
  }
  i = 0;
  goto ldv_51416;
  ldv_51415:
  tmp___1 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )((u32 )(i * 4) + reg),
                                                    & err);
  val = (u32 )tmp___1;
  if (err == -5) {
    return;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "0x%x  ", val);
  i = i + 1;
  ldv_51416: ;
  if (i <= 3) {
    goto ldv_51415;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "\n");
  j = j + 1;
  ldv_51419: ;
  if (j <= 1) {
    goto ldv_51418;
  } else {
  }
  j = 0;
  goto ldv_51425;
  ldv_51424: ;
  if (j == 0) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Port 0 RxB Rx TC Stats[TC7..TC0]:");
    reg = 186647452U;
  } else
  if (j == 1) {
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "Port 1 RxB Rx TC Stats[TC7..TC0]:");
    reg = 186651548U;
  } else {
  }
  i = 7;
  goto ldv_51422;
  ldv_51421:
  tmp___2 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )reg, & err);
  val = (u32 )tmp___2;
  if (err == -5) {
    return;
  } else {
  }
  val = val & 536870911U;
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (ulong )reg, (u32 )(i << 29) | val);
  tmp___3 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, (ulong )reg, & err);
  val = (u32 )tmp___3;
  if (err == -5) {
    return;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "0x%x  ", val);
  i = i - 1;
  ldv_51422: ;
  if (i >= 0) {
    goto ldv_51421;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "\n");
  j = j + 1;
  ldv_51425: ;
  if (j <= 1) {
    goto ldv_51424;
  } else {
  }
  tmp___4 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 186648324UL, & err);
  val = (u32 )tmp___4;
  if (err == -5) {
    return;
  } else {
  }
  tmp___5 = (*(((adapter->ahw)->hw_ops)->read_reg))(adapter, 186652420UL, & err);
  val1 = (u32 )tmp___5;
  if (err == -5) {
    return;
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "IFB-Pause Thresholds: Port 2:0x%x, Port 3:0x%x\n",
            val, val1);
  return;
}
}
static void qlcnic_83xx_disable_pause_frames(struct qlcnic_adapter *adapter )
{
  u32 reg ;
  u32 i ;
  u32 j ;
  int tmp ;
  {
  reg = 0U;
  tmp = qlcnic_83xx_lock_driver(adapter);
  if (tmp != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s:failed to acquire driver lock\n",
            "qlcnic_83xx_disable_pause_frames");
    return;
  } else {
  }
  qlcnic_83xx_dump_pause_control_regs(adapter);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 220201604UL, 0U);
  j = 0U;
  goto ldv_51438;
  ldv_51437: ;
  if (j == 0U) {
    reg = 186647460U;
  } else
  if (j == 1U) {
    reg = 186651556U;
  } else {
  }
  i = 0U;
  goto ldv_51435;
  ldv_51434:
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (ulong )(i * 4U + reg), 0U);
  i = i + 1U;
  ldv_51435: ;
  if (i <= 7U) {
    goto ldv_51434;
  } else {
  }
  j = j + 1U;
  ldv_51438: ;
  if (j <= 1U) {
    goto ldv_51437;
  } else {
  }
  j = 0U;
  goto ldv_51444;
  ldv_51443: ;
  if (j == 0U) {
    reg = 186647432U;
  } else
  if (j == 1U) {
    reg = 186651528U;
  } else {
  }
  i = 0U;
  goto ldv_51441;
  ldv_51440:
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, (ulong )(i * 4U + reg), 67044351U);
  i = i + 1U;
  ldv_51441: ;
  if (i <= 3U) {
    goto ldv_51440;
  } else {
  }
  j = j + 1U;
  ldv_51444: ;
  if (j <= 1U) {
    goto ldv_51443;
  } else {
  }
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 186648324UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 186652420UL, 0U);
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Disabled pause frames successfully on all ports\n");
  qlcnic_83xx_unlock_driver(adapter);
  return;
}
}
static void qlcnic_83xx_take_eport_out_of_reset(struct qlcnic_adapter *adapter )
{
  {
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671632992UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671633008UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671633024UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671633040UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671633056UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671633072UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671633088UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671633104UL, 0U);
  (*(((adapter->ahw)->hw_ops)->write_reg))(adapter, 671632976UL, 1U);
  return;
}
}
static int qlcnic_83xx_check_heartbeat(struct qlcnic_adapter *p_dev )
{
  u32 heartbeat ;
  u32 peg_status ;
  int retries ;
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  {
  ret = -5;
  err = 0;
  retries = 10;
  p_dev->heartbeat = readl((void const volatile *)(p_dev->ahw)->pci_base0 + (unsigned long )*((p_dev->ahw)->reg_tbl + 2UL));
  ldv_51458:
  msleep(200U);
  heartbeat = readl((void const volatile *)(p_dev->ahw)->pci_base0 + (unsigned long )*((p_dev->ahw)->reg_tbl + 2UL));
  if (p_dev->heartbeat != heartbeat) {
    ret = 0;
    goto ldv_51457;
  } else {
  }
  retries = retries - 1;
  if (retries != 0) {
    goto ldv_51458;
  } else {
  }
  ldv_51457: ;
  if (ret != 0) {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "firmware hang detected\n");
    qlcnic_83xx_take_eport_out_of_reset(p_dev);
    qlcnic_83xx_disable_pause_frames(p_dev);
    peg_status = readl((void const volatile *)(p_dev->ahw)->pci_base0 + (unsigned long )*((p_dev->ahw)->reg_tbl));
    tmp = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, 883949628UL, & err);
    tmp___0 = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, 875561020UL, & err);
    tmp___1 = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, 874512444UL, & err);
    tmp___2 = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, 873463868UL, & err);
    tmp___3 = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, 872415292UL, & err);
    tmp___4 = readl((void const volatile *)(p_dev->ahw)->pci_base0 + (unsigned long )*((p_dev->ahw)->reg_tbl + 1UL));
    _dev_info((struct device const *)(& (p_dev->pdev)->dev), "Dumping HW/FW registers\nPEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\nPEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\nPEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\nPEG_NET_4_PC: 0x%x\n",
              peg_status, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
    if (((peg_status >> 8) & 2097151U) == 103U) {
      dev_err((struct device const *)(& (p_dev->pdev)->dev), "Device is being reset err code 0x00006700.\n");
    } else {
    }
  } else {
  }
  return (ret);
}
}
static int qlcnic_83xx_check_cmd_peg_status(struct qlcnic_adapter *p_dev )
{
  int retries ;
  u32 val ;
  {
  retries = 60;
  ldv_51464:
  val = readl((void const volatile *)(p_dev->ahw)->pci_base0 + (unsigned long )*((p_dev->ahw)->reg_tbl + 16UL));
  if (val == 65281U) {
    return (0);
  } else {
  }
  msleep(500U);
  retries = retries - 1;
  if (retries != 0) {
    goto ldv_51464;
  } else {
  }
  dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: failed, state = 0x%x\n",
          "qlcnic_83xx_check_cmd_peg_status", val);
  return (-5);
}
}
static int qlcnic_83xx_check_hw_status(struct qlcnic_adapter *p_dev )
{
  int err ;
  {
  err = qlcnic_83xx_check_cmd_peg_status(p_dev);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_83xx_check_heartbeat(p_dev);
  if (err != 0) {
    return (err);
  } else {
  }
  return (err);
}
}
static int qlcnic_83xx_poll_reg(struct qlcnic_adapter *p_dev , u32 addr , int duration ,
                                u32 mask , u32 status )
{
  int timeout_error ;
  int err ;
  u32 value ;
  u8 retries ;
  int tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  {
  err = 0;
  tmp = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, (ulong )addr, & err);
  value = (u32 )tmp;
  if (err == -5) {
    return (err);
  } else {
  }
  retries = (u8 )(duration / 10);
  ldv_51483: ;
  if ((value & mask) != status) {
    timeout_error = 1;
    msleep((unsigned int )(duration / 10));
    tmp___0 = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, (ulong )addr, & err);
    value = (u32 )tmp___0;
    if (err == -5) {
      return (err);
    } else {
    }
  } else {
    timeout_error = 0;
    goto ldv_51482;
  }
  tmp___1 = retries;
  retries = (u8 )((int )retries - 1);
  if ((unsigned int )tmp___1 != 0U) {
    goto ldv_51483;
  } else {
  }
  ldv_51482: ;
  if (timeout_error != 0) {
    (p_dev->ahw)->reset.seq_error = (p_dev->ahw)->reset.seq_error + 1;
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: Timeout Err, entry_num = %d\n",
            "qlcnic_83xx_poll_reg", (p_dev->ahw)->reset.seq_index);
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "0x%08x 0x%08x 0x%08x\n",
            value, mask, status);
  } else {
  }
  return (timeout_error);
}
}
static int qlcnic_83xx_reset_template_checksum(struct qlcnic_adapter *p_dev )
{
  u32 sum ;
  u16 *buff ;
  int count ;
  u16 *tmp ;
  int tmp___0 ;
  {
  sum = 0U;
  buff = (u16 *)(p_dev->ahw)->reset.buff;
  count = (int )((unsigned int )((p_dev->ahw)->reset.hdr)->size / 2U);
  goto ldv_51492;
  ldv_51491:
  tmp = buff;
  buff = buff + 1;
  sum = (u32 )*tmp + sum;
  ldv_51492:
  tmp___0 = count;
  count = count - 1;
  if (tmp___0 > 0) {
    goto ldv_51491;
  } else {
  }
  goto ldv_51495;
  ldv_51494:
  sum = (sum & 65535U) + (sum >> 16);
  ldv_51495: ;
  if (sum >> 16 != 0U) {
    goto ldv_51494;
  } else {
  }
  if (sum != 4294967295U) {
    return (0);
  } else {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: failed\n", "qlcnic_83xx_reset_template_checksum");
    return (-1);
  }
}
}
static int qlcnic_83xx_get_reset_instruction_template(struct qlcnic_adapter *p_dev )
{
  struct qlcnic_hardware_context *ahw ;
  u32 addr ;
  u32 count ;
  u32 prev_ver ;
  u32 curr_ver ;
  u8 *p_buff ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  ahw = p_dev->ahw;
  if ((unsigned long )ahw->reset.buff != (unsigned long )((u8 *)0U)) {
    prev_ver = p_dev->fw_version;
    tmp = qlcnic_83xx_get_fw_version(p_dev);
    curr_ver = (u32 )tmp;
    if (curr_ver > prev_ver) {
      kfree((void const *)ahw->reset.buff);
    } else {
      return (0);
    }
  } else {
  }
  ahw->reset.seq_error = 0;
  tmp___0 = kzalloc(8192UL, 208U);
  ahw->reset.buff = (u8 *)tmp___0;
  if ((unsigned long )(p_dev->ahw)->reset.buff == (unsigned long )((u8 *)0U)) {
    return (-12);
  } else {
  }
  p_buff = (p_dev->ahw)->reset.buff;
  addr = 5177344U;
  count = 4U;
  tmp___1 = qlcnic_83xx_flash_read32(p_dev, addr, p_buff, (int )count);
  if (tmp___1 != 0) {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: flash read failed\n",
            "qlcnic_83xx_get_reset_instruction_template");
    return (-5);
  } else {
  }
  ahw->reset.hdr = (struct qlc_83xx_reset_hdr *)ahw->reset.buff;
  addr = (u32 )((int )(ahw->reset.hdr)->hdr_size + 5177344);
  p_buff = ahw->reset.buff + (unsigned long )(ahw->reset.hdr)->hdr_size;
  count = (u32 )((unsigned long )((int )(ahw->reset.hdr)->size - (int )(ahw->reset.hdr)->hdr_size) / 4UL);
  tmp___2 = qlcnic_83xx_flash_read32(p_dev, addr, p_buff, (int )count);
  if (tmp___2 != 0) {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: flash read failed\n",
            "qlcnic_83xx_get_reset_instruction_template");
    return (-5);
  } else {
  }
  tmp___3 = qlcnic_83xx_reset_template_checksum(p_dev);
  if (tmp___3 != 0) {
    return (-5);
  } else {
  }
  ahw->reset.init_offset = ahw->reset.buff + (unsigned long )(ahw->reset.hdr)->init_offset;
  ahw->reset.start_offset = ahw->reset.buff + (unsigned long )(ahw->reset.hdr)->start_offset;
  ahw->reset.stop_offset = ahw->reset.buff + (unsigned long )(ahw->reset.hdr)->hdr_size;
  return (0);
}
}
static void qlcnic_83xx_read_write_crb_reg(struct qlcnic_adapter *p_dev , u32 raddr ,
                                           u32 waddr )
{
  int err ;
  u32 value ;
  int tmp ;
  {
  err = 0;
  tmp = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, (ulong )raddr, & err);
  value = (u32 )tmp;
  if (err == -5) {
    return;
  } else {
  }
  qlcnic_83xx_wrt_reg_indirect(p_dev, (ulong )waddr, value);
  return;
}
}
static void qlcnic_83xx_rmw_crb_reg(struct qlcnic_adapter *p_dev , u32 raddr , u32 waddr ,
                                    struct qlc_83xx_rmw *p_rmw_hdr )
{
  int err ;
  u32 value ;
  int tmp ;
  {
  err = 0;
  if ((unsigned int )p_rmw_hdr->index_a != 0U) {
    value = (p_dev->ahw)->reset.array[(int )p_rmw_hdr->index_a];
  } else {
    tmp = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, (ulong )raddr, & err);
    value = (u32 )tmp;
    if (err == -5) {
      return;
    } else {
    }
  }
  value = p_rmw_hdr->mask & value;
  value = value << (int )p_rmw_hdr->shl;
  value = value >> (int )p_rmw_hdr->shr;
  value = p_rmw_hdr->or_value | value;
  value = p_rmw_hdr->xor_value ^ value;
  qlcnic_83xx_wrt_reg_indirect(p_dev, (ulong )waddr, value);
  return;
}
}
static void qlcnic_83xx_write_list(struct qlcnic_adapter *p_dev , struct qlc_83xx_entry_hdr *p_hdr )
{
  int i ;
  struct qlc_83xx_entry *entry ;
  {
  entry = (struct qlc_83xx_entry *)p_hdr + 8U;
  i = 0;
  goto ldv_51530;
  ldv_51529:
  qlcnic_83xx_wrt_reg_indirect(p_dev, (ulong )entry->arg1, entry->arg2);
  if ((unsigned int )p_hdr->delay != 0U) {
    __udelay((unsigned long )p_hdr->delay);
  } else {
  }
  i = i + 1;
  entry = entry + 1;
  ldv_51530: ;
  if ((int )p_hdr->count > i) {
    goto ldv_51529;
  } else {
  }
  return;
}
}
static void qlcnic_83xx_read_write_list(struct qlcnic_adapter *p_dev , struct qlc_83xx_entry_hdr *p_hdr )
{
  int i ;
  struct qlc_83xx_entry *entry ;
  {
  entry = (struct qlc_83xx_entry *)p_hdr + 8U;
  i = 0;
  goto ldv_51539;
  ldv_51538:
  qlcnic_83xx_read_write_crb_reg(p_dev, entry->arg1, entry->arg2);
  if ((unsigned int )p_hdr->delay != 0U) {
    __udelay((unsigned long )p_hdr->delay);
  } else {
  }
  i = i + 1;
  entry = entry + 1;
  ldv_51539: ;
  if ((int )p_hdr->count > i) {
    goto ldv_51538;
  } else {
  }
  return;
}
}
static void qlcnic_83xx_poll_list(struct qlcnic_adapter *p_dev , struct qlc_83xx_entry_hdr *p_hdr )
{
  long delay ;
  struct qlc_83xx_entry *entry ;
  struct qlc_83xx_poll *poll ;
  int i ;
  int err ;
  unsigned long arg1 ;
  unsigned long arg2 ;
  int tmp ;
  {
  err = 0;
  poll = (struct qlc_83xx_poll *)p_hdr + 8U;
  entry = (struct qlc_83xx_entry *)poll + 8U;
  delay = (long )p_hdr->delay;
  if (delay == 0L) {
    i = 0;
    goto ldv_51553;
    ldv_51552:
    qlcnic_83xx_poll_reg(p_dev, entry->arg1, (int )delay, poll->mask, poll->status);
    i = i + 1;
    entry = entry + 1;
    ldv_51553: ;
    if ((int )p_hdr->count > i) {
      goto ldv_51552;
    } else {
    }
  } else {
    i = 0;
    goto ldv_51556;
    ldv_51555:
    arg1 = (unsigned long )entry->arg1;
    arg2 = (unsigned long )entry->arg2;
    if (delay != 0L) {
      tmp = qlcnic_83xx_poll_reg(p_dev, (u32 )arg1, (int )delay, poll->mask, poll->status);
      if (tmp != 0) {
        (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, arg1, & err);
        if (err == -5) {
          return;
        } else {
        }
        (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, arg2, & err);
        if (err == -5) {
          return;
        } else {
        }
      } else {
      }
    } else {
    }
    i = i + 1;
    entry = entry + 1;
    ldv_51556: ;
    if ((int )p_hdr->count > i) {
      goto ldv_51555;
    } else {
    }
  }
  return;
}
}
static void qlcnic_83xx_poll_write_list(struct qlcnic_adapter *p_dev , struct qlc_83xx_entry_hdr *p_hdr )
{
  int i ;
  long delay ;
  struct qlc_83xx_quad_entry *entry ;
  struct qlc_83xx_poll *poll ;
  {
  poll = (struct qlc_83xx_poll *)p_hdr + 8U;
  entry = (struct qlc_83xx_quad_entry *)poll + 8U;
  delay = (long )p_hdr->delay;
  i = 0;
  goto ldv_51567;
  ldv_51566:
  qlcnic_83xx_wrt_reg_indirect(p_dev, (ulong )entry->dr_addr, entry->dr_value);
  qlcnic_83xx_wrt_reg_indirect(p_dev, (ulong )entry->ar_addr, entry->ar_value);
  if (delay != 0L) {
    qlcnic_83xx_poll_reg(p_dev, entry->ar_addr, (int )delay, poll->mask, poll->status);
  } else {
  }
  i = i + 1;
  entry = entry + 1;
  ldv_51567: ;
  if ((int )p_hdr->count > i) {
    goto ldv_51566;
  } else {
  }
  return;
}
}
static void qlcnic_83xx_read_modify_write(struct qlcnic_adapter *p_dev , struct qlc_83xx_entry_hdr *p_hdr )
{
  int i ;
  struct qlc_83xx_entry *entry ;
  struct qlc_83xx_rmw *rmw_hdr ;
  {
  rmw_hdr = (struct qlc_83xx_rmw *)p_hdr + 8U;
  entry = (struct qlc_83xx_entry *)rmw_hdr + 16U;
  i = 0;
  goto ldv_51577;
  ldv_51576:
  qlcnic_83xx_rmw_crb_reg(p_dev, entry->arg1, entry->arg2, rmw_hdr);
  if ((unsigned int )p_hdr->delay != 0U) {
    __udelay((unsigned long )p_hdr->delay);
  } else {
  }
  i = i + 1;
  entry = entry + 1;
  ldv_51577: ;
  if ((int )p_hdr->count > i) {
    goto ldv_51576;
  } else {
  }
  return;
}
}
static void qlcnic_83xx_pause(struct qlc_83xx_entry_hdr *p_hdr )
{
  unsigned long __ms ;
  unsigned long tmp ;
  {
  if ((unsigned int )p_hdr->delay != 0U) {
    __ms = (unsigned long )p_hdr->delay;
    goto ldv_51584;
    ldv_51583:
    __const_udelay(4295000UL);
    ldv_51584:
    tmp = __ms;
    __ms = __ms - 1UL;
    if (tmp != 0UL) {
      goto ldv_51583;
    } else {
    }
  } else {
  }
  return;
}
}
static void qlcnic_83xx_poll_read_list(struct qlcnic_adapter *p_dev , struct qlc_83xx_entry_hdr *p_hdr )
{
  long delay ;
  int index ;
  int i ;
  int j ;
  int err ;
  struct qlc_83xx_quad_entry *entry ;
  struct qlc_83xx_poll *poll ;
  unsigned long addr ;
  int tmp ;
  int tmp___0 ;
  {
  poll = (struct qlc_83xx_poll *)p_hdr + 8U;
  entry = (struct qlc_83xx_quad_entry *)poll + 8U;
  delay = (long )p_hdr->delay;
  i = 0;
  goto ldv_51599;
  ldv_51598:
  qlcnic_83xx_wrt_reg_indirect(p_dev, (ulong )entry->ar_addr, entry->ar_value);
  if (delay != 0L) {
    tmp___0 = qlcnic_83xx_poll_reg(p_dev, entry->ar_addr, (int )delay, poll->mask,
                                   poll->status);
    if (tmp___0 == 0) {
      index = (p_dev->ahw)->reset.array_index;
      addr = (unsigned long )entry->dr_addr;
      j = (*(((p_dev->ahw)->hw_ops)->read_reg))(p_dev, addr, & err);
      if (err == -5) {
        return;
      } else {
      }
      tmp = index;
      index = index + 1;
      (p_dev->ahw)->reset.array[tmp] = (u32 )j;
      if (index == 16) {
        (p_dev->ahw)->reset.array_index = 1;
      } else {
      }
    } else {
    }
  } else {
  }
  i = i + 1;
  entry = entry + 1;
  ldv_51599: ;
  if ((int )p_hdr->count > i) {
    goto ldv_51598;
  } else {
  }
  return;
}
}
__inline static void qlcnic_83xx_seq_end(struct qlcnic_adapter *p_dev )
{
  {
  (p_dev->ahw)->reset.seq_end = 1U;
  return;
}
}
static void qlcnic_83xx_template_end(struct qlcnic_adapter *p_dev )
{
  {
  (p_dev->ahw)->reset.template_end = 1U;
  if ((p_dev->ahw)->reset.seq_error == 0) {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "HW restart process completed successfully.\n");
  } else {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "HW restart completed with timeout errors.\n");
  }
  return;
}
}
static void qlcnic_83xx_exec_template_cmd(struct qlcnic_adapter *p_dev , char *p_buff )
{
  int index ;
  int entries ;
  struct qlc_83xx_entry_hdr *p_hdr ;
  char *entry ;
  {
  entry = p_buff;
  (p_dev->ahw)->reset.seq_end = 0U;
  (p_dev->ahw)->reset.template_end = 0U;
  entries = (int )((p_dev->ahw)->reset.hdr)->entries;
  index = (p_dev->ahw)->reset.seq_index;
  goto ldv_51629;
  ldv_51628:
  p_hdr = (struct qlc_83xx_entry_hdr *)entry;
  switch ((int )p_hdr->cmd) {
  case 0: ;
  goto ldv_51616;
  case 1:
  qlcnic_83xx_write_list(p_dev, p_hdr);
  goto ldv_51616;
  case 2:
  qlcnic_83xx_read_write_list(p_dev, p_hdr);
  goto ldv_51616;
  case 4:
  qlcnic_83xx_poll_list(p_dev, p_hdr);
  goto ldv_51616;
  case 8:
  qlcnic_83xx_poll_write_list(p_dev, p_hdr);
  goto ldv_51616;
  case 16:
  qlcnic_83xx_read_modify_write(p_dev, p_hdr);
  goto ldv_51616;
  case 32:
  qlcnic_83xx_pause(p_hdr);
  goto ldv_51616;
  case 64:
  qlcnic_83xx_seq_end(p_dev);
  goto ldv_51616;
  case 128:
  qlcnic_83xx_template_end(p_dev);
  goto ldv_51616;
  case 256:
  qlcnic_83xx_poll_read_list(p_dev, p_hdr);
  goto ldv_51616;
  default:
  dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: Unknown opcode 0x%04x in template %d\n",
          "qlcnic_83xx_exec_template_cmd", (int )p_hdr->cmd, index);
  goto ldv_51616;
  }
  ldv_51616:
  entry = entry + (unsigned long )p_hdr->size;
  index = index + 1;
  ldv_51629: ;
  if ((unsigned int )(p_dev->ahw)->reset.seq_end == 0U && index < entries) {
    goto ldv_51628;
  } else {
  }
  (p_dev->ahw)->reset.seq_index = index;
  return;
}
}
static void qlcnic_83xx_stop_hw(struct qlcnic_adapter *p_dev )
{
  {
  (p_dev->ahw)->reset.seq_index = 0;
  qlcnic_83xx_exec_template_cmd(p_dev, (char *)(p_dev->ahw)->reset.stop_offset);
  if ((unsigned int )(p_dev->ahw)->reset.seq_end != 1U) {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: failed\n", "qlcnic_83xx_stop_hw");
  } else {
  }
  return;
}
}
static void qlcnic_83xx_start_hw(struct qlcnic_adapter *p_dev )
{
  {
  qlcnic_83xx_exec_template_cmd(p_dev, (char *)(p_dev->ahw)->reset.start_offset);
  if ((unsigned int )(p_dev->ahw)->reset.template_end != 1U) {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: failed\n", "qlcnic_83xx_start_hw");
  } else {
  }
  return;
}
}
static void qlcnic_83xx_init_hw(struct qlcnic_adapter *p_dev )
{
  {
  qlcnic_83xx_exec_template_cmd(p_dev, (char *)(p_dev->ahw)->reset.init_offset);
  if ((unsigned int )(p_dev->ahw)->reset.seq_end != 1U) {
    dev_err((struct device const *)(& (p_dev->pdev)->dev), "%s: failed\n", "qlcnic_83xx_init_hw");
  } else {
  }
  return;
}
}
static int qlcnic_83xx_load_fw_image_from_host(struct qlcnic_adapter *adapter )
{
  struct qlc_83xx_fw_info *fw_info ;
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  fw_info = (adapter->ahw)->fw_info;
  err = -5;
  tmp___0 = request_firmware(& fw_info->fw, (char const *)(& fw_info->fw_file_name),
                             & (adapter->pdev)->dev);
  if (tmp___0 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "No file FW image, loading flash FW image.\n");
    writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 15UL));
  } else {
    tmp = qlcnic_83xx_copy_fw_file(adapter);
    if (tmp != 0) {
      return (err);
    } else {
    }
    writel(305419896U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 15UL));
  }
  return (0);
}
}
static int qlcnic_83xx_restart_hw(struct qlcnic_adapter *adapter )
{
  u32 val ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  err = -5;
  qlcnic_83xx_stop_hw(adapter);
  val = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 15UL));
  if ((val & 2U) == 0U) {
    qlcnic_dump_fw(adapter);
  } else {
  }
  if ((int )val & 1) {
    netdev_info((struct net_device const *)adapter->netdev, "%s: Auto firmware recovery is disabled\n",
                "qlcnic_83xx_restart_hw");
    qlcnic_83xx_idc_enter_failed_state(adapter, 1);
    return (err);
  } else {
  }
  qlcnic_83xx_init_hw(adapter);
  tmp = qlcnic_83xx_copy_bootloader(adapter);
  if (tmp != 0) {
    return (err);
  } else {
  }
  if (qlcnic_load_fw_file != 0) {
    tmp___0 = qlcnic_83xx_load_fw_image_from_host(adapter);
    if (tmp___0 != 0) {
      return (err);
    } else {
    }
  } else {
    writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->reg_tbl + 15UL));
  }
  qlcnic_83xx_start_hw(adapter);
  tmp___1 = qlcnic_83xx_check_hw_status(adapter);
  if (tmp___1 != 0) {
    return (-5);
  } else {
  }
  return (0);
}
}
static int qlcnic_83xx_get_nic_configuration(struct qlcnic_adapter *adapter )
{
  int err ;
  struct qlcnic_info nic_info ;
  struct qlcnic_hardware_context *ahw ;
  int tmp ;
  {
  ahw = adapter->ahw;
  memset((void *)(& nic_info), 0, 72UL);
  err = qlcnic_get_nic_info(adapter, & nic_info, (int )ahw->pci_func);
  if (err != 0) {
    return (-5);
  } else {
  }
  ahw->physical_port = (unsigned char )nic_info.phys_port;
  ahw->switch_mode = nic_info.switch_mode;
  ahw->max_tx_ques = nic_info.max_tx_ques;
  ahw->max_rx_ques = nic_info.max_rx_ques;
  ahw->capabilities = nic_info.capabilities;
  ahw->max_mac_filters = nic_info.max_mac_filters;
  ahw->max_mtu = nic_info.max_mtu;
  tmp = constant_test_bit(11L, (unsigned long const volatile *)(& adapter->state));
  if (tmp != 0) {
    return (1431655765);
  } else {
  }
  if ((ahw->capabilities & 8388608U) != 0U) {
    return (255);
  } else {
  }
  return (1431655765);
}
}
int qlcnic_83xx_configure_opmode(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  u16 max_sds_rings ;
  u16 max_tx_rings ;
  int ret ;
  int tmp ;
  u16 _min1 ;
  u16 _min2 ;
  u16 _min1___0 ;
  u16 _min2___0 ;
  {
  ahw = adapter->ahw;
  ret = qlcnic_83xx_get_nic_configuration(adapter);
  if (ret == -5) {
    return (-5);
  } else {
  }
  if (ret == 255) {
    ahw->nic_mode = 255U;
    tmp = qlcnic_83xx_config_vnic_opmode(adapter);
    if (tmp != 0) {
      return (-5);
    } else {
    }
    max_sds_rings = 4U;
    max_tx_rings = 4U;
  } else
  if (ret == 1431655765) {
    ahw->nic_mode = 0U;
    (adapter->nic_ops)->init_driver = & qlcnic_83xx_init_default_driver;
    ahw->idc.state_entry = & qlcnic_83xx_idc_ready_state_entry;
    max_sds_rings = 8U;
    max_tx_rings = 8U;
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Invalid opmode %d\n",
            "qlcnic_83xx_configure_opmode", ret);
    return (-5);
  }
  _min1 = ahw->max_rx_ques;
  _min2 = max_sds_rings;
  adapter->max_sds_rings = (u8 )((int )_min1 < (int )_min2 ? _min1 : _min2);
  _min1___0 = ahw->max_tx_ques;
  _min2___0 = max_tx_rings;
  adapter->max_tx_rings = (u8 )((int )_min1___0 < (int )_min2___0 ? _min1___0 : _min2___0);
  return (0);
}
}
static void qlcnic_83xx_config_buff_descriptors(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  if ((unsigned int )ahw->port_type == 2U) {
    adapter->num_rxd = 4096U;
    adapter->max_rxd = 8192U;
    adapter->num_jumbo_rxd = 1024U;
    adapter->max_jumbo_rxd = 1024U;
  } else
  if ((unsigned int )ahw->port_type == 1U) {
    adapter->num_rxd = 2048U;
    adapter->num_jumbo_rxd = 512U;
    adapter->max_jumbo_rxd = 512U;
    adapter->max_rxd = 4096U;
  } else {
  }
  adapter->num_txd = 1024U;
  adapter->max_rds_rings = 2U;
  return;
}
}
static int qlcnic_83xx_init_default_driver(struct qlcnic_adapter *adapter )
{
  int err ;
  int tmp ;
  {
  err = -5;
  qlcnic_83xx_get_minidump_template(adapter);
  tmp = qlcnic_83xx_get_port_info(adapter);
  if (tmp != 0) {
    return (err);
  } else {
  }
  qlcnic_83xx_config_buff_descriptors(adapter);
  (adapter->ahw)->msix_supported = qlcnic_use_msi_x != 0;
  adapter->flags = adapter->flags | 128U;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d\n",
            (adapter->ahw)->fw_hal_version);
  return (0);
}
}
static void qlcnic_83xx_clear_function_resources(struct qlcnic_adapter *adapter )
{
  struct qlcnic_cmd_args cmd ;
  u32 presence_mask ;
  u32 audit_mask ;
  int status ;
  {
  presence_mask = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 13UL));
  audit_mask = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 16UL));
  if (((u32 )(1 << (int )adapter->portnum) & presence_mask) != 0U || (audit_mask & 64U) != 0U) {
    status = qlcnic_alloc_mbx_args(& cmd, adapter, 97U);
    if (status != 0) {
      return;
    } else {
    }
    *(cmd.req.arg + 1UL) = 2147483648U;
    status = qlcnic_issue_cmd(adapter, & cmd);
    if (status != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to clean up the function resources\n");
    } else {
    }
    qlcnic_free_mbx_args(& cmd);
  } else {
  }
  return;
}
}
static int qlcnic_83xx_get_fw_info(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct pci_dev *pdev ;
  struct qlc_83xx_fw_info *fw_info ;
  int err ;
  void *tmp ;
  {
  ahw = adapter->ahw;
  pdev = adapter->pdev;
  err = 0;
  tmp = kzalloc(32UL, 208U);
  ahw->fw_info = (struct qlc_83xx_fw_info *)tmp;
  if ((unsigned long )ahw->fw_info == (unsigned long )((struct qlc_83xx_fw_info *)0)) {
    err = -12;
  } else {
    fw_info = ahw->fw_info;
    switch ((int )pdev->device) {
    case 32816:
    strncpy((char *)(& fw_info->fw_file_name), "83xx_fw.bin", 20UL);
    goto ldv_51697;
    case 32832:
    strncpy((char *)(& fw_info->fw_file_name), "84xx_fw.bin", 20UL);
    goto ldv_51697;
    default:
    dev_err((struct device const *)(& pdev->dev), "%s: Invalid device id\n", "qlcnic_83xx_get_fw_info");
    err = -22;
    goto ldv_51697;
    }
    ldv_51697: ;
  }
  return (err);
}
}
static void qlcnic_83xx_init_rings(struct qlcnic_adapter *adapter )
{
  u8 rx_cnt ;
  u8 tx_cnt ;
  {
  rx_cnt = 4U;
  tx_cnt = 4U;
  adapter->max_tx_rings = 8U;
  adapter->max_sds_rings = 8U;
  if ((unsigned int )(adapter->ahw)->msix_supported == 0U) {
    rx_cnt = 1U;
    tx_cnt = 1U;
  } else {
  }
  qlcnic_set_tx_ring_count(adapter, (int )tx_cnt);
  qlcnic_set_sds_ring_count(adapter, (int )rx_cnt);
  return;
}
}
int qlcnic_83xx_init(struct qlcnic_adapter *adapter , int pci_using_dac )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  {
  ahw = adapter->ahw;
  err = 0;
  adapter->rx_mac_learn = 0;
  ahw->msix_supported = qlcnic_use_msi_x != 0;
  qlcnic_83xx_init_rings(adapter);
  err = qlcnic_83xx_init_mailbox_work(adapter);
  if (err != 0) {
    goto exit;
  } else {
  }
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    err = qlcnic_sriov_vf_init(adapter, pci_using_dac);
    if (err != 0) {
      goto detach_mbx;
    } else {
      return (err);
    }
  } else {
  }
  tmp___0 = qlcnic_83xx_read_flash_descriptor_table(adapter);
  if (tmp___0 != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed reading flash mfg id\n");
    err = -131;
    goto detach_mbx;
  } else {
    tmp___1 = qlcnic_83xx_read_flash_mfg_id(adapter);
    if (tmp___1 != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed reading flash mfg id\n");
      err = -131;
      goto detach_mbx;
    } else {
    }
  }
  err = qlcnic_83xx_check_hw_status(adapter);
  if (err != 0) {
    goto detach_mbx;
  } else {
  }
  err = qlcnic_83xx_get_fw_info(adapter);
  if (err != 0) {
    goto detach_mbx;
  } else {
  }
  err = qlcnic_83xx_idc_init(adapter);
  if (err != 0) {
    goto detach_mbx;
  } else {
  }
  err = qlcnic_setup_intr(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to setup interrupt\n");
    goto disable_intr;
  } else {
  }
  __init_work(& adapter->idc_aen_work.work, 0);
  __constr_expr_0.counter = 137438953408L;
  adapter->idc_aen_work.work.data = __constr_expr_0;
  lockdep_init_map(& adapter->idc_aen_work.work.lockdep_map, "(&(&adapter->idc_aen_work)->work)",
                   & __key, 0);
  INIT_LIST_HEAD(& adapter->idc_aen_work.work.entry);
  adapter->idc_aen_work.work.func = & qlcnic_83xx_idc_aen_work;
  init_timer_key(& adapter->idc_aen_work.timer, 2U, "(&(&adapter->idc_aen_work)->timer)",
                 & __key___0);
  adapter->idc_aen_work.timer.function = & delayed_work_timer_fn;
  adapter->idc_aen_work.timer.data = (unsigned long )(& adapter->idc_aen_work);
  err = qlcnic_83xx_setup_mbx_intr(adapter);
  if (err != 0) {
    goto disable_mbx_intr;
  } else {
  }
  qlcnic_83xx_clear_function_resources(adapter);
  qlcnic_dcb_enable(adapter->dcb);
  qlcnic_83xx_initialize_nic(adapter, 1);
  qlcnic_dcb_get_info(adapter->dcb);
  err = qlcnic_83xx_configure_opmode(adapter);
  if (err != 0) {
    goto disable_mbx_intr;
  } else {
  }
  err = (*((adapter->nic_ops)->init_driver))(adapter);
  if (err != 0) {
    goto disable_mbx_intr;
  } else {
  }
  qlcnic_83xx_idc_poll_dev_state(& adapter->fw_work.work);
  return (0);
  disable_mbx_intr:
  qlcnic_83xx_free_mbx_intr(adapter);
  disable_intr:
  qlcnic_teardown_intr(adapter);
  detach_mbx:
  qlcnic_83xx_detach_mailbox_work(adapter);
  qlcnic_83xx_free_mailbox(ahw->mailbox);
  ahw->mailbox = (struct qlcnic_mailbox *)0;
  exit: ;
  return (err);
}
}
void qlcnic_83xx_aer_stop_poll_work(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlc_83xx_idc *idc ;
  {
  ahw = adapter->ahw;
  idc = & ahw->idc;
  clear_bit(2L, (unsigned long volatile *)(& idc->status));
  cancel_delayed_work_sync(& adapter->fw_work);
  if ((unsigned int )ahw->nic_mode == 255U) {
    qlcnic_83xx_disable_vnic_mode(adapter, 1);
  } else {
  }
  qlcnic_83xx_idc_detach_driver(adapter);
  qlcnic_83xx_initialize_nic(adapter, 0);
  cancel_delayed_work_sync(& adapter->idc_aen_work);
  return;
}
}
int qlcnic_83xx_aer_reset(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlc_83xx_idc *idc ;
  int ret ;
  u32 owner ;
  int tmp ;
  {
  ahw = adapter->ahw;
  idc = & ahw->idc;
  ret = 0;
  idc->prev_state = 4U;
  tmp = qlcnic_83xx_idc_find_reset_owner_id(adapter);
  owner = (u32 )tmp;
  if ((u32 )ahw->pci_func == owner) {
    ret = qlcnic_83xx_restart_hw(adapter);
    if (ret < 0) {
      return (ret);
    } else {
    }
    qlcnic_83xx_idc_clear_registers(adapter, 0);
  } else {
  }
  ret = (*(idc->state_entry))(adapter);
  return (ret);
}
}
void qlcnic_83xx_aer_start_poll_work(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlc_83xx_idc *idc ;
  u32 owner ;
  int tmp ;
  {
  ahw = adapter->ahw;
  idc = & ahw->idc;
  idc->prev_state = 3U;
  tmp = qlcnic_83xx_idc_find_reset_owner_id(adapter);
  owner = (u32 )tmp;
  if ((u32 )ahw->pci_func == owner) {
    qlcnic_83xx_idc_enter_ready_state(adapter, 0);
  } else {
  }
  qlcnic_schedule_work(adapter, & qlcnic_83xx_idc_poll_dev_state, 0);
  return;
}
}
void *ldv_kmem_cache_alloc_436(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_442(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_444(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_446(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_447(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_448(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_449(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_450(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_451(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_452(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_453(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_vzalloc_454(unsigned long ldv_func_arg1 )
{
  {
  ldv_check_alloc_nonatomic();
  vzalloc(ldv_func_arg1);
  return ((void *)0);
}
}
void *ldv_kmem_cache_alloc_482(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_499(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_490(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_498(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_492(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_488(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_496(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_497(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_493(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_494(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_495(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
static int qlcnic_83xx_enable_vnic_mode(struct qlcnic_adapter *adapter , int lock )
{
  int tmp ;
  {
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  writel(1U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 38UL));
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_disable_vnic_mode(struct qlcnic_adapter *adapter , int lock )
{
  struct qlcnic_hardware_context *ahw ;
  int tmp ;
  {
  ahw = adapter->ahw;
  if (lock != 0) {
    tmp = qlcnic_83xx_lock_driver(adapter);
    if (tmp != 0) {
      return (-16);
    } else {
    }
  } else {
  }
  writel(0U, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 38UL));
  ahw->idc.vnic_state = 0U;
  if (lock != 0) {
    qlcnic_83xx_unlock_driver(adapter);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_set_vnic_opmode(struct qlcnic_adapter *adapter )
{
  u8 id ;
  int ret ;
  u32 data ;
  struct qlcnic_hardware_context *ahw ;
  int tmp ;
  {
  ret = -16;
  data = 0U;
  ahw = adapter->ahw;
  tmp = qlcnic_83xx_lock_driver(adapter);
  if (tmp != 0) {
    return (ret);
  } else {
  }
  id = ahw->pci_func;
  data = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 37UL));
  data = (u32 )(~ (3 << (int )id * 2)) & data;
  writel(data, (void volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 37UL));
  qlcnic_83xx_unlock_driver(adapter);
  return (0);
}
}
static void qlcnic_83xx_config_vnic_buff_descriptors(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  if ((unsigned int )ahw->port_type == 2U) {
    adapter->num_rxd = 1024U;
    adapter->max_rxd = 2048U;
    adapter->num_jumbo_rxd = 1024U;
    adapter->max_jumbo_rxd = 1024U;
  } else
  if ((unsigned int )ahw->port_type == 1U) {
    adapter->num_rxd = 2048U;
    adapter->num_jumbo_rxd = 512U;
    adapter->max_jumbo_rxd = 512U;
    adapter->max_rxd = 4096U;
  } else {
  }
  adapter->num_txd = 1024U;
  adapter->max_rds_rings = 2U;
  return;
}
}
static int qlcnic_83xx_init_mgmt_vnic(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct device *dev ;
  struct qlcnic_npar_info *npar ;
  int i ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  ahw = adapter->ahw;
  dev = & (adapter->pdev)->dev;
  err = -5;
  qlcnic_83xx_get_minidump_template(adapter);
  if ((adapter->flags & 128U) == 0U) {
    tmp = qlcnic_init_pci_info(adapter);
    if (tmp != 0) {
      return (err);
    } else {
    }
    npar = adapter->npars;
    i = 0;
    goto ldv_50866;
    ldv_50865:
    _dev_info((struct device const *)dev, "id:%d active:%d type:%d port:%d min_bw:%d max_bw:%d mac_addr:%pM\n",
              (int )npar->pci_func, (int )npar->active, (int )npar->type, (int )npar->phy_port,
              (int )npar->min_bw, (int )npar->max_bw, (u8 *)(& npar->mac));
    i = i + 1;
    npar = npar + 1;
    ldv_50866: ;
    if ((int )ahw->total_nic_func > i) {
      goto ldv_50865;
    } else {
    }
    _dev_info((struct device const *)dev, "Max functions = %d, active functions = %d\n",
              (int )ahw->max_pci_func, (int )ahw->total_nic_func);
    tmp___0 = qlcnic_83xx_set_vnic_opmode(adapter);
    if (tmp___0 != 0) {
      return (err);
    } else {
    }
    tmp___1 = qlcnic_set_default_offload_settings(adapter);
    if (tmp___1 != 0) {
      return (err);
    } else {
    }
  } else {
    tmp___2 = qlcnic_reset_npar_config(adapter);
    if (tmp___2 != 0) {
      return (err);
    } else {
    }
  }
  tmp___3 = qlcnic_83xx_get_port_info(adapter);
  if (tmp___3 != 0) {
    return (err);
  } else {
  }
  qlcnic_83xx_config_vnic_buff_descriptors(adapter);
  ahw->msix_supported = qlcnic_use_msi_x != 0;
  adapter->flags = adapter->flags | 128U;
  qlcnic_83xx_enable_vnic_mode(adapter, 1);
  _dev_info((struct device const *)dev, "HAL Version: %d, Management function\n",
            ahw->fw_hal_version);
  return (0);
}
}
static int qlcnic_83xx_init_privileged_vnic(struct qlcnic_adapter *adapter )
{
  int err ;
  int tmp ;
  {
  err = -5;
  qlcnic_83xx_get_minidump_template(adapter);
  tmp = qlcnic_83xx_get_port_info(adapter);
  if (tmp != 0) {
    return (err);
  } else {
  }
  qlcnic_83xx_config_vnic_buff_descriptors(adapter);
  (adapter->ahw)->msix_supported = qlcnic_use_msi_x != 0;
  adapter->flags = adapter->flags | 128U;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d, Privileged function\n",
            (adapter->ahw)->fw_hal_version);
  return (0);
}
}
static int qlcnic_83xx_init_non_privileged_vnic(struct qlcnic_adapter *adapter )
{
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  err = -5;
  qlcnic_83xx_get_fw_version(adapter);
  tmp = qlcnic_set_eswitch_port_config(adapter);
  if (tmp != 0) {
    return (err);
  } else {
  }
  tmp___0 = qlcnic_83xx_get_port_info(adapter);
  if (tmp___0 != 0) {
    return (err);
  } else {
  }
  qlcnic_83xx_config_vnic_buff_descriptors(adapter);
  (adapter->ahw)->msix_supported = qlcnic_use_msi_x != 0;
  adapter->flags = adapter->flags | 128U;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d, Virtual function\n",
            (adapter->ahw)->fw_hal_version);
  return (0);
}
}
int qlcnic_83xx_config_vnic_opmode(struct qlcnic_adapter *adapter )
{
  u32 op_mode ;
  u32 priv_level ;
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_nic_template *nic_ops ;
  {
  ahw = adapter->ahw;
  nic_ops = adapter->nic_ops;
  qlcnic_get_func_no(adapter);
  op_mode = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 37UL));
  if (op_mode == 1431655765U) {
    priv_level = 0U;
  } else {
    priv_level = (op_mode >> (int )ahw->pci_func * 2) & 3U;
  }
  switch (priv_level) {
  case 2U:
  ahw->op_mode = 2U;
  ahw->idc.state_entry = & qlcnic_83xx_idc_ready_state_entry;
  nic_ops->init_driver = & qlcnic_83xx_init_non_privileged_vnic;
  goto ldv_50884;
  case 1U:
  ahw->op_mode = 1U;
  ahw->idc.state_entry = & qlcnic_83xx_idc_vnic_pf_entry;
  nic_ops->init_driver = & qlcnic_83xx_init_privileged_vnic;
  goto ldv_50884;
  case 0U:
  ahw->op_mode = 0U;
  ahw->idc.state_entry = & qlcnic_83xx_idc_ready_state_entry;
  nic_ops->init_driver = & qlcnic_83xx_init_mgmt_vnic;
  goto ldv_50884;
  default:
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Invalid Virtual NIC opmode\n");
  return (-5);
  }
  ldv_50884: ;
  if ((ahw->capabilities & 8388608U) != 0U) {
    adapter->flags = adapter->flags | 64U;
    if ((int )adapter->drv_mac_learn) {
      adapter->rx_mac_learn = 1;
    } else {
    }
  } else {
    adapter->flags = adapter->flags & 4294967231U;
    adapter->rx_mac_learn = 0;
  }
  ahw->idc.vnic_state = 0U;
  ahw->idc.vnic_wait_limit = 30U;
  return (0);
}
}
int qlcnic_83xx_check_vnic_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlc_83xx_idc *idc ;
  u32 state ;
  u8 tmp ;
  {
  ahw = adapter->ahw;
  idc = & ahw->idc;
  state = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 38UL));
  goto ldv_50895;
  ldv_50894:
  msleep(1000U);
  state = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 38UL));
  ldv_50895: ;
  if (state != 1U) {
    tmp = idc->vnic_wait_limit;
    idc->vnic_wait_limit = (u8 )((int )idc->vnic_wait_limit - 1);
    if ((unsigned int )tmp != 0U) {
      goto ldv_50894;
    } else {
      goto ldv_50896;
    }
  } else {
  }
  ldv_50896: ;
  if ((unsigned int )idc->vnic_wait_limit == 0U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "vNIC mode not operational, state check timed out.\n");
    return (-5);
  } else {
  }
  return (0);
}
}
int qlcnic_83xx_set_port_eswitch_status(struct qlcnic_adapter *adapter , int func ,
                                        int *port_id )
{
  struct qlcnic_info nic_info ;
  int err ;
  {
  err = 0;
  memset((void *)(& nic_info), 0, 72UL);
  err = qlcnic_get_nic_info(adapter, & nic_info, (int )((u8 )func));
  if (err != 0) {
    return (err);
  } else {
  }
  if ((nic_info.capabilities & 8388608U) != 0U) {
    *port_id = (int )nic_info.phys_port;
  } else {
    err = -5;
  }
  if (err == 0) {
    (adapter->eswitch + (unsigned long )*port_id)->flags = (adapter->eswitch + (unsigned long )*port_id)->flags | 2U;
  } else {
  }
  return (err);
}
}
void *ldv_kmem_cache_alloc_482(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_488(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_490(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_492(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_493(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_494(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_495(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_496(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_497(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_498(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_499(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
__inline static void spin_lock(spinlock_t *lock ) ;
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
void *ldv_kmem_cache_alloc_526(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_543(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int , int , u16 * ) ;
__inline static int pci_read_config_word(struct pci_dev const *dev , int where ,
                                         u16 *val )
{
  int tmp ;
  {
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
extern void get_random_bytes(void * , int ) ;
struct sk_buff *ldv_skb_clone_534(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_542(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_536(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_532(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_540(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_541(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_537(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_538(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_539(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
__inline static void netif_addr_lock_bh(struct net_device *dev )
{
  {
  spin_lock_bh(& dev->addr_list_lock);
  return;
}
}
__inline static void netif_addr_unlock_bh(struct net_device *dev )
{
  {
  spin_unlock_bh(& dev->addr_list_lock);
  return;
}
}
__inline static void eth_random_addr(u8 *addr )
{
  {
  get_random_bytes((void *)addr, 6);
  *addr = (unsigned int )*addr & 254U;
  *addr = (u8 )((unsigned int )*addr | 2U);
  return;
}
}
__inline static bool qlcnic_83xx_vf_check(struct qlcnic_adapter *adapter )
{
  unsigned short device ;
  {
  device = (adapter->pdev)->device;
  return ((unsigned int )device == 33840U);
}
}
int qlcnic_sriov_init(struct qlcnic_adapter *adapter , int num_vfs ) ;
void __qlcnic_sriov_cleanup(struct qlcnic_adapter *adapter ) ;
int qlcnic_sriov_func_to_index(struct qlcnic_adapter *adapter , u8 pci_func ) ;
int qlcnic_sriov_cfg_bc_intr(struct qlcnic_adapter *adapter , u8 enable ) ;
void qlcnic_sriov_cleanup_list(struct qlcnic_trans_list *t_list ) ;
int __qlcnic_sriov_add_act_list(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                struct qlcnic_bc_trans *trans ) ;
int qlcnic_sriov_get_vf_vport_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info ,
                                   u16 vport_id ) ;
void qlcnic_sriov_free_vlans(struct qlcnic_adapter *adapter ) ;
void qlcnic_sriov_alloc_vlans(struct qlcnic_adapter *adapter ) ;
bool qlcnic_sriov_check_any_vlan(struct qlcnic_vf_info *vf ) ;
void qlcnic_sriov_del_vlan_id(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                              u16 vlan_id ) ;
void qlcnic_sriov_add_vlan_id(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                              u16 vlan_id ) ;
__inline static bool qlcnic_sriov_enable_check(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  tmp = constant_test_bit(10L, (unsigned long const volatile *)(& adapter->state));
  return (tmp != 0);
}
}
void qlcnic_sriov_pf_process_bc_cmd(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans ,
                                    struct qlcnic_cmd_args *cmd ) ;
void qlcnic_sriov_pf_cleanup(struct qlcnic_adapter *adapter ) ;
void qlcnic_sriov_pf_handle_flr(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ) ;
bool qlcnic_sriov_soft_flr_check(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans ,
                                 struct qlcnic_vf_info *vf ) ;
static void qlcnic_sriov_vf_free_mac_list(struct qlcnic_adapter *adapter ) ;
static int qlcnic_sriov_alloc_bc_mbx_args(struct qlcnic_cmd_args *mbx , u32 type ) ;
static void qlcnic_sriov_vf_poll_dev_state(struct work_struct *work ) ;
static void qlcnic_sriov_vf_cancel_fw_work(struct qlcnic_adapter *adapter ) ;
static void qlcnic_sriov_cleanup_transaction(struct qlcnic_bc_trans *trans ) ;
static int qlcnic_sriov_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd ) ;
static int qlcnic_sriov_channel_cfg_cmd(struct qlcnic_adapter *adapter , u8 cmd_op ) ;
static void qlcnic_sriov_process_bc_cmd(struct work_struct *work ) ;
static int qlcnic_sriov_vf_shutdown(struct pci_dev *pdev ) ;
static int qlcnic_sriov_vf_resume(struct qlcnic_adapter *adapter ) ;
static int qlcnic_sriov_async_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd ) ;
static struct qlcnic_hardware_ops qlcnic_sriov_vf_hw_ops =
     {& qlcnic_83xx_read_crb, & qlcnic_83xx_write_crb, & qlcnic_83xx_rd_reg_indirect,
    & qlcnic_83xx_wrt_reg_indirect, 0, & qlcnic_83xx_get_mac_address, & qlcnic_83xx_setup_intr,
    & qlcnic_83xx_alloc_mbx_args, & qlcnic_sriov_issue_cmd, & qlcnic_83xx_get_func_no,
    & qlcnic_83xx_cam_lock, & qlcnic_83xx_cam_unlock, 0, 0, & qlcnic_83xx_process_rcv_ring_diag,
    & qlcnic_83xx_create_rx_ctx, & qlcnic_83xx_create_tx_ctx, & qlcnic_83xx_del_rx_ctx,
    & qlcnic_83xx_del_tx_ctx, & qlcnic_83xx_setup_link_event, & qlcnic_83xx_get_nic_info,
    & qlcnic_83xx_get_pci_info, & qlcnic_83xx_set_nic_info, & qlcnic_83xx_sre_macaddr_change,
    & qlcnic_83xx_napi_enable, & qlcnic_83xx_napi_disable, & qlcnic_83xx_config_intr_coal,
    & qlcnic_83xx_config_rss, & qlcnic_83xx_config_hw_lro, 0, 0, & qlcnic_83xx_nic_set_promisc,
    & qlcnic_83xx_change_l2_filter, & qlcnic_83xx_get_port_info, 0, & qlcnic_sriov_vf_free_mac_list,
    0, 0, 0, 0, 0, & qlcnic_83xx_enable_sds_intr, & qlcnic_83xx_disable_sds_intr,
    0, 0, 0, 0, 0, 0, 0, 0};
static struct qlcnic_nic_template qlcnic_sriov_vf_ops =
     {& qlcnic_config_bridged_mode, & qlcnic_config_led, 0, 0, 0, & qlcnic_sriov_vf_cancel_fw_work,
    & qlcnic_83xx_napi_add, & qlcnic_83xx_napi_del, & qlcnic_83xx_config_ipaddr, & qlcnic_83xx_clear_legacy_intr,
    & qlcnic_sriov_vf_shutdown, & qlcnic_sriov_vf_resume};
static struct qlcnic_mailbox_metadata const qlcnic_sriov_bc_mbx_tbl[4U] = { {0U, 2U, 2U},
        {1U, 2U, 2U},
        {2U, 3U, 14U},
        {3U, 2U, 2U}};
__inline static bool qlcnic_sriov_bc_msg_check(u32 val )
{
  {
  return (((int )val & 1) != 0);
}
}
__inline static bool qlcnic_sriov_channel_free_check(u32 val )
{
  {
  return ((val & 2U) != 0U);
}
}
__inline static bool qlcnic_sriov_flr_check(u32 val )
{
  {
  return ((val & 4U) != 0U);
}
}
__inline static u8 qlcnic_sriov_target_func_id(u32 val )
{
  {
  return ((u8 )(val >> 4));
}
}
static int qlcnic_sriov_virtid_fn(struct qlcnic_adapter *adapter , int vf_id )
{
  struct pci_dev *dev ;
  int pos ;
  u16 stride ;
  u16 offset ;
  bool tmp ;
  {
  dev = adapter->pdev;
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    return (0);
  } else {
  }
  pos = pci_find_ext_capability(dev, 16);
  pci_read_config_word((struct pci_dev const *)dev, pos + 20, & offset);
  pci_read_config_word((struct pci_dev const *)dev, pos + 22, & stride);
  return ((int )((dev->devfn + (unsigned int )offset) + (unsigned int )((int )stride * vf_id)) & 255);
}
}
int qlcnic_sriov_init(struct qlcnic_adapter *adapter , int num_vfs )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_back_channel *bc ;
  struct workqueue_struct *wq ;
  struct qlcnic_vport *vp ;
  struct qlcnic_vf_info *vf ;
  int err ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct lock_class_key __key ;
  char const *__lock_name ;
  struct workqueue_struct *tmp___3 ;
  struct lock_class_key __key___0 ;
  char const *__lock_name___0 ;
  struct workqueue_struct *tmp___4 ;
  int tmp___5 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_0 ;
  void *tmp___6 ;
  bool tmp___7 ;
  {
  tmp = qlcnic_sriov_enable_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (-5);
  } else {
  }
  tmp___1 = kzalloc(104UL, 208U);
  sriov = (struct qlcnic_sriov *)tmp___1;
  if ((unsigned long )sriov == (unsigned long )((struct qlcnic_sriov *)0)) {
    return (-12);
  } else {
  }
  (adapter->ahw)->sriov = sriov;
  sriov->num_vfs = (u8 )num_vfs;
  bc = & sriov->bc;
  tmp___2 = kzalloc((unsigned long )num_vfs * 752UL, 208U);
  sriov->vf_info = (struct qlcnic_vf_info *)tmp___2;
  if ((unsigned long )sriov->vf_info == (unsigned long )((struct qlcnic_vf_info *)0)) {
    err = -12;
    goto qlcnic_free_sriov;
  } else {
  }
  __lock_name = "\"%s\"(\"bc-trans\")";
  tmp___3 = __alloc_workqueue_key("%s", 10U, 1, & __key, __lock_name, (char *)"bc-trans");
  wq = tmp___3;
  if ((unsigned long )wq == (unsigned long )((struct workqueue_struct *)0)) {
    err = -12;
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Cannot create bc-trans workqueue\n");
    goto qlcnic_free_vf_info;
  } else {
  }
  bc->bc_trans_wq = wq;
  __lock_name___0 = "\"%s\"(\"async\")";
  tmp___4 = __alloc_workqueue_key("%s", 10U, 1, & __key___0, __lock_name___0, (char *)"async");
  wq = tmp___4;
  if ((unsigned long )wq == (unsigned long )((struct workqueue_struct *)0)) {
    err = -12;
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Cannot create async workqueue\n");
    goto qlcnic_destroy_trans_wq;
  } else {
  }
  bc->bc_async_wq = wq;
  INIT_LIST_HEAD(& bc->async_list);
  i = 0;
  goto ldv_51154;
  ldv_51153:
  vf = sriov->vf_info + (unsigned long )i;
  vf->adapter = adapter;
  tmp___5 = qlcnic_sriov_virtid_fn(adapter, i);
  vf->pci_func = (u8 )tmp___5;
  __mutex_init(& vf->send_cmd_lock, "&vf->send_cmd_lock", & __key___1);
  spinlock_check(& vf->vlan_list_lock);
  __raw_spin_lock_init(& vf->vlan_list_lock.ldv_6347.rlock, "&(&vf->vlan_list_lock)->rlock",
                       & __key___2);
  INIT_LIST_HEAD(& vf->rcv_act.wait_list);
  INIT_LIST_HEAD(& vf->rcv_pend.wait_list);
  spinlock_check(& vf->rcv_act.lock);
  __raw_spin_lock_init(& vf->rcv_act.lock.ldv_6347.rlock, "&(&vf->rcv_act.lock)->rlock",
                       & __key___3);
  spinlock_check(& vf->rcv_pend.lock);
  __raw_spin_lock_init(& vf->rcv_pend.lock.ldv_6347.rlock, "&(&vf->rcv_pend.lock)->rlock",
                       & __key___4);
  init_completion(& vf->ch_free_cmpl);
  __init_work(& vf->trans_work, 0);
  __constr_expr_0.counter = 137438953408L;
  vf->trans_work.data = __constr_expr_0;
  lockdep_init_map(& vf->trans_work.lockdep_map, "(&vf->trans_work)", & __key___5,
                   0);
  INIT_LIST_HEAD(& vf->trans_work.entry);
  vf->trans_work.func = & qlcnic_sriov_process_bc_cmd;
  tmp___7 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___7) {
    tmp___6 = kzalloc(18UL, 208U);
    vp = (struct qlcnic_vport *)tmp___6;
    if ((unsigned long )vp == (unsigned long )((struct qlcnic_vport *)0)) {
      err = -12;
      goto qlcnic_destroy_async_wq;
    } else {
    }
    (sriov->vf_info + (unsigned long )i)->vp = vp;
    vp->vlan_mode = 2U;
    vp->max_tx_bw = 100U;
    vp->min_tx_bw = 1U;
    vp->spoofchk = 0;
    eth_random_addr((u8 *)(& vp->mac));
    _dev_info((struct device const *)(& (adapter->pdev)->dev), "MAC Address %pM is configured for VF %d\n",
              (u8 *)(& vp->mac), i);
  } else {
  }
  i = i + 1;
  ldv_51154: ;
  if (i < num_vfs) {
    goto ldv_51153;
  } else {
  }
  return (0);
  qlcnic_destroy_async_wq:
  destroy_workqueue(bc->bc_async_wq);
  qlcnic_destroy_trans_wq:
  destroy_workqueue(bc->bc_trans_wq);
  qlcnic_free_vf_info:
  kfree((void const *)sriov->vf_info);
  qlcnic_free_sriov:
  kfree((void const *)(adapter->ahw)->sriov);
  return (err);
}
}
void qlcnic_sriov_cleanup_list(struct qlcnic_trans_list *t_list )
{
  struct qlcnic_bc_trans *trans ;
  struct qlcnic_cmd_args cmd ;
  unsigned long flags ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  ldv_spin_lock();
  goto ldv_51165;
  ldv_51164:
  __mptr = (struct list_head const *)t_list->wait_list.next;
  trans = (struct qlcnic_bc_trans *)__mptr + 0xffffffffffffffe8UL;
  list_del(& trans->list);
  t_list->count = t_list->count - 1;
  cmd.req.arg = (u32 *)trans->req_pay;
  cmd.rsp.arg = (u32 *)trans->rsp_pay;
  qlcnic_free_mbx_args(& cmd);
  qlcnic_sriov_cleanup_transaction(trans);
  ldv_51165:
  tmp = list_empty((struct list_head const *)(& t_list->wait_list));
  if (tmp == 0) {
    goto ldv_51164;
  } else {
  }
  spin_unlock_irqrestore(& t_list->lock, flags);
  return;
}
}
void __qlcnic_sriov_cleanup(struct qlcnic_adapter *adapter )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_back_channel *bc ;
  struct qlcnic_vf_info *vf ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  {
  sriov = (adapter->ahw)->sriov;
  bc = & sriov->bc;
  tmp = qlcnic_sriov_enable_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  qlcnic_sriov_cleanup_async_list(bc);
  destroy_workqueue(bc->bc_async_wq);
  i = 0;
  goto ldv_51175;
  ldv_51174:
  vf = sriov->vf_info + (unsigned long )i;
  qlcnic_sriov_cleanup_list(& vf->rcv_pend);
  cancel_work_sync(& vf->trans_work);
  qlcnic_sriov_cleanup_list(& vf->rcv_act);
  i = i + 1;
  ldv_51175: ;
  if ((int )sriov->num_vfs > i) {
    goto ldv_51174;
  } else {
  }
  destroy_workqueue(bc->bc_trans_wq);
  i = 0;
  goto ldv_51178;
  ldv_51177:
  kfree((void const *)(sriov->vf_info + (unsigned long )i)->vp);
  i = i + 1;
  ldv_51178: ;
  if ((int )sriov->num_vfs > i) {
    goto ldv_51177;
  } else {
  }
  kfree((void const *)sriov->vf_info);
  kfree((void const *)(adapter->ahw)->sriov);
  return;
}
}
static void qlcnic_sriov_vf_cleanup(struct qlcnic_adapter *adapter )
{
  {
  qlcnic_sriov_channel_cfg_cmd(adapter, 1);
  qlcnic_sriov_cfg_bc_intr(adapter, 0);
  __qlcnic_sriov_cleanup(adapter);
  return;
}
}
void qlcnic_sriov_cleanup(struct qlcnic_adapter *adapter )
{
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  tmp = constant_test_bit(10L, (unsigned long const volatile *)(& adapter->state));
  if (tmp == 0) {
    return;
  } else {
  }
  qlcnic_sriov_free_vlans(adapter);
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp___0) {
    qlcnic_sriov_pf_cleanup(adapter);
  } else {
  }
  tmp___1 = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp___1) {
    qlcnic_sriov_vf_cleanup(adapter);
  } else {
  }
  return;
}
}
static int qlcnic_sriov_post_bc_msg(struct qlcnic_adapter *adapter , u32 *hdr , u32 *pay ,
                                    u8 pci_func , u8 size )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_mailbox *mbx ;
  struct qlcnic_cmd_args cmd ;
  unsigned long timeout ;
  int err ;
  unsigned long tmp ;
  {
  ahw = adapter->ahw;
  mbx = ahw->mailbox;
  memset((void *)(& cmd), 0, 200UL);
  cmd.hdr = hdr;
  cmd.pay = pay;
  cmd.pay_size = (int )size;
  cmd.func_num = pci_func;
  cmd.op_type = 1U;
  cmd.cmd_op = (u32 )((struct qlcnic_bc_hdr *)hdr)->cmd_op;
  err = (*((mbx->ops)->enqueue_cmd))(adapter, & cmd, & timeout);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Mailbox not available, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",
            "qlcnic_sriov_post_bc_msg", cmd.cmd_op, cmd.type, (int )ahw->pci_func,
            (int )ahw->op_mode);
    return (err);
  } else {
  }
  tmp = wait_for_completion_timeout(& cmd.completion, timeout);
  if (tmp == 0UL) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",
            "qlcnic_sriov_post_bc_msg", cmd.cmd_op, cmd.type, (int )ahw->pci_func,
            (int )ahw->op_mode);
    flush_workqueue(mbx->work_q);
  } else {
  }
  return ((int )cmd.rsp_opcode);
}
}
static void qlcnic_sriov_vf_cfg_buff_desc(struct qlcnic_adapter *adapter )
{
  {
  adapter->num_rxd = 2048U;
  adapter->max_rxd = 8192U;
  adapter->num_jumbo_rxd = 512U;
  adapter->max_jumbo_rxd = 1024U;
  adapter->num_txd = 1024U;
  adapter->max_rds_rings = 2U;
  return;
}
}
int qlcnic_sriov_get_vf_vport_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info ,
                                   u16 vport_id )
{
  struct device *dev ;
  struct qlcnic_cmd_args cmd ;
  int err ;
  u32 status ;
  {
  dev = & (adapter->pdev)->dev;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 33U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )(((int )vport_id << 16) | 1);
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get vport info, err=%d\n",
            err);
    qlcnic_free_mbx_args(& cmd);
    return (err);
  } else {
  }
  status = *(cmd.rsp.arg + 2UL) & 65535U;
  if ((int )status & 1) {
    npar_info->min_tx_bw = (unsigned short )(*(cmd.rsp.arg + 2UL) >> 16);
  } else {
  }
  if ((status & 2U) != 0U) {
    npar_info->max_tx_bw = (unsigned short )*(cmd.rsp.arg + 3UL);
  } else {
  }
  if ((status & 4U) != 0U) {
    npar_info->max_tx_ques = (unsigned short )(*(cmd.rsp.arg + 3UL) >> 16);
  } else {
  }
  if ((status & 8U) != 0U) {
    npar_info->max_tx_mac_filters = (unsigned short )*(cmd.rsp.arg + 4UL);
  } else {
  }
  if ((status & 16U) != 0U) {
    npar_info->max_rx_mcast_mac_filters = (unsigned short )(*(cmd.rsp.arg + 4UL) >> 16);
  } else {
  }
  if ((status & 32U) != 0U) {
    npar_info->max_rx_ucast_mac_filters = (unsigned short )*(cmd.rsp.arg + 5UL);
  } else {
  }
  if ((status & 64U) != 0U) {
    npar_info->max_rx_ip_addr = (unsigned short )(*(cmd.rsp.arg + 5UL) >> 16);
  } else {
  }
  if ((status & 128U) != 0U) {
    npar_info->max_rx_lro_flow = (unsigned short )*(cmd.rsp.arg + 6UL);
  } else {
  }
  if ((status & 256U) != 0U) {
    npar_info->max_rx_status_rings = (unsigned short )(*(cmd.rsp.arg + 6UL) >> 16);
  } else {
  }
  if ((status & 512U) != 0U) {
    npar_info->max_rx_buf_rings = (unsigned short )*(cmd.rsp.arg + 7UL);
  } else {
  }
  npar_info->max_rx_ques = (unsigned short )(*(cmd.rsp.arg + 7UL) >> 16);
  npar_info->max_tx_vlan_keys = (unsigned short )*(cmd.rsp.arg + 8UL);
  npar_info->max_local_ipv6_addrs = (unsigned short )(*(cmd.rsp.arg + 8UL) >> 16);
  npar_info->max_remote_ipv6_addrs = (unsigned short )*(cmd.rsp.arg + 9UL);
  _dev_info((struct device const *)dev, "\n\tmin_tx_bw: %d, max_tx_bw: %d max_tx_ques: %d,\n\tmax_tx_mac_filters: %d max_rx_mcast_mac_filters: %d,\n\tmax_rx_ucast_mac_filters: 0x%x, max_rx_ip_addr: %d,\n\tmax_rx_lro_flow: %d max_rx_status_rings: %d,\n\tmax_rx_buf_rings: %d, max_rx_ques: %d, max_tx_vlan_keys %d\n\tlocal_ipv6_addr: %d, remote_ipv6_addr: %d\n",
            (int )npar_info->min_tx_bw, (int )npar_info->max_tx_bw, (int )npar_info->max_tx_ques,
            (int )npar_info->max_tx_mac_filters, (int )npar_info->max_rx_mcast_mac_filters,
            (int )npar_info->max_rx_ucast_mac_filters, (int )npar_info->max_rx_ip_addr,
            (int )npar_info->max_rx_lro_flow, (int )npar_info->max_rx_status_rings,
            (int )npar_info->max_rx_buf_rings, (int )npar_info->max_rx_ques, (int )npar_info->max_tx_vlan_keys,
            (int )npar_info->max_local_ipv6_addrs, (int )npar_info->max_remote_ipv6_addrs);
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_sriov_set_pvid_mode(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  {
  adapter->rx_pvid = (u16 )(*(cmd->rsp.arg + 1UL) >> 16);
  adapter->flags = adapter->flags & 4294967039U;
  return (0);
}
}
static int qlcnic_sriov_set_guest_vlan_mode(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_sriov *sriov ;
  int i ;
  int num_vlans ;
  u16 *vlans ;
  void *tmp ;
  {
  sriov = (adapter->ahw)->sriov;
  if ((unsigned long )sriov->allowed_vlans != (unsigned long )((u16 *)0U)) {
    return (0);
  } else {
  }
  sriov->any_vlan = (unsigned int )((u8 )*(cmd->rsp.arg + 2UL)) & 15U;
  sriov->num_allowed_vlans = (u16 )(*(cmd->rsp.arg + 2UL) >> 16);
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Number of allowed Guest VLANs = %d\n",
            (int )sriov->num_allowed_vlans);
  qlcnic_sriov_alloc_vlans(adapter);
  if ((unsigned int )sriov->any_vlan == 0U) {
    return (0);
  } else {
  }
  num_vlans = (int )sriov->num_allowed_vlans;
  tmp = kzalloc((unsigned long )num_vlans * 2UL, 208U);
  sriov->allowed_vlans = (u16 *)tmp;
  if ((unsigned long )sriov->allowed_vlans == (unsigned long )((u16 *)0U)) {
    return (-12);
  } else {
  }
  vlans = (u16 *)cmd->rsp.arg + 3U;
  i = 0;
  goto ldv_51224;
  ldv_51223:
  *(sriov->allowed_vlans + (unsigned long )i) = *(vlans + (unsigned long )i);
  i = i + 1;
  ldv_51224: ;
  if (i < num_vlans) {
    goto ldv_51223;
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_get_vf_acl(struct qlcnic_adapter *adapter )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_cmd_args cmd ;
  int ret ;
  {
  sriov = (adapter->ahw)->sriov;
  ret = 0;
  memset((void *)(& cmd), 0, 200UL);
  ret = qlcnic_sriov_alloc_bc_mbx_args(& cmd, 2U);
  if (ret != 0) {
    return (ret);
  } else {
  }
  ret = qlcnic_issue_cmd(adapter, & cmd);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get ACL, err=%d\n",
            ret);
  } else {
    sriov->vlan_mode = (unsigned int )((u8 )*(cmd.rsp.arg + 1UL)) & 3U;
    switch ((int )sriov->vlan_mode) {
    case 2:
    ret = qlcnic_sriov_set_guest_vlan_mode(adapter, & cmd);
    goto ldv_51233;
    case 1:
    ret = qlcnic_sriov_set_pvid_mode(adapter, & cmd);
    goto ldv_51233;
    }
    ldv_51233: ;
  }
  qlcnic_free_mbx_args(& cmd);
  return (ret);
}
}
static int qlcnic_sriov_vf_init_driver(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_info nic_info ;
  int err ;
  int tmp ;
  {
  ahw = adapter->ahw;
  err = qlcnic_sriov_get_vf_vport_info(adapter, & nic_info, 0);
  if (err != 0) {
    return (err);
  } else {
  }
  ahw->max_mc_count = (u8 )nic_info.max_rx_mcast_mac_filters;
  err = qlcnic_get_nic_info(adapter, & nic_info, (int )ahw->pci_func);
  if (err != 0) {
    return (-5);
  } else {
  }
  tmp = qlcnic_83xx_get_port_info(adapter);
  if (tmp != 0) {
    return (-5);
  } else {
  }
  qlcnic_sriov_vf_cfg_buff_desc(adapter);
  adapter->flags = adapter->flags | 128U;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d\n",
            (adapter->ahw)->fw_hal_version);
  ahw->physical_port = (unsigned char )nic_info.phys_port;
  ahw->switch_mode = nic_info.switch_mode;
  ahw->max_mtu = nic_info.max_mtu;
  ahw->op_mode = nic_info.op_mode;
  ahw->capabilities = nic_info.capabilities;
  return (0);
}
}
static int qlcnic_sriov_setup_vf(struct qlcnic_adapter *adapter , int pci_using_dac )
{
  int err ;
  {
  adapter->flags = adapter->flags | 8388608U;
  (adapter->ahw)->total_nic_func = 1U;
  INIT_LIST_HEAD(& adapter->vf_mc_list);
  if (qlcnic_use_msi_x == 0 && qlcnic_use_msi != 0) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "Device does not support MSI interrupts\n");
  } else {
  }
  qlcnic_set_tx_ring_count(adapter, 1);
  qlcnic_set_sds_ring_count(adapter, 1);
  err = qlcnic_setup_intr(adapter);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to setup interrupt\n");
    goto err_out_disable_msi;
  } else {
  }
  err = qlcnic_83xx_setup_mbx_intr(adapter);
  if (err != 0) {
    goto err_out_disable_msi;
  } else {
  }
  err = qlcnic_sriov_init(adapter, 1);
  if (err != 0) {
    goto err_out_disable_mbx_intr;
  } else {
  }
  err = qlcnic_sriov_cfg_bc_intr(adapter, 1);
  if (err != 0) {
    goto err_out_cleanup_sriov;
  } else {
  }
  err = qlcnic_sriov_channel_cfg_cmd(adapter, 0);
  if (err != 0) {
    goto err_out_disable_bc_intr;
  } else {
  }
  err = qlcnic_sriov_vf_init_driver(adapter);
  if (err != 0) {
    goto err_out_send_channel_term;
  } else {
  }
  err = qlcnic_sriov_get_vf_acl(adapter);
  if (err != 0) {
    goto err_out_send_channel_term;
  } else {
  }
  err = qlcnic_setup_netdev(adapter, adapter->netdev, pci_using_dac);
  if (err != 0) {
    goto err_out_send_channel_term;
  } else {
  }
  pci_set_drvdata(adapter->pdev, (void *)adapter);
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: XGbE port initialized\n",
            (char *)(& (adapter->netdev)->name));
  qlcnic_schedule_work(adapter, & qlcnic_sriov_vf_poll_dev_state, (int )(adapter->ahw)->idc.delay);
  return (0);
  err_out_send_channel_term:
  qlcnic_sriov_channel_cfg_cmd(adapter, 1);
  err_out_disable_bc_intr:
  qlcnic_sriov_cfg_bc_intr(adapter, 0);
  err_out_cleanup_sriov:
  __qlcnic_sriov_cleanup(adapter);
  err_out_disable_mbx_intr:
  qlcnic_83xx_free_mbx_intr(adapter);
  err_out_disable_msi:
  qlcnic_teardown_intr(adapter);
  return (err);
}
}
static int qlcnic_sriov_check_dev_ready(struct qlcnic_adapter *adapter )
{
  u32 state ;
  {
  ldv_51255:
  msleep(20U);
  adapter->fw_fail_cnt = (u8 )((int )adapter->fw_fail_cnt + 1);
  if ((unsigned int )adapter->fw_fail_cnt > 5U) {
    return (-5);
  } else {
  }
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  if (state != 3U) {
    goto ldv_51255;
  } else {
  }
  return (0);
}
}
int qlcnic_sriov_vf_init(struct qlcnic_adapter *adapter , int pci_using_dac )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  int tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  {
  ahw = adapter->ahw;
  set_bit(1L, (unsigned long volatile *)(& ahw->idc.status));
  ahw->idc.delay = 250ULL;
  ahw->reset_context = 0U;
  adapter->fw_fail_cnt = 0U;
  ahw->msix_supported = 1U;
  adapter->need_fw_reset = 0U;
  adapter->flags = adapter->flags | 65536U;
  err = qlcnic_sriov_check_dev_ready(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_sriov_setup_vf(adapter, pci_using_dac);
  if (err != 0) {
    return (err);
  } else {
  }
  tmp = qlcnic_read_mac_addr(adapter);
  if (tmp != 0) {
    dev_warn((struct device const *)(& (adapter->pdev)->dev), "failed to read mac addr\n");
  } else {
  }
  __init_work(& adapter->idc_aen_work.work, 0);
  __constr_expr_0.counter = 137438953408L;
  adapter->idc_aen_work.work.data = __constr_expr_0;
  lockdep_init_map(& adapter->idc_aen_work.work.lockdep_map, "(&(&adapter->idc_aen_work)->work)",
                   & __key, 0);
  INIT_LIST_HEAD(& adapter->idc_aen_work.work.entry);
  adapter->idc_aen_work.work.func = & qlcnic_83xx_idc_aen_work;
  init_timer_key(& adapter->idc_aen_work.timer, 2U, "(&(&adapter->idc_aen_work)->timer)",
                 & __key___0);
  adapter->idc_aen_work.timer.function = & delayed_work_timer_fn;
  adapter->idc_aen_work.timer.data = (unsigned long )(& adapter->idc_aen_work);
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (0);
}
}
void qlcnic_sriov_vf_set_ops(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  {
  ahw = adapter->ahw;
  ahw->op_mode = 4U;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "HAL Version: %d Non Privileged SRIOV function\n",
            ahw->fw_hal_version);
  adapter->nic_ops = & qlcnic_sriov_vf_ops;
  set_bit(10L, (unsigned long volatile *)(& adapter->state));
  return;
}
}
void qlcnic_sriov_vf_register_map(struct qlcnic_hardware_context *ahw )
{
  {
  ahw->hw_ops = & qlcnic_sriov_vf_hw_ops;
  ahw->reg_tbl = (u32 *)(& qlcnic_83xx_reg_tbl);
  ahw->ext_reg_tbl = (u32 *)(& qlcnic_83xx_ext_reg_tbl);
  return;
}
}
static u32 qlcnic_sriov_get_bc_paysize(u32 real_pay_size , u8 curr_frag )
{
  u32 pay_size ;
  {
  pay_size = real_pay_size / (u32 )(((int )curr_frag + 1) * 1008);
  if (pay_size != 0U) {
    pay_size = 1008U;
  } else {
    pay_size = real_pay_size % 1008U;
  }
  return (pay_size);
}
}
int qlcnic_sriov_func_to_index(struct qlcnic_adapter *adapter , u8 pci_func )
{
  struct qlcnic_vf_info *vf_info ;
  u8 i ;
  bool tmp ;
  {
  vf_info = ((adapter->ahw)->sriov)->vf_info;
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    return (0);
  } else {
  }
  i = 0U;
  goto ldv_51285;
  ldv_51284: ;
  if ((int )(vf_info + (unsigned long )i)->pci_func == (int )pci_func) {
    return ((int )i);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_51285: ;
  if ((int )((adapter->ahw)->sriov)->num_vfs > (int )i) {
    goto ldv_51284;
  } else {
  }
  return (-22);
}
}
__inline static int qlcnic_sriov_alloc_bc_trans(struct qlcnic_bc_trans **trans )
{
  void *tmp ;
  {
  tmp = kzalloc(176UL, 32U);
  *trans = (struct qlcnic_bc_trans *)tmp;
  if ((unsigned long )*trans == (unsigned long )((struct qlcnic_bc_trans *)0)) {
    return (-12);
  } else {
  }
  init_completion(& (*trans)->resp_cmpl);
  return (0);
}
}
__inline static int qlcnic_sriov_alloc_bc_msg(struct qlcnic_bc_hdr **hdr , u32 size )
{
  void *tmp ;
  {
  tmp = kzalloc((unsigned long )size * 16UL, 32U);
  *hdr = (struct qlcnic_bc_hdr *)tmp;
  if ((unsigned long )*hdr == (unsigned long )((struct qlcnic_bc_hdr *)0)) {
    return (-12);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_alloc_bc_mbx_args(struct qlcnic_cmd_args *mbx , u32 type )
{
  struct qlcnic_mailbox_metadata const *mbx_tbl ;
  int i ;
  int size ;
  void *tmp ;
  void *tmp___0 ;
  {
  mbx_tbl = (struct qlcnic_mailbox_metadata const *)(& qlcnic_sriov_bc_mbx_tbl);
  size = 4;
  i = 0;
  goto ldv_51304;
  ldv_51303: ;
  if ((u32 )(mbx_tbl + (unsigned long )i)->cmd == type) {
    mbx->op_type = 1U;
    mbx->req.num = (mbx_tbl + (unsigned long )i)->in_args;
    mbx->rsp.num = (mbx_tbl + (unsigned long )i)->out_args;
    tmp = kcalloc((size_t )mbx->req.num, 4UL, 32U);
    mbx->req.arg = (u32 *)tmp;
    if ((unsigned long )mbx->req.arg == (unsigned long )((u32 *)0U)) {
      return (-12);
    } else {
    }
    tmp___0 = kcalloc((size_t )mbx->rsp.num, 4UL, 32U);
    mbx->rsp.arg = (u32 *)tmp___0;
    if ((unsigned long )mbx->rsp.arg == (unsigned long )((u32 *)0U)) {
      kfree((void const *)mbx->req.arg);
      mbx->req.arg = (u32 *)0U;
      return (-12);
    } else {
    }
    memset((void *)mbx->req.arg, 0, (unsigned long )mbx->req.num * 4UL);
    memset((void *)mbx->rsp.arg, 0, (unsigned long )mbx->rsp.num * 4UL);
    *(mbx->req.arg) = ((mbx->req.num << 16) | type) | 1610612736U;
    *(mbx->rsp.arg) = (type & 65535U) | (mbx->rsp.num << 16);
    return (0);
  } else {
  }
  i = i + 1;
  ldv_51304: ;
  if (i < size) {
    goto ldv_51303;
  } else {
  }
  return (-22);
}
}
static int qlcnic_sriov_prepare_bc_hdr(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd ,
                                       u16 seq , u8 msg_type )
{
  struct qlcnic_bc_hdr *hdr ;
  int i ;
  u32 num_regs ;
  u32 bc_pay_sz ;
  u16 remainder ;
  u8 cmd_op ;
  u8 num_frags ;
  u8 t_num_frags ;
  int tmp ;
  int tmp___0 ;
  {
  bc_pay_sz = 1008U;
  if ((unsigned int )msg_type == 0U) {
    trans->req_pay = (struct qlcnic_bc_payload *)cmd->req.arg;
    trans->rsp_pay = (struct qlcnic_bc_payload *)cmd->rsp.arg;
    num_regs = cmd->req.num;
    trans->req_pay_size = (unsigned int )((u16 )num_regs) * 4U;
    num_regs = cmd->rsp.num;
    trans->rsp_pay_size = (unsigned int )((u16 )num_regs) * 4U;
    cmd_op = (u8 )*(cmd->req.arg);
    remainder = (u16 )((u32 )trans->req_pay_size % bc_pay_sz);
    num_frags = (u8 )((u32 )trans->req_pay_size / bc_pay_sz);
    if ((unsigned int )remainder != 0U) {
      num_frags = (u8 )((int )num_frags + 1);
    } else {
    }
    t_num_frags = num_frags;
    tmp = qlcnic_sriov_alloc_bc_msg(& trans->req_hdr, (u32 )num_frags);
    if (tmp != 0) {
      return (-12);
    } else {
    }
    remainder = (u16 )((u32 )trans->rsp_pay_size % bc_pay_sz);
    num_frags = (u8 )((u32 )trans->rsp_pay_size / bc_pay_sz);
    if ((unsigned int )remainder != 0U) {
      num_frags = (u8 )((int )num_frags + 1);
    } else {
    }
    tmp___0 = qlcnic_sriov_alloc_bc_msg(& trans->rsp_hdr, (u32 )num_frags);
    if (tmp___0 != 0) {
      return (-12);
    } else {
    }
    num_frags = t_num_frags;
    hdr = trans->req_hdr;
  } else {
    cmd->req.arg = (u32 *)trans->req_pay;
    cmd->rsp.arg = (u32 *)trans->rsp_pay;
    cmd_op = (u8 )*(cmd->req.arg);
    cmd->cmd_op = (u32 )cmd_op;
    remainder = (u16 )((u32 )trans->rsp_pay_size % bc_pay_sz);
    num_frags = (u8 )((u32 )trans->rsp_pay_size / bc_pay_sz);
    if ((unsigned int )remainder != 0U) {
      num_frags = (u8 )((int )num_frags + 1);
    } else {
    }
    cmd->req.num = (unsigned int )trans->req_pay_size / 4U;
    cmd->rsp.num = (unsigned int )trans->rsp_pay_size / 4U;
    hdr = trans->rsp_hdr;
    cmd->op_type = (u32 )(trans->req_hdr)->op_type;
  }
  trans->trans_id = (u32 )seq;
  trans->cmd_id = (u16 )cmd_op;
  i = 0;
  goto ldv_51321;
  ldv_51320:
  (hdr + (unsigned long )i)->version = 2U;
  (hdr + (unsigned long )i)->msg_type = msg_type;
  (hdr + (unsigned long )i)->op_type = (unsigned char )cmd->op_type;
  (hdr + (unsigned long )i)->num_cmds = 1U;
  (hdr + (unsigned long )i)->num_frags = num_frags;
  (hdr + (unsigned long )i)->frag_num = (unsigned int )((u8 )i) + 1U;
  (hdr + (unsigned long )i)->cmd_op = cmd_op;
  (hdr + (unsigned long )i)->seq_id = seq;
  i = i + 1;
  ldv_51321: ;
  if ((int )num_frags > i) {
    goto ldv_51320;
  } else {
  }
  return (0);
}
}
static void qlcnic_sriov_cleanup_transaction(struct qlcnic_bc_trans *trans )
{
  {
  if ((unsigned long )trans == (unsigned long )((struct qlcnic_bc_trans *)0)) {
    return;
  } else {
  }
  kfree((void const *)trans->req_hdr);
  kfree((void const *)trans->rsp_hdr);
  kfree((void const *)trans);
  return;
}
}
static int qlcnic_sriov_clear_trans(struct qlcnic_vf_info *vf , struct qlcnic_bc_trans *trans ,
                                    u8 type )
{
  struct qlcnic_trans_list *t_list ;
  unsigned long flags ;
  int ret ;
  int tmp ;
  {
  ret = 0;
  if ((unsigned int )type == 1U) {
    t_list = & vf->rcv_act;
    ldv_spin_lock();
    t_list->count = t_list->count - 1;
    list_del(& trans->list);
    if (t_list->count > 0) {
      ret = 1;
    } else {
    }
    spin_unlock_irqrestore(& t_list->lock, flags);
  } else {
  }
  if ((unsigned int )type == 0U) {
    goto ldv_51335;
    ldv_51334:
    msleep(100U);
    ldv_51335:
    tmp = test_and_set_bit(0L, (unsigned long volatile *)(& vf->state));
    if (tmp != 0) {
      goto ldv_51334;
    } else {
    }
    vf->send_cmd = (struct qlcnic_bc_trans *)0;
    clear_bit(0L, (unsigned long volatile *)(& vf->state));
  } else {
  }
  return (ret);
}
}
static void qlcnic_sriov_schedule_bc_cmd(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                         void (*func)(struct work_struct * ) )
{
  int tmp ;
  {
  tmp = constant_test_bit(4L, (unsigned long const volatile *)(& vf->state));
  if (tmp != 0 || (unsigned int )(vf->adapter)->need_fw_reset != 0U) {
    return;
  } else {
  }
  queue_work(sriov->bc.bc_trans_wq, & vf->trans_work);
  return;
}
}
__inline static void qlcnic_sriov_wait_for_resp(struct qlcnic_bc_trans *trans )
{
  struct completion *cmpl ;
  unsigned long tmp ;
  {
  cmpl = & trans->resp_cmpl;
  tmp = wait_for_completion_timeout(cmpl, 2500UL);
  if (tmp != 0UL) {
    trans->trans_state = 4;
  } else {
    trans->trans_state = 3;
  }
  return;
}
}
static void qlcnic_sriov_handle_multi_frags(struct qlcnic_bc_trans *trans , u8 type )
{
  {
  if ((unsigned int )type == 1U) {
    trans->curr_rsp_frag = (u8 )((int )trans->curr_rsp_frag + 1);
    if ((int )trans->curr_rsp_frag < (int )(trans->rsp_hdr)->num_frags) {
      trans->trans_state = 0;
    } else {
      trans->trans_state = 4;
    }
  } else {
    trans->curr_req_frag = (u8 )((int )trans->curr_req_frag + 1);
    if ((int )trans->curr_req_frag < (int )(trans->req_hdr)->num_frags) {
      trans->trans_state = 0;
    } else {
      trans->trans_state = 2;
    }
  }
  return;
}
}
static void qlcnic_sriov_wait_for_channel_free(struct qlcnic_bc_trans *trans , u8 type )
{
  struct qlcnic_vf_info *vf ;
  struct completion *cmpl ;
  unsigned long tmp ;
  {
  vf = trans->vf;
  cmpl = & vf->ch_free_cmpl;
  tmp = wait_for_completion_timeout(cmpl, 2500UL);
  if (tmp == 0UL) {
    trans->trans_state = 3;
    return;
  } else {
  }
  clear_bit(2L, (unsigned long volatile *)(& vf->state));
  qlcnic_sriov_handle_multi_frags(trans, (int )type);
  return;
}
}
static void qlcnic_sriov_pull_bc_msg(struct qlcnic_adapter *adapter , u32 *hdr , u32 *pay ,
                                     u32 size )
{
  struct qlcnic_hardware_context *ahw ;
  u32 fw_mbx ;
  u8 i ;
  u8 max ;
  u8 hdr_size ;
  u8 j ;
  u32 *tmp ;
  u32 *tmp___0 ;
  {
  ahw = adapter->ahw;
  max = 2U;
  hdr_size = 4U;
  max = (int )((u8 )(size / 4U)) + (int )hdr_size;
  fw_mbx = readl((void const volatile *)ahw->pci_base0 + 2048U);
  i = 2U;
  j = 0U;
  goto ldv_51369;
  ldv_51368:
  tmp = hdr;
  hdr = hdr + 1;
  *tmp = readl((void const volatile *)(ahw->pci_base0 + ((unsigned long )((int )i * 4) + 2048UL)));
  i = (u8 )((int )i + 1);
  j = (u8 )((int )j + 1);
  ldv_51369: ;
  if ((int )j < (int )hdr_size) {
    goto ldv_51368;
  } else {
  }
  goto ldv_51372;
  ldv_51371:
  tmp___0 = pay;
  pay = pay + 1;
  *tmp___0 = readl((void const volatile *)(ahw->pci_base0 + ((unsigned long )((int )i * 4) + 2048UL)));
  i = (u8 )((int )i + 1);
  j = (u8 )((int )j + 1);
  ldv_51372: ;
  if ((int )j < (int )max) {
    goto ldv_51371;
  } else {
  }
  return;
}
}
static int __qlcnic_sriov_issue_bc_post(struct qlcnic_vf_info *vf )
{
  int ret ;
  u32 timeout ;
  int tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;
  {
  ret = -16;
  timeout = 10000U;
  ldv_51384:
  tmp = test_and_set_bit(2L, (unsigned long volatile *)(& vf->state));
  if (tmp == 0) {
    ret = 0;
    goto ldv_51379;
  } else {
  }
  if (1) {
    __const_udelay(4295000UL);
  } else {
    __ms = 1UL;
    goto ldv_51382;
    ldv_51381:
    __const_udelay(4295000UL);
    ldv_51382:
    tmp___0 = __ms;
    __ms = __ms - 1UL;
    if (tmp___0 != 0UL) {
      goto ldv_51381;
    } else {
    }
  }
  timeout = timeout - 1U;
  if (timeout != 0U) {
    goto ldv_51384;
  } else {
  }
  ldv_51379: ;
  return (ret);
}
}
static int qlcnic_sriov_issue_bc_post(struct qlcnic_bc_trans *trans , u8 type )
{
  struct qlcnic_vf_info *vf ;
  u32 pay_size ;
  u32 hdr_size ;
  u32 *hdr ;
  u32 *pay ;
  int ret ;
  u8 pci_func ;
  int tmp ;
  {
  vf = trans->vf;
  pci_func = trans->func_id;
  tmp = __qlcnic_sriov_issue_bc_post(vf);
  if (tmp != 0) {
    return (-16);
  } else {
  }
  if ((unsigned int )type == 0U) {
    hdr = (u32 *)trans->req_hdr + (unsigned long )trans->curr_req_frag;
    pay = (u32 *)trans->req_pay + (unsigned long )trans->curr_req_frag;
    hdr_size = 4U;
    pay_size = qlcnic_sriov_get_bc_paysize((u32 )trans->req_pay_size, (int )trans->curr_req_frag);
    pay_size = pay_size / 4U;
  } else {
    hdr = (u32 *)trans->rsp_hdr + (unsigned long )trans->curr_rsp_frag;
    pay = (u32 *)trans->rsp_pay + (unsigned long )trans->curr_rsp_frag;
    hdr_size = 4U;
    pay_size = qlcnic_sriov_get_bc_paysize((u32 )trans->rsp_pay_size, (int )trans->curr_rsp_frag);
    pay_size = pay_size / 4U;
  }
  ret = qlcnic_sriov_post_bc_msg(vf->adapter, hdr, pay, (int )pci_func, (int )((u8 )pay_size));
  return (ret);
}
}
static int __qlcnic_sriov_send_bc_msg(struct qlcnic_bc_trans *trans , struct qlcnic_vf_info *vf ,
                                      u8 type )
{
  bool flag ;
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  flag = 1;
  err = -5;
  goto ldv_51411;
  ldv_51410:
  tmp = constant_test_bit(4L, (unsigned long const volatile *)(& vf->state));
  if (tmp != 0 || (unsigned int )(vf->adapter)->need_fw_reset != 0U) {
    trans->trans_state = 3;
  } else {
  }
  switch ((unsigned int )trans->trans_state) {
  case 0U:
  trans->trans_state = 1;
  tmp___0 = qlcnic_sriov_issue_bc_post(trans, (int )type);
  if (tmp___0 != 0) {
    trans->trans_state = 3;
  } else {
  }
  goto ldv_51404;
  case 1U:
  qlcnic_sriov_wait_for_channel_free(trans, (int )type);
  goto ldv_51404;
  case 2U:
  qlcnic_sriov_wait_for_resp(trans);
  goto ldv_51404;
  case 4U:
  err = 0;
  flag = 0;
  goto ldv_51404;
  case 3U:
  err = -5;
  flag = 0;
  clear_bit(2L, (unsigned long volatile *)(& vf->state));
  goto ldv_51404;
  default:
  err = -5;
  flag = 0;
  }
  ldv_51404: ;
  ldv_51411: ;
  if ((int )flag) {
    goto ldv_51410;
  } else {
  }
  return (err);
}
}
static int qlcnic_sriov_send_bc_cmd(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans ,
                                    int pci_func )
{
  struct qlcnic_vf_info *vf ;
  int err ;
  int index ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = qlcnic_sriov_func_to_index(adapter, (int )((u8 )pci_func));
  index = tmp;
  if (index < 0) {
    return (-5);
  } else {
  }
  vf = ((adapter->ahw)->sriov)->vf_info + (unsigned long )index;
  trans->vf = vf;
  trans->func_id = (u8 )pci_func;
  tmp___2 = constant_test_bit(3L, (unsigned long const volatile *)(& vf->state));
  if (tmp___2 == 0) {
    tmp___0 = qlcnic_sriov_pf_check(adapter);
    if ((int )tmp___0) {
      return (-5);
    } else {
    }
    tmp___1 = qlcnic_sriov_vf_check(adapter);
    if ((int )tmp___1 && (unsigned int )trans->cmd_id != 0U) {
      return (-5);
    } else {
    }
  } else {
  }
  mutex_lock_nested(& vf->send_cmd_lock, 0U);
  vf->send_cmd = trans;
  err = __qlcnic_sriov_send_bc_msg(trans, vf, 0);
  qlcnic_sriov_clear_trans(vf, trans, 0);
  mutex_unlock(& vf->send_cmd_lock);
  return (err);
}
}
static void __qlcnic_sriov_process_bc_cmd(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans ,
                                          struct qlcnic_cmd_args *cmd )
{
  bool tmp ;
  {
  tmp = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp) {
    qlcnic_sriov_pf_process_bc_cmd(adapter, trans, cmd);
    return;
  } else {
  }
  *(cmd->rsp.arg) = *(cmd->rsp.arg) | 301989888U;
  return;
}
}
static void qlcnic_sriov_process_bc_cmd(struct work_struct *work )
{
  struct qlcnic_vf_info *vf ;
  struct work_struct const *__mptr ;
  struct qlcnic_bc_trans *trans ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_cmd_args cmd ;
  u8 req ;
  int tmp ;
  struct list_head const *__mptr___0 ;
  int tmp___0 ;
  int tmp___1 ;
  {
  __mptr = (struct work_struct const *)work;
  vf = (struct qlcnic_vf_info *)__mptr + 0xffffffffffffff80UL;
  trans = (struct qlcnic_bc_trans *)0;
  adapter = vf->adapter;
  if ((unsigned int )adapter->need_fw_reset != 0U) {
    return;
  } else {
  }
  tmp = constant_test_bit(4L, (unsigned long const volatile *)(& vf->state));
  if (tmp != 0) {
    return;
  } else {
  }
  memset((void *)(& cmd), 0, 200UL);
  __mptr___0 = (struct list_head const *)vf->rcv_act.wait_list.next;
  trans = (struct qlcnic_bc_trans *)__mptr___0 + 0xffffffffffffffe8UL;
  adapter = vf->adapter;
  tmp___0 = qlcnic_sriov_prepare_bc_hdr(trans, & cmd, (int )(trans->req_hdr)->seq_id,
                                        1);
  if (tmp___0 != 0) {
    goto cleanup_trans;
  } else {
  }
  __qlcnic_sriov_process_bc_cmd(adapter, trans, & cmd);
  trans->trans_state = 0;
  __qlcnic_sriov_send_bc_msg(trans, vf, 1);
  cleanup_trans:
  qlcnic_free_mbx_args(& cmd);
  tmp___1 = qlcnic_sriov_clear_trans(vf, trans, 1);
  req = (u8 )tmp___1;
  qlcnic_sriov_cleanup_transaction(trans);
  if ((unsigned int )req != 0U) {
    qlcnic_sriov_schedule_bc_cmd((adapter->ahw)->sriov, vf, & qlcnic_sriov_process_bc_cmd);
  } else {
  }
  return;
}
}
static void qlcnic_sriov_handle_bc_resp(struct qlcnic_bc_hdr *hdr , struct qlcnic_vf_info *vf )
{
  struct qlcnic_bc_trans *trans ;
  u32 pay_size ;
  int tmp ;
  {
  tmp = test_and_set_bit(0L, (unsigned long volatile *)(& vf->state));
  if (tmp != 0) {
    return;
  } else {
  }
  trans = vf->send_cmd;
  if ((unsigned long )trans == (unsigned long )((struct qlcnic_bc_trans *)0)) {
    goto clear_send;
  } else {
  }
  if (trans->trans_id != (u32 )hdr->seq_id) {
    goto clear_send;
  } else {
  }
  pay_size = qlcnic_sriov_get_bc_paysize((u32 )trans->rsp_pay_size, (int )trans->curr_rsp_frag);
  qlcnic_sriov_pull_bc_msg(vf->adapter, (u32 *)trans->rsp_hdr + (unsigned long )trans->curr_rsp_frag,
                           (u32 *)trans->rsp_pay + (unsigned long )trans->curr_rsp_frag,
                           pay_size);
  trans->curr_rsp_frag = (u8 )((int )trans->curr_rsp_frag + 1);
  if ((int )trans->curr_rsp_frag < (int )(trans->rsp_hdr)->num_frags) {
    goto clear_send;
  } else {
  }
  complete(& trans->resp_cmpl);
  clear_send:
  clear_bit(0L, (unsigned long volatile *)(& vf->state));
  return;
}
}
int __qlcnic_sriov_add_act_list(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                struct qlcnic_bc_trans *trans )
{
  struct qlcnic_trans_list *t_list ;
  {
  t_list = & vf->rcv_act;
  t_list->count = t_list->count + 1;
  list_add_tail(& trans->list, & t_list->wait_list);
  if (t_list->count == 1) {
    qlcnic_sriov_schedule_bc_cmd(sriov, vf, & qlcnic_sriov_process_bc_cmd);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_add_act_list(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                     struct qlcnic_bc_trans *trans )
{
  struct qlcnic_trans_list *t_list ;
  {
  t_list = & vf->rcv_act;
  spin_lock(& t_list->lock);
  __qlcnic_sriov_add_act_list(sriov, vf, trans);
  spin_unlock(& t_list->lock);
  return (0);
}
}
static void qlcnic_sriov_handle_pending_trans(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                              struct qlcnic_bc_hdr *hdr )
{
  struct qlcnic_bc_trans *trans ;
  struct list_head *node ;
  u32 pay_size ;
  u32 curr_frag ;
  u8 found ;
  u8 active ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  trans = (struct qlcnic_bc_trans *)0;
  found = 0U;
  active = 0U;
  spin_lock(& vf->rcv_pend.lock);
  if (vf->rcv_pend.count > 0) {
    node = vf->rcv_pend.wait_list.next;
    goto ldv_51473;
    ldv_51472:
    __mptr = (struct list_head const *)node;
    trans = (struct qlcnic_bc_trans *)__mptr + 0xffffffffffffffe8UL;
    if (trans->trans_id == (u32 )hdr->seq_id) {
      found = 1U;
      goto ldv_51471;
    } else {
    }
    node = node->next;
    ldv_51473: ;
    if ((unsigned long )(& vf->rcv_pend.wait_list) != (unsigned long )node) {
      goto ldv_51472;
    } else {
    }
    ldv_51471: ;
  } else {
  }
  if ((unsigned int )found != 0U) {
    curr_frag = (u32 )trans->curr_req_frag;
    pay_size = qlcnic_sriov_get_bc_paysize((u32 )trans->req_pay_size, (int )((u8 )curr_frag));
    qlcnic_sriov_pull_bc_msg(vf->adapter, (u32 *)trans->req_hdr + (unsigned long )curr_frag,
                             (u32 *)trans->req_pay + (unsigned long )curr_frag, pay_size);
    trans->curr_req_frag = (u8 )((int )trans->curr_req_frag + 1);
    if ((int )trans->curr_req_frag >= (int )hdr->num_frags) {
      vf->rcv_pend.count = vf->rcv_pend.count - 1;
      list_del(& trans->list);
      active = 1U;
    } else {
    }
  } else {
  }
  spin_unlock(& vf->rcv_pend.lock);
  if ((unsigned int )active != 0U) {
    tmp = qlcnic_sriov_add_act_list(sriov, vf, trans);
    if (tmp != 0) {
      qlcnic_sriov_cleanup_transaction(trans);
    } else {
    }
  } else {
  }
  return;
}
}
static void qlcnic_sriov_handle_bc_cmd(struct qlcnic_sriov *sriov , struct qlcnic_bc_hdr *hdr ,
                                       struct qlcnic_vf_info *vf )
{
  struct qlcnic_bc_trans *trans ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_cmd_args cmd ;
  u32 pay_size ;
  int err ;
  u8 cmd_op ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  adapter = vf->adapter;
  if ((unsigned int )adapter->need_fw_reset != 0U) {
    return;
  } else {
  }
  tmp = constant_test_bit(3L, (unsigned long const volatile *)(& vf->state));
  if ((tmp == 0 && (unsigned int )*((unsigned char *)hdr + 1UL) == 0U) && (unsigned int )hdr->cmd_op != 0U) {
    return;
  } else {
  }
  if ((unsigned int )hdr->frag_num > 1U) {
    qlcnic_sriov_handle_pending_trans(sriov, vf, hdr);
    return;
  } else {
  }
  memset((void *)(& cmd), 0, 200UL);
  cmd_op = hdr->cmd_op;
  tmp___0 = qlcnic_sriov_alloc_bc_trans(& trans);
  if (tmp___0 != 0) {
    return;
  } else {
  }
  if ((unsigned int )*((unsigned char *)hdr + 1UL) != 0U) {
    err = qlcnic_sriov_alloc_bc_mbx_args(& cmd, (u32 )cmd_op);
  } else {
    err = qlcnic_alloc_mbx_args(& cmd, adapter, (u32 )cmd_op);
  }
  if (err != 0) {
    qlcnic_sriov_cleanup_transaction(trans);
    return;
  } else {
  }
  cmd.op_type = (u32 )hdr->op_type;
  tmp___1 = qlcnic_sriov_prepare_bc_hdr(trans, & cmd, (int )hdr->seq_id, 0);
  if (tmp___1 != 0) {
    qlcnic_free_mbx_args(& cmd);
    qlcnic_sriov_cleanup_transaction(trans);
    return;
  } else {
  }
  pay_size = qlcnic_sriov_get_bc_paysize((u32 )trans->req_pay_size, (int )trans->curr_req_frag);
  qlcnic_sriov_pull_bc_msg(vf->adapter, (u32 *)trans->req_hdr + (unsigned long )trans->curr_req_frag,
                           (u32 *)trans->req_pay + (unsigned long )trans->curr_req_frag,
                           pay_size);
  trans->func_id = vf->pci_func;
  trans->vf = vf;
  trans->trans_id = (u32 )hdr->seq_id;
  trans->curr_req_frag = (u8 )((int )trans->curr_req_frag + 1);
  tmp___2 = qlcnic_sriov_soft_flr_check(adapter, trans, vf);
  if ((int )tmp___2) {
    return;
  } else {
  }
  if ((int )trans->curr_req_frag == (int )(trans->req_hdr)->num_frags) {
    tmp___3 = qlcnic_sriov_add_act_list(sriov, vf, trans);
    if (tmp___3 != 0) {
      qlcnic_free_mbx_args(& cmd);
      qlcnic_sriov_cleanup_transaction(trans);
    } else {
    }
  } else {
    spin_lock(& vf->rcv_pend.lock);
    list_add_tail(& trans->list, & vf->rcv_pend.wait_list);
    vf->rcv_pend.count = vf->rcv_pend.count + 1;
    spin_unlock(& vf->rcv_pend.lock);
  }
  return;
}
}
static void qlcnic_sriov_handle_msg_event(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf )
{
  struct qlcnic_bc_hdr hdr ;
  u32 *ptr ;
  u8 msg_type ;
  u8 i ;
  {
  ptr = (u32 *)(& hdr);
  i = 2U;
  goto ldv_51494;
  ldv_51493:
  *(ptr + ((unsigned long )i + 0xfffffffffffffffeUL)) = readl((void const volatile *)(((vf->adapter)->ahw)->pci_base0 + ((unsigned long )((int )i * 4) + 2048UL)));
  i = (u8 )((int )i + 1);
  ldv_51494: ;
  if ((unsigned int )i <= 5U) {
    goto ldv_51493;
  } else {
  }
  msg_type = hdr.msg_type;
  switch ((int )msg_type) {
  case 0:
  qlcnic_sriov_handle_bc_cmd(sriov, & hdr, vf);
  goto ldv_51497;
  case 1:
  qlcnic_sriov_handle_bc_resp(& hdr, vf);
  goto ldv_51497;
  }
  ldv_51497: ;
  return;
}
}
static void qlcnic_sriov_handle_flr_event(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf )
{
  struct qlcnic_adapter *adapter ;
  bool tmp ;
  {
  adapter = vf->adapter;
  tmp = qlcnic_sriov_pf_check(adapter);
  if ((int )tmp) {
    qlcnic_sriov_pf_handle_flr(sriov, vf);
  } else {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Invalid event to VF. VF should not get FLR event\n");
  }
  return;
}
}
void qlcnic_sriov_handle_bc_event(struct qlcnic_adapter *adapter , u32 event )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_sriov *sriov ;
  int index ;
  u8 pci_func ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  sriov = (adapter->ahw)->sriov;
  pci_func = qlcnic_sriov_target_func_id(event);
  index = qlcnic_sriov_func_to_index(adapter, (int )pci_func);
  if (index < 0) {
    return;
  } else {
  }
  vf = sriov->vf_info + (unsigned long )index;
  vf->pci_func = pci_func;
  tmp = qlcnic_sriov_channel_free_check(event);
  if ((int )tmp) {
    complete(& vf->ch_free_cmpl);
  } else {
  }
  tmp___0 = qlcnic_sriov_flr_check(event);
  if ((int )tmp___0) {
    qlcnic_sriov_handle_flr_event(sriov, vf);
    return;
  } else {
  }
  tmp___1 = qlcnic_sriov_bc_msg_check(event);
  if ((int )tmp___1) {
    qlcnic_sriov_handle_msg_event(sriov, vf);
  } else {
  }
  return;
}
}
int qlcnic_sriov_cfg_bc_intr(struct qlcnic_adapter *adapter , u8 enable )
{
  struct qlcnic_cmd_args cmd ;
  int err ;
  int tmp ;
  int tmp___0 ;
  {
  tmp = constant_test_bit(10L, (unsigned long const volatile *)(& adapter->state));
  if (tmp == 0) {
    return (0);
  } else {
  }
  tmp___0 = qlcnic_alloc_mbx_args(& cmd, adapter, 49U);
  if (tmp___0 != 0) {
    return (-12);
  } else {
  }
  if ((unsigned int )enable != 0U) {
    *(cmd.req.arg + 1UL) = 240U;
  } else {
  }
  err = qlcnic_83xx_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to %s bc events, err=%d\n",
            (unsigned int )enable != 0U ? (char *)"enable" : (char *)"disable", err);
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_sriov_retry_bc_cmd(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans )
{
  u8 max ;
  u32 state ;
  {
  max = 5U;
  state = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  if (state == 3U) {
    msleep(20U);
    clear_bit(2L, (unsigned long volatile *)(& (trans->vf)->state));
    trans->trans_state = 0;
    adapter->fw_fail_cnt = (u8 )((int )adapter->fw_fail_cnt + 1);
    if ((int )adapter->fw_fail_cnt > (int )max) {
      return (-5);
    } else {
      return (0);
    }
  } else {
  }
  return (-5);
}
}
static int __qlcnic_sriov_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_mailbox *mbx ;
  struct device *dev ;
  struct qlcnic_bc_trans *trans ;
  int err ;
  u32 rsp_data ;
  u32 opcode ;
  u32 mbx_err_code ;
  u32 rsp ;
  u16 seq ;
  u8 func ;
  int tmp ;
  int tmp___0 ;
  char const *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  ahw = adapter->ahw;
  mbx = ahw->mailbox;
  dev = & (adapter->pdev)->dev;
  ((adapter->ahw)->sriov)->bc.trans_counter = (u16 )((int )((adapter->ahw)->sriov)->bc.trans_counter + 1);
  seq = ((adapter->ahw)->sriov)->bc.trans_counter;
  func = ahw->pci_func;
  tmp = qlcnic_sriov_alloc_bc_trans(& trans);
  rsp = (u32 )tmp;
  if (rsp != 0U) {
    goto free_cmd;
  } else {
  }
  tmp___0 = qlcnic_sriov_prepare_bc_hdr(trans, cmd, (int )seq, 0);
  rsp = (u32 )tmp___0;
  if (rsp != 0U) {
    goto cleanup_transaction;
  } else {
  }
  retry:
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile *)(& mbx->status));
  if (tmp___2 == 0) {
    rsp = 4294967291U;
    if ((int )(adapter->ahw)->msg_enable & 1) {
      tmp___1 = dev_name((struct device const *)(& (adapter->pdev)->dev));
      printk("\016%s: %s: MBX not Ready!(cmd 0x%x) for VF 0x%x\n", tmp___1, "__qlcnic_sriov_issue_cmd",
             (int )((unsigned short )*(cmd->req.arg)), (int )func);
    } else {
    }
    goto err_out;
  } else {
  }
  err = qlcnic_sriov_send_bc_cmd(adapter, trans, (int )func);
  if (err != 0) {
    dev_err((struct device const *)dev, "MBX command 0x%x timed out for VF %d\n",
            *(cmd->req.arg) & 65535U, (int )func);
    rsp = 17U;
    if ((unsigned int )(trans->req_hdr)->cmd_op == 0U) {
      tmp___3 = qlcnic_sriov_retry_bc_cmd(adapter, trans);
      if (tmp___3 == 0) {
        goto retry;
      } else {
      }
    } else {
    }
    goto err_out;
  } else {
  }
  rsp_data = *(cmd->rsp.arg);
  mbx_err_code = rsp_data >> 25;
  opcode = (u32 )((unsigned short )*(cmd->req.arg));
  if (mbx_err_code == 1U || mbx_err_code == 26U) {
    rsp = 0U;
  } else
  if (cmd->type == 1U) {
    rsp = 0U;
  } else {
    rsp = mbx_err_code;
    if (rsp == 0U) {
      rsp = 1U;
    } else {
    }
    dev_err((struct device const *)dev, "MBX command 0x%x failed with err:0x%x for VF %d\n",
            opcode, mbx_err_code, (int )func);
  }
  err_out: ;
  if (rsp == 17U) {
    ahw->reset_context = 1U;
    adapter->need_fw_reset = 1U;
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
  } else {
  }
  cleanup_transaction:
  qlcnic_sriov_cleanup_transaction(trans);
  free_cmd: ;
  if (cmd->type == 1U) {
    qlcnic_free_mbx_args(cmd);
    kfree((void const *)cmd);
  } else {
  }
  return ((int )rsp);
}
}
static int qlcnic_sriov_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  int tmp ;
  int tmp___0 ;
  {
  if (cmd->type == 1U) {
    tmp = qlcnic_sriov_async_issue_cmd(adapter, cmd);
    return (tmp);
  } else {
    tmp___0 = __qlcnic_sriov_issue_cmd(adapter, cmd);
    return (tmp___0);
  }
}
}
static int qlcnic_sriov_channel_cfg_cmd(struct qlcnic_adapter *adapter , u8 cmd_op )
{
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_vf_info *vf ;
  int ret ;
  int tmp ;
  {
  vf = ((adapter->ahw)->sriov)->vf_info;
  memset((void *)(& cmd), 0, 200UL);
  tmp = qlcnic_sriov_alloc_bc_mbx_args(& cmd, (u32 )cmd_op);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  ret = qlcnic_issue_cmd(adapter, & cmd);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed bc channel %s %d\n",
            (unsigned int )cmd_op != 0U ? (char *)"term" : (char *)"init", ret);
    goto out;
  } else {
  }
  cmd_op = (u8 )*(cmd.rsp.arg);
  if (*(cmd.rsp.arg) >> 25 == 2U) {
    return (2);
  } else {
  }
  if ((unsigned int )cmd_op == 0U) {
    set_bit(3L, (unsigned long volatile *)(& vf->state));
  } else {
    clear_bit(3L, (unsigned long volatile *)(& vf->state));
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return (ret);
}
}
static void qlcnic_vf_add_mc_list(struct net_device *netdev , u8 const *mac )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf ;
  u16 vlan_id ;
  int i ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  sriov = (adapter->ahw)->sriov;
  vf = ((adapter->ahw)->sriov)->vf_info;
  tmp___1 = qlcnic_sriov_check_any_vlan(vf);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    qlcnic_nic_add_mac(adapter, mac, 0);
  } else {
    spin_lock(& vf->vlan_list_lock);
    i = 0;
    goto ldv_51566;
    ldv_51565:
    vlan_id = *(vf->sriov_vlans + (unsigned long )i);
    if ((unsigned int )vlan_id != 0U) {
      qlcnic_nic_add_mac(adapter, mac, (int )vlan_id);
    } else {
    }
    i = i + 1;
    ldv_51566: ;
    if ((int )sriov->num_allowed_vlans > i) {
      goto ldv_51565;
    } else {
    }
    spin_unlock(& vf->vlan_list_lock);
    tmp___0 = qlcnic_84xx_check(adapter);
    if ((int )tmp___0) {
      qlcnic_nic_add_mac(adapter, mac, 0);
    } else {
    }
  }
  return;
}
}
void qlcnic_sriov_cleanup_async_list(struct qlcnic_back_channel *bc )
{
  struct list_head *head ;
  struct qlcnic_async_work_list *entry ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  head = & bc->async_list;
  flush_workqueue(bc->bc_async_wq);
  goto ldv_51576;
  ldv_51575:
  __mptr = (struct list_head const *)head->next;
  entry = (struct qlcnic_async_work_list *)__mptr;
  cancel_work_sync(& entry->work);
  list_del(& entry->list);
  kfree((void const *)entry);
  ldv_51576:
  tmp = list_empty((struct list_head const *)head);
  if (tmp == 0) {
    goto ldv_51575;
  } else {
  }
  return;
}
}
void qlcnic_sriov_vf_set_multi(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_hardware_context *ahw ;
  u8 bcast_addr[6U] ;
  struct netdev_hw_addr *ha ;
  u32 mode ;
  int tmp___0 ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  ahw = adapter->ahw;
  bcast_addr[0] = 255U;
  bcast_addr[1] = 255U;
  bcast_addr[2] = 255U;
  bcast_addr[3] = 255U;
  bcast_addr[4] = 255U;
  bcast_addr[5] = 255U;
  mode = 0U;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& adapter->state));
  if (tmp___0 == 0) {
    return;
  } else {
  }
  if ((netdev->flags & 256U) != 0U) {
    if ((adapter->flags & 2048U) == 0U) {
      mode = 1U;
    } else {
    }
  } else
  if ((netdev->flags & 512U) != 0U || netdev->mc.count > (int )ahw->max_mc_count) {
    mode = 2U;
  } else {
    qlcnic_vf_add_mc_list(netdev, (u8 const *)(& bcast_addr));
    if (netdev->mc.count != 0) {
      __mptr = (struct list_head const *)netdev->mc.list.next;
      ha = (struct netdev_hw_addr *)__mptr;
      goto ldv_51591;
      ldv_51590:
      qlcnic_vf_add_mc_list(netdev, (u8 const *)(& ha->addr));
      __mptr___0 = (struct list_head const *)ha->list.next;
      ha = (struct netdev_hw_addr *)__mptr___0;
      ldv_51591: ;
      if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->mc.list)) {
        goto ldv_51590;
      } else {
      }
    } else {
    }
  }
  if (netdev->uc.count > (int )ahw->max_uc_count) {
    mode = 1U;
  } else
  if (netdev->uc.count != 0) {
    __mptr___1 = (struct list_head const *)netdev->uc.list.next;
    ha = (struct netdev_hw_addr *)__mptr___1;
    goto ldv_51598;
    ldv_51597:
    qlcnic_vf_add_mc_list(netdev, (u8 const *)(& ha->addr));
    __mptr___2 = (struct list_head const *)ha->list.next;
    ha = (struct netdev_hw_addr *)__mptr___2;
    ldv_51598: ;
    if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->uc.list)) {
      goto ldv_51597;
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)adapter->pdev + 2531UL) != 0U) {
    if (mode == 1U && ! adapter->fdb_mac_learn) {
      qlcnic_alloc_lb_filters_mem(adapter);
      adapter->drv_mac_learn = 1;
      adapter->rx_mac_learn = 1;
    } else {
      adapter->drv_mac_learn = 0;
      adapter->rx_mac_learn = 0;
    }
  } else {
  }
  qlcnic_nic_set_promisc(adapter, mode);
  return;
}
}
static void qlcnic_sriov_handle_async_issue_cmd(struct work_struct *work )
{
  struct qlcnic_async_work_list *entry ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_cmd_args *cmd ;
  struct work_struct const *__mptr ;
  {
  __mptr = (struct work_struct const *)work;
  entry = (struct qlcnic_async_work_list *)__mptr + 0xfffffffffffffff0UL;
  adapter = (struct qlcnic_adapter *)entry->ptr;
  cmd = entry->cmd;
  __qlcnic_sriov_issue_cmd(adapter, cmd);
  return;
}
}
static struct qlcnic_async_work_list *qlcnic_sriov_get_free_node_async_work(struct qlcnic_back_channel *bc )
{
  struct list_head *node ;
  struct qlcnic_async_work_list *entry ;
  u8 empty ;
  struct list_head const *__mptr ;
  int tmp ;
  void *tmp___0 ;
  {
  entry = (struct qlcnic_async_work_list *)0;
  empty = 0U;
  node = bc->async_list.next;
  goto ldv_51618;
  ldv_51617:
  __mptr = (struct list_head const *)node;
  entry = (struct qlcnic_async_work_list *)__mptr;
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& entry->work.data));
  if (tmp == 0) {
    empty = 1U;
    goto ldv_51616;
  } else {
  }
  node = node->next;
  ldv_51618: ;
  if ((unsigned long )(& bc->async_list) != (unsigned long )node) {
    goto ldv_51617;
  } else {
  }
  ldv_51616: ;
  if ((unsigned int )empty == 0U) {
    tmp___0 = kzalloc(112UL, 32U);
    entry = (struct qlcnic_async_work_list *)tmp___0;
    if ((unsigned long )entry == (unsigned long )((struct qlcnic_async_work_list *)0)) {
      return ((struct qlcnic_async_work_list *)0);
    } else {
    }
    list_add_tail(& entry->list, & bc->async_list);
  } else {
  }
  return (entry);
}
}
static void qlcnic_sriov_schedule_async_cmd(struct qlcnic_back_channel *bc , void (*func)(struct work_struct * ) ,
                                            void *data , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_async_work_list *entry ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  {
  entry = (struct qlcnic_async_work_list *)0;
  entry = qlcnic_sriov_get_free_node_async_work(bc);
  if ((unsigned long )entry == (unsigned long )((struct qlcnic_async_work_list *)0)) {
    return;
  } else {
  }
  entry->ptr = data;
  entry->cmd = cmd;
  __init_work(& entry->work, 0);
  __constr_expr_0.counter = 137438953408L;
  entry->work.data = __constr_expr_0;
  lockdep_init_map(& entry->work.lockdep_map, "(&entry->work)", & __key, 0);
  INIT_LIST_HEAD(& entry->work.entry);
  entry->work.func = func;
  queue_work(bc->bc_async_wq, & entry->work);
  return;
}
}
static int qlcnic_sriov_async_issue_cmd(struct qlcnic_adapter *adapter , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_back_channel *bc ;
  {
  bc = & ((adapter->ahw)->sriov)->bc;
  if ((unsigned int )adapter->need_fw_reset != 0U) {
    return (-5);
  } else {
  }
  qlcnic_sriov_schedule_async_cmd(bc, & qlcnic_sriov_handle_async_issue_cmd, (void *)adapter,
                                  cmd);
  return (0);
}
}
static int qlcnic_sriov_vf_reinit_driver(struct qlcnic_adapter *adapter )
{
  int err ;
  {
  adapter->need_fw_reset = 0U;
  qlcnic_83xx_reinit_mbx_work((adapter->ahw)->mailbox);
  qlcnic_83xx_enable_mbx_interrupt(adapter);
  err = qlcnic_sriov_cfg_bc_intr(adapter, 1);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_sriov_channel_cfg_cmd(adapter, 0);
  if (err != 0) {
    goto err_out_cleanup_bc_intr;
  } else {
  }
  err = qlcnic_sriov_vf_init_driver(adapter);
  if (err != 0) {
    goto err_out_term_channel;
  } else {
  }
  return (0);
  err_out_term_channel:
  qlcnic_sriov_channel_cfg_cmd(adapter, 1);
  err_out_cleanup_bc_intr:
  qlcnic_sriov_cfg_bc_intr(adapter, 0);
  return (err);
}
}
static void qlcnic_sriov_vf_attach(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  int tmp ;
  bool tmp___0 ;
  {
  netdev = adapter->netdev;
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    tmp = qlcnic_up(adapter, netdev);
    if (tmp == 0) {
      qlcnic_restore_indev_addr(netdev, 1UL);
    } else {
    }
  } else {
  }
  netif_device_attach(netdev);
  return;
}
}
static void qlcnic_sriov_vf_detach(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_intrpt_config *intr_tbl ;
  struct net_device *netdev ;
  u8 i ;
  u8 max_ints ;
  bool tmp ;
  {
  ahw = adapter->ahw;
  intr_tbl = ahw->intr_tbl;
  netdev = adapter->netdev;
  max_ints = (unsigned int )ahw->num_msix + 255U;
  netif_device_detach(netdev);
  qlcnic_83xx_detach_mailbox_work(adapter);
  qlcnic_83xx_disable_mbx_intr(adapter);
  tmp = netif_running((struct net_device const *)netdev);
  if ((int )tmp) {
    qlcnic_down(adapter, netdev);
  } else {
  }
  i = 0U;
  goto ldv_51652;
  ldv_51651:
  (intr_tbl + (unsigned long )i)->id = (u16 )i;
  (intr_tbl + (unsigned long )i)->enabled = 0U;
  (intr_tbl + (unsigned long )i)->src = 0U;
  i = (u8 )((int )i + 1);
  ldv_51652: ;
  if ((int )i < (int )max_ints) {
    goto ldv_51651;
  } else {
  }
  ahw->reset_context = 0U;
  return;
}
}
static int qlcnic_sriov_vf_handle_dev_ready(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct device *dev ;
  struct qlc_83xx_idc *idc ;
  u8 func ;
  u32 state ;
  int tmp ;
  {
  ahw = adapter->ahw;
  dev = & (adapter->pdev)->dev;
  idc = & ahw->idc;
  func = ahw->pci_func;
  if ((unsigned int )idc->prev_state == 4U || (unsigned int )idc->prev_state == 2U) {
    tmp = qlcnic_sriov_vf_reinit_driver(adapter);
    if (tmp == 0) {
      qlcnic_sriov_vf_attach(adapter);
      adapter->fw_fail_cnt = 0U;
      _dev_info((struct device const *)dev, "%s: Reinitialization of VF 0x%x done after FW reset\n",
                "qlcnic_sriov_vf_handle_dev_ready", (int )func);
    } else {
      dev_err((struct device const *)dev, "%s: Reinitialization of VF 0x%x failed after FW reset\n",
              "qlcnic_sriov_vf_handle_dev_ready", (int )func);
      state = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 12UL));
      _dev_info((struct device const *)dev, "Current state 0x%x after FW reset\n",
                state);
    }
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_vf_handle_context_reset(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_mailbox *mbx ;
  struct device *dev ;
  struct qlc_83xx_idc *idc ;
  u8 func ;
  u32 state ;
  int tmp ;
  {
  ahw = adapter->ahw;
  mbx = ahw->mailbox;
  dev = & (adapter->pdev)->dev;
  idc = & ahw->idc;
  func = ahw->pci_func;
  adapter->reset_ctx_cnt = (u8 )((int )adapter->reset_ctx_cnt + 1);
  if ((unsigned int )adapter->reset_ctx_cnt <= 2U) {
    adapter->need_fw_reset = 1U;
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
    _dev_info((struct device const *)dev, "Resetting context, wait here to check if FW is in failed state\n");
    return (0);
  } else {
  }
  if ((unsigned int )adapter->reset_ctx_cnt > 8U) {
    clear_bit(1L, (unsigned long volatile *)(& idc->status));
    adapter->tx_timeo_cnt = 0U;
    adapter->fw_fail_cnt = 0U;
    adapter->reset_ctx_cnt = 0U;
    qlcnic_sriov_vf_detach(adapter);
    dev_err((struct device const *)dev, "Device context resets have exceeded the threshold, device interface will be shutdown\n");
    return (-5);
  } else {
  }
  _dev_info((struct device const *)dev, "Resetting context of VF 0x%x\n", (int )func);
  _dev_info((struct device const *)dev, "%s: Context reset count %d for VF 0x%x\n",
            "qlcnic_sriov_vf_handle_context_reset", (int )adapter->reset_ctx_cnt,
            (int )func);
  set_bit(2L, (unsigned long volatile *)(& adapter->state));
  adapter->need_fw_reset = 1U;
  clear_bit(2L, (unsigned long volatile *)(& mbx->status));
  qlcnic_sriov_vf_detach(adapter);
  adapter->need_fw_reset = 0U;
  tmp = qlcnic_sriov_vf_reinit_driver(adapter);
  if (tmp == 0) {
    qlcnic_sriov_vf_attach(adapter);
    adapter->tx_timeo_cnt = 0U;
    adapter->reset_ctx_cnt = 0U;
    adapter->fw_fail_cnt = 0U;
    _dev_info((struct device const *)dev, "Done resetting context for VF 0x%x\n",
              (int )func);
  } else {
    dev_err((struct device const *)dev, "%s: Reinitialization of VF 0x%x failed\n",
            "qlcnic_sriov_vf_handle_context_reset", (int )func);
    state = readl((void const volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 12UL));
    _dev_info((struct device const *)dev, "%s: Current state 0x%x\n", "qlcnic_sriov_vf_handle_context_reset",
              state);
  }
  return (0);
}
}
static int qlcnic_sriov_vf_idc_ready_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  int ret ;
  {
  ahw = adapter->ahw;
  ret = 0;
  if ((unsigned int )ahw->idc.prev_state != 3U) {
    ret = qlcnic_sriov_vf_handle_dev_ready(adapter);
  } else
  if ((unsigned int )ahw->reset_context != 0U) {
    ret = qlcnic_sriov_vf_handle_context_reset(adapter);
  } else {
  }
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (ret);
}
}
static int qlcnic_sriov_vf_idc_failed_state(struct qlcnic_adapter *adapter )
{
  struct qlc_83xx_idc *idc ;
  {
  idc = & (adapter->ahw)->idc;
  dev_err((struct device const *)(& (adapter->pdev)->dev), "Device is in failed state\n");
  if ((unsigned int )idc->prev_state == 3U) {
    qlcnic_sriov_vf_detach(adapter);
  } else {
  }
  clear_bit(1L, (unsigned long volatile *)(& idc->status));
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (-5);
}
}
static int qlcnic_sriov_vf_idc_need_quiescent_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_mailbox *mbx ;
  struct qlc_83xx_idc *idc ;
  {
  mbx = (adapter->ahw)->mailbox;
  idc = & (adapter->ahw)->idc;
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "Device is in quiescent state\n");
  if ((unsigned int )idc->prev_state == 3U) {
    set_bit(2L, (unsigned long volatile *)(& adapter->state));
    adapter->tx_timeo_cnt = 0U;
    adapter->reset_ctx_cnt = 0U;
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
    qlcnic_sriov_vf_detach(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_vf_idc_init_reset_state(struct qlcnic_adapter *adapter )
{
  struct qlcnic_mailbox *mbx ;
  struct qlc_83xx_idc *idc ;
  u8 func ;
  {
  mbx = (adapter->ahw)->mailbox;
  idc = & (adapter->ahw)->idc;
  func = (adapter->ahw)->pci_func;
  if ((unsigned int )idc->prev_state == 3U) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Firmware hang detected by VF 0x%x\n",
            (int )func);
    set_bit(2L, (unsigned long volatile *)(& adapter->state));
    adapter->tx_timeo_cnt = 0U;
    adapter->reset_ctx_cnt = 0U;
    clear_bit(2L, (unsigned long volatile *)(& mbx->status));
    qlcnic_sriov_vf_detach(adapter);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_vf_idc_unknown_state(struct qlcnic_adapter *adapter )
{
  {
  dev_err((struct device const *)(& (adapter->pdev)->dev), "%s: Device in unknown state\n",
          "qlcnic_sriov_vf_idc_unknown_state");
  return (0);
}
}
static void qlcnic_sriov_vf_periodic_tasks(struct qlcnic_adapter *adapter )
{
  {
  if ((unsigned int )adapter->fhash.fnum != 0U) {
    qlcnic_prune_lb_filters(adapter);
  } else {
  }
  return;
}
}
static void qlcnic_sriov_vf_poll_dev_state(struct work_struct *work )
{
  struct qlcnic_adapter *adapter ;
  struct qlc_83xx_idc *idc ;
  int ret ;
  struct work_struct const *__mptr ;
  unsigned int tmp ;
  int tmp___0 ;
  {
  ret = 0;
  __mptr = (struct work_struct const *)work;
  adapter = (struct qlcnic_adapter *)__mptr + 0xfffffffffffffc78UL;
  idc = & (adapter->ahw)->idc;
  tmp = readl((void const volatile *)(adapter->ahw)->pci_base0 + (unsigned long )*((adapter->ahw)->ext_reg_tbl + 12UL));
  idc->curr_state = (u8 )tmp;
  switch ((int )idc->curr_state) {
  case 3:
  ret = qlcnic_sriov_vf_idc_ready_state(adapter);
  goto ldv_51709;
  case 4: ;
  case 2:
  ret = qlcnic_sriov_vf_idc_init_reset_state(adapter);
  goto ldv_51709;
  case 5:
  ret = qlcnic_sriov_vf_idc_need_quiescent_state(adapter);
  goto ldv_51709;
  case 6:
  ret = qlcnic_sriov_vf_idc_failed_state(adapter);
  goto ldv_51709;
  case 7: ;
  goto ldv_51709;
  default:
  ret = qlcnic_sriov_vf_idc_unknown_state(adapter);
  }
  ldv_51709:
  idc->prev_state = idc->curr_state;
  qlcnic_sriov_vf_periodic_tasks(adapter);
  if (ret == 0) {
    tmp___0 = constant_test_bit(1L, (unsigned long const volatile *)(& idc->status));
    if (tmp___0 != 0) {
      qlcnic_schedule_work(adapter, & qlcnic_sriov_vf_poll_dev_state, (int )idc->delay);
    } else {
    }
  } else {
  }
  return;
}
}
static void qlcnic_sriov_vf_cancel_fw_work(struct qlcnic_adapter *adapter )
{
  int tmp ;
  {
  goto ldv_51720;
  ldv_51719:
  msleep(20U);
  ldv_51720:
  tmp = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp != 0) {
    goto ldv_51719;
  } else {
  }
  clear_bit(1L, (unsigned long volatile *)(& (adapter->ahw)->idc.status));
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  cancel_delayed_work_sync(& adapter->fw_work);
  return;
}
}
static int qlcnic_sriov_check_vlan_id(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                      u16 vlan_id )
{
  int i ;
  int err ;
  {
  err = -22;
  if ((unsigned long )vf->sriov_vlans == (unsigned long )((u16 *)0U)) {
    return (err);
  } else {
  }
  spin_lock_bh(& vf->vlan_list_lock);
  i = 0;
  goto ldv_51731;
  ldv_51730: ;
  if ((int )*(vf->sriov_vlans + (unsigned long )i) == (int )vlan_id) {
    err = 0;
    goto ldv_51729;
  } else {
  }
  i = i + 1;
  ldv_51731: ;
  if ((int )sriov->num_allowed_vlans > i) {
    goto ldv_51730;
  } else {
  }
  ldv_51729:
  spin_unlock_bh(& vf->vlan_list_lock);
  return (err);
}
}
static int qlcnic_sriov_validate_num_vlans(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf )
{
  int err ;
  {
  err = 0;
  spin_lock_bh(& vf->vlan_list_lock);
  if (vf->num_vlan >= (int )sriov->num_allowed_vlans) {
    err = -22;
  } else {
  }
  spin_unlock_bh(& vf->vlan_list_lock);
  return (err);
}
}
static int qlcnic_sriov_validate_vlan_cfg(struct qlcnic_adapter *adapter , u16 vid ,
                                          u8 enable )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf ;
  bool vlan_exist ;
  u8 allowed ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  sriov = (adapter->ahw)->sriov;
  allowed = 0U;
  vf = ((adapter->ahw)->sriov)->vf_info;
  vlan_exist = qlcnic_sriov_check_any_vlan(vf);
  if ((unsigned int )sriov->vlan_mode != 2U) {
    return (-22);
  } else {
  }
  if ((unsigned int )enable != 0U) {
    tmp = qlcnic_83xx_vf_check(adapter);
    if ((int )tmp && (int )vlan_exist) {
      return (-22);
    } else {
    }
    tmp___0 = qlcnic_sriov_validate_num_vlans(sriov, vf);
    if (tmp___0 != 0) {
      return (-22);
    } else {
    }
    if ((unsigned int )sriov->any_vlan != 0U) {
      i = 0;
      goto ldv_51748;
      ldv_51747: ;
      if ((int )*(sriov->allowed_vlans + (unsigned long )i) == (int )vid) {
        allowed = 1U;
      } else {
      }
      i = i + 1;
      ldv_51748: ;
      if ((int )sriov->num_allowed_vlans > i) {
        goto ldv_51747;
      } else {
      }
      if ((unsigned int )allowed == 0U) {
        return (-22);
      } else {
      }
    } else {
    }
  } else
  if (! vlan_exist) {
    return (-22);
  } else {
    tmp___1 = qlcnic_sriov_check_vlan_id(sriov, vf, (int )vid);
    if (tmp___1 != 0) {
      return (-22);
    } else {
    }
  }
  return (0);
}
}
static void qlcnic_sriov_vlan_operation(struct qlcnic_vf_info *vf , u16 vlan_id ,
                                        enum qlcnic_vlan_operations opcode )
{
  struct qlcnic_adapter *adapter ;
  struct qlcnic_sriov *sriov ;
  {
  adapter = vf->adapter;
  sriov = (adapter->ahw)->sriov;
  if ((unsigned long )vf->sriov_vlans == (unsigned long )((u16 *)0U)) {
    return;
  } else {
  }
  spin_lock_bh(& vf->vlan_list_lock);
  switch ((unsigned int )opcode) {
  case 0U:
  qlcnic_sriov_add_vlan_id(sriov, vf, (int )vlan_id);
  goto ldv_51758;
  case 1U:
  qlcnic_sriov_del_vlan_id(sriov, vf, (int )vlan_id);
  goto ldv_51758;
  default:
  netdev_err((struct net_device const *)adapter->netdev, "Invalid VLAN operation\n");
  }
  ldv_51758:
  spin_unlock_bh(& vf->vlan_list_lock);
  return;
}
}
int qlcnic_sriov_cfg_vf_guest_vlan(struct qlcnic_adapter *adapter , u16 vid , u8 enable )
{
  struct qlcnic_sriov *sriov ;
  struct net_device *netdev ;
  struct qlcnic_vf_info *vf ;
  struct qlcnic_cmd_args cmd ;
  int ret ;
  {
  sriov = (adapter->ahw)->sriov;
  netdev = adapter->netdev;
  memset((void *)(& cmd), 0, 200UL);
  if ((unsigned int )vid == 0U) {
    return (0);
  } else {
  }
  vf = ((adapter->ahw)->sriov)->vf_info;
  ret = qlcnic_sriov_validate_vlan_cfg(adapter, (int )vid, (int )enable);
  if (ret != 0) {
    return (ret);
  } else {
  }
  ret = qlcnic_sriov_alloc_bc_mbx_args(& cmd, 3U);
  if (ret != 0) {
    return (ret);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )(((int )enable & 1) | ((int )vid << 16));
  qlcnic_sriov_cleanup_async_list(& sriov->bc);
  ret = qlcnic_issue_cmd(adapter, & cmd);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to configure guest VLAN, err=%d\n",
            ret);
  } else {
    netif_addr_lock_bh(netdev);
    qlcnic_free_mac_list(adapter);
    netif_addr_unlock_bh(netdev);
    if ((unsigned int )enable != 0U) {
      qlcnic_sriov_vlan_operation(vf, (int )vid, 0);
    } else {
      qlcnic_sriov_vlan_operation(vf, (int )vid, 1);
    }
    netif_addr_lock_bh(netdev);
    qlcnic_set_multi(netdev);
    netif_addr_unlock_bh(netdev);
  }
  qlcnic_free_mbx_args(& cmd);
  return (ret);
}
}
static void qlcnic_sriov_vf_free_mac_list(struct qlcnic_adapter *adapter )
{
  struct list_head *head ;
  struct qlcnic_mac_vlan_list *cur ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  head = & adapter->mac_list;
  goto ldv_51779;
  ldv_51778:
  __mptr = (struct list_head const *)head->next;
  cur = (struct qlcnic_mac_vlan_list *)__mptr;
  qlcnic_sre_macaddr_change(adapter, (u8 *)(& cur->mac_addr), (int )cur->vlan_id,
                            2);
  list_del(& cur->list);
  kfree((void const *)cur);
  ldv_51779:
  tmp = list_empty((struct list_head const *)head);
  if (tmp == 0) {
    goto ldv_51778;
  } else {
  }
  return;
}
}
static int qlcnic_sriov_vf_shutdown(struct pci_dev *pdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  int retval ;
  bool tmp___0 ;
  {
  tmp = pci_get_drvdata(pdev);
  adapter = (struct qlcnic_adapter *)tmp;
  netdev = adapter->netdev;
  netif_device_detach(netdev);
  qlcnic_cancel_idc_work(adapter);
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_sriov_channel_cfg_cmd(adapter, 1);
  qlcnic_sriov_cfg_bc_intr(adapter, 0);
  qlcnic_83xx_disable_mbx_intr(adapter);
  cancel_delayed_work_sync(& adapter->idc_aen_work);
  retval = pci_save_state(pdev);
  if (retval != 0) {
    return (retval);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_vf_resume(struct qlcnic_adapter *adapter )
{
  struct qlc_83xx_idc *idc ;
  struct net_device *netdev ;
  int err ;
  bool tmp ;
  {
  idc = & (adapter->ahw)->idc;
  netdev = adapter->netdev;
  set_bit(1L, (unsigned long volatile *)(& idc->status));
  qlcnic_83xx_enable_mbx_interrupt(adapter);
  err = qlcnic_sriov_cfg_bc_intr(adapter, 1);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_sriov_channel_cfg_cmd(adapter, 0);
  if (err == 0) {
    tmp = netif_running((struct net_device const *)netdev);
    if ((int )tmp) {
      err = qlcnic_up(adapter, netdev);
      if (err == 0) {
        qlcnic_restore_indev_addr(netdev, 1UL);
      } else {
      }
    } else {
    }
  } else {
  }
  netif_device_attach(netdev);
  qlcnic_schedule_work(adapter, & qlcnic_sriov_vf_poll_dev_state, (int )idc->delay);
  return (err);
}
}
void qlcnic_sriov_alloc_vlans(struct qlcnic_adapter *adapter )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf ;
  int i ;
  void *tmp ;
  {
  sriov = (adapter->ahw)->sriov;
  i = 0;
  goto ldv_51800;
  ldv_51799:
  vf = sriov->vf_info + (unsigned long )i;
  tmp = kcalloc((size_t )sriov->num_allowed_vlans, 2UL, 208U);
  vf->sriov_vlans = (u16 *)tmp;
  i = i + 1;
  ldv_51800: ;
  if ((int )sriov->num_vfs > i) {
    goto ldv_51799;
  } else {
  }
  return;
}
}
void qlcnic_sriov_free_vlans(struct qlcnic_adapter *adapter )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf ;
  int i ;
  {
  sriov = (adapter->ahw)->sriov;
  i = 0;
  goto ldv_51809;
  ldv_51808:
  vf = sriov->vf_info + (unsigned long )i;
  kfree((void const *)vf->sriov_vlans);
  vf->sriov_vlans = (u16 *)0U;
  i = i + 1;
  ldv_51809: ;
  if ((int )sriov->num_vfs > i) {
    goto ldv_51808;
  } else {
  }
  return;
}
}
void qlcnic_sriov_add_vlan_id(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                              u16 vlan_id )
{
  int i ;
  {
  i = 0;
  goto ldv_51818;
  ldv_51817: ;
  if ((unsigned int )*(vf->sriov_vlans + (unsigned long )i) == 0U) {
    *(vf->sriov_vlans + (unsigned long )i) = vlan_id;
    vf->num_vlan = vf->num_vlan + 1;
    return;
  } else {
  }
  i = i + 1;
  ldv_51818: ;
  if ((int )sriov->num_allowed_vlans > i) {
    goto ldv_51817;
  } else {
  }
  return;
}
}
void qlcnic_sriov_del_vlan_id(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                              u16 vlan_id )
{
  int i ;
  {
  i = 0;
  goto ldv_51827;
  ldv_51826: ;
  if ((int )*(vf->sriov_vlans + (unsigned long )i) == (int )vlan_id) {
    *(vf->sriov_vlans + (unsigned long )i) = 0U;
    vf->num_vlan = vf->num_vlan - 1;
    return;
  } else {
  }
  i = i + 1;
  ldv_51827: ;
  if ((int )sriov->num_allowed_vlans > i) {
    goto ldv_51826;
  } else {
  }
  return;
}
}
bool qlcnic_sriov_check_any_vlan(struct qlcnic_vf_info *vf )
{
  bool err ;
  {
  err = 0;
  spin_lock_bh(& vf->vlan_list_lock);
  if (vf->num_vlan != 0) {
    err = 1;
  } else {
  }
  spin_unlock_bh(& vf->vlan_list_lock);
  return (err);
}
}
extern int ldv_release_4(void) ;
extern int ldv_suspend_4(void) ;
extern int ldv_probe_4(void) ;
extern int ldv_probe_5(void) ;
extern int ldv_release_5(void) ;
int ldv_retval_10 ;
void ldv_initialize_qlcnic_hardware_ops_5(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_sriov_vf_hw_ops_group0 = (struct qlcnic_adapter *)tmp;
  tmp___0 = ldv_zalloc(4096UL);
  qlcnic_sriov_vf_hw_ops_group1 = (struct qlcnic_host_sds_ring *)tmp___0;
  tmp___1 = ldv_zalloc(4096UL);
  qlcnic_sriov_vf_hw_ops_group2 = (struct qlcnic_host_tx_ring *)tmp___1;
  tmp___2 = ldv_zalloc(72UL);
  qlcnic_sriov_vf_hw_ops_group3 = (struct qlcnic_info *)tmp___2;
  tmp___3 = ldv_zalloc(200UL);
  qlcnic_sriov_vf_hw_ops_group4 = (struct qlcnic_cmd_args *)tmp___3;
  return;
}
}
void ldv_initialize_qlcnic_nic_template_4(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(1800UL);
  qlcnic_sriov_vf_ops_group0 = (struct qlcnic_adapter *)tmp;
  return;
}
}
void ldv_main_exported_4(void)
{
  int ldvarg289 ;
  int tmp ;
  u32 ldvarg286 ;
  u32 tmp___0 ;
  u32 ldvarg287 ;
  u32 tmp___1 ;
  struct net_device *ldvarg288 ;
  void *tmp___2 ;
  struct pci_dev *ldvarg284 ;
  void *tmp___3 ;
  __be32 ldvarg290 ;
  u32 ldvarg285 ;
  u32 tmp___4 ;
  int tmp___5 ;
  {
  tmp = __VERIFIER_nondet_int();
  ldvarg289 = tmp;
  tmp___0 = __VERIFIER_nondet_u32();
  ldvarg286 = tmp___0;
  tmp___1 = __VERIFIER_nondet_u32();
  ldvarg287 = tmp___1;
  tmp___2 = ldv_zalloc(3264UL);
  ldvarg288 = (struct net_device *)tmp___2;
  tmp___3 = ldv_zalloc(2976UL);
  ldvarg284 = (struct pci_dev *)tmp___3;
  tmp___4 = __VERIFIER_nondet_u32();
  ldvarg285 = tmp___4;
  memset((void *)(& ldvarg290), 0, 4UL);
  tmp___5 = __VERIFIER_nondet_int();
  switch (tmp___5) {
  case 0: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_83xx_config_ipaddr(qlcnic_sriov_vf_ops_group0, ldvarg290, ldvarg289);
    ldv_state_variable_4 = 4;
  } else {
  }
  if (ldv_state_variable_4 == 1) {
    qlcnic_83xx_config_ipaddr(qlcnic_sriov_vf_ops_group0, ldvarg290, ldvarg289);
    ldv_state_variable_4 = 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    qlcnic_83xx_config_ipaddr(qlcnic_sriov_vf_ops_group0, ldvarg290, ldvarg289);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_83xx_config_ipaddr(qlcnic_sriov_vf_ops_group0, ldvarg290, ldvarg289);
    ldv_state_variable_4 = 2;
  } else {
  }
  goto ldv_51861;
  case 1: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_83xx_napi_add(qlcnic_sriov_vf_ops_group0, ldvarg288);
    ldv_state_variable_4 = 4;
  } else {
  }
  if (ldv_state_variable_4 == 1) {
    qlcnic_83xx_napi_add(qlcnic_sriov_vf_ops_group0, ldvarg288);
    ldv_state_variable_4 = 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    qlcnic_83xx_napi_add(qlcnic_sriov_vf_ops_group0, ldvarg288);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_83xx_napi_add(qlcnic_sriov_vf_ops_group0, ldvarg288);
    ldv_state_variable_4 = 2;
  } else {
  }
  goto ldv_51861;
  case 2: ;
  if (ldv_state_variable_4 == 4) {
    ldv_retval_10 = qlcnic_sriov_vf_resume(qlcnic_sriov_vf_ops_group0);
    if (ldv_retval_10 == 0) {
      ldv_state_variable_4 = 2;
    } else {
    }
  } else {
  }
  goto ldv_51861;
  case 3: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_config_bridged_mode(qlcnic_sriov_vf_ops_group0, ldvarg287);
    ldv_state_variable_4 = 4;
  } else {
  }
  if (ldv_state_variable_4 == 1) {
    qlcnic_config_bridged_mode(qlcnic_sriov_vf_ops_group0, ldvarg287);
    ldv_state_variable_4 = 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    qlcnic_config_bridged_mode(qlcnic_sriov_vf_ops_group0, ldvarg287);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_config_bridged_mode(qlcnic_sriov_vf_ops_group0, ldvarg287);
    ldv_state_variable_4 = 2;
  } else {
  }
  goto ldv_51861;
  case 4: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_config_led(qlcnic_sriov_vf_ops_group0, ldvarg286, ldvarg285);
    ldv_state_variable_4 = 4;
  } else {
  }
  if (ldv_state_variable_4 == 1) {
    qlcnic_config_led(qlcnic_sriov_vf_ops_group0, ldvarg286, ldvarg285);
    ldv_state_variable_4 = 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    qlcnic_config_led(qlcnic_sriov_vf_ops_group0, ldvarg286, ldvarg285);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_config_led(qlcnic_sriov_vf_ops_group0, ldvarg286, ldvarg285);
    ldv_state_variable_4 = 2;
  } else {
  }
  goto ldv_51861;
  case 5: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 4;
  } else {
  }
  if (ldv_state_variable_4 == 1) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_83xx_clear_legacy_intr(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 2;
  } else {
  }
  goto ldv_51861;
  case 6: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_83xx_napi_del(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 4;
  } else {
  }
  if (ldv_state_variable_4 == 1) {
    qlcnic_83xx_napi_del(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    qlcnic_83xx_napi_del(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_83xx_napi_del(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 2;
  } else {
  }
  goto ldv_51861;
  case 7: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_sriov_vf_shutdown(ldvarg284);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_sriov_vf_shutdown(ldvarg284);
    ldv_state_variable_4 = 3;
  } else {
  }
  goto ldv_51861;
  case 8: ;
  if (ldv_state_variable_4 == 4) {
    qlcnic_sriov_vf_cancel_fw_work(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 4;
  } else {
  }
  if (ldv_state_variable_4 == 1) {
    qlcnic_sriov_vf_cancel_fw_work(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    qlcnic_sriov_vf_cancel_fw_work(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 3;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    qlcnic_sriov_vf_cancel_fw_work(qlcnic_sriov_vf_ops_group0);
    ldv_state_variable_4 = 2;
  } else {
  }
  goto ldv_51861;
  case 9: ;
  if (ldv_state_variable_4 == 2) {
    ldv_suspend_4();
    ldv_state_variable_4 = 4;
  } else {
  }
  goto ldv_51861;
  case 10: ;
  if (ldv_state_variable_4 == 4) {
    ldv_release_4();
    ldv_state_variable_4 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  if (ldv_state_variable_4 == 3) {
    ldv_release_4();
    ldv_state_variable_4 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  if (ldv_state_variable_4 == 2) {
    ldv_release_4();
    ldv_state_variable_4 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_51861;
  case 11: ;
  if (ldv_state_variable_4 == 1) {
    ldv_probe_4();
    ldv_state_variable_4 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_51861;
  default:
  ldv_stop();
  }
  ldv_51861: ;
  return;
}
}
void ldv_main_exported_5(void)
{
  struct ethtool_coalesce *ldvarg304 ;
  void *tmp ;
  u8 ldvarg294 ;
  u8 tmp___0 ;
  loff_t ldvarg316 ;
  loff_t tmp___1 ;
  u32 ldvarg298 ;
  u32 tmp___2 ;
  char *ldvarg317 ;
  void *tmp___3 ;
  u32 ldvarg303 ;
  u32 tmp___4 ;
  char *ldvarg302 ;
  void *tmp___5 ;
  ulong ldvarg297 ;
  int *ldvarg296 ;
  void *tmp___6 ;
  loff_t ldvarg301 ;
  loff_t tmp___7 ;
  int ldvarg295 ;
  int tmp___8 ;
  u16 ldvarg310 ;
  u16 tmp___9 ;
  struct qlcnic_pci_info *ldvarg319 ;
  void *tmp___10 ;
  size_t ldvarg300 ;
  size_t tmp___11 ;
  u8 *ldvarg314 ;
  void *tmp___12 ;
  u32 ldvarg306 ;
  u32 tmp___13 ;
  u8 *ldvarg309 ;
  void *tmp___14 ;
  u64 *ldvarg311 ;
  void *tmp___15 ;
  ulong ldvarg299 ;
  int ldvarg307 ;
  int tmp___16 ;
  u16 ldvarg313 ;
  u16 tmp___17 ;
  int ldvarg318 ;
  int tmp___18 ;
  int ldvarg305 ;
  int tmp___19 ;
  u8 ldvarg312 ;
  u8 tmp___20 ;
  u8 ldvarg308 ;
  u8 tmp___21 ;
  size_t ldvarg315 ;
  size_t tmp___22 ;
  int tmp___23 ;
  {
  tmp = ldv_zalloc(92UL);
  ldvarg304 = (struct ethtool_coalesce *)tmp;
  tmp___0 = __VERIFIER_nondet_u8();
  ldvarg294 = tmp___0;
  tmp___1 = __VERIFIER_nondet_loff_t();
  ldvarg316 = tmp___1;
  tmp___2 = __VERIFIER_nondet_u32();
  ldvarg298 = tmp___2;
  tmp___3 = ldv_zalloc(1UL);
  ldvarg317 = (char *)tmp___3;
  tmp___4 = __VERIFIER_nondet_u32();
  ldvarg303 = tmp___4;
  tmp___5 = ldv_zalloc(1UL);
  ldvarg302 = (char *)tmp___5;
  tmp___6 = ldv_zalloc(4UL);
  ldvarg296 = (int *)tmp___6;
  tmp___7 = __VERIFIER_nondet_loff_t();
  ldvarg301 = tmp___7;
  tmp___8 = __VERIFIER_nondet_int();
  ldvarg295 = tmp___8;
  tmp___9 = __VERIFIER_nondet_u16();
  ldvarg310 = tmp___9;
  tmp___10 = ldv_zalloc(20UL);
  ldvarg319 = (struct qlcnic_pci_info *)tmp___10;
  tmp___11 = __VERIFIER_nondet_size_t();
  ldvarg300 = tmp___11;
  tmp___12 = ldv_zalloc(1UL);
  ldvarg314 = (u8 *)tmp___12;
  tmp___13 = __VERIFIER_nondet_u32();
  ldvarg306 = tmp___13;
  tmp___14 = ldv_zalloc(1UL);
  ldvarg309 = (u8 *)tmp___14;
  tmp___15 = ldv_zalloc(8UL);
  ldvarg311 = (u64 *)tmp___15;
  tmp___16 = __VERIFIER_nondet_int();
  ldvarg307 = tmp___16;
  tmp___17 = __VERIFIER_nondet_u16();
  ldvarg313 = tmp___17;
  tmp___18 = __VERIFIER_nondet_int();
  ldvarg318 = tmp___18;
  tmp___19 = __VERIFIER_nondet_int();
  ldvarg305 = tmp___19;
  tmp___20 = __VERIFIER_nondet_u8();
  ldvarg312 = tmp___20;
  tmp___21 = __VERIFIER_nondet_u8();
  ldvarg308 = tmp___21;
  tmp___22 = __VERIFIER_nondet_size_t();
  ldvarg315 = tmp___22;
  memset((void *)(& ldvarg297), 0, 8UL);
  memset((void *)(& ldvarg299), 0, 8UL);
  tmp___23 = __VERIFIER_nondet_int();
  switch (tmp___23) {
  case 0: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_get_pci_info(qlcnic_sriov_vf_hw_ops_group0, ldvarg319);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_get_pci_info(qlcnic_sriov_vf_hw_ops_group0, ldvarg319);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 1: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_create_tx_ctx(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group2,
                              ldvarg318);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_create_tx_ctx(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group2,
                              ldvarg318);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 2: ;
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_read_crb(qlcnic_sriov_vf_hw_ops_group0, ldvarg317, ldvarg316, ldvarg315);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 3: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_sre_macaddr_change(qlcnic_sriov_vf_hw_ops_group0, ldvarg314, (int )ldvarg313,
                                   (int )ldvarg312);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_sre_macaddr_change(qlcnic_sriov_vf_hw_ops_group0, ldvarg314, (int )ldvarg313,
                                   (int )ldvarg312);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 4: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_sriov_vf_free_mac_list(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_sriov_vf_free_mac_list(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 5: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_set_nic_info(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group3);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_set_nic_info(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group3);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 6: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_change_l2_filter(qlcnic_sriov_vf_hw_ops_group0, ldvarg311, (int )ldvarg310);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_change_l2_filter(qlcnic_sriov_vf_hw_ops_group0, ldvarg311, (int )ldvarg310);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 7: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_get_mac_address(qlcnic_sriov_vf_hw_ops_group0, ldvarg309, (int )ldvarg308);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_get_mac_address(qlcnic_sriov_vf_hw_ops_group0, ldvarg309, (int )ldvarg308);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 8: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_config_hw_lro(qlcnic_sriov_vf_hw_ops_group0, ldvarg307);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_config_hw_lro(qlcnic_sriov_vf_hw_ops_group0, ldvarg307);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 9: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_get_func_no(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_get_func_no(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 10: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_setup_intr(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_setup_intr(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 11: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_cam_lock(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_cam_lock(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 12: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_alloc_mbx_args(qlcnic_sriov_vf_hw_ops_group4, qlcnic_sriov_vf_hw_ops_group0,
                               ldvarg306);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_alloc_mbx_args(qlcnic_sriov_vf_hw_ops_group4, qlcnic_sriov_vf_hw_ops_group0,
                               ldvarg306);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 13: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_del_tx_ctx(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group2);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_del_tx_ctx(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group2);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 14: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_setup_link_event(qlcnic_sriov_vf_hw_ops_group0, ldvarg305);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_setup_link_event(qlcnic_sriov_vf_hw_ops_group0, ldvarg305);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 15: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_disable_sds_intr(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group1);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_disable_sds_intr(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group1);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 16: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_config_intr_coal(qlcnic_sriov_vf_hw_ops_group0, ldvarg304);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_config_intr_coal(qlcnic_sriov_vf_hw_ops_group0, ldvarg304);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 17: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_sriov_issue_cmd(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group4);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_sriov_issue_cmd(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group4);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 18: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_cam_unlock(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_cam_unlock(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 19: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_create_rx_ctx(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_create_rx_ctx(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 20: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_nic_set_promisc(qlcnic_sriov_vf_hw_ops_group0, ldvarg303);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_nic_set_promisc(qlcnic_sriov_vf_hw_ops_group0, ldvarg303);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 21: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_napi_enable(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_napi_enable(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 22: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_process_rcv_ring_diag(qlcnic_sriov_vf_hw_ops_group1);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_process_rcv_ring_diag(qlcnic_sriov_vf_hw_ops_group1);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 23: ;
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_write_crb(qlcnic_sriov_vf_hw_ops_group0, ldvarg302, ldvarg301, ldvarg300);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 24: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_wrt_reg_indirect(qlcnic_sriov_vf_hw_ops_group0, ldvarg299, ldvarg298);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_wrt_reg_indirect(qlcnic_sriov_vf_hw_ops_group0, ldvarg299, ldvarg298);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 25: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_get_port_info(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_get_port_info(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 26: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_napi_disable(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_napi_disable(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 27: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_rd_reg_indirect(qlcnic_sriov_vf_hw_ops_group0, ldvarg297, ldvarg296);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_rd_reg_indirect(qlcnic_sriov_vf_hw_ops_group0, ldvarg297, ldvarg296);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 28: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_enable_sds_intr(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group1);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_enable_sds_intr(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group1);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 29: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_config_rss(qlcnic_sriov_vf_hw_ops_group0, ldvarg295);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_config_rss(qlcnic_sriov_vf_hw_ops_group0, ldvarg295);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 30: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_del_rx_ctx(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_del_rx_ctx(qlcnic_sriov_vf_hw_ops_group0);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 31: ;
  if (ldv_state_variable_5 == 1) {
    qlcnic_83xx_get_nic_info(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group3,
                             (int )ldvarg294);
    ldv_state_variable_5 = 1;
  } else {
  }
  if (ldv_state_variable_5 == 2) {
    qlcnic_83xx_get_nic_info(qlcnic_sriov_vf_hw_ops_group0, qlcnic_sriov_vf_hw_ops_group3,
                             (int )ldvarg294);
    ldv_state_variable_5 = 2;
  } else {
  }
  goto ldv_51904;
  case 32: ;
  if (ldv_state_variable_5 == 2) {
    ldv_release_5();
    ldv_state_variable_5 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_51904;
  case 33: ;
  if (ldv_state_variable_5 == 1) {
    ldv_probe_5();
    ldv_state_variable_5 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_51904;
  default:
  ldv_stop();
  }
  ldv_51904: ;
  return;
}
}
void *ldv_kmem_cache_alloc_526(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_532(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_534(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_536(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_537(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_538(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_539(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_540(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_541(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_542(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_543(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
void *ldv_kmem_cache_alloc_570(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_587(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
extern int pci_enable_sriov(struct pci_dev * , int ) ;
extern void pci_disable_sriov(struct pci_dev * ) ;
extern int pci_vfs_assigned(struct pci_dev * ) ;
struct sk_buff *ldv_skb_clone_578(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_586(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_580(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_576(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_584(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_585(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_581(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_582(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_583(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
__inline static bool qlcnic_83xx_pf_check(struct qlcnic_adapter *adapter )
{
  unsigned short device ;
  {
  device = (adapter->pdev)->device;
  return ((unsigned int )device == 32816U);
}
}
static int qlcnic_sriov_pf_get_vport_handle(struct qlcnic_adapter *adapter , u8 func ) ;
static int qlcnic_sriov_pf_set_vport_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info ,
                                          u16 vport_id )
{
  struct qlcnic_cmd_args cmd ;
  int err ;
  int tmp ;
  {
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 34U);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )(((int )vport_id << 16) | 1);
  *(cmd.req.arg + 2UL) = (u32 )npar_info->bit_offsets;
  *(cmd.req.arg + 2UL) = *(cmd.req.arg + 2UL) | (u32 )((int )npar_info->min_tx_bw << 16);
  *(cmd.req.arg + 3UL) = (u32 )((int )npar_info->max_tx_bw | ((int )npar_info->max_tx_ques << 16));
  *(cmd.req.arg + 4UL) = (u32 )npar_info->max_tx_mac_filters;
  *(cmd.req.arg + 4UL) = *(cmd.req.arg + 4UL) | (u32 )((int )npar_info->max_rx_mcast_mac_filters << 16);
  *(cmd.req.arg + 5UL) = (u32 )((int )npar_info->max_rx_ucast_mac_filters | ((int )npar_info->max_rx_ip_addr << 16));
  *(cmd.req.arg + 6UL) = (u32 )((int )npar_info->max_rx_lro_flow | ((int )npar_info->max_rx_status_rings << 16));
  *(cmd.req.arg + 7UL) = (u32 )((int )npar_info->max_rx_buf_rings | ((int )npar_info->max_rx_ques << 16));
  *(cmd.req.arg + 8UL) = (u32 )npar_info->max_tx_vlan_keys;
  *(cmd.req.arg + 8UL) = *(cmd.req.arg + 8UL) | (u32 )((int )npar_info->max_local_ipv6_addrs << 16);
  *(cmd.req.arg + 9UL) = (u32 )npar_info->max_remote_ipv6_addrs;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to set vport info, err=%d\n",
            err);
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_sriov_pf_cal_res_limit(struct qlcnic_adapter *adapter , struct qlcnic_info *info ,
                                         u16 func )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_resources *res ;
  u16 num_macs ;
  int ret ;
  int vpid ;
  int id ;
  struct qlcnic_vport *vp ;
  u32 num_vfs ;
  u32 max ;
  u32 temp ;
  bool tmp ;
  {
  sriov = (adapter->ahw)->sriov;
  res = & sriov->ff_max;
  num_macs = (unsigned int )sriov->num_allowed_vlans + 1U;
  ret = -5;
  vpid = qlcnic_sriov_pf_get_vport_handle(adapter, (int )((u8 )func));
  if (vpid < 0) {
    return (-22);
  } else {
  }
  num_vfs = (u32 )sriov->num_vfs;
  max = num_vfs + 1U;
  info->bit_offsets = 65535U;
  info->max_tx_ques = (u16 )((u32 )res->num_tx_queues / max);
  tmp = qlcnic_83xx_pf_check(adapter);
  if ((int )tmp) {
    num_macs = 2U;
  } else {
  }
  info->max_rx_mcast_mac_filters = res->num_rx_mcast_mac_filters;
  if ((int )((unsigned short )(adapter->ahw)->pci_func) == (int )func) {
    info->min_tx_bw = 0U;
    info->max_tx_bw = 100U;
    temp = (u32 )res->num_rx_ucast_mac_filters - (u32 )num_macs * num_vfs;
    info->max_rx_ucast_mac_filters = (u16 )temp;
    temp = (u32 )res->num_tx_mac_filters - (u32 )num_macs * num_vfs;
    info->max_tx_mac_filters = (u16 )temp;
    temp = ((u32 )num_macs * num_vfs) * 7U;
    temp = (u32 )res->num_rx_mcast_mac_filters - temp;
    info->max_rx_mcast_mac_filters = (u16 )temp;
    info->max_tx_ques = (int )res->num_tx_queues - (int )((u16 )sriov->num_vfs);
  } else {
    id = qlcnic_sriov_func_to_index(adapter, (int )((u8 )func));
    if (id < 0) {
      return (id);
    } else {
    }
    vp = (sriov->vf_info + (unsigned long )id)->vp;
    info->min_tx_bw = vp->min_tx_bw;
    info->max_tx_bw = vp->max_tx_bw;
    info->max_rx_ucast_mac_filters = num_macs;
    info->max_tx_mac_filters = num_macs;
    temp = (u32 )((int )num_macs * 7);
    info->max_rx_mcast_mac_filters = (u16 )temp;
    info->max_tx_ques = 1U;
  }
  info->max_rx_ip_addr = (u16 )((u32 )res->num_destip / max);
  info->max_rx_status_rings = (u16 )((u32 )res->num_rx_status_rings / max);
  info->max_rx_buf_rings = (u16 )((u32 )res->num_rx_buf_rings / max);
  info->max_rx_ques = (u16 )((u32 )res->num_rx_queues / max);
  info->max_rx_lro_flow = (u16 )(res->num_lro_flows_supported / max);
  info->max_tx_vlan_keys = res->num_txvlan_keys;
  info->max_local_ipv6_addrs = res->max_local_ipv6_addrs;
  info->max_remote_ipv6_addrs = res->max_remote_ipv6_addrs;
  ret = qlcnic_sriov_pf_set_vport_info(adapter, info, (int )((u16 )vpid));
  if (ret != 0) {
    return (ret);
  } else {
  }
  return (0);
}
}
static void qlcnic_sriov_pf_set_ff_max_res(struct qlcnic_adapter *adapter , struct qlcnic_info *info )
{
  struct qlcnic_resources *ff_max ;
  {
  ff_max = & ((adapter->ahw)->sriov)->ff_max;
  ff_max->num_tx_mac_filters = info->max_tx_mac_filters;
  ff_max->num_rx_ucast_mac_filters = info->max_rx_ucast_mac_filters;
  ff_max->num_rx_mcast_mac_filters = info->max_rx_mcast_mac_filters;
  ff_max->num_txvlan_keys = info->max_tx_vlan_keys;
  ff_max->num_rx_queues = info->max_rx_ques;
  ff_max->num_tx_queues = info->max_tx_ques;
  ff_max->num_lro_flows_supported = (u32 )info->max_rx_lro_flow;
  ff_max->num_destip = info->max_rx_ip_addr;
  ff_max->num_rx_buf_rings = info->max_rx_buf_rings;
  ff_max->num_rx_status_rings = info->max_rx_status_rings;
  ff_max->max_remote_ipv6_addrs = info->max_remote_ipv6_addrs;
  ff_max->max_local_ipv6_addrs = info->max_local_ipv6_addrs;
  return;
}
}
static void qlcnic_sriov_set_vf_max_vlan(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info )
{
  struct qlcnic_sriov *sriov ;
  int temp ;
  int total_fn ;
  bool tmp ;
  {
  sriov = (adapter->ahw)->sriov;
  temp = (int )npar_info->max_rx_mcast_mac_filters;
  total_fn = (int )sriov->num_vfs + 1;
  temp = temp / (total_fn * 7);
  sriov->num_allowed_vlans = (unsigned int )((u16 )temp) + 65535U;
  tmp = qlcnic_83xx_pf_check(adapter);
  if ((int )tmp) {
    sriov->num_allowed_vlans = 1U;
  } else {
  }
  netdev_info((struct net_device const *)adapter->netdev, "Max Guest VLANs supported per VF = %d\n",
              (int )sriov->num_allowed_vlans);
  return;
}
}
static int qlcnic_sriov_get_pf_info(struct qlcnic_adapter *adapter , struct qlcnic_info *npar_info )
{
  int err ;
  struct qlcnic_cmd_args cmd ;
  int tmp ;
  {
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 33U);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  *(cmd.req.arg + 1UL) = 2U;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to get PF info, err=%d\n",
            err);
    goto out;
  } else {
  }
  npar_info->total_pf = (u8 )*(cmd.rsp.arg + 2UL);
  npar_info->total_rss_engines = (u8 )(*(cmd.rsp.arg + 2UL) >> 8);
  npar_info->max_vports = (unsigned short )(*(cmd.rsp.arg + 2UL) >> 16);
  npar_info->max_tx_ques = (unsigned short )*(cmd.rsp.arg + 3UL);
  npar_info->max_tx_mac_filters = (unsigned short )(*(cmd.rsp.arg + 3UL) >> 16);
  npar_info->max_rx_mcast_mac_filters = (unsigned short )*(cmd.rsp.arg + 4UL);
  npar_info->max_rx_ucast_mac_filters = (unsigned short )(*(cmd.rsp.arg + 4UL) >> 16);
  npar_info->max_rx_ip_addr = (unsigned short )*(cmd.rsp.arg + 5UL);
  npar_info->max_rx_lro_flow = (unsigned short )(*(cmd.rsp.arg + 5UL) >> 16);
  npar_info->max_rx_status_rings = (unsigned short )*(cmd.rsp.arg + 6UL);
  npar_info->max_rx_buf_rings = (unsigned short )(*(cmd.rsp.arg + 6UL) >> 16);
  npar_info->max_rx_ques = (unsigned short )*(cmd.rsp.arg + 7UL);
  npar_info->max_tx_vlan_keys = (unsigned short )(*(cmd.rsp.arg + 7UL) >> 16);
  npar_info->max_local_ipv6_addrs = (unsigned short )*(cmd.rsp.arg + 8UL);
  npar_info->max_remote_ipv6_addrs = (unsigned short )(*(cmd.rsp.arg + 8UL) >> 16);
  qlcnic_sriov_set_vf_max_vlan(adapter, npar_info);
  qlcnic_sriov_pf_set_ff_max_res(adapter, npar_info);
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "\n\ttotal_pf: %d,\n\n\ttotal_rss_engines: %d max_vports: %d max_tx_ques %d,\n\tmax_tx_mac_filters: %d max_rx_mcast_mac_filters: %d,\n\tmax_rx_ucast_mac_filters: 0x%x, max_rx_ip_addr: %d,\n\tmax_rx_lro_flow: %d max_rx_status_rings: %d,\n\tmax_rx_buf_rings: %d, max_rx_ques: %d, max_tx_vlan_keys %d\n\tmax_local_ipv6_addrs: %d, max_remote_ipv6_addrs: %d\n",
            (int )npar_info->total_pf, (int )npar_info->total_rss_engines, (int )npar_info->max_vports,
            (int )npar_info->max_tx_ques, (int )npar_info->max_tx_mac_filters, (int )npar_info->max_rx_mcast_mac_filters,
            (int )npar_info->max_rx_ucast_mac_filters, (int )npar_info->max_rx_ip_addr,
            (int )npar_info->max_rx_lro_flow, (int )npar_info->max_rx_status_rings,
            (int )npar_info->max_rx_buf_rings, (int )npar_info->max_rx_ques, (int )npar_info->max_tx_vlan_keys,
            (int )npar_info->max_local_ipv6_addrs, (int )npar_info->max_remote_ipv6_addrs);
  out:
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static void qlcnic_sriov_pf_reset_vport_handle(struct qlcnic_adapter *adapter , u8 func )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vport *vp ;
  int index ;
  {
  sriov = (adapter->ahw)->sriov;
  if ((int )(adapter->ahw)->pci_func == (int )func) {
    sriov->vp_handle = 0U;
  } else {
    index = qlcnic_sriov_func_to_index(adapter, (int )func);
    if (index < 0) {
      return;
    } else {
    }
    vp = (sriov->vf_info + (unsigned long )index)->vp;
    vp->handle = 0U;
  }
  return;
}
}
static void qlcnic_sriov_pf_set_vport_handle(struct qlcnic_adapter *adapter , u16 vport_handle ,
                                             u8 func )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vport *vp ;
  int index ;
  {
  sriov = (adapter->ahw)->sriov;
  if ((int )(adapter->ahw)->pci_func == (int )func) {
    sriov->vp_handle = vport_handle;
  } else {
    index = qlcnic_sriov_func_to_index(adapter, (int )func);
    if (index < 0) {
      return;
    } else {
    }
    vp = (sriov->vf_info + (unsigned long )index)->vp;
    vp->handle = vport_handle;
  }
  return;
}
}
static int qlcnic_sriov_pf_get_vport_handle(struct qlcnic_adapter *adapter , u8 func )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf_info ;
  int index ;
  {
  sriov = (adapter->ahw)->sriov;
  if ((int )(adapter->ahw)->pci_func == (int )func) {
    return ((int )sriov->vp_handle);
  } else {
    index = qlcnic_sriov_func_to_index(adapter, (int )func);
    if (index >= 0) {
      vf_info = sriov->vf_info + (unsigned long )index;
      return ((int )(vf_info->vp)->handle);
    } else {
    }
  }
  return (-22);
}
}
static int qlcnic_sriov_pf_config_vport(struct qlcnic_adapter *adapter , u8 flag ,
                                        u16 func )
{
  struct qlcnic_cmd_args cmd ;
  int ret ;
  int vpid ;
  int tmp ;
  {
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 50U);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  if ((unsigned int )flag != 0U) {
    *(cmd.req.arg + 3UL) = (u32 )((int )func << 8);
  } else {
    vpid = qlcnic_sriov_pf_get_vport_handle(adapter, (int )((u8 )func));
    if (vpid < 0) {
      ret = -22;
      goto out;
    } else {
    }
    *(cmd.req.arg + 3UL) = (u32 )(((vpid & 65535) << 8) | 1);
  }
  ret = qlcnic_issue_cmd(adapter, & cmd);
  if (ret != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed %s vport, err %d for func 0x%x\n",
            (unsigned int )flag != 0U ? (char *)"enable" : (char *)"disable", ret,
            (int )func);
    goto out;
  } else {
  }
  if ((unsigned int )flag != 0U) {
    vpid = (int )*(cmd.rsp.arg + 2UL) & 65535;
    qlcnic_sriov_pf_set_vport_handle(adapter, (int )((u16 )vpid), (int )((u8 )func));
  } else {
    qlcnic_sriov_pf_reset_vport_handle(adapter, (int )((u8 )func));
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return (ret);
}
}
static int qlcnic_sriov_pf_cfg_vlan_filtering(struct qlcnic_adapter *adapter , u8 enable )
{
  struct qlcnic_cmd_args cmd ;
  int err ;
  bool tmp ;
  {
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 34U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = 4U;
  if ((unsigned int )enable != 0U) {
    adapter->flags = adapter->flags | 8388608U;
    *(cmd.req.arg + 1UL) = *(cmd.req.arg + 1UL) | 65536U;
    tmp = qlcnic_84xx_check(adapter);
    if ((int )tmp) {
      *(cmd.req.arg + 1UL) = *(cmd.req.arg + 1UL) | 524288U;
    } else {
    }
  } else {
    adapter->flags = adapter->flags & 4286578687U;
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to configure VLAN filtering, err=%d\n",
            err);
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_sriov_pf_cfg_flood(struct qlcnic_adapter *adapter )
{
  struct qlcnic_cmd_args cmd ;
  int err ;
  {
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 34U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = 65541U;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to configure VF Flood bit on PF, err=%d\n",
            err);
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_sriov_pf_cfg_eswitch(struct qlcnic_adapter *adapter , u8 func ,
                                       u8 enable )
{
  struct qlcnic_cmd_args cmd ;
  int err ;
  int tmp ;
  {
  err = -5;
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 37U);
  if (tmp != 0) {
    return (-12);
  } else {
  }
  *(cmd.req.arg) = *(cmd.req.arg) | 1610612736U;
  *(cmd.req.arg + 1UL) = (u32 )((((int )func & 15) << 2) | 66);
  if ((unsigned int )enable != 0U) {
    *(cmd.req.arg + 1UL) = *(cmd.req.arg + 1UL) | 1U;
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to enable sriov eswitch%d\n",
            err);
    err = -5;
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static void qlcnic_sriov_pf_del_flr_queue(struct qlcnic_adapter *adapter )
{
  struct qlcnic_sriov *sriov ;
  struct qlcnic_back_channel *bc ;
  int i ;
  {
  sriov = (adapter->ahw)->sriov;
  bc = & sriov->bc;
  i = 0;
  goto ldv_51186;
  ldv_51185:
  cancel_work_sync(& (sriov->vf_info + (unsigned long )i)->flr_work);
  i = i + 1;
  ldv_51186: ;
  if ((int )sriov->num_vfs > i) {
    goto ldv_51185;
  } else {
  }
  destroy_workqueue(bc->bc_flr_wq);
  return;
}
}
static int qlcnic_sriov_pf_create_flr_queue(struct qlcnic_adapter *adapter )
{
  struct qlcnic_back_channel *bc ;
  struct workqueue_struct *wq ;
  struct lock_class_key __key ;
  char const *__lock_name ;
  struct workqueue_struct *tmp ;
  {
  bc = & ((adapter->ahw)->sriov)->bc;
  __lock_name = "\"%s\"(\"qlcnic-flr\")";
  tmp = __alloc_workqueue_key("%s", 10U, 1, & __key, __lock_name, (char *)"qlcnic-flr");
  wq = tmp;
  if ((unsigned long )wq == (unsigned long )((struct workqueue_struct *)0)) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Cannot create FLR workqueue\n");
    return (-12);
  } else {
  }
  bc->bc_flr_wq = wq;
  return (0);
}
}
void qlcnic_sriov_pf_cleanup(struct qlcnic_adapter *adapter )
{
  u8 func ;
  bool tmp ;
  int tmp___0 ;
  {
  func = (adapter->ahw)->pci_func;
  tmp = qlcnic_sriov_enable_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  qlcnic_sriov_pf_del_flr_queue(adapter);
  qlcnic_sriov_cfg_bc_intr(adapter, 0);
  qlcnic_sriov_pf_config_vport(adapter, 0, (int )func);
  qlcnic_sriov_pf_cfg_eswitch(adapter, (int )func, 0);
  qlcnic_sriov_pf_cfg_vlan_filtering(adapter, 0);
  __qlcnic_sriov_cleanup(adapter);
  (adapter->ahw)->op_mode = 0U;
  clear_bit(10L, (unsigned long volatile *)(& adapter->state));
  return;
}
}
void qlcnic_sriov_pf_disable(struct qlcnic_adapter *adapter )
{
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  tmp = qlcnic_sriov_pf_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  tmp___1 = qlcnic_sriov_enable_check(adapter);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return;
  } else {
  }
  pci_disable_sriov(adapter->pdev);
  netdev_info((struct net_device const *)adapter->netdev, "SR-IOV is disabled successfully on port %d\n",
              (int )adapter->portnum);
  return;
}
}
static int qlcnic_pci_sriov_disable(struct qlcnic_adapter *adapter )
{
  struct net_device *netdev ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  {
  netdev = adapter->netdev;
  tmp = pci_vfs_assigned(adapter->pdev);
  if (tmp != 0) {
    netdev_err((struct net_device const *)adapter->netdev, "SR-IOV VFs belonging to port %d are assigned to VMs. SR-IOV can not be disabled on this port\n",
               (int )adapter->portnum);
    netdev_info((struct net_device const *)adapter->netdev, "Please detach SR-IOV VFs belonging to port %d from VMs, and then try to disable SR-IOV on this port\n",
                (int )adapter->portnum);
    return (-1);
  } else {
  }
  qlcnic_sriov_pf_disable(adapter);
  rtnl_lock();
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    __qlcnic_down(adapter, netdev);
  } else {
  }
  qlcnic_sriov_free_vlans(adapter);
  qlcnic_sriov_pf_cleanup(adapter);
  tmp___1 = qlcnic_83xx_configure_opmode(adapter);
  if (tmp___1 != 0) {
    rtnl_unlock();
    return (-5);
  } else {
  }
  tmp___2 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___2) {
    __qlcnic_up(adapter, netdev);
  } else {
  }
  rtnl_unlock();
  return (0);
}
}
static int qlcnic_sriov_pf_init(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_info nic_info ;
  struct qlcnic_info pf_info ;
  struct qlcnic_info vp_info ;
  int err ;
  u8 func ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  ahw = adapter->ahw;
  func = ahw->pci_func;
  tmp = qlcnic_sriov_enable_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {
  }
  err = qlcnic_sriov_pf_cfg_vlan_filtering(adapter, 1);
  if (err != 0) {
    return (err);
  } else {
  }
  tmp___1 = qlcnic_84xx_check(adapter);
  if ((int )tmp___1) {
    err = qlcnic_sriov_pf_cfg_flood(adapter);
    if (err != 0) {
      goto disable_vlan_filtering;
    } else {
    }
  } else {
  }
  err = qlcnic_sriov_pf_cfg_eswitch(adapter, (int )func, 1);
  if (err != 0) {
    goto disable_vlan_filtering;
  } else {
  }
  err = qlcnic_sriov_pf_config_vport(adapter, 1, (int )func);
  if (err != 0) {
    goto disable_eswitch;
  } else {
  }
  err = qlcnic_sriov_get_pf_info(adapter, & pf_info);
  if (err != 0) {
    goto delete_vport;
  } else {
  }
  err = qlcnic_get_nic_info(adapter, & nic_info, (int )func);
  if (err != 0) {
    goto delete_vport;
  } else {
  }
  err = qlcnic_sriov_pf_cal_res_limit(adapter, & vp_info, (int )func);
  if (err != 0) {
    goto delete_vport;
  } else {
  }
  err = qlcnic_sriov_cfg_bc_intr(adapter, 1);
  if (err != 0) {
    goto delete_vport;
  } else {
  }
  ahw->physical_port = (unsigned char )nic_info.phys_port;
  ahw->switch_mode = nic_info.switch_mode;
  ahw->max_mtu = nic_info.max_mtu;
  ahw->capabilities = nic_info.capabilities;
  ahw->nic_mode = 1U;
  return (err);
  delete_vport:
  qlcnic_sriov_pf_config_vport(adapter, 0, (int )func);
  disable_eswitch:
  qlcnic_sriov_pf_cfg_eswitch(adapter, (int )func, 0);
  disable_vlan_filtering:
  qlcnic_sriov_pf_cfg_vlan_filtering(adapter, 0);
  return (err);
}
}
static int qlcnic_sriov_pf_enable(struct qlcnic_adapter *adapter , int num_vfs )
{
  int err ;
  bool tmp ;
  int tmp___0 ;
  {
  tmp = qlcnic_sriov_enable_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {
  }
  err = pci_enable_sriov(adapter->pdev, num_vfs);
  if (err != 0) {
    qlcnic_sriov_pf_cleanup(adapter);
  } else {
  }
  return (err);
}
}
static int __qlcnic_pci_sriov_enable(struct qlcnic_adapter *adapter , int num_vfs )
{
  int err ;
  {
  err = 0;
  set_bit(10L, (unsigned long volatile *)(& adapter->state));
  (adapter->ahw)->op_mode = 3U;
  err = qlcnic_sriov_init(adapter, num_vfs);
  if (err != 0) {
    goto clear_op_mode;
  } else {
  }
  err = qlcnic_sriov_pf_create_flr_queue(adapter);
  if (err != 0) {
    goto sriov_cleanup;
  } else {
  }
  err = qlcnic_sriov_pf_init(adapter);
  if (err != 0) {
    goto del_flr_queue;
  } else {
  }
  qlcnic_sriov_alloc_vlans(adapter);
  return (err);
  del_flr_queue:
  qlcnic_sriov_pf_del_flr_queue(adapter);
  sriov_cleanup:
  __qlcnic_sriov_cleanup(adapter);
  clear_op_mode:
  clear_bit(10L, (unsigned long volatile *)(& adapter->state));
  (adapter->ahw)->op_mode = 0U;
  return (err);
}
}
static int qlcnic_pci_sriov_enable(struct qlcnic_adapter *adapter , int num_vfs )
{
  struct net_device *netdev ;
  int err ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  netdev = adapter->netdev;
  if ((adapter->flags & 4U) == 0U) {
    netdev_err((struct net_device const *)netdev, "SR-IOV cannot be enabled, when legacy interrupts are enabled\n");
    return (-5);
  } else {
  }
  rtnl_lock();
  tmp = netif_running((struct net_device const *)netdev);
  if ((int )tmp) {
    __qlcnic_down(adapter, netdev);
  } else {
  }
  err = __qlcnic_pci_sriov_enable(adapter, num_vfs);
  if (err != 0) {
    goto error;
  } else {
  }
  tmp___0 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___0) {
    __qlcnic_up(adapter, netdev);
  } else {
  }
  rtnl_unlock();
  err = qlcnic_sriov_pf_enable(adapter, num_vfs);
  if (err == 0) {
    netdev_info((struct net_device const *)netdev, "SR-IOV is enabled successfully on port %d\n",
                (int )adapter->portnum);
    return (num_vfs);
  } else {
  }
  rtnl_lock();
  tmp___1 = netif_running((struct net_device const *)netdev);
  if ((int )tmp___1) {
    __qlcnic_down(adapter, netdev);
  } else {
  }
  error:
  tmp___3 = qlcnic_83xx_configure_opmode(adapter);
  if (tmp___3 == 0) {
    tmp___2 = netif_running((struct net_device const *)netdev);
    if ((int )tmp___2) {
      __qlcnic_up(adapter, netdev);
    } else {
    }
  } else {
  }
  rtnl_unlock();
  netdev_info((struct net_device const *)netdev, "Failed to enable SR-IOV on port %d\n",
              (int )adapter->portnum);
  return (err);
}
}
int qlcnic_pci_sriov_configure(struct pci_dev *dev , int num_vfs )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int err ;
  int tmp___0 ;
  {
  tmp = pci_get_drvdata(dev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = test_and_set_bit(2L, (unsigned long volatile *)(& adapter->state));
  if (tmp___0 != 0) {
    return (-16);
  } else {
  }
  if (num_vfs == 0) {
    err = qlcnic_pci_sriov_disable(adapter);
  } else {
    err = qlcnic_pci_sriov_enable(adapter, num_vfs);
  }
  clear_bit(2L, (unsigned long volatile *)(& adapter->state));
  return (err);
}
}
static int qlcnic_sriov_set_vf_acl(struct qlcnic_adapter *adapter , u8 func )
{
  struct qlcnic_cmd_args cmd ;
  struct qlcnic_vport *vp ;
  int err ;
  int id ;
  u8 *mac ;
  {
  id = qlcnic_sriov_func_to_index(adapter, (int )func);
  if (id < 0) {
    return (id);
  } else {
  }
  vp = (((adapter->ahw)->sriov)->vf_info + (unsigned long )id)->vp;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 34U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg + 1UL) = (u32 )(((int )func << 16) | 3);
  if ((int )vp->spoofchk) {
    mac = (u8 *)(& vp->mac);
    *(cmd.req.arg + 2UL) = *(cmd.req.arg + 2UL) | 266U;
    *(cmd.req.arg + 4UL) = (u32 )((((int )*(mac + 5UL) | ((int )*(mac + 4UL) << 8)) | ((int )*(mac + 3UL) << 16)) | ((int )*(mac + 2UL) << 24));
    *(cmd.req.arg + 5UL) = (u32 )((int )*(mac + 1UL) | ((int )*mac << 8));
  } else {
  }
  if ((unsigned int )vp->vlan_mode == 1U) {
    *(cmd.req.arg + 2UL) = *(cmd.req.arg + 2UL) | 64U;
    *(cmd.req.arg + 3UL) = *(cmd.req.arg + 3UL) | (u32 )((int )vp->pvid << 8);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to set ACL, err=%d\n",
            err);
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_sriov_set_vf_vport_info(struct qlcnic_adapter *adapter , u16 func )
{
  struct qlcnic_info defvp_info ;
  int err ;
  {
  err = qlcnic_sriov_pf_cal_res_limit(adapter, & defvp_info, (int )func);
  if (err != 0) {
    return (-5);
  } else {
  }
  err = qlcnic_sriov_set_vf_acl(adapter, (int )((u8 )func));
  if (err != 0) {
    return (err);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_channel_cfg_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_vport *vp ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_sriov *sriov ;
  u16 func ;
  size_t size ;
  int err ;
  {
  vf = trans->vf;
  vp = vf->vp;
  func = (u16 )vf->pci_func;
  adapter = vf->adapter;
  sriov = (adapter->ahw)->sriov;
  if ((unsigned int )(trans->req_hdr)->cmd_op == 0U) {
    err = qlcnic_sriov_pf_config_vport(adapter, 1, (int )func);
    if (err == 0) {
      err = qlcnic_sriov_set_vf_vport_info(adapter, (int )func);
      if (err != 0) {
        qlcnic_sriov_pf_config_vport(adapter, 0, (int )func);
      } else {
      }
    } else {
    }
  } else {
    if ((unsigned int )vp->vlan_mode == 2U) {
      size = 2UL;
      size = (size_t )sriov->num_allowed_vlans * size;
      memset((void *)vf->sriov_vlans, 0, size);
    } else {
    }
    err = qlcnic_sriov_pf_config_vport(adapter, 0, (int )func);
  }
  if (err != 0) {
    goto err_out;
  } else {
  }
  *(cmd->rsp.arg) = *(cmd->rsp.arg) | 33554432U;
  if ((unsigned int )(trans->req_hdr)->cmd_op == 0U) {
    set_bit(3L, (unsigned long volatile *)(& vf->state));
  } else {
    clear_bit(3L, (unsigned long volatile *)(& vf->state));
  }
  return (err);
  err_out:
  *(cmd->rsp.arg) = *(cmd->rsp.arg) | 67108864U;
  return (err);
}
}
static int qlcnic_sriov_cfg_vf_def_mac(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf ,
                                       u16 vlan , u8 op )
{
  struct qlcnic_cmd_args *cmd ;
  struct qlcnic_macvlan_mbx mv ;
  struct qlcnic_vport *vp ;
  u8 *addr ;
  int err ;
  u32 *buf ;
  int vpid ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  {
  vp = vf->vp;
  tmp = kzalloc(200UL, 32U);
  cmd = (struct qlcnic_cmd_args *)tmp;
  if ((unsigned long )cmd == (unsigned long )((struct qlcnic_cmd_args *)0)) {
    return (-12);
  } else {
  }
  err = qlcnic_alloc_mbx_args(cmd, adapter, 69U);
  if (err != 0) {
    goto free_cmd;
  } else {
  }
  cmd->type = 1U;
  vpid = qlcnic_sriov_pf_get_vport_handle(adapter, (int )vf->pci_func);
  if (vpid < 0) {
    err = -22;
    goto free_args;
  } else {
  }
  if ((unsigned int )vlan != 0U) {
    op = (unsigned int )op == 1U || (unsigned int )op == 3U ? 3U : 4U;
  } else {
  }
  *(cmd->req.arg + 1UL) = (u32 )((int )op | 448);
  *(cmd->req.arg + 1UL) = (*(cmd->req.arg + 1UL) | (u32 )(vpid << 16)) | 2147483648U;
  addr = (u8 *)(& vp->mac);
  mv.vlan = vlan;
  mv.mac_addr0 = *addr;
  mv.mac_addr1 = *(addr + 1UL);
  mv.mac_addr2 = *(addr + 2UL);
  mv.mac_addr3 = *(addr + 3UL);
  mv.mac_addr4 = *(addr + 4UL);
  mv.mac_addr5 = *(addr + 5UL);
  buf = cmd->req.arg + 2UL;
  __len = 8UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)buf, (void const *)(& mv), __len);
  } else {
    __ret = memcpy((void *)buf, (void const *)(& mv), __len);
  }
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err == 0) {
    return (err);
  } else {
  }
  free_args:
  qlcnic_free_mbx_args(cmd);
  free_cmd:
  kfree((void const *)cmd);
  return (err);
}
}
static int qlcnic_sriov_validate_create_rx_ctx(struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg) >> 29 != 3U) {
    return (-22);
  } else {
  }
  return (0);
}
}
static void qlcnic_83xx_cfg_default_mac_vlan(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf ,
                                             int opcode )
{
  struct qlcnic_sriov *sriov ;
  u16 vlan ;
  int i ;
  bool tmp ;
  bool tmp___0 ;
  {
  sriov = (adapter->ahw)->sriov;
  spin_lock_bh(& vf->vlan_list_lock);
  if (vf->num_vlan != 0) {
    i = 0;
    goto ldv_51302;
    ldv_51301:
    vlan = *(vf->sriov_vlans + (unsigned long )i);
    if ((unsigned int )vlan != 0U) {
      qlcnic_sriov_cfg_vf_def_mac(adapter, vf, (int )vlan, (int )((u8 )opcode));
    } else {
    }
    i = i + 1;
    ldv_51302: ;
    if ((int )sriov->num_allowed_vlans > i) {
      goto ldv_51301;
    } else {
    }
  } else {
  }
  spin_unlock_bh(& vf->vlan_list_lock);
  if ((unsigned int )(vf->vp)->vlan_mode != 1U) {
    tmp = qlcnic_83xx_pf_check(adapter);
    if ((int )tmp) {
      tmp___0 = qlcnic_sriov_check_any_vlan(vf);
      if ((int )tmp___0) {
        return;
      } else {
      }
    } else {
    }
    qlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0, (int )((u8 )opcode));
  } else {
  }
  return;
}
}
static int qlcnic_sriov_pf_create_rx_ctx_cmd(struct qlcnic_bc_trans *tran , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_rcv_mbx_out *mbx_out ;
  int err ;
  {
  vf = tran->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_create_rx_ctx(cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  *(cmd->req.arg + 6UL) = (u32 )(vf->vp)->handle;
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err == 0) {
    mbx_out = (struct qlcnic_rcv_mbx_out *)cmd->rsp.arg + 1U;
    vf->rx_ctx_id = mbx_out->ctx_id;
    qlcnic_83xx_cfg_default_mac_vlan(adapter, vf, 1);
  } else {
    vf->rx_ctx_id = 0U;
  }
  return (err);
}
}
static int qlcnic_sriov_pf_mac_address_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  u8 type ;
  u8 *mac ;
  {
  vf = trans->vf;
  type = (u8 )*(cmd->req.arg + 1UL);
  switch ((int )type) {
  case 2: ;
  case 5:
  *(cmd->rsp.arg) = 67108864U;
  goto ldv_51321;
  case 1:
  *(cmd->rsp.arg) = 33554432U;
  mac = (u8 *)(& (vf->vp)->mac);
  *(cmd->rsp.arg + 2UL) = (u32 )((int )*(mac + 1UL) | (((int )*mac << 8) & 65535));
  *(cmd->rsp.arg + 1UL) = (unsigned int )(((int )*(mac + 5UL) | (((int )*(mac + 4UL) << 8) & 65535)) | (((int )*(mac + 3UL) << 16) & 16711680)) | (unsigned int )((int )*(mac + 2UL) << 24);
  }
  ldv_51321: ;
  return (0);
}
}
static int qlcnic_sriov_validate_create_tx_ctx(struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg) >> 29 != 3U) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_create_tx_ctx_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_tx_mbx_out *mbx_out ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_create_tx_ctx(cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  *(cmd->req.arg + 5UL) = *(cmd->req.arg + 5UL) | (u32 )((int )(vf->vp)->handle << 16);
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err == 0) {
    mbx_out = (struct qlcnic_tx_mbx_out *)cmd->rsp.arg + 2U;
    vf->tx_ctx_id = mbx_out->ctx_id;
  } else {
    vf->tx_ctx_id = 0U;
  }
  return (err);
}
}
static int qlcnic_sriov_validate_del_rx_ctx(struct qlcnic_vf_info *vf , struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg) >> 29 != 3U) {
    return (-22);
  } else {
  }
  if ((*(cmd->req.arg + 1UL) & 65535U) != (u32 )vf->rx_ctx_id) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_del_rx_ctx_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_del_rx_ctx(vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  qlcnic_83xx_cfg_default_mac_vlan(adapter, vf, 2);
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | (u32 )((int )(vf->vp)->handle << 16);
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err == 0) {
    vf->rx_ctx_id = 0U;
  } else {
  }
  return (err);
}
}
static int qlcnic_sriov_validate_del_tx_ctx(struct qlcnic_vf_info *vf , struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg) >> 29 != 3U) {
    return (-22);
  } else {
  }
  if ((*(cmd->req.arg + 1UL) & 65535U) != (u32 )vf->tx_ctx_id) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_del_tx_ctx_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_del_tx_ctx(vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | (u32 )((int )(vf->vp)->handle << 16);
  err = qlcnic_issue_cmd(adapter, cmd);
  if (err == 0) {
    vf->tx_ctx_id = 0U;
  } else {
  }
  return (err);
}
}
static int qlcnic_sriov_validate_cfg_lro(struct qlcnic_vf_info *vf , struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg + 1UL) >> 16 != (u32 )vf->rx_ctx_id) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_cfg_lro_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_cfg_lro(vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, cmd);
  return (err);
}
}
static int qlcnic_sriov_pf_cfg_ip_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  u8 op ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = -5;
  op = (u8 )*(cmd->req.arg + 1UL);
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | (u32 )((int )(vf->vp)->handle << 16);
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | 2147483648U;
  err = qlcnic_issue_cmd(adapter, cmd);
  return (err);
}
}
static int qlcnic_sriov_validate_cfg_intrpt(struct qlcnic_vf_info *vf , struct qlcnic_cmd_args *cmd )
{
  {
  if (((*(cmd->req.arg + 1UL) >> 8) & 255U) != (u32 )vf->pci_func) {
    return (-22);
  } else {
  }
  if ((*(cmd->req.arg + 1UL) & 65536U) == 0U) {
    return (-22);
  } else {
  }
  if ((*(cmd->req.arg + 1UL) & 255U) != 1U) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_cfg_intrpt_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_cfg_intrpt(vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
  } else {
    err = qlcnic_issue_cmd(adapter, cmd);
  }
  return (err);
}
}
static int qlcnic_sriov_validate_mtu(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf ,
                                     struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg + 1UL) != (u32 )vf->rx_ctx_id) {
    return (-22);
  } else {
  }
  if (*(cmd->req.arg + 2UL) > (u32 )(adapter->ahw)->max_mtu) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_set_mtu_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_mtu(adapter, vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
  } else {
    err = qlcnic_issue_cmd(adapter, cmd);
  }
  return (err);
}
}
static int qlcnic_sriov_validate_get_nic_info(struct qlcnic_vf_info *vf , struct qlcnic_cmd_args *cmd )
{
  {
  if ((int )*(cmd->req.arg + 1UL) < 0) {
    if (((*(cmd->req.arg + 1UL) >> 16) & 32767U) != (u32 )vf->pci_func) {
      return (-22);
    } else {
    }
  } else {
    *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | (u32 )((int )(vf->vp)->handle << 16);
  }
  return (0);
}
}
static int qlcnic_sriov_pf_get_nic_info_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_get_nic_info(vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, cmd);
  return (err);
}
}
static int qlcnic_sriov_validate_cfg_rss(struct qlcnic_vf_info *vf , struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg + 1UL) != (u32 )vf->rx_ctx_id) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_cfg_rss_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_cfg_rss(vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
  } else {
    err = qlcnic_issue_cmd(adapter, cmd);
  }
  return (err);
}
}
static int qlcnic_sriov_validate_cfg_intrcoal(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf ,
                                              struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_nic_intr_coalesce *coal ;
  u16 ctx_id ;
  u16 pkts ;
  u16 time ;
  int err ;
  u8 type ;
  {
  coal = & (adapter->ahw)->coal;
  err = -22;
  type = (unsigned int )((u8 )*(cmd->req.arg + 1UL)) & 7U;
  ctx_id = (u16 )(*(cmd->req.arg + 1UL) >> 16);
  pkts = (u16 )*(cmd->req.arg + 2UL);
  time = (u16 )(*(cmd->req.arg + 2UL) >> 16);
  switch ((int )type) {
  case 1: ;
  if (((int )vf->rx_ctx_id != (int )ctx_id || (int )coal->rx_packets < (int )pkts) || (int )coal->rx_time_us > (int )time) {
    goto err_label;
  } else {
  }
  goto ldv_51433;
  case 2: ;
  if (((int )vf->tx_ctx_id != (int )ctx_id || (int )coal->tx_packets < (int )pkts) || (int )coal->tx_time_us > (int )time) {
    goto err_label;
  } else {
  }
  goto ldv_51433;
  default:
  netdev_err((struct net_device const *)adapter->netdev, "Invalid coalescing type 0x%x received\n",
             (int )type);
  return (err);
  }
  ldv_51433: ;
  return (0);
  err_label:
  netdev_err((struct net_device const *)adapter->netdev, "Expected: rx_ctx_id 0x%x rx_packets 0x%x rx_time_us 0x%x tx_ctx_id 0x%x tx_packets 0x%x tx_time_us 0x%x\n",
             (int )vf->rx_ctx_id, (int )coal->rx_packets, (int )coal->rx_time_us,
             (int )vf->tx_ctx_id, (int )coal->tx_packets, (int )coal->tx_time_us);
  netdev_err((struct net_device const *)adapter->netdev, "Received: ctx_id 0x%x packets 0x%x time_us 0x%x type 0x%x\n",
             (int )ctx_id, (int )pkts, (int )time, (int )type);
  return (err);
}
}
static int qlcnic_sriov_pf_cfg_intrcoal_cmd(struct qlcnic_bc_trans *tran , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = tran->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_cfg_intrcoal(adapter, vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, cmd);
  return (err);
}
}
static int qlcnic_sriov_validate_cfg_macvlan(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf ,
                                             struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vport *vp ;
  u8 op ;
  u8 new_op ;
  {
  vp = vf->vp;
  if ((*(cmd->req.arg + 1UL) & 256U) == 0U) {
    return (-22);
  } else {
  }
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | (u32 )((int )(vf->vp)->handle << 16);
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | 2147483648U;
  if ((unsigned int )vp->vlan_mode == 1U) {
    op = (unsigned int )((u8 )*(cmd->req.arg + 1UL)) & 7U;
    *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) & 4294967288U;
    new_op = (unsigned int )op == 1U || (unsigned int )op == 3U ? 3U : 4U;
    *(cmd->req.arg + 3UL) = *(cmd->req.arg + 3UL) | (u32 )((int )vp->pvid << 16);
    *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | (u32 )new_op;
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_cfg_macvlan_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_cfg_macvlan(adapter, vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, cmd);
  return (err);
}
}
static int qlcnic_sriov_validate_linkevent(struct qlcnic_vf_info *vf , struct qlcnic_cmd_args *cmd )
{
  {
  if (*(cmd->req.arg + 1UL) >> 16 != (u32 )vf->rx_ctx_id) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_linkevent_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  err = qlcnic_sriov_validate_linkevent(vf, cmd);
  if (err != 0) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 201326592U;
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, cmd);
  return (err);
}
}
static int qlcnic_sriov_pf_cfg_promisc_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  int err ;
  {
  vf = trans->vf;
  adapter = vf->adapter;
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | (u32 )((int )(vf->vp)->handle << 16);
  *(cmd->req.arg + 1UL) = *(cmd->req.arg + 1UL) | 2147483648U;
  err = qlcnic_issue_cmd(adapter, cmd);
  return (err);
}
}
static int qlcnic_sriov_pf_get_acl_cmd(struct qlcnic_bc_trans *trans , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_vport *vp ;
  u8 cmd_op ;
  u8 mode ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_sriov *sriov ;
  bool tmp ;
  {
  vf = trans->vf;
  vp = vf->vp;
  mode = vp->vlan_mode;
  adapter = vf->adapter;
  sriov = (adapter->ahw)->sriov;
  cmd_op = (trans->req_hdr)->cmd_op;
  *(cmd->rsp.arg) = *(cmd->rsp.arg) | 33554432U;
  tmp = qlcnic_84xx_check(adapter);
  if ((int )tmp && (unsigned int )mode == 1U) {
    return (0);
  } else {
  }
  switch ((int )mode) {
  case 2:
  *(cmd->rsp.arg + 1UL) = (u32 )((int )mode | 256);
  *(cmd->rsp.arg + 2UL) = (u32 )((int )sriov->num_allowed_vlans << 16);
  goto ldv_51487;
  case 1:
  *(cmd->rsp.arg + 1UL) = (u32 )(((int )mode | 256) | ((int )vp->pvid << 16));
  goto ldv_51487;
  }
  ldv_51487: ;
  return (0);
}
}
static int qlcnic_sriov_pf_del_guest_vlan(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf ,
                                          struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_sriov *sriov ;
  u16 vlan ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  sriov = (adapter->ahw)->sriov;
  tmp = qlcnic_sriov_check_any_vlan(vf);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (-22);
  } else {
  }
  vlan = (u16 )(*(cmd->req.arg + 1UL) >> 16);
  if ((unsigned int )vf->rx_ctx_id == 0U) {
    qlcnic_sriov_del_vlan_id(sriov, vf, (int )vlan);
    return (0);
  } else {
  }
  qlcnic_sriov_cfg_vf_def_mac(adapter, vf, (int )vlan, 2);
  qlcnic_sriov_del_vlan_id(sriov, vf, (int )vlan);
  tmp___1 = qlcnic_83xx_pf_check(adapter);
  if ((int )tmp___1) {
    qlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0, 1);
  } else {
  }
  return (0);
}
}
static int qlcnic_sriov_pf_add_guest_vlan(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf ,
                                          struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_sriov *sriov ;
  int err ;
  u16 vlan ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  {
  sriov = (adapter->ahw)->sriov;
  err = -5;
  tmp = qlcnic_83xx_pf_check(adapter);
  if ((int )tmp) {
    tmp___0 = qlcnic_sriov_check_any_vlan(vf);
    if ((int )tmp___0) {
      return (err);
    } else {
    }
  } else {
  }
  vlan = (u16 )(*(cmd->req.arg + 1UL) >> 16);
  if ((unsigned int )vf->rx_ctx_id == 0U) {
    qlcnic_sriov_add_vlan_id(sriov, vf, (int )vlan);
    return (0);
  } else {
  }
  tmp___1 = qlcnic_83xx_pf_check(adapter);
  if ((int )tmp___1) {
    err = qlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0, 2);
    if (err != 0) {
      return (err);
    } else {
    }
  } else {
  }
  err = qlcnic_sriov_cfg_vf_def_mac(adapter, vf, (int )vlan, 1);
  if (err != 0) {
    tmp___2 = qlcnic_83xx_pf_check(adapter);
    if ((int )tmp___2) {
      qlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0, 1);
    } else {
    }
    return (err);
  } else {
  }
  qlcnic_sriov_add_vlan_id(sriov, vf, (int )vlan);
  return (err);
}
}
static int qlcnic_sriov_pf_cfg_guest_vlan_cmd(struct qlcnic_bc_trans *tran , struct qlcnic_cmd_args *cmd )
{
  struct qlcnic_vf_info *vf ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_vport *vp ;
  int err ;
  u8 op ;
  {
  vf = tran->vf;
  adapter = vf->adapter;
  vp = vf->vp;
  err = -5;
  if ((unsigned int )vp->vlan_mode != 2U) {
    *(cmd->rsp.arg) = *(cmd->rsp.arg) | 67108864U;
    return (err);
  } else {
  }
  op = (unsigned int )((u8 )*(cmd->req.arg + 1UL)) & 15U;
  if ((unsigned int )op != 0U) {
    err = qlcnic_sriov_pf_add_guest_vlan(adapter, vf, cmd);
  } else {
    err = qlcnic_sriov_pf_del_guest_vlan(adapter, vf, cmd);
  }
  *(cmd->rsp.arg) = *(cmd->rsp.arg) | (err != 0 ? 67108864U : 33554432U);
  return (err);
}
}
static int const qlcnic_pf_passthru_supp_cmds[5U] = { 15, 103, 104, 96,
        97};
static struct qlcnic_sriov_cmd_handler const qlcnic_pf_bc_cmd_hdlr[4U] = { {& qlcnic_sriov_pf_channel_cfg_cmd},
        {& qlcnic_sriov_pf_channel_cfg_cmd},
        {& qlcnic_sriov_pf_get_acl_cmd},
        {& qlcnic_sriov_pf_cfg_guest_vlan_cmd}};
static struct qlcnic_sriov_fw_cmd_handler const qlcnic_pf_fw_cmd_hdlr[15U] =
  { {7U, & qlcnic_sriov_pf_create_rx_ctx_cmd},
        {9U, & qlcnic_sriov_pf_create_tx_ctx_cmd},
        {31U, & qlcnic_sriov_pf_mac_address_cmd},
        {8U, & qlcnic_sriov_pf_del_rx_ctx_cmd},
        {10U, & qlcnic_sriov_pf_del_tx_ctx_cmd},
        {74U, & qlcnic_sriov_pf_cfg_lro_cmd},
        {1U, & qlcnic_sriov_pf_cfg_ip_cmd},
        {2U, & qlcnic_sriov_pf_cfg_intrpt_cmd},
        {18U, & qlcnic_sriov_pf_set_mtu_cmd},
        {33U, & qlcnic_sriov_pf_get_nic_info_cmd},
        {65U, & qlcnic_sriov_pf_cfg_rss_cmd},
        {67U, & qlcnic_sriov_pf_cfg_intrcoal_cmd},
        {69U, & qlcnic_sriov_pf_cfg_macvlan_cmd},
        {72U, & qlcnic_sriov_pf_linkevent_cmd},
        {73U, & qlcnic_sriov_pf_cfg_promisc_cmd}};
void qlcnic_sriov_pf_process_bc_cmd(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans ,
                                    struct qlcnic_cmd_args *cmd )
{
  u8 size ;
  u8 cmd_op ;
  int i ;
  {
  cmd_op = (trans->req_hdr)->cmd_op;
  if ((unsigned int )*((unsigned char *)trans->req_hdr + 1UL) != 0U) {
    size = 4U;
    if ((int )cmd_op < (int )size) {
      (*(qlcnic_pf_bc_cmd_hdlr[(int )cmd_op].fn))(trans, cmd);
      return;
    } else {
    }
  } else {
    size = 15U;
    i = 0;
    goto ldv_51529;
    ldv_51528: ;
    if ((unsigned int )cmd_op == (unsigned int )qlcnic_pf_fw_cmd_hdlr[i].cmd) {
      (*(qlcnic_pf_fw_cmd_hdlr[i].fn))(trans, cmd);
      return;
    } else {
    }
    i = i + 1;
    ldv_51529: ;
    if ((int )size > i) {
      goto ldv_51528;
    } else {
    }
    size = 5U;
    i = 0;
    goto ldv_51534;
    ldv_51533: ;
    if ((int )cmd_op == (int )qlcnic_pf_passthru_supp_cmds[i]) {
      qlcnic_issue_cmd(adapter, cmd);
      return;
    } else {
    }
    i = i + 1;
    ldv_51534: ;
    if ((int )size > i) {
      goto ldv_51533;
    } else {
    }
  }
  *(cmd->rsp.arg) = *(cmd->rsp.arg) | 301989888U;
  return;
}
}
void qlcnic_pf_set_interface_id_create_rx_ctx(struct qlcnic_adapter *adapter , u32 *int_id )
{
  u16 vpid ;
  int tmp ;
  {
  tmp = qlcnic_sriov_pf_get_vport_handle(adapter, (int )(adapter->ahw)->pci_func);
  vpid = (u16 )tmp;
  *int_id = *int_id | (u32 )vpid;
  return;
}
}
void qlcnic_pf_set_interface_id_del_rx_ctx(struct qlcnic_adapter *adapter , u32 *int_id )
{
  u16 vpid ;
  int tmp ;
  {
  tmp = qlcnic_sriov_pf_get_vport_handle(adapter, (int )(adapter->ahw)->pci_func);
  vpid = (u16 )tmp;
  *int_id = *int_id | (u32 )((int )vpid << 16);
  return;
}
}
void qlcnic_pf_set_interface_id_create_tx_ctx(struct qlcnic_adapter *adapter , u32 *int_id )
{
  int vpid ;
  {
  vpid = qlcnic_sriov_pf_get_vport_handle(adapter, (int )(adapter->ahw)->pci_func);
  *int_id = *int_id | (u32 )(vpid << 16);
  return;
}
}
void qlcnic_pf_set_interface_id_del_tx_ctx(struct qlcnic_adapter *adapter , u32 *int_id )
{
  u16 vpid ;
  int tmp ;
  {
  tmp = qlcnic_sriov_pf_get_vport_handle(adapter, (int )(adapter->ahw)->pci_func);
  vpid = (u16 )tmp;
  *int_id = *int_id | (u32 )((int )vpid << 16);
  return;
}
}
void qlcnic_pf_set_interface_id_promisc(struct qlcnic_adapter *adapter , u32 *int_id )
{
  u16 vpid ;
  int tmp ;
  {
  tmp = qlcnic_sriov_pf_get_vport_handle(adapter, (int )(adapter->ahw)->pci_func);
  vpid = (u16 )tmp;
  *int_id = (*int_id | (u32 )((int )vpid << 16)) | 2147483648U;
  return;
}
}
void qlcnic_pf_set_interface_id_ipaddr(struct qlcnic_adapter *adapter , u32 *int_id )
{
  u16 vpid ;
  int tmp ;
  {
  tmp = qlcnic_sriov_pf_get_vport_handle(adapter, (int )(adapter->ahw)->pci_func);
  vpid = (u16 )tmp;
  *int_id = (*int_id | (u32 )((int )vpid << 16)) | 2147483648U;
  return;
}
}
void qlcnic_pf_set_interface_id_macaddr(struct qlcnic_adapter *adapter , u32 *int_id )
{
  u16 vpid ;
  int tmp ;
  {
  tmp = qlcnic_sriov_pf_get_vport_handle(adapter, (int )(adapter->ahw)->pci_func);
  vpid = (u16 )tmp;
  *int_id = (*int_id | (u32 )((int )vpid << 16)) | 2147483648U;
  return;
}
}
static void qlcnic_sriov_del_rx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf )
{
  struct qlcnic_cmd_args cmd ;
  int vpid ;
  int tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )vf->rx_ctx_id == 0U) {
    return;
  } else {
  }
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 8U);
  if (tmp != 0) {
    return;
  } else {
  }
  vpid = qlcnic_sriov_pf_get_vport_handle(adapter, (int )vf->pci_func);
  if (vpid >= 0) {
    *(cmd.req.arg + 1UL) = (u32 )((int )vf->rx_ctx_id | (vpid << 16));
    tmp___0 = qlcnic_issue_cmd(adapter, & cmd);
    if (tmp___0 != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to delete Tx ctx in firmware for func 0x%x\n",
              (int )vf->pci_func);
    } else {
      vf->rx_ctx_id = 0U;
    }
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
static void qlcnic_sriov_del_tx_ctx(struct qlcnic_adapter *adapter , struct qlcnic_vf_info *vf )
{
  struct qlcnic_cmd_args cmd ;
  int vpid ;
  int tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )vf->tx_ctx_id == 0U) {
    return;
  } else {
  }
  tmp = qlcnic_alloc_mbx_args(& cmd, adapter, 10U);
  if (tmp != 0) {
    return;
  } else {
  }
  vpid = qlcnic_sriov_pf_get_vport_handle(adapter, (int )vf->pci_func);
  if (vpid >= 0) {
    *(cmd.req.arg + 1UL) = *(cmd.req.arg + 1UL) | (u32 )((int )vf->tx_ctx_id | (vpid << 16));
    tmp___0 = qlcnic_issue_cmd(adapter, & cmd);
    if (tmp___0 != 0) {
      dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to delete Tx ctx in firmware for func 0x%x\n",
              (int )vf->pci_func);
    } else {
      vf->tx_ctx_id = 0U;
    }
  } else {
  }
  qlcnic_free_mbx_args(& cmd);
  return;
}
}
static int qlcnic_sriov_add_act_list_irqsave(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                             struct qlcnic_bc_trans *trans )
{
  struct qlcnic_trans_list *t_list ;
  unsigned long flag ;
  {
  t_list = & vf->rcv_act;
  ldv_spin_lock();
  __qlcnic_sriov_add_act_list(sriov, vf, trans);
  spin_unlock_irqrestore(& t_list->lock, flag);
  return (0);
}
}
static void __qlcnic_sriov_process_flr(struct qlcnic_vf_info *vf )
{
  struct qlcnic_adapter *adapter ;
  int tmp ;
  int tmp___0 ;
  {
  adapter = vf->adapter;
  qlcnic_sriov_cleanup_list(& vf->rcv_pend);
  cancel_work_sync(& vf->trans_work);
  qlcnic_sriov_cleanup_list(& vf->rcv_act);
  tmp = constant_test_bit(5L, (unsigned long const volatile *)(& vf->state));
  if (tmp != 0) {
    qlcnic_sriov_del_tx_ctx(adapter, vf);
    qlcnic_sriov_del_rx_ctx(adapter, vf);
  } else {
  }
  qlcnic_sriov_pf_config_vport(adapter, 0, (int )vf->pci_func);
  clear_bit(4L, (unsigned long volatile *)(& vf->state));
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile *)(& vf->state));
  if (tmp___0 != 0) {
    qlcnic_sriov_add_act_list_irqsave((adapter->ahw)->sriov, vf, vf->flr_trans);
    clear_bit(5L, (unsigned long volatile *)(& vf->state));
    vf->flr_trans = (struct qlcnic_bc_trans *)0;
  } else {
  }
  return;
}
}
static void qlcnic_sriov_pf_process_flr(struct work_struct *work )
{
  struct qlcnic_vf_info *vf ;
  struct work_struct const *__mptr ;
  {
  __mptr = (struct work_struct const *)work;
  vf = (struct qlcnic_vf_info *)__mptr + 0xffffffffffffff30UL;
  __qlcnic_sriov_process_flr(vf);
  return;
}
}
static void qlcnic_sriov_schedule_flr(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf ,
                                      void (*func)(struct work_struct * ) )
{
  int tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  {
  tmp = constant_test_bit(2L, (unsigned long const volatile *)(& (vf->adapter)->state));
  if (tmp != 0) {
    return;
  } else {
  }
  __init_work(& vf->flr_work, 0);
  __constr_expr_0.counter = 137438953408L;
  vf->flr_work.data = __constr_expr_0;
  lockdep_init_map(& vf->flr_work.lockdep_map, "(&vf->flr_work)", & __key, 0);
  INIT_LIST_HEAD(& vf->flr_work.entry);
  vf->flr_work.func = func;
  queue_work(sriov->bc.bc_flr_wq, & vf->flr_work);
  return;
}
}
static void qlcnic_sriov_handle_soft_flr(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans ,
                                         struct qlcnic_vf_info *vf )
{
  struct qlcnic_sriov *sriov ;
  {
  sriov = (adapter->ahw)->sriov;
  set_bit(4L, (unsigned long volatile *)(& vf->state));
  clear_bit(3L, (unsigned long volatile *)(& vf->state));
  set_bit(5L, (unsigned long volatile *)(& vf->state));
  vf->flr_trans = trans;
  qlcnic_sriov_schedule_flr(sriov, vf, & qlcnic_sriov_pf_process_flr);
  netdev_info((struct net_device const *)adapter->netdev, "Software FLR for PCI func %d\n",
              (int )vf->pci_func);
  return;
}
}
bool qlcnic_sriov_soft_flr_check(struct qlcnic_adapter *adapter , struct qlcnic_bc_trans *trans ,
                                 struct qlcnic_vf_info *vf )
{
  struct qlcnic_bc_hdr *hdr ;
  int tmp ;
  {
  hdr = trans->req_hdr;
  if ((unsigned int )hdr->cmd_op == 0U && (unsigned int )*((unsigned char *)hdr + 1UL) != 0U) {
    tmp = constant_test_bit(3L, (unsigned long const volatile *)(& vf->state));
    if (tmp != 0) {
      qlcnic_sriov_handle_soft_flr(adapter, trans, vf);
      return (1);
    } else {
    }
  } else {
  }
  return (0);
}
}
void qlcnic_sriov_pf_handle_flr(struct qlcnic_sriov *sriov , struct qlcnic_vf_info *vf )
{
  struct net_device *dev ;
  struct qlcnic_vport *vp ;
  int tmp ;
  int tmp___0 ;
  {
  dev = (vf->adapter)->netdev;
  vp = vf->vp;
  tmp = test_and_clear_bit(3L, (unsigned long volatile *)(& vf->state));
  if (tmp == 0) {
    clear_bit(4L, (unsigned long volatile *)(& vf->state));
    return;
  } else {
  }
  tmp___0 = test_and_set_bit(4L, (unsigned long volatile *)(& vf->state));
  if (tmp___0 != 0) {
    netdev_info((struct net_device const *)dev, "FLR for PCI func %d in progress\n",
                (int )vf->pci_func);
    return;
  } else {
  }
  if ((unsigned int )vp->vlan_mode == 2U) {
    memset((void *)vf->sriov_vlans, 0, (unsigned long )sriov->num_allowed_vlans * 2UL);
  } else {
  }
  qlcnic_sriov_schedule_flr(sriov, vf, & qlcnic_sriov_pf_process_flr);
  netdev_info((struct net_device const *)dev, "FLR received for PCI func %d\n",
              (int )vf->pci_func);
  return;
}
}
void qlcnic_sriov_pf_reset(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf ;
  u16 num_vfs ;
  int i ;
  {
  ahw = adapter->ahw;
  sriov = ahw->sriov;
  num_vfs = (u16 )sriov->num_vfs;
  i = 0;
  goto ldv_51634;
  ldv_51633:
  vf = sriov->vf_info + (unsigned long )i;
  vf->rx_ctx_id = 0U;
  vf->tx_ctx_id = 0U;
  cancel_work_sync(& vf->flr_work);
  __qlcnic_sriov_process_flr(vf);
  clear_bit(3L, (unsigned long volatile *)(& vf->state));
  i = i + 1;
  ldv_51634: ;
  if ((int )num_vfs > i) {
    goto ldv_51633;
  } else {
  }
  qlcnic_sriov_pf_reset_vport_handle(adapter, (int )ahw->pci_func);
  writel((unsigned int )(((int )ahw->num_msix + -1) << 8), (void volatile *)ahw->pci_base0 + (unsigned long )*(ahw->ext_reg_tbl + 8UL));
  return;
}
}
int qlcnic_sriov_pf_reinit(struct qlcnic_adapter *adapter )
{
  struct qlcnic_hardware_context *ahw ;
  int err ;
  bool tmp ;
  int tmp___0 ;
  {
  ahw = adapter->ahw;
  tmp = qlcnic_sriov_enable_check(adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {
  }
  ahw->op_mode = 3U;
  err = qlcnic_sriov_pf_init(adapter);
  if (err != 0) {
    return (err);
  } else {
  }
  _dev_info((struct device const *)(& (adapter->pdev)->dev), "%s: op_mode %d\n",
            "qlcnic_sriov_pf_reinit", (int )ahw->op_mode);
  return (err);
}
}
int qlcnic_sriov_set_vf_mac(struct net_device *netdev , int vf , u8 *mac )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_sriov *sriov ;
  int i ;
  int num_vfs ;
  struct qlcnic_vf_info *vf_info ;
  u8 *curr_mac ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  size_t __len ;
  void *__ret ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  sriov = (adapter->ahw)->sriov;
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (-95);
  } else {
  }
  num_vfs = (int )sriov->num_vfs;
  tmp___2 = is_valid_ether_addr((u8 const *)mac);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3 || vf >= num_vfs) {
    return (-22);
  } else {
  }
  tmp___4 = ether_addr_equal((u8 const *)(& adapter->mac_addr), (u8 const *)mac);
  if ((int )tmp___4) {
    netdev_err((struct net_device const *)netdev, "MAC address is already in use by the PF\n");
    return (-22);
  } else {
  }
  i = 0;
  goto ldv_51654;
  ldv_51653:
  vf_info = sriov->vf_info + (unsigned long )i;
  tmp___5 = ether_addr_equal((u8 const *)(& (vf_info->vp)->mac), (u8 const *)mac);
  if ((int )tmp___5) {
    netdev_err((struct net_device const *)netdev, "MAC address is already in use by VF %d\n",
               i);
    return (-22);
  } else {
  }
  i = i + 1;
  ldv_51654: ;
  if (i < num_vfs) {
    goto ldv_51653;
  } else {
  }
  vf_info = sriov->vf_info + (unsigned long )vf;
  curr_mac = (u8 *)(& (vf_info->vp)->mac);
  tmp___6 = constant_test_bit(3L, (unsigned long const volatile *)(& vf_info->state));
  if (tmp___6 != 0) {
    netdev_err((struct net_device const *)netdev, "MAC address change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\n",
               vf);
    return (-95);
  } else {
  }
  __len = (size_t )netdev->addr_len;
  __ret = memcpy((void *)curr_mac, (void const *)mac, __len);
  netdev_info((struct net_device const *)netdev, "MAC Address %pM  is configured for VF %d\n",
              mac, vf);
  return (0);
}
}
int qlcnic_sriov_set_vf_tx_rate(struct net_device *netdev , int vf , int min_tx_rate ,
                                int max_tx_rate )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf_info ;
  struct qlcnic_info nic_info ;
  struct qlcnic_vport *vp ;
  u16 vpid ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  sriov = (adapter->ahw)->sriov;
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (-95);
  } else {
  }
  if ((int )sriov->num_vfs <= vf) {
    return (-22);
  } else {
  }
  vf_info = sriov->vf_info + (unsigned long )vf;
  vp = vf_info->vp;
  vpid = vp->handle;
  if (min_tx_rate == 0) {
    min_tx_rate = 100;
  } else {
  }
  if (max_tx_rate != 0 && (max_tx_rate > 9999 || max_tx_rate < min_tx_rate)) {
    netdev_err((struct net_device const *)netdev, "Invalid max Tx rate, allowed range is [%d - %d]",
               min_tx_rate, 9999);
    return (-22);
  } else {
  }
  if (max_tx_rate == 0) {
    max_tx_rate = 10000;
  } else {
  }
  if (min_tx_rate != 0 && (min_tx_rate > max_tx_rate || min_tx_rate <= 99)) {
    netdev_err((struct net_device const *)netdev, "Invalid min Tx rate, allowed range is [%d - %d]",
               100, max_tx_rate);
    return (-22);
  } else {
  }
  tmp___4 = constant_test_bit(3L, (unsigned long const volatile *)(& vf_info->state));
  if (tmp___4 != 0) {
    tmp___2 = qlcnic_sriov_get_vf_vport_info(adapter, & nic_info, (int )vpid);
    if (tmp___2 != 0) {
      return (-5);
    } else {
    }
    nic_info.max_tx_bw = (u16 )(max_tx_rate / 100);
    nic_info.min_tx_bw = (u16 )(min_tx_rate / 100);
    nic_info.bit_offsets = 1U;
    tmp___3 = qlcnic_sriov_pf_set_vport_info(adapter, & nic_info, (int )vpid);
    if (tmp___3 != 0) {
      return (-5);
    } else {
    }
  } else {
  }
  vp->max_tx_bw = (u16 )(max_tx_rate / 100);
  netdev_info((struct net_device const *)netdev, "Setting Max Tx rate %d (Mbps), %d %% of PF bandwidth, for VF %d\n",
              max_tx_rate, (int )vp->max_tx_bw, vf);
  vp->min_tx_bw = (u16 )(min_tx_rate / 100);
  netdev_info((struct net_device const *)netdev, "Setting Min Tx rate %d (Mbps), %d %% of PF bandwidth, for VF %d\n",
              min_tx_rate, (int )vp->min_tx_bw, vf);
  return (0);
}
}
int qlcnic_sriov_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf_info ;
  struct qlcnic_vport *vp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  sriov = (adapter->ahw)->sriov;
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (-95);
  } else {
  }
  if ((int )sriov->num_vfs <= vf || (unsigned int )qos > 7U) {
    return (-22);
  } else {
  }
  if ((unsigned int )vlan > 4095U) {
    netdev_err((struct net_device const *)netdev, "Invalid VLAN ID, allowed range is [0 - %d]\n",
               4095);
    return (-22);
  } else {
  }
  vf_info = sriov->vf_info + (unsigned long )vf;
  vp = vf_info->vp;
  tmp___2 = constant_test_bit(3L, (unsigned long const volatile *)(& vf_info->state));
  if (tmp___2 != 0) {
    netdev_err((struct net_device const *)netdev, "VLAN change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\n",
               vf);
    return (-95);
  } else {
  }
  memset((void *)vf_info->sriov_vlans, 0, (unsigned long )sriov->num_allowed_vlans * 2UL);
  switch ((int )vlan) {
  case 4095:
  vp->vlan_mode = 2U;
  goto ldv_51682;
  case 0:
  vp->vlan_mode = 0U;
  vp->qos = 0U;
  goto ldv_51682;
  default:
  vp->vlan_mode = 1U;
  qlcnic_sriov_add_vlan_id(sriov, vf_info, (int )vlan);
  vp->qos = qos;
  vp->pvid = vlan;
  }
  ldv_51682:
  netdev_info((struct net_device const *)netdev, "Setting VLAN %d, QoS %d, for VF %d\n",
              (int )vlan, (int )qos, vf);
  return (0);
}
}
static __u32 qlcnic_sriov_get_vf_vlan(struct qlcnic_adapter *adapter , struct qlcnic_vport *vp ,
                                      int vf )
{
  __u32 vlan ;
  {
  vlan = 0U;
  switch ((int )vp->vlan_mode) {
  case 1:
  vlan = (__u32 )vp->pvid;
  goto ldv_51692;
  case 2:
  vlan = 4095U;
  goto ldv_51692;
  case 0:
  vlan = 0U;
  goto ldv_51692;
  default:
  netdev_info((struct net_device const *)adapter->netdev, "Invalid VLAN mode = %d for VF %d\n",
              (int )vp->vlan_mode, vf);
  }
  ldv_51692: ;
  return (vlan);
}
}
int qlcnic_sriov_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *ivi )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vport *vp ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  sriov = (adapter->ahw)->sriov;
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (-95);
  } else {
  }
  if ((int )sriov->num_vfs <= vf) {
    return (-22);
  } else {
  }
  vp = (sriov->vf_info + (unsigned long )vf)->vp;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& ivi->mac), (void const *)(& vp->mac), __len);
  } else {
    __ret = memcpy((void *)(& ivi->mac), (void const *)(& vp->mac), __len);
  }
  ivi->vlan = qlcnic_sriov_get_vf_vlan(adapter, vp, vf);
  ivi->qos = (__u32 )vp->qos;
  ivi->spoofchk = (__u32 )vp->spoofchk;
  if ((unsigned int )vp->max_tx_bw == 100U) {
    ivi->max_tx_rate = 0U;
  } else {
    ivi->max_tx_rate = (__u32 )((int )vp->max_tx_bw * 100);
  }
  if ((unsigned int )vp->min_tx_bw == 1U) {
    ivi->min_tx_rate = 0U;
  } else {
    ivi->min_tx_rate = (__u32 )((int )vp->min_tx_bw * 100);
  }
  ivi->vf = (__u32 )vf;
  return (0);
}
}
int qlcnic_sriov_set_vf_spoofchk(struct net_device *netdev , int vf , bool chk )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_sriov *sriov ;
  struct qlcnic_vf_info *vf_info ;
  struct qlcnic_vport *vp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  sriov = (adapter->ahw)->sriov;
  tmp___0 = qlcnic_sriov_pf_check(adapter);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (-95);
  } else {
  }
  if ((int )sriov->num_vfs <= vf) {
    return (-22);
  } else {
  }
  vf_info = sriov->vf_info + (unsigned long )vf;
  vp = vf_info->vp;
  tmp___2 = constant_test_bit(3L, (unsigned long const volatile *)(& vf_info->state));
  if (tmp___2 != 0) {
    netdev_err((struct net_device const *)netdev, "Spoof check change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\n",
               vf);
    return (-95);
  } else {
  }
  vp->spoofchk = chk;
  return (0);
}
}
void *ldv_kmem_cache_alloc_570(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_576(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_578(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_580(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_581(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_582(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_583(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_584(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_585(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_586(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_587(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
void *ldv_kmem_cache_alloc_614(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
void *ldv_kmem_cache_alloc_631(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_622(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_630(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_624(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_620(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_628(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_629(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_625(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_626(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_627(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern int dcb_setapp(struct net_device * , struct dcb_app * ) ;
extern u8 dcb_getapp(struct net_device * , struct dcb_app * ) ;
extern int dcbnl_cee_notify(struct net_device * , int , int , u32 , u32 ) ;
__inline static int qlcnic_dcb_get_hw_capability(struct qlcnic_dcb *dcb )
{
  int tmp ;
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->get_hw_capability != (unsigned long )((int (*)(struct qlcnic_dcb * ))0)) {
    tmp = (*((dcb->ops)->get_hw_capability))(dcb);
    return (tmp);
  } else {
  }
  return (0);
}
}
__inline static int qlcnic_dcb_query_hw_capability(struct qlcnic_dcb *dcb , char *buf )
{
  int tmp ;
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->query_hw_capability != (unsigned long )((int (*)(struct qlcnic_dcb * ,
                                                                                                                                                      char * ))0)) {
    tmp = (*((dcb->ops)->query_hw_capability))(dcb, buf);
    return (tmp);
  } else {
  }
  return (0);
}
}
__inline static int qlcnic_dcb_query_cee_param(struct qlcnic_dcb *dcb , char *buf ,
                                               u8 type )
{
  int tmp ;
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->query_cee_param != (unsigned long )((int (*)(struct qlcnic_dcb * ,
                                                                                                                                                  char * ,
                                                                                                                                                  u8 ))0)) {
    tmp = (*((dcb->ops)->query_cee_param))(dcb, buf, (int )type);
    return (tmp);
  } else {
  }
  return (0);
}
}
__inline static int qlcnic_dcb_get_cee_cfg(struct qlcnic_dcb *dcb )
{
  int tmp ;
  {
  if ((unsigned long )dcb != (unsigned long )((struct qlcnic_dcb *)0) && (unsigned long )(dcb->ops)->get_cee_cfg != (unsigned long )((int (*)(struct qlcnic_dcb * ))0)) {
    tmp = (*((dcb->ops)->get_cee_cfg))(dcb);
    return (tmp);
  } else {
  }
  return (0);
}
}
static struct dcbnl_rtnl_ops const qlcnic_dcbnl_ops ;
static void qlcnic_dcb_aen_work(struct work_struct *work ) ;
static void qlcnic_dcb_data_cee_param_map(struct qlcnic_adapter *adapter ) ;
__inline static void __qlcnic_init_dcbnl_ops(struct qlcnic_dcb *dcb ) ;
static void __qlcnic_dcb_free(struct qlcnic_dcb *dcb ) ;
static int __qlcnic_dcb_attach(struct qlcnic_dcb *dcb ) ;
static int __qlcnic_dcb_query_hw_capability(struct qlcnic_dcb *dcb , char *buf ) ;
static void __qlcnic_dcb_get_info(struct qlcnic_dcb *dcb ) ;
static int qlcnic_82xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb ) ;
static int qlcnic_82xx_dcb_query_cee_param(struct qlcnic_dcb *dcb , char *buf , u8 type ) ;
static int qlcnic_82xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb ) ;
static void qlcnic_82xx_dcb_aen_handler(struct qlcnic_dcb *dcb , void *data ) ;
static int qlcnic_83xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb ) ;
static int qlcnic_83xx_dcb_query_cee_param(struct qlcnic_dcb *dcb , char *buf , u8 idx ) ;
static int qlcnic_83xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb ) ;
static void qlcnic_83xx_dcb_aen_handler(struct qlcnic_dcb *dcb , void *data ) ;
static struct qlcnic_dcb_ops qlcnic_83xx_dcb_ops =
     {& __qlcnic_dcb_query_hw_capability, & qlcnic_83xx_dcb_get_hw_capability, & qlcnic_83xx_dcb_query_cee_param,
    & __qlcnic_init_dcbnl_ops, & qlcnic_83xx_dcb_aen_handler, & qlcnic_83xx_dcb_get_cee_cfg,
    & __qlcnic_dcb_get_info, & __qlcnic_dcb_attach, & __qlcnic_dcb_free};
static struct qlcnic_dcb_ops qlcnic_82xx_dcb_ops =
     {& __qlcnic_dcb_query_hw_capability, & qlcnic_82xx_dcb_get_hw_capability, & qlcnic_82xx_dcb_query_cee_param,
    & __qlcnic_init_dcbnl_ops, & qlcnic_82xx_dcb_aen_handler, & qlcnic_82xx_dcb_get_cee_cfg,
    & __qlcnic_dcb_get_info, & __qlcnic_dcb_attach, & __qlcnic_dcb_free};
static u8 qlcnic_dcb_get_num_app(struct qlcnic_adapter *adapter , u32 val )
{
  bool tmp ;
  {
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    return ((unsigned int )((u8 )(val >> 12)) & 15U);
  } else {
    return ((unsigned int )((u8 )(val >> 2)) & 15U);
  }
}
}
__inline static u8 qlcnic_dcb_pfc_hdr_valid(struct qlcnic_adapter *adapter , u32 val )
{
  bool tmp ;
  {
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    return ((unsigned int )((u8 )(val >> 5)) & 1U);
  } else {
    return ((unsigned int )((u8 )(val >> 1)) & 1U);
  }
}
}
__inline static u8 qlcnic_dcb_tsa_hdr_valid(struct qlcnic_adapter *adapter , u32 val )
{
  bool tmp ;
  {
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    return ((unsigned int )((u8 )(val >> 4)) & 1U);
  } else {
    return ((unsigned int )((u8 )val) & 1U);
  }
}
}
__inline static u8 qlcnic_dcb_get_prio_map_app(struct qlcnic_adapter *adapter , u32 val )
{
  bool tmp ;
  {
  tmp = qlcnic_82xx_check(adapter);
  if ((int )tmp) {
    return ((u8 )(1 << (int )val));
  } else {
    return ((u8 )(val >> 24));
  }
}
}
static int qlcnic_dcb_prio_count(u8 up_tc_map )
{
  int j ;
  {
  j = 0;
  goto ldv_50964;
  ldv_50963: ;
  if (((int )up_tc_map >> j) & 1) {
    goto ldv_50962;
  } else {
  }
  j = j + 1;
  ldv_50964: ;
  if (j <= 7) {
    goto ldv_50963;
  } else {
  }
  ldv_50962: ;
  return (j);
}
}
__inline static void __qlcnic_init_dcbnl_ops(struct qlcnic_dcb *dcb )
{
  int tmp ;
  {
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& dcb->state));
  if (tmp != 0) {
    ((dcb->adapter)->netdev)->dcbnl_ops = & qlcnic_dcbnl_ops;
  } else {
  }
  return;
}
}
static void qlcnic_set_dcb_ops(struct qlcnic_adapter *adapter )
{
  bool tmp ;
  bool tmp___0 ;
  {
  tmp___0 = qlcnic_82xx_check(adapter);
  if ((int )tmp___0) {
    (adapter->dcb)->ops = & qlcnic_82xx_dcb_ops;
  } else {
    tmp = qlcnic_83xx_check(adapter);
    if ((int )tmp) {
      (adapter->dcb)->ops = & qlcnic_83xx_dcb_ops;
    } else {
    }
  }
  return;
}
}
int qlcnic_register_dcb(struct qlcnic_adapter *adapter )
{
  struct qlcnic_dcb *dcb ;
  bool tmp ;
  void *tmp___0 ;
  {
  tmp = qlcnic_sriov_vf_check(adapter);
  if ((int )tmp) {
    return (0);
  } else {
  }
  tmp___0 = kzalloc(272UL, 32U);
  dcb = (struct qlcnic_dcb *)tmp___0;
  if ((unsigned long )dcb == (unsigned long )((struct qlcnic_dcb *)0)) {
    return (-12);
  } else {
  }
  adapter->dcb = dcb;
  dcb->adapter = adapter;
  qlcnic_set_dcb_ops(adapter);
  dcb->state = 0UL;
  return (0);
}
}
static void __qlcnic_dcb_free(struct qlcnic_dcb *dcb )
{
  struct qlcnic_adapter *adapter ;
  int tmp ;
  {
  if ((unsigned long )dcb == (unsigned long )((struct qlcnic_dcb *)0)) {
    return;
  } else {
  }
  adapter = dcb->adapter;
  goto ldv_50980;
  ldv_50979:
  usleep_range(10000UL, 11000UL);
  ldv_50980:
  tmp = constant_test_bit(1L, (unsigned long const volatile *)(& dcb->state));
  if (tmp != 0) {
    goto ldv_50979;
  } else {
  }
  cancel_delayed_work_sync(& dcb->aen_work);
  if ((unsigned long )dcb->wq != (unsigned long )((struct workqueue_struct *)0)) {
    destroy_workqueue(dcb->wq);
    dcb->wq = (struct workqueue_struct *)0;
  } else {
  }
  kfree((void const *)dcb->cfg);
  dcb->cfg = (struct qlcnic_dcb_cfg *)0;
  kfree((void const *)dcb->param);
  dcb->param = (struct qlcnic_dcb_mbx_params *)0;
  kfree((void const *)dcb);
  adapter->dcb = (struct qlcnic_dcb *)0;
  return;
}
}
static void __qlcnic_dcb_get_info(struct qlcnic_dcb *dcb )
{
  {
  qlcnic_dcb_get_hw_capability(dcb);
  qlcnic_dcb_get_cee_cfg(dcb);
  return;
}
}
static int __qlcnic_dcb_attach(struct qlcnic_dcb *dcb )
{
  int err ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  char const *__lock_name ;
  struct workqueue_struct *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  err = 0;
  __init_work(& dcb->aen_work.work, 0);
  __constr_expr_0.counter = 137438953408L;
  dcb->aen_work.work.data = __constr_expr_0;
  lockdep_init_map(& dcb->aen_work.work.lockdep_map, "(&(&dcb->aen_work)->work)",
                   & __key, 0);
  INIT_LIST_HEAD(& dcb->aen_work.work.entry);
  dcb->aen_work.work.func = & qlcnic_dcb_aen_work;
  init_timer_key(& dcb->aen_work.timer, 2U, "(&(&dcb->aen_work)->timer)", & __key___0);
  dcb->aen_work.timer.function = & delayed_work_timer_fn;
  dcb->aen_work.timer.data = (unsigned long )(& dcb->aen_work);
  __lock_name = "\"%s\"(\"qlcnic-dcb\")";
  tmp = __alloc_workqueue_key("%s", 10U, 1, & __key___1, __lock_name, (char *)"qlcnic-dcb");
  dcb->wq = tmp;
  if ((unsigned long )dcb->wq == (unsigned long )((struct workqueue_struct *)0)) {
    dev_err((struct device const *)(& ((dcb->adapter)->pdev)->dev), "DCB workqueue allocation failed. DCB will be disabled\n");
    return (-1);
  } else {
  }
  tmp___0 = kzalloc(2232UL, 32U);
  dcb->cfg = (struct qlcnic_dcb_cfg *)tmp___0;
  if ((unsigned long )dcb->cfg == (unsigned long )((struct qlcnic_dcb_cfg *)0)) {
    err = -12;
    goto out_free_wq;
  } else {
  }
  tmp___1 = kzalloc(196UL, 32U);
  dcb->param = (struct qlcnic_dcb_mbx_params *)tmp___1;
  if ((unsigned long )dcb->param == (unsigned long )((struct qlcnic_dcb_mbx_params *)0)) {
    err = -12;
    goto out_free_cfg;
  } else {
  }
  return (0);
  out_free_cfg:
  kfree((void const *)dcb->cfg);
  dcb->cfg = (struct qlcnic_dcb_cfg *)0;
  out_free_wq:
  destroy_workqueue(dcb->wq);
  dcb->wq = (struct workqueue_struct *)0;
  return (err);
}
}
static int __qlcnic_dcb_query_hw_capability(struct qlcnic_dcb *dcb , char *buf )
{
  struct qlcnic_adapter *adapter ;
  struct qlcnic_cmd_args cmd ;
  u32 mbx_out ;
  int err ;
  size_t __len ;
  void *__ret ;
  {
  adapter = dcb->adapter;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 52U);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to query DCBX capability, err %d\n",
            err);
  } else {
    mbx_out = *(cmd.rsp.arg + 1UL);
    if ((unsigned long )buf != (unsigned long )((char *)0)) {
      __len = 4UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)buf, (void const *)(& mbx_out), __len);
      } else {
        __ret = memcpy((void *)buf, (void const *)(& mbx_out), __len);
      }
    } else {
    }
  }
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int __qlcnic_dcb_get_capability(struct qlcnic_dcb *dcb , u32 *val )
{
  struct qlcnic_dcb_capability *cap ;
  u32 mbx_out ;
  int err ;
  {
  cap = & (dcb->cfg)->capability;
  memset((void *)cap, 0, 6UL);
  err = qlcnic_dcb_query_hw_capability(dcb, (char *)val);
  if (err != 0) {
    return (err);
  } else {
  }
  mbx_out = *val;
  if ((int )mbx_out & 1) {
    cap->tsa_capability = 1;
  } else {
  }
  if ((mbx_out & 2U) != 0U) {
    cap->ets_capability = 1;
  } else {
  }
  cap->max_num_tc = (unsigned int )((u8 )(mbx_out >> 20)) & 15U;
  cap->max_ets_tc = (unsigned int )((u8 )(mbx_out >> 24)) & 15U;
  cap->max_pfc_tc = (u8 )(mbx_out >> 28);
  if (((unsigned int )cap->max_num_tc > 8U || (int )cap->max_ets_tc > (int )cap->max_num_tc) || (int )cap->max_pfc_tc > (int )cap->max_num_tc) {
    dev_err((struct device const *)(& ((dcb->adapter)->pdev)->dev), "Invalid DCB configuration\n");
    return (-22);
  } else {
  }
  return (err);
}
}
static int qlcnic_82xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb )
{
  struct qlcnic_dcb_cfg *cfg ;
  struct qlcnic_dcb_capability *cap ;
  u32 mbx_out ;
  int err ;
  {
  cfg = dcb->cfg;
  err = __qlcnic_dcb_get_capability(dcb, & mbx_out);
  if (err != 0) {
    return (err);
  } else {
  }
  cap = & cfg->capability;
  cap->dcb_capability = 6U;
  if (((unsigned int )cap->dcb_capability != 0U && (int )cap->tsa_capability) && (int )cap->ets_capability) {
    set_bit(0L, (unsigned long volatile *)(& dcb->state));
  } else {
  }
  return (err);
}
}
static int qlcnic_82xx_dcb_query_cee_param(struct qlcnic_dcb *dcb , char *buf , u8 type )
{
  u16 size ;
  struct qlcnic_adapter *adapter ;
  struct qlcnic_82xx_dcb_param_mbx_le *prsp_le ;
  struct device *dev ;
  dma_addr_t cardrsp_phys_addr ;
  struct qlcnic_dcb_param rsp ;
  struct qlcnic_cmd_args cmd ;
  u64 phys_addr ;
  void *addr ;
  int err ;
  int i ;
  size_t __len ;
  void *__ret ;
  {
  size = 64U;
  adapter = dcb->adapter;
  dev = & (adapter->pdev)->dev;
  switch ((int )type) {
  case 3: ;
  case 1: ;
  case 2: ;
  goto ldv_51041;
  default:
  dev_err((struct device const *)dev, "Invalid parameter type %d\n", (int )type);
  return (-22);
  }
  ldv_51041:
  addr = dma_alloc_attrs(dev, (size_t )size, & cardrsp_phys_addr, 208U, (struct dma_attrs *)0);
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    return (-12);
  } else {
  }
  prsp_le = (struct qlcnic_82xx_dcb_param_mbx_le *)addr;
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 53U);
  if (err != 0) {
    goto out_free_rsp;
  } else {
  }
  phys_addr = cardrsp_phys_addr;
  *(cmd.req.arg + 1UL) = (u32 )((int )size | ((int )type << 16));
  *(cmd.req.arg + 2UL) = (unsigned int )(phys_addr >> 32ULL);
  *(cmd.req.arg + 3UL) = (unsigned int )phys_addr;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)dev, "Failed to query DCBX parameter, err %d\n",
            err);
    goto out;
  } else {
  }
  memset((void *)(& rsp), 0, 64UL);
  rsp.hdr_prio_pfc_map[0] = prsp_le->hdr_prio_pfc_map[0];
  rsp.hdr_prio_pfc_map[1] = prsp_le->hdr_prio_pfc_map[1];
  rsp.prio_pg_map[0] = prsp_le->prio_pg_map[0];
  rsp.prio_pg_map[1] = prsp_le->prio_pg_map[1];
  rsp.pg_bw_map[0] = prsp_le->pg_bw_map[0];
  rsp.pg_bw_map[1] = prsp_le->pg_bw_map[1];
  rsp.pg_tsa_map[0] = prsp_le->pg_tsa_map[0];
  rsp.pg_tsa_map[1] = prsp_le->pg_tsa_map[1];
  i = 0;
  goto ldv_51046;
  ldv_51045:
  rsp.app[i] = prsp_le->app[i];
  i = i + 1;
  ldv_51046: ;
  if (i <= 7) {
    goto ldv_51045;
  } else {
  }
  if ((unsigned long )buf != (unsigned long )((char *)0)) {
    __len = (size_t )size;
    __ret = memcpy((void *)buf, (void const *)(& rsp), __len);
  } else {
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  out_free_rsp:
  dma_free_attrs(dev, (size_t )size, addr, cardrsp_phys_addr, (struct dma_attrs *)0);
  return (err);
}
}
static int qlcnic_82xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb )
{
  struct qlcnic_dcb_mbx_params *mbx ;
  int err ;
  {
  mbx = dcb->param;
  if ((unsigned long )mbx == (unsigned long )((struct qlcnic_dcb_mbx_params *)0)) {
    return (0);
  } else {
  }
  err = qlcnic_dcb_query_cee_param(dcb, (char *)(& mbx->type), 3);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_dcb_query_cee_param(dcb, (char *)(& mbx->type) + 1U, 1);
  if (err != 0) {
    return (err);
  } else {
  }
  err = qlcnic_dcb_query_cee_param(dcb, (char *)(& mbx->type) + 2U, 2);
  if (err != 0) {
    return (err);
  } else {
  }
  mbx->prio_tc_map = 1985229328U;
  qlcnic_dcb_data_cee_param_map(dcb->adapter);
  return (err);
}
}
static void qlcnic_dcb_aen_work(struct work_struct *work )
{
  struct qlcnic_dcb *dcb ;
  struct work_struct const *__mptr ;
  {
  __mptr = (struct work_struct const *)work;
  dcb = (struct qlcnic_dcb *)__mptr + 0xfffffffffffffff0UL;
  qlcnic_dcb_get_cee_cfg(dcb);
  clear_bit(1L, (unsigned long volatile *)(& dcb->state));
  return;
}
}
static void qlcnic_82xx_dcb_aen_handler(struct qlcnic_dcb *dcb , void *data )
{
  int tmp ;
  {
  tmp = test_and_set_bit(1L, (unsigned long volatile *)(& dcb->state));
  if (tmp != 0) {
    return;
  } else {
  }
  queue_delayed_work(dcb->wq, & dcb->aen_work, 0UL);
  return;
}
}
static int qlcnic_83xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb )
{
  struct qlcnic_dcb_capability *cap ;
  u32 mbx_out ;
  int err ;
  {
  cap = & (dcb->cfg)->capability;
  err = __qlcnic_dcb_get_capability(dcb, & mbx_out);
  if (err != 0) {
    return (err);
  } else {
  }
  if ((mbx_out & 4U) != 0U) {
    cap->dcb_capability = 4U;
  } else {
  }
  if ((mbx_out & 8U) != 0U) {
    cap->dcb_capability = (u8 )((unsigned int )cap->dcb_capability | 8U);
  } else {
  }
  if ((unsigned int )cap->dcb_capability != 0U) {
    cap->dcb_capability = (u8 )((unsigned int )cap->dcb_capability | 2U);
  } else {
  }
  if (((unsigned int )cap->dcb_capability != 0U && (int )cap->tsa_capability) && (int )cap->ets_capability) {
    set_bit(0L, (unsigned long volatile *)(& dcb->state));
  } else {
  }
  return (err);
}
}
static int qlcnic_83xx_dcb_query_cee_param(struct qlcnic_dcb *dcb , char *buf , u8 idx )
{
  struct qlcnic_adapter *adapter ;
  struct qlcnic_dcb_mbx_params mbx_out ;
  int err ;
  int i ;
  int j ;
  int k ;
  int max_app ;
  int size ;
  struct qlcnic_dcb_param *each ;
  struct qlcnic_cmd_args cmd ;
  u32 val ;
  char *p ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  u8 tmp___7 ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  adapter = dcb->adapter;
  size = 0;
  memset((void *)(& mbx_out), 0, 196UL);
  memset((void *)buf, 0, 196UL);
  err = qlcnic_alloc_mbx_args(& cmd, adapter, 53U);
  if (err != 0) {
    return (err);
  } else {
  }
  *(cmd.req.arg) = *(cmd.req.arg) | 1073741824U;
  err = qlcnic_issue_cmd(adapter, & cmd);
  if (err != 0) {
    dev_err((struct device const *)(& (adapter->pdev)->dev), "Failed to query DCBX param, err %d\n",
            err);
    goto out;
  } else {
  }
  mbx_out.prio_tc_map = *(cmd.rsp.arg + 1UL);
  __len = 4UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)buf, (void const *)(& mbx_out), __len);
  } else {
    __ret = memcpy((void *)buf, (void const *)(& mbx_out), __len);
  }
  p = (char *)__ret;
  k = 2;
  p = p + 4UL;
  j = 0;
  goto ldv_51100;
  ldv_51099:
  each = (struct qlcnic_dcb_param *)(& mbx_out.type) + (unsigned long )j;
  tmp = k;
  k = k + 1;
  each->hdr_prio_pfc_map[0] = *(cmd.rsp.arg + (unsigned long )tmp);
  tmp___0 = k;
  k = k + 1;
  each->hdr_prio_pfc_map[1] = *(cmd.rsp.arg + (unsigned long )tmp___0);
  tmp___1 = k;
  k = k + 1;
  each->prio_pg_map[0] = *(cmd.rsp.arg + (unsigned long )tmp___1);
  tmp___2 = k;
  k = k + 1;
  each->prio_pg_map[1] = *(cmd.rsp.arg + (unsigned long )tmp___2);
  tmp___3 = k;
  k = k + 1;
  each->pg_bw_map[0] = *(cmd.rsp.arg + (unsigned long )tmp___3);
  tmp___4 = k;
  k = k + 1;
  each->pg_bw_map[1] = *(cmd.rsp.arg + (unsigned long )tmp___4);
  tmp___5 = k;
  k = k + 1;
  each->pg_tsa_map[0] = *(cmd.rsp.arg + (unsigned long )tmp___5);
  tmp___6 = k;
  k = k + 1;
  each->pg_tsa_map[1] = *(cmd.rsp.arg + (unsigned long )tmp___6);
  val = each->hdr_prio_pfc_map[0];
  tmp___7 = qlcnic_dcb_get_num_app(adapter, val);
  max_app = (int )tmp___7;
  i = 0;
  goto ldv_51094;
  ldv_51093:
  each->app[i] = *(cmd.rsp.arg + (unsigned long )(i + k));
  i = i + 1;
  ldv_51094: ;
  if (i < max_app) {
    goto ldv_51093;
  } else {
  }
  size = 64;
  __len___0 = (size_t )size;
  __ret___0 = memcpy((void *)p, (void const *)(& each->hdr_prio_pfc_map),
                               __len___0);
  p = p + (unsigned long )size;
  if (j == 0) {
    k = 18;
  } else {
    k = 34;
  }
  j = j + 1;
  ldv_51100: ;
  if (j <= 2) {
    goto ldv_51099;
  } else {
  }
  out:
  qlcnic_free_mbx_args(& cmd);
  return (err);
}
}
static int qlcnic_83xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb )
{
  int err ;
  {
  err = qlcnic_dcb_query_cee_param(dcb, (char *)dcb->param, 0);
  if (err != 0) {
    return (err);
  } else {
  }
  qlcnic_dcb_data_cee_param_map(dcb->adapter);
  return (err);
}
}
static void qlcnic_83xx_dcb_aen_handler(struct qlcnic_dcb *dcb , void *data )
{
  u32 *val ;
  int tmp ;
  {
  val = (u32 *)data;
  tmp = test_and_set_bit(1L, (unsigned long volatile *)(& dcb->state));
  if (tmp != 0) {
    return;
  } else {
  }
  if ((*val & 256U) != 0U) {
    set_bit(0L, (unsigned long volatile *)(& dcb->state));
  } else {
    clear_bit(0L, (unsigned long volatile *)(& dcb->state));
  }
  queue_delayed_work(dcb->wq, & dcb->aen_work, 0UL);
  return;
}
}
static void qlcnic_dcb_fill_cee_tc_params(struct qlcnic_dcb_mbx_params *mbx , struct qlcnic_dcb_param *each ,
                                          struct qlcnic_dcb_cee *type )
{
  struct qlcnic_dcb_tc_cfg *tc_cfg ;
  u8 i ;
  u8 tc ;
  u8 pgid ;
  {
  i = 0U;
  goto ldv_51121;
  ldv_51120:
  tc = (unsigned int )((u8 )(mbx->prio_tc_map >> (int )i * 3)) & 7U;
  tc_cfg = (struct qlcnic_dcb_tc_cfg *)(& type->tc_cfg) + (unsigned long )tc;
  tc_cfg->valid = 1;
  tc_cfg->up_tc_map = (u8 )((int )((signed char )tc_cfg->up_tc_map) | (int )((signed char )(1 << (int )i)));
  if ((int )((each->hdr_prio_pfc_map[1] >> 24) >> (int )i) & 1 && (int )type->pfc_mode_enable) {
    tc_cfg->prio_cfg[(int )i].valid = 1;
    tc_cfg->prio_cfg[(int )i].pfc_type = 1;
  } else {
  }
  if ((unsigned int )i <= 3U) {
    pgid = (u8 )(each->prio_pg_map[0] >> (int )i * 8);
  } else {
    pgid = (u8 )(each->prio_pg_map[1] >> (int )i * 8);
  }
  tc_cfg->pgid = pgid;
  tc_cfg->prio_type = 2;
  type->pg_cfg[(int )tc_cfg->pgid].prio_count = (u8 )((int )type->pg_cfg[(int )tc_cfg->pgid].prio_count + 1);
  i = (u8 )((int )i + 1);
  ldv_51121: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_51120;
  } else {
  }
  return;
}
}
static void qlcnic_dcb_fill_cee_pg_params(struct qlcnic_dcb_param *each , struct qlcnic_dcb_cee *type )
{
  struct qlcnic_dcb_pg_cfg *pg_cfg ;
  u8 i ;
  u8 tsa ;
  u8 bw_per ;
  {
  i = 0U;
  goto ldv_51132;
  ldv_51131:
  pg_cfg = (struct qlcnic_dcb_pg_cfg *)(& type->pg_cfg) + (unsigned long )i;
  pg_cfg->valid = 1;
  if ((unsigned int )i <= 3U) {
    bw_per = (u8 )(each->pg_bw_map[0] >> (int )i * 8);
    tsa = (u8 )(each->pg_tsa_map[0] >> (int )i * 8);
  } else {
    bw_per = (u8 )(each->pg_bw_map[1] >> (int )i * 8);
    tsa = (u8 )(each->pg_tsa_map[1] >> (int )i * 8);
  }
  pg_cfg->total_bw_percent = bw_per;
  pg_cfg->tsa_type = tsa;
  i = (u8 )((int )i + 1);
  ldv_51132: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_51131;
  } else {
  }
  return;
}
}
static void qlcnic_dcb_fill_cee_app_params(struct qlcnic_adapter *adapter , u8 idx ,
                                           struct qlcnic_dcb_param *each , struct qlcnic_dcb_cee *type )
{
  struct qlcnic_dcb_app *app ;
  u8 i ;
  u8 num_app ;
  u8 map ;
  u8 cnt ;
  struct dcb_app new_app ;
  int tmp ;
  {
  num_app = qlcnic_dcb_get_num_app(adapter, each->hdr_prio_pfc_map[0]);
  i = 0U;
  goto ldv_51147;
  ldv_51146:
  app = (struct qlcnic_dcb_app *)(& type->app) + (unsigned long )i;
  app->valid = 1;
  app->selector = (enum qlcnic_dcb_selector )((each->app[(int )i] & 255U) - 1U);
  new_app.selector = (__u8 )app->selector;
  app->protocol = (u16 )(each->app[(int )i] >> 8);
  new_app.protocol = app->protocol;
  map = qlcnic_dcb_get_prio_map_app(adapter, each->app[(int )i]);
  tmp = qlcnic_dcb_prio_count((int )map);
  cnt = (u8 )tmp;
  if ((unsigned int )cnt > 7U) {
    cnt = 0U;
  } else {
  }
  app->priority = cnt;
  new_app.priority = cnt;
  if ((unsigned int )idx == 1U && (unsigned long )(adapter->netdev)->dcbnl_ops != (unsigned long )((struct dcbnl_rtnl_ops const *)0)) {
    dcb_setapp(adapter->netdev, & new_app);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_51147: ;
  if ((int )i < (int )num_app) {
    goto ldv_51146;
  } else {
  }
  return;
}
}
static void qlcnic_dcb_map_cee_params(struct qlcnic_adapter *adapter , u8 idx )
{
  struct qlcnic_dcb_mbx_params *mbx ;
  struct qlcnic_dcb_param *each ;
  struct qlcnic_dcb_cfg *cfg ;
  struct qlcnic_dcb_cee *type ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  mbx = (adapter->dcb)->param;
  each = (struct qlcnic_dcb_param *)(& mbx->type) + (unsigned long )idx;
  cfg = (adapter->dcb)->cfg;
  type = (struct qlcnic_dcb_cee *)(& cfg->type) + (unsigned long )idx;
  type->tc_param_valid = 0;
  type->pfc_mode_enable = 0;
  memset((void *)(& type->tc_cfg), 0, 608UL);
  memset((void *)(& type->pg_cfg), 0, 32UL);
  tmp = qlcnic_dcb_pfc_hdr_valid(adapter, each->hdr_prio_pfc_map[0]);
  if ((unsigned int )tmp != 0U && (unsigned int )cfg->capability.max_pfc_tc != 0U) {
    type->pfc_mode_enable = 1;
  } else {
  }
  tmp___0 = qlcnic_dcb_tsa_hdr_valid(adapter, each->hdr_prio_pfc_map[0]);
  if ((unsigned int )tmp___0 != 0U && (unsigned int )cfg->capability.max_ets_tc != 0U) {
    type->tc_param_valid = 1;
  } else {
  }
  qlcnic_dcb_fill_cee_tc_params(mbx, each, type);
  qlcnic_dcb_fill_cee_pg_params(each, type);
  qlcnic_dcb_fill_cee_app_params(adapter, (int )idx, each, type);
  return;
}
}
static void qlcnic_dcb_data_cee_param_map(struct qlcnic_adapter *adapter )
{
  int i ;
  {
  i = 0;
  goto ldv_51162;
  ldv_51161:
  qlcnic_dcb_map_cee_params(adapter, (int )((u8 )i));
  i = i + 1;
  ldv_51162: ;
  if (i <= 2) {
    goto ldv_51161;
  } else {
  }
  dcbnl_cee_notify(adapter->netdev, 78, 26, 0U, 0U);
  return;
}
}
static u8 qlcnic_dcb_get_state(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  return ((u8 )tmp___0);
}
}
static void qlcnic_dcb_get_perm_hw_addr(struct net_device *netdev , u8 *addr )
{
  size_t __len ;
  void *__ret ;
  {
  __len = (size_t )netdev->addr_len;
  __ret = memcpy((void *)addr, (void const *)(& netdev->perm_addr), __len);
  return;
}
}
static void qlcnic_dcb_get_pg_tc_cfg_tx(struct net_device *netdev , int tc , u8 *prio ,
                                        u8 *pgid , u8 *bw_per , u8 *up_tc_map )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_tc_cfg *tc_cfg ;
  struct qlcnic_dcb_tc_cfg *temp ;
  struct qlcnic_dcb_cee *type ;
  u8 i ;
  u8 cnt ;
  u8 pg ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  int tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  type = (struct qlcnic_dcb_cee *)(& ((adapter->dcb)->cfg)->type) + 1UL;
  tmp___2 = 0U;
  *up_tc_map = tmp___2;
  tmp___1 = tmp___2;
  *bw_per = tmp___1;
  tmp___0 = tmp___1;
  *pgid = tmp___0;
  *prio = tmp___0;
  tmp___3 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___3 == 0 || ! type->tc_param_valid) {
    return;
  } else {
  }
  if (tc < 0 || tc > 7) {
    return;
  } else {
  }
  tc_cfg = (struct qlcnic_dcb_tc_cfg *)(& type->tc_cfg) + (unsigned long )tc;
  if (! tc_cfg->valid) {
    return;
  } else {
  }
  *pgid = tc_cfg->pgid;
  *prio = (u8 )tc_cfg->prio_type;
  *up_tc_map = tc_cfg->up_tc_map;
  pg = *pgid;
  i = 0U;
  cnt = 0U;
  goto ldv_51191;
  ldv_51190:
  temp = (struct qlcnic_dcb_tc_cfg *)(& type->tc_cfg) + (unsigned long )i;
  if ((int )temp->valid && (int )temp->pgid == (int )pg) {
    cnt = (u8 )((int )cnt + 1);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_51191: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_51190;
  } else {
  }
  tc_cfg->bwg_percent = (u8 )(100 / (int )cnt);
  *bw_per = tc_cfg->bwg_percent;
  return;
}
}
static void qlcnic_dcb_get_pg_bwg_cfg_tx(struct net_device *netdev , int pgid , u8 *bw_pct )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_pg_cfg *pgcfg ;
  struct qlcnic_dcb_cee *type ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  *bw_pct = 0U;
  type = (struct qlcnic_dcb_cee *)(& ((adapter->dcb)->cfg)->type) + 1UL;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0 || ! type->tc_param_valid) {
    return;
  } else {
  }
  if (pgid < 0 || pgid > 7) {
    return;
  } else {
  }
  pgcfg = (struct qlcnic_dcb_pg_cfg *)(& type->pg_cfg) + (unsigned long )pgid;
  if (! pgcfg->valid) {
    return;
  } else {
  }
  *bw_pct = pgcfg->total_bw_percent;
  return;
}
}
static void qlcnic_dcb_get_pfc_cfg(struct net_device *netdev , int prio , u8 *setting )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_tc_cfg *tc_cfg ;
  u8 val ;
  struct qlcnic_dcb_cee *type ;
  u8 i ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  val = (u8 )(1 << prio);
  *setting = 0U;
  type = (struct qlcnic_dcb_cee *)(& ((adapter->dcb)->cfg)->type) + 1UL;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0 || ! type->pfc_mode_enable) {
    return;
  } else {
  }
  i = 0U;
  goto ldv_51213;
  ldv_51212:
  tc_cfg = (struct qlcnic_dcb_tc_cfg *)(& type->tc_cfg) + (unsigned long )i;
  if (! tc_cfg->valid) {
    goto ldv_51211;
  } else {
  }
  if ((unsigned int )((int )tc_cfg->up_tc_map & (int )val) != 0U && (int )tc_cfg->prio_cfg[prio].valid) {
    *setting = (u8 )tc_cfg->prio_cfg[prio].pfc_type;
  } else {
  }
  ldv_51211:
  i = (u8 )((int )i + 1);
  ldv_51213: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_51212;
  } else {
  }
  return;
}
}
static u8 qlcnic_dcb_get_capability(struct net_device *netdev , int capid , u8 *cap )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (0U);
  } else {
  }
  switch (capid) {
  case 2: ;
  case 4: ;
  case 3: ;
  case 7:
  *cap = 1U;
  goto ldv_51225;
  case 5: ;
  case 6:
  *cap = 128U;
  goto ldv_51225;
  case 9:
  *cap = ((adapter->dcb)->cfg)->capability.dcb_capability;
  goto ldv_51225;
  default:
  *cap = 0U;
  }
  ldv_51225: ;
  return (0U);
}
}
static int qlcnic_dcb_get_num_tcs(struct net_device *netdev , int attr , u8 *num )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_cfg *cfg ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  cfg = (adapter->dcb)->cfg;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (-22);
  } else {
  }
  switch (attr) {
  case 2:
  *num = cfg->capability.max_ets_tc;
  return (0);
  case 3:
  *num = cfg->capability.max_pfc_tc;
  return (0);
  default: ;
  return (-22);
  }
}
}
static u8 qlcnic_dcb_get_app(struct net_device *netdev , u8 idtype , u16 id )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct dcb_app app ;
  int tmp___0 ;
  u8 tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  app.selector = idtype;
  app.priority = (unsigned char)0;
  app.protocol = id;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (0U);
  } else {
  }
  tmp___1 = dcb_getapp(netdev, & app);
  return (tmp___1);
}
}
static u8 qlcnic_dcb_get_pfc_state(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb *dcb ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  dcb = adapter->dcb;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& dcb->state));
  if (tmp___0 == 0) {
    return (0U);
  } else {
  }
  return ((u8 )(dcb->cfg)->type[1].pfc_mode_enable);
}
}
static u8 qlcnic_dcb_get_dcbx(struct net_device *netdev )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_cfg *cfg ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  cfg = (adapter->dcb)->cfg;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (0U);
  } else {
  }
  return (cfg->capability.dcb_capability);
}
}
static u8 qlcnic_dcb_get_feat_cfg(struct net_device *netdev , int fid , u8 *flag )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_cee *type ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (1U);
  } else {
  }
  type = (struct qlcnic_dcb_cee *)(& ((adapter->dcb)->cfg)->type) + 1UL;
  *flag = 0U;
  switch (fid) {
  case 2: ;
  if ((int )type->tc_param_valid) {
    *flag = (u8 )((unsigned int )*flag | 2U);
  } else {
    *flag = (u8 )((unsigned int )*flag | 1U);
  }
  goto ldv_51265;
  case 3: ;
  if ((int )type->pfc_mode_enable) {
    if ((unsigned int )type->tc_cfg[0].prio_cfg[0].pfc_type != 0U) {
      *flag = (u8 )((unsigned int )*flag | 2U);
    } else {
    }
  } else {
    *flag = (u8 )((unsigned int )*flag | 1U);
  }
  goto ldv_51265;
  case 4:
  *flag = (u8 )((unsigned int )*flag | 2U);
  goto ldv_51265;
  default:
  netdev_err((struct net_device const *)netdev, "Invalid Feature ID %d\n", fid);
  return (1U);
  }
  ldv_51265: ;
  return (0U);
}
}
__inline static void qlcnic_dcb_get_pg_tc_cfg_rx(struct net_device *netdev , int prio ,
                                                 u8 *prio_type , u8 *pgid , u8 *bw_pct ,
                                                 u8 *up_map )
{
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  {
  tmp___1 = 0U;
  *up_map = tmp___1;
  tmp___0 = tmp___1;
  *bw_pct = tmp___0;
  tmp = tmp___0;
  *pgid = tmp;
  *prio_type = tmp;
  return;
}
}
__inline static void qlcnic_dcb_get_pg_bwg_cfg_rx(struct net_device *netdev , int pgid ,
                                                  u8 *bw_pct )
{
  {
  *bw_pct = 0U;
  return;
}
}
static int qlcnic_dcb_peer_app_info(struct net_device *netdev , struct dcb_peer_app_info *info ,
                                    u16 *app_count )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_cee *peer ;
  int i ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  memset((void *)info, 0, 2UL);
  *app_count = 0U;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (0);
  } else {
  }
  peer = (struct qlcnic_dcb_cee *)(& ((adapter->dcb)->cfg)->type) + 2UL;
  i = 0;
  goto ldv_51291;
  ldv_51290: ;
  if ((int )peer->app[i].valid) {
    *app_count = (u16 )((int )*app_count + 1);
  } else {
  }
  i = i + 1;
  ldv_51291: ;
  if (i <= 7) {
    goto ldv_51290;
  } else {
  }
  return (0);
}
}
static int qlcnic_dcb_peer_app_table(struct net_device *netdev , struct dcb_app *table )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_cee *peer ;
  struct qlcnic_dcb_app *app ;
  int i ;
  int j ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (0);
  } else {
  }
  peer = (struct qlcnic_dcb_cee *)(& ((adapter->dcb)->cfg)->type) + 2UL;
  i = 0;
  j = 0;
  goto ldv_51304;
  ldv_51303:
  app = (struct qlcnic_dcb_app *)(& peer->app) + (unsigned long )i;
  if (! app->valid) {
    goto ldv_51302;
  } else {
  }
  (table + (unsigned long )j)->selector = (__u8 )app->selector;
  (table + (unsigned long )j)->priority = app->priority;
  tmp___1 = j;
  j = j + 1;
  (table + (unsigned long )tmp___1)->protocol = app->protocol;
  ldv_51302:
  i = i + 1;
  ldv_51304: ;
  if (i <= 7) {
    goto ldv_51303;
  } else {
  }
  return (0);
}
}
static int qlcnic_dcb_cee_peer_get_pg(struct net_device *netdev , struct cee_pg *pg )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_cee *peer ;
  u8 i ;
  u8 j ;
  u8 k ;
  u8 map ;
  int tmp___0 ;
  u8 tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (0);
  } else {
  }
  peer = (struct qlcnic_dcb_cee *)(& ((adapter->dcb)->cfg)->type) + 2UL;
  i = 0U;
  j = 0U;
  goto ldv_51321;
  ldv_51320: ;
  if (! peer->pg_cfg[(int )i].valid) {
    goto ldv_51316;
  } else {
  }
  pg->pg_bw[(int )j] = peer->pg_cfg[(int )i].total_bw_percent;
  k = 0U;
  goto ldv_51319;
  ldv_51318: ;
  if ((int )peer->tc_cfg[(int )i].valid && (int )peer->tc_cfg[(int )i].pgid == (int )i) {
    map = peer->tc_cfg[(int )i].up_tc_map;
    tmp___1 = j;
    j = (u8 )((int )j + 1);
    pg->prio_pg[(int )tmp___1] = map;
    goto ldv_51317;
  } else {
  }
  k = (u8 )((int )k + 1);
  ldv_51319: ;
  if ((unsigned int )k <= 7U) {
    goto ldv_51318;
  } else {
  }
  ldv_51317: ;
  ldv_51316:
  i = (u8 )((int )i + 1);
  ldv_51321: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_51320;
  } else {
  }
  return (0);
}
}
static int qlcnic_dcb_cee_peer_get_pfc(struct net_device *netdev , struct cee_pfc *pfc )
{
  struct qlcnic_adapter *adapter ;
  void *tmp ;
  struct qlcnic_dcb_cfg *cfg ;
  struct qlcnic_dcb_tc_cfg *tc ;
  struct qlcnic_dcb_cee *peer ;
  u8 i ;
  u8 setting ;
  u8 prio ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = netdev_priv((struct net_device const *)netdev);
  adapter = (struct qlcnic_adapter *)tmp;
  cfg = (adapter->dcb)->cfg;
  pfc->pfc_en = 0U;
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile *)(& (adapter->dcb)->state));
  if (tmp___0 == 0) {
    return (0);
  } else {
  }
  peer = (struct qlcnic_dcb_cee *)(& cfg->type) + 2UL;
  i = 0U;
  goto ldv_51335;
  ldv_51334:
  tc = (struct qlcnic_dcb_tc_cfg *)(& peer->tc_cfg) + (unsigned long )i;
  tmp___1 = qlcnic_dcb_prio_count((int )tc->up_tc_map);
  prio = (u8 )tmp___1;
  setting = 0U;
  qlcnic_dcb_get_pfc_cfg(netdev, (int )prio, & setting);
  if ((unsigned int )setting != 0U) {
    pfc->pfc_en = (__u8 )((int )((signed char )pfc->pfc_en) | (int )((signed char )(1 << (int )i)));
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_51335: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_51334;
  } else {
  }
  pfc->tcs_supported = cfg->capability.max_pfc_tc;
  return (0);
}
}
static struct dcbnl_rtnl_ops const qlcnic_dcbnl_ops =
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & qlcnic_dcb_get_state, 0, & qlcnic_dcb_get_perm_hw_addr,
    0, 0, 0, 0, & qlcnic_dcb_get_pg_tc_cfg_tx, & qlcnic_dcb_get_pg_bwg_cfg_tx, & qlcnic_dcb_get_pg_tc_cfg_rx,
    & qlcnic_dcb_get_pg_bwg_cfg_rx, 0, & qlcnic_dcb_get_pfc_cfg, 0, & qlcnic_dcb_get_capability,
    & qlcnic_dcb_get_num_tcs, 0, & qlcnic_dcb_get_pfc_state, 0, 0, 0, 0, 0, 0, & qlcnic_dcb_get_app,
    & qlcnic_dcb_get_feat_cfg, 0, & qlcnic_dcb_get_dcbx, 0, & qlcnic_dcb_peer_app_info,
    & qlcnic_dcb_peer_app_table, & qlcnic_dcb_cee_peer_get_pg, & qlcnic_dcb_cee_peer_get_pfc};
void ldv_initialize_qlcnic_dcb_ops_2(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(272UL);
  qlcnic_82xx_dcb_ops_group0 = (struct qlcnic_dcb *)tmp;
  return;
}
}
void ldv_initialize_qlcnic_dcb_ops_3(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(272UL);
  qlcnic_83xx_dcb_ops_group0 = (struct qlcnic_dcb *)tmp;
  return;
}
}
void ldv_initialize_dcbnl_rtnl_ops_1(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(3264UL);
  qlcnic_dcbnl_ops_group0 = (struct net_device *)tmp;
  return;
}
}
void ldv_main_exported_1(void)
{
  u8 *ldvarg75 ;
  void *tmp ;
  int ldvarg76 ;
  int tmp___0 ;
  int ldvarg74 ;
  int tmp___1 ;
  int ldvarg82 ;
  int tmp___2 ;
  u8 *ldvarg61 ;
  void *tmp___3 ;
  u16 *ldvarg69 ;
  void *tmp___4 ;
  int ldvarg68 ;
  int tmp___5 ;
  int ldvarg78 ;
  int tmp___6 ;
  struct dcb_peer_app_info *ldvarg70 ;
  void *tmp___7 ;
  u8 *ldvarg73 ;
  void *tmp___8 ;
  struct cee_pg *ldvarg85 ;
  void *tmp___9 ;
  u8 *ldvarg63 ;
  void *tmp___10 ;
  u8 *ldvarg81 ;
  void *tmp___11 ;
  u8 *ldvarg83 ;
  void *tmp___12 ;
  struct dcb_app *ldvarg66 ;
  void *tmp___13 ;
  int ldvarg64 ;
  int tmp___14 ;
  u8 *ldvarg58 ;
  void *tmp___15 ;
  u8 *ldvarg79 ;
  void *tmp___16 ;
  u8 *ldvarg65 ;
  void *tmp___17 ;
  u8 *ldvarg62 ;
  void *tmp___18 ;
  int ldvarg72 ;
  int tmp___19 ;
  u16 ldvarg86 ;
  u16 tmp___20 ;
  int ldvarg59 ;
  int tmp___21 ;
  u8 *ldvarg71 ;
  void *tmp___22 ;
  u8 ldvarg87 ;
  u8 tmp___23 ;
  u8 *ldvarg80 ;
  void *tmp___24 ;
  struct cee_pfc *ldvarg60 ;
  void *tmp___25 ;
  u8 *ldvarg67 ;
  void *tmp___26 ;
  u8 *ldvarg84 ;
  void *tmp___27 ;
  u8 *ldvarg77 ;
  void *tmp___28 ;
  int tmp___29 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg75 = (u8 *)tmp;
  tmp___0 = __VERIFIER_nondet_int();
  ldvarg76 = tmp___0;
  tmp___1 = __VERIFIER_nondet_int();
  ldvarg74 = tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  ldvarg82 = tmp___2;
  tmp___3 = ldv_zalloc(1UL);
  ldvarg61 = (u8 *)tmp___3;
  tmp___4 = ldv_zalloc(2UL);
  ldvarg69 = (u16 *)tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  ldvarg68 = tmp___5;
  tmp___6 = __VERIFIER_nondet_int();
  ldvarg78 = tmp___6;
  tmp___7 = ldv_zalloc(2UL);
  ldvarg70 = (struct dcb_peer_app_info *)tmp___7;
  tmp___8 = ldv_zalloc(1UL);
  ldvarg73 = (u8 *)tmp___8;
  tmp___9 = ldv_zalloc(20UL);
  ldvarg85 = (struct cee_pg *)tmp___9;
  tmp___10 = ldv_zalloc(1UL);
  ldvarg63 = (u8 *)tmp___10;
  tmp___11 = ldv_zalloc(1UL);
  ldvarg81 = (u8 *)tmp___11;
  tmp___12 = ldv_zalloc(1UL);
  ldvarg83 = (u8 *)tmp___12;
  tmp___13 = ldv_zalloc(4UL);
  ldvarg66 = (struct dcb_app *)tmp___13;
  tmp___14 = __VERIFIER_nondet_int();
  ldvarg64 = tmp___14;
  tmp___15 = ldv_zalloc(1UL);
  ldvarg58 = (u8 *)tmp___15;
  tmp___16 = ldv_zalloc(1UL);
  ldvarg79 = (u8 *)tmp___16;
  tmp___17 = ldv_zalloc(1UL);
  ldvarg65 = (u8 *)tmp___17;
  tmp___18 = ldv_zalloc(1UL);
  ldvarg62 = (u8 *)tmp___18;
  tmp___19 = __VERIFIER_nondet_int();
  ldvarg72 = tmp___19;
  tmp___20 = __VERIFIER_nondet_u16();
  ldvarg86 = tmp___20;
  tmp___21 = __VERIFIER_nondet_int();
  ldvarg59 = tmp___21;
  tmp___22 = ldv_zalloc(1UL);
  ldvarg71 = (u8 *)tmp___22;
  tmp___23 = __VERIFIER_nondet_u8();
  ldvarg87 = tmp___23;
  tmp___24 = ldv_zalloc(1UL);
  ldvarg80 = (u8 *)tmp___24;
  tmp___25 = ldv_zalloc(4UL);
  ldvarg60 = (struct cee_pfc *)tmp___25;
  tmp___26 = ldv_zalloc(1UL);
  ldvarg67 = (u8 *)tmp___26;
  tmp___27 = ldv_zalloc(1UL);
  ldvarg84 = (u8 *)tmp___27;
  tmp___28 = ldv_zalloc(1UL);
  ldvarg77 = (u8 *)tmp___28;
  tmp___29 = __VERIFIER_nondet_int();
  switch (tmp___29) {
  case 0: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_app(qlcnic_dcbnl_ops_group0, (int )ldvarg87, (int )ldvarg86);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 1: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_cee_peer_get_pg(qlcnic_dcbnl_ops_group0, ldvarg85);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 2: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_perm_hw_addr(qlcnic_dcbnl_ops_group0, ldvarg84);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 3: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_pg_tc_cfg_tx(qlcnic_dcbnl_ops_group0, ldvarg82, ldvarg81, ldvarg80,
                                ldvarg83, ldvarg79);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 4: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_pg_bwg_cfg_tx(qlcnic_dcbnl_ops_group0, ldvarg78, ldvarg77);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 5: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_pfc_cfg(qlcnic_dcbnl_ops_group0, ldvarg76, ldvarg75);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 6: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_pfc_state(qlcnic_dcbnl_ops_group0);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 7: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_dcbx(qlcnic_dcbnl_ops_group0);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 8: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_pg_bwg_cfg_rx(qlcnic_dcbnl_ops_group0, ldvarg74, ldvarg73);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 9: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_num_tcs(qlcnic_dcbnl_ops_group0, ldvarg72, ldvarg71);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 10: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_state(qlcnic_dcbnl_ops_group0);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 11: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_peer_app_info(qlcnic_dcbnl_ops_group0, ldvarg70, ldvarg69);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 12: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_capability(qlcnic_dcbnl_ops_group0, ldvarg68, ldvarg67);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 13: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_peer_app_table(qlcnic_dcbnl_ops_group0, ldvarg66);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 14: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_pg_tc_cfg_rx(qlcnic_dcbnl_ops_group0, ldvarg64, ldvarg63, ldvarg62,
                                ldvarg65, ldvarg61);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 15: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_cee_peer_get_pfc(qlcnic_dcbnl_ops_group0, ldvarg60);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  case 16: ;
  if (ldv_state_variable_1 == 1) {
    qlcnic_dcb_get_feat_cfg(qlcnic_dcbnl_ops_group0, ldvarg59, ldvarg58);
    ldv_state_variable_1 = 1;
  } else {
  }
  goto ldv_51381;
  default:
  ldv_stop();
  }
  ldv_51381: ;
  return;
}
}
void ldv_main_exported_3(void)
{
  u8 ldvarg226 ;
  u8 tmp ;
  char *ldvarg227 ;
  void *tmp___0 ;
  void *ldvarg228 ;
  void *tmp___1 ;
  char *ldvarg225 ;
  void *tmp___2 ;
  int tmp___3 ;
  {
  tmp = __VERIFIER_nondet_u8();
  ldvarg226 = tmp;
  tmp___0 = ldv_zalloc(1UL);
  ldvarg227 = (char *)tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg228 = tmp___1;
  tmp___2 = ldv_zalloc(1UL);
  ldvarg225 = (char *)tmp___2;
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_3 == 1) {
    qlcnic_83xx_dcb_aen_handler(qlcnic_83xx_dcb_ops_group0, ldvarg228);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 1: ;
  if (ldv_state_variable_3 == 1) {
    qlcnic_83xx_dcb_get_hw_capability(qlcnic_83xx_dcb_ops_group0);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 2: ;
  if (ldv_state_variable_3 == 1) {
    __qlcnic_dcb_attach(qlcnic_83xx_dcb_ops_group0);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 3: ;
  if (ldv_state_variable_3 == 1) {
    __qlcnic_dcb_free(qlcnic_83xx_dcb_ops_group0);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 4: ;
  if (ldv_state_variable_3 == 1) {
    qlcnic_83xx_dcb_query_cee_param(qlcnic_83xx_dcb_ops_group0, ldvarg227, (int )ldvarg226);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 5: ;
  if (ldv_state_variable_3 == 1) {
    qlcnic_83xx_dcb_get_cee_cfg(qlcnic_83xx_dcb_ops_group0);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 6: ;
  if (ldv_state_variable_3 == 1) {
    __qlcnic_init_dcbnl_ops(qlcnic_83xx_dcb_ops_group0);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 7: ;
  if (ldv_state_variable_3 == 1) {
    __qlcnic_dcb_get_info(qlcnic_83xx_dcb_ops_group0);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  case 8: ;
  if (ldv_state_variable_3 == 1) {
    __qlcnic_dcb_query_hw_capability(qlcnic_83xx_dcb_ops_group0, ldvarg225);
    ldv_state_variable_3 = 1;
  } else {
  }
  goto ldv_51407;
  default:
  ldv_stop();
  }
  ldv_51407: ;
  return;
}
}
void ldv_main_exported_2(void)
{
  char *ldvarg56 ;
  void *tmp ;
  u8 ldvarg55 ;
  u8 tmp___0 ;
  char *ldvarg54 ;
  void *tmp___1 ;
  void *ldvarg57 ;
  void *tmp___2 ;
  int tmp___3 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg56 = (char *)tmp;
  tmp___0 = __VERIFIER_nondet_u8();
  ldvarg55 = tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg54 = (char *)tmp___1;
  tmp___2 = ldv_zalloc(1UL);
  ldvarg57 = tmp___2;
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_2 == 1) {
    qlcnic_82xx_dcb_aen_handler(qlcnic_82xx_dcb_ops_group0, ldvarg57);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 1: ;
  if (ldv_state_variable_2 == 1) {
    qlcnic_82xx_dcb_get_hw_capability(qlcnic_82xx_dcb_ops_group0);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 2: ;
  if (ldv_state_variable_2 == 1) {
    __qlcnic_dcb_attach(qlcnic_82xx_dcb_ops_group0);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 3: ;
  if (ldv_state_variable_2 == 1) {
    __qlcnic_dcb_free(qlcnic_82xx_dcb_ops_group0);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 4: ;
  if (ldv_state_variable_2 == 1) {
    qlcnic_82xx_dcb_query_cee_param(qlcnic_82xx_dcb_ops_group0, ldvarg56, (int )ldvarg55);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 5: ;
  if (ldv_state_variable_2 == 1) {
    qlcnic_82xx_dcb_get_cee_cfg(qlcnic_82xx_dcb_ops_group0);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 6: ;
  if (ldv_state_variable_2 == 1) {
    __qlcnic_init_dcbnl_ops(qlcnic_82xx_dcb_ops_group0);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 7: ;
  if (ldv_state_variable_2 == 1) {
    __qlcnic_dcb_get_info(qlcnic_82xx_dcb_ops_group0);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  case 8: ;
  if (ldv_state_variable_2 == 1) {
    __qlcnic_dcb_query_hw_capability(qlcnic_82xx_dcb_ops_group0, ldvarg54);
    ldv_state_variable_2 = 1;
  } else {
  }
  goto ldv_51425;
  default:
  ldv_stop();
  }
  ldv_51425: ;
  return;
}
}
void *ldv_kmem_cache_alloc_614(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_620(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_622(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_624(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_625(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_626(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_627(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_628(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_629(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_630(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_631(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
__inline static void ldv_error(void);
int ldv_spin = 0;
void ldv_check_alloc_flags(gfp_t flags )
{
  {
  if (ldv_spin == 0 || ! (flags & 16U)) {
  } else {
    ldv_error();
  }
  return;
}
}
extern struct page___0 *ldv_some_page(void) ;
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags )
{
  struct page___0 *tmp ;
  {
  if (ldv_spin == 0 || ! (flags & 16U)) {
  } else {
    ldv_error();
  }
  tmp = ldv_some_page();
  return (tmp);
}
}
void ldv_check_alloc_nonatomic(void)
{
  {
  if (ldv_spin == 0) {
  } else {
    ldv_error();
  }
  return;
}
}
void ldv_spin_lock(void)
{
  {
  ldv_spin = 1;
  return;
}
}
void ldv_spin_unlock(void)
{
  {
  ldv_spin = 0;
  return;
}
}
int ldv_spin_trylock(void)
{
  int is_lock ;
  {
  is_lock = ldv_undef_int();
  if (is_lock) {
    return (0);
  } else {
    ldv_spin = 1;
    return (1);
  }
}
}
int __VERIFIER_nondet_int(void);
int ___ratelimit(struct ratelimit_state *arg0, const char *arg1) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct workqueue_struct *__alloc_workqueue_key(const char *arg0, unsigned int arg1, int arg2, struct lock_class_key *arg3, const char *arg4, ...) {
  return (struct workqueue_struct *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int __bitmap_weight(const unsigned long *arg0, int arg1) {
  return __VERIFIER_nondet_int();
}
void __const_udelay(unsigned long arg0) {
  return;
}
void __dev_kfree_skb_any(struct sk_buff *arg0, enum skb_free_reason arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int __dynamic_dev_dbg(struct _ddebug *arg0, const struct device *arg1, const char *arg2, ...) {
  return __VERIFIER_nondet_int();
}
void __init_waitqueue_head(wait_queue_head_t *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void __init_work(struct work_struct *arg0, int arg1) {
  return;
}
void __list_add(struct list_head *arg0, struct list_head *arg1, struct list_head *arg2) {
  return;
}
void __local_bh_disable_ip(unsigned long arg0, unsigned int arg1) {
  return;
}
void __local_bh_enable_ip(unsigned long arg0, unsigned int arg1) {
  return;
}
void __might_sleep(const char *arg0, int arg1, int arg2) {
  return;
}
void __mutex_init(struct mutex *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void __napi_schedule(struct napi_struct *arg0) {
  return;
}
void *external_alloc(void);
struct sk_buff *__netdev_alloc_skb(struct net_device *arg0, unsigned int arg1, gfp_t arg2) {
  return (struct sk_buff *)external_alloc();
}
void __netif_schedule(struct Qdisc *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int __pci_enable_wake(struct pci_dev *arg0, pci_power_t arg1, bool arg2, bool arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int __pci_register_driver(struct pci_driver *arg0, struct module *arg1, const char *arg2) {
  return __VERIFIER_nondet_int();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int __phys_addr(unsigned long arg0) {
  return __VERIFIER_nondet_ulong();
}
int __VERIFIER_nondet_int(void);
int __printk_ratelimit(const char *arg0) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
unsigned char *__pskb_pull_tail(struct sk_buff *arg0, int arg1) {
  return (unsigned char *)external_alloc();
}
void __raw_spin_lock_init(raw_spinlock_t *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void __rwlock_init(rwlock_t *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void __udelay(unsigned long arg0) {
  return;
}
void *external_alloc(void);
struct net_device *__vlan_find_dev_deep_rcu(struct net_device *arg0, __be16 arg1, u16 arg2) {
  return (struct net_device *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int _cond_resched() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int _dev_info(const struct device *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
void _raw_spin_lock(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_lock_bh(raw_spinlock_t *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int _raw_spin_trylock(raw_spinlock_t *arg0) {
  return __VERIFIER_nondet_int();
}
void _raw_spin_unlock(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_unlock_bh(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_unlock_irqrestore(raw_spinlock_t *arg0, unsigned long arg1) {
  return;
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int _raw_write_lock_irqsave(rwlock_t *arg0) {
  return __VERIFIER_nondet_ulong();
}
void _raw_write_unlock_irqrestore(rwlock_t *arg0, unsigned long arg1) {
  return;
}
void *external_alloc(void);
struct net_device *alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2) {
  return (struct net_device *)external_alloc();
}
bool __VERIFIER_nondet_bool(void);
bool cancel_delayed_work_sync(struct delayed_work *arg0) {
  return __VERIFIER_nondet_bool();
}
bool __VERIFIER_nondet_bool(void);
bool cancel_work_sync(struct work_struct *arg0) {
  return __VERIFIER_nondet_bool();
}
void complete(struct completion *arg0) {
  return;
}
void consume_skb(struct sk_buff *arg0) {
  return;
}
unsigned char __VERIFIER_nondet_uchar(void);
u8 dcb_getapp(struct net_device *arg0, struct dcb_app *arg1) {
  return __VERIFIER_nondet_uchar();
}
int __VERIFIER_nondet_int(void);
int dcb_setapp(struct net_device *arg0, struct dcb_app *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dcbnl_cee_notify(struct net_device *arg0, int arg1, int arg2, u32 arg3, u32 arg4) {
  return __VERIFIER_nondet_int();
}
void debug_dma_alloc_coherent(struct device *arg0, size_t arg1, dma_addr_t arg2, void *arg3) {
  return;
}
void debug_dma_free_coherent(struct device *arg0, size_t arg1, void *arg2, dma_addr_t arg3) {
  return;
}
void debug_dma_map_page(struct device *arg0, struct page *arg1, size_t arg2, size_t arg3, int arg4, dma_addr_t arg5, bool arg6) {
  return;
}
void debug_dma_mapping_error(struct device *arg0, dma_addr_t arg1) {
  return;
}
void debug_dma_unmap_page(struct device *arg0, dma_addr_t arg1, size_t arg2, int arg3, bool arg4) {
  return;
}
int __VERIFIER_nondet_int(void);
int debug_lockdep_rcu_enabled() {
  return __VERIFIER_nondet_int();
}
void destroy_workqueue(struct workqueue_struct *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int dev_err(const struct device *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dev_mc_add_excl(struct net_device *arg0, const unsigned char *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dev_mc_del(struct net_device *arg0, const unsigned char *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dev_uc_add_excl(struct net_device *arg0, const unsigned char *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dev_uc_del(struct net_device *arg0, const unsigned char *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dev_warn(const struct device *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int device_create_bin_file(struct device *arg0, const struct bin_attribute *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int device_create_file(struct device *arg0, const struct device_attribute *arg1) {
  return __VERIFIER_nondet_int();
}
void device_remove_bin_file(struct device *arg0, const struct bin_attribute *arg1) {
  return;
}
void device_remove_file(struct device *arg0, const struct device_attribute *arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int dma_set_mask(struct device *arg0, u64 arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dma_supported(struct device *arg0, u64 arg1) {
  return __VERIFIER_nondet_int();
}
void dump_stack() {
  return;
}
unsigned short __VERIFIER_nondet_ushort(void);
__be16 eth_type_trans(struct sk_buff *arg0, struct net_device *arg1) {
  return __VERIFIER_nondet_ushort();
}
int __VERIFIER_nondet_int(void);
int eth_validate_addr(struct net_device *arg0) {
  return __VERIFIER_nondet_int();
}
unsigned int __VERIFIER_nondet_uint(void);
u32 ethtool_op_get_link(struct net_device *arg0) {
  return __VERIFIER_nondet_uint();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int find_first_bit(const unsigned long *arg0, unsigned long arg1) {
  return __VERIFIER_nondet_ulong();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int find_next_bit(const unsigned long *arg0, unsigned long arg1, unsigned long arg2) {
  return __VERIFIER_nondet_ulong();
}
void flush_workqueue(struct workqueue_struct *arg0) {
  return;
}
void free_irq(unsigned int arg0, void *arg1) {
  return;
}
void free_netdev(struct net_device *arg0) {
  return;
}
void get_random_bytes(void *arg0, int arg1) {
  return;
}
void *external_alloc(void);
struct device *hwmon_device_register_with_groups(struct device *arg0, const char *arg1, void *arg2, const struct attribute_group **arg3) {
  return (struct device *)external_alloc();
}
void hwmon_device_unregister(struct device *arg0) {
  return;
}
void in_dev_finish_destroy(struct in_device *arg0) {
  return;
}
void init_timer_key(struct timer_list *arg0, unsigned int arg1, const char *arg2, struct lock_class_key *arg3) {
  return;
}
void iounmap(volatile void *arg0) {
  return;
}
void *external_alloc(void);
void *kmem_cache_alloc(struct kmem_cache *arg0, gfp_t arg1) {
  return (void *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int kobject_uevent_env(struct kobject *arg0, enum kobject_action arg1, char **arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int kstrtoull(const char *arg0, unsigned int arg1, unsigned long long *arg2) {
  return __VERIFIER_nondet_int();
}
void ldv_check_final_state() {
  return;
}
void ldv_initialize() {
  return;
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_init_32() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_init_33() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_stop_32() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_uninit_32() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_uninit_33() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_10() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_11() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_12() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_13() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_14() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_15() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_16() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_17() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_18() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_26() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_29() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_31() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_4() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_5() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_7() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_probe_8() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_10() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_11() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_12() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_13() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_14() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_15() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_16() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_17() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_18() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_26() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_29() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_31() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_4() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_5() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_7() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_8() {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct page___0 *ldv_some_page() {
  return (struct page___0 *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int ldv_suspend_26() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_suspend_31() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_suspend_4() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_suspend_7() {
  return __VERIFIER_nondet_int();
}
void list_del(struct list_head *arg0) {
  return;
}
void lock_acquire(struct lockdep_map *arg0, unsigned int arg1, int arg2, int arg3, int arg4, struct lockdep_map *arg5, unsigned long arg6) {
  return;
}
int __VERIFIER_nondet_int(void);
int lock_is_held(struct lockdep_map *arg0) {
  return __VERIFIER_nondet_int();
}
void lock_release(struct lockdep_map *arg0, int arg1, unsigned long arg2) {
  return;
}
void lockdep_init_map(struct lockdep_map *arg0, const char *arg1, struct lock_class_key *arg2, int arg3) {
  return;
}
void lockdep_rcu_suspicious(const char *arg0, const int arg1, const char *arg2) {
  return;
}
void msleep(unsigned int arg0) {
  return;
}
void mutex_lock_nested(struct mutex *arg0, unsigned int arg1) {
  return;
}
void mutex_unlock(struct mutex *arg0) {
  return;
}
void napi_complete(struct napi_struct *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
gro_result_t napi_gro_receive(struct napi_struct *arg0, struct sk_buff *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ndo_dflt_fdb_add(struct ndmsg *arg0, struct nlattr **arg1, struct net_device *arg2, const unsigned char *arg3, u16 arg4) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ndo_dflt_fdb_del(struct ndmsg *arg0, struct nlattr **arg1, struct net_device *arg2, const unsigned char *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ndo_dflt_fdb_dump(struct sk_buff *arg0, struct netlink_callback *arg1, struct net_device *arg2, int arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int netdev_err(const struct net_device *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int netdev_info(const struct net_device *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
void netdev_update_features(struct net_device *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int netdev_warn(const struct net_device *arg0, const char *arg1, ...) {
  return __VERIFIER_nondet_int();
}
void netif_carrier_off(struct net_device *arg0) {
  return;
}
void netif_carrier_on(struct net_device *arg0) {
  return;
}
void netif_device_attach(struct net_device *arg0) {
  return;
}
void netif_device_detach(struct net_device *arg0) {
  return;
}
void netif_napi_add(struct net_device *arg0, struct napi_struct *arg1, int (*arg2)(struct napi_struct *, int), int arg3) {
  return;
}
void netif_napi_del(struct napi_struct *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int netif_receive_skb(struct sk_buff *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int netif_set_real_num_rx_queues(struct net_device *arg0, unsigned int arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int netif_set_real_num_tx_queues(struct net_device *arg0, unsigned int arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_read_config_dword(struct pci_bus *arg0, unsigned int arg1, int arg2, u32 *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_bus_read_config_word(struct pci_bus *arg0, unsigned int arg1, int arg2, u16 *arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
pci_power_t pci_choose_state(struct pci_dev *arg0, pm_message_t arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_cleanup_aer_uncorrect_error_status(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
void pci_dev_put(struct pci_dev *arg0) {
  return;
}
void pci_disable_device(struct pci_dev *arg0) {
  return;
}
void pci_disable_msi(struct pci_dev *arg0) {
  return;
}
void pci_disable_msix(struct pci_dev *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_disable_pcie_error_reporting(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
void pci_disable_sriov(struct pci_dev *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_enable_device(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_enable_msi_range(struct pci_dev *arg0, int arg1, int arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_enable_msix_range(struct pci_dev *arg0, struct msix_entry *arg1, int arg2, int arg3) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_enable_pcie_error_reporting(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_enable_sriov(struct pci_dev *arg0, int arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_find_ext_capability(struct pci_dev *arg0, int arg1) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct pci_dev *pci_get_domain_bus_and_slot(int arg0, unsigned int arg1, unsigned int arg2) {
  return (struct pci_dev *)external_alloc();
}
void *external_alloc(void);
void *pci_ioremap_bar(struct pci_dev *arg0, int arg1) {
  return (void *)external_alloc();
}
void pci_release_regions(struct pci_dev *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_request_regions(struct pci_dev *arg0, const char *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pci_reset_function(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
void pci_restore_state(struct pci_dev *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_save_state(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
void pci_set_master(struct pci_dev *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_set_power_state(struct pci_dev *arg0, pci_power_t arg1) {
  return __VERIFIER_nondet_int();
}
void pci_unregister_driver(struct pci_driver *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int pci_vfs_assigned(struct pci_dev *arg0) {
  return __VERIFIER_nondet_int();
}
void print_hex_dump(const char *arg0, const char *arg1, int arg2, int arg3, int arg4, const void *arg5, size_t arg6, bool arg7) {
  return;
}
int __VERIFIER_nondet_int(void);
int printk(const char *arg0, ...) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pskb_expand_head(struct sk_buff *arg0, int arg1, int arg2, gfp_t arg3) {
  return __VERIFIER_nondet_int();
}
unsigned int __VERIFIER_nondet_uint(void);
u32 qlcnic_82xx_get_cap_size(void *arg0, int arg1) {
  return __VERIFIER_nondet_uint();
}
unsigned int __VERIFIER_nondet_uint(void);
u32 qlcnic_82xx_get_saved_state(void *arg0, u32 arg1) {
  return __VERIFIER_nondet_uint();
}
void qlcnic_82xx_set_saved_state(void *arg0, u32 arg1, u32 arg2) {
  return;
}
unsigned int __VERIFIER_nondet_uint(void);
u32 qlcnic_83xx_get_cap_size(void *arg0, int arg1) {
  return __VERIFIER_nondet_uint();
}
int __VERIFIER_nondet_int(void);
int qlcnic_83xx_get_regs_len(struct qlcnic_adapter *arg0) {
  return __VERIFIER_nondet_int();
}
unsigned int __VERIFIER_nondet_uint(void);
u32 qlcnic_83xx_get_saved_state(void *arg0, u32 arg1) {
  return __VERIFIER_nondet_uint();
}
void qlcnic_83xx_set_saved_state(void *arg0, u32 arg1, u32 arg2) {
  return;
}
void qlcnic_update_cmd_producer(struct qlcnic_host_tx_ring *arg0) {
  return;
}
bool __VERIFIER_nondet_bool(void);
bool queue_delayed_work_on(int arg0, struct workqueue_struct *arg1, struct delayed_work *arg2, unsigned long arg3) {
  return __VERIFIER_nondet_bool();
}
bool __VERIFIER_nondet_bool(void);
bool queue_work_on(int arg0, struct workqueue_struct *arg1, struct work_struct *arg2) {
  return __VERIFIER_nondet_bool();
}
bool __VERIFIER_nondet_bool(void);
bool rcu_is_watching() {
  return __VERIFIER_nondet_bool();
}
bool __VERIFIER_nondet_bool(void);
bool rcu_lockdep_current_cpu_online() {
  return __VERIFIER_nondet_bool();
}
int __VERIFIER_nondet_int(void);
int register_inetaddr_notifier(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int register_netdev(struct net_device *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int register_netdevice_notifier(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
void release_firmware(const struct firmware *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int request_firmware(const struct firmware **arg0, const char *arg1, struct device *arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int request_threaded_irq(unsigned int arg0, irqreturn_t (*arg1)(int, void *), irqreturn_t (*arg2)(int, void *), unsigned long arg3, const char *arg4, void *arg5) {
  return __VERIFIER_nondet_int();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int round_jiffies_relative(unsigned long arg0) {
  return __VERIFIER_nondet_ulong();
}
void rtnl_lock() {
  return;
}
void rtnl_unlock() {
  return;
}
void *external_alloc(void);
struct sk_buff *skb_clone(struct sk_buff *arg0, gfp_t arg1) {
  return (struct sk_buff *)external_alloc();
}
void *external_alloc(void);
struct sk_buff *skb_copy(const struct sk_buff *arg0, gfp_t arg1) {
  return (struct sk_buff *)external_alloc();
}
void *external_alloc(void);
unsigned char *skb_pull(struct sk_buff *arg0, unsigned int arg1) {
  return (unsigned char *)external_alloc();
}
void *external_alloc(void);
unsigned char *skb_put(struct sk_buff *arg0, unsigned int arg1) {
  return (unsigned char *)external_alloc();
}
unsigned long __VERIFIER_nondet_ulong(void);
size_t strlcpy(char *arg0, const char *arg1, size_t arg2) {
  return __VERIFIER_nondet_ulong();
}
void synchronize_irq(unsigned int arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int sysfs_create_bin_file(struct kobject *arg0, const struct bin_attribute *arg1) {
  return __VERIFIER_nondet_int();
}
void sysfs_remove_bin_file(struct kobject *arg0, const struct bin_attribute *arg1) {
  return;
}
int __VERIFIER_nondet_int(void);
int unregister_inetaddr_notifier(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
void unregister_netdev(struct net_device *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int unregister_netdevice_notifier(struct notifier_block *arg0) {
  return __VERIFIER_nondet_int();
}
void usleep_range(unsigned long arg0, unsigned long arg1) {
  return;
}
void vfree(const void *arg0) {
  return;
}
void *external_alloc(void);
struct net_device *vlan_dev_real_dev(const struct net_device *arg0) {
  return (struct net_device *)external_alloc();
}
void vxlan_get_rx_port(struct net_device *arg0) {
  return;
}
void *external_alloc(void);
void *vzalloc(unsigned long arg0) {
  return (void *)external_alloc();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int wait_for_completion_timeout(struct completion *arg0, unsigned long arg1) {
  return __VERIFIER_nondet_ulong();
}
void warn_slowpath_null(const char *arg0, const int arg1) {
  return;
}
void *__VERIFIER_external_alloc(void);
void *external_alloc(void) {
  return __VERIFIER_external_alloc();
}
void free(void *);
void kfree(void const *p) {
  free((void *)p);
}
