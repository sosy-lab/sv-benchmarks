extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef long __kernel_off_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef unsigned short umode_t;
typedef unsigned char __u8;
typedef unsigned int __u32;
typedef unsigned long long u64;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_off_t off_t;
typedef long long loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef unsigned int gfp_t;
typedef unsigned long sector_t;
struct timer_list {
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   short __ddv_active ;
   short __ddv_init ;
};
struct __anonstruct_spinlock_t_1 {
   int init ;
   int locked ;
};
typedef struct __anonstruct_spinlock_t_1 spinlock_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct __wait_queue_head {
   int number_process_waiting ;
   int wakeup ;
   int init ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __pthread_mutex_t_struct {
   _Bool locked ;
};
struct __pthread_mutexattr_t_struct {
   int dummy ;
};
typedef struct __pthread_mutex_t_struct pthread_mutex_t;
typedef struct __pthread_mutexattr_t_struct pthread_mutexattr_t;
typedef int atomic_t;
struct page;
struct module {
   int something ;
};
struct file_operations;
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations *fops ;
};
struct watchdog_info {
   __u32 options ;
   __u32 firmware_version ;
   __u8 identity[32] ;
};
struct inode;
struct dentry {
   struct inode *d_inode ;
};
struct semaphore {
   int init ;
   int locked ;
};
struct hd_geometry;
struct hd_geometry;
struct iovec;
struct iovec;
struct poll_table_struct;
struct poll_table_struct;
struct vm_area_struct;
struct vm_area_struct;
struct page;
struct address_space {
   struct inode *host ;
};
struct file {
   struct dentry *f_dentry ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   void *private_data ;
   struct address_space *f_mapping ;
};
struct gendisk;
struct block_device {
   struct inode *bd_inode ;
   struct gendisk *bd_disk ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
};
struct cdev;
struct inode {
   umode_t i_mode ;
   struct block_device *i_bdev ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct cdev *i_cdev ;
};
struct __anonstruct_read_descriptor_t_12 {
   size_t written ;
   size_t count ;
};
typedef struct __anonstruct_read_descriptor_t_12 read_descriptor_t;
struct file_lock {
   int something ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   int (*open_exec)(struct inode * ) ;
};
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , unsigned long * ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   struct module *owner ;
};
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block *self , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct pt_regs;
struct pt_regs;
struct cdev {
   struct module *owner ;
   struct file_operations *ops ;
   dev_t dev ;
   unsigned int count ;
};
struct ddv_cdev {
   struct cdev *cdevp ;
   struct file filp ;
   struct inode inode ;
   int open ;
};
struct module;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct device {
   void *driver_data ;
   void (*release)(struct device *dev ) ;
};
struct request_queue;
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   char devfs_name[64] ;
};
struct work_struct {
   unsigned long pending ;
   void (*func)(void * ) ;
   void *data ;
   int init ;
};
struct mutex {
   int locked ;
   int init ;
};
struct page {
   int something ;
};
struct pt_regs {
   int something ;
};
typedef int irqreturn_t;
struct tasklet_struct {
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
   int init ;
};
struct backing_dev_info {
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
};
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
struct bio;
struct bio;
typedef int bio_end_io_t(struct bio * , unsigned int  , int  );
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned short bi_phys_segments ;
   unsigned int bi_size ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
};
struct request;
struct request_queue;
typedef struct request_queue request_queue_t;
typedef void request_fn_proc(request_queue_t *q );
typedef int make_request_fn(request_queue_t *q , struct bio *bio );
typedef void unplug_fn(request_queue_t * );
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_FLUSH = 7,
    REQ_TYPE_SPECIAL = 8,
    REQ_TYPE_LINUX_BLOCK = 9,
    REQ_TYPE_ATA_CMD = 10,
    REQ_TYPE_ATA_TASK = 11,
    REQ_TYPE_ATA_TASKFILE = 12,
    REQ_TYPE_ATA_PC = 13
} ;
struct request_queue {
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   unplug_fn *unplug_fn ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   spinlock_t *queue_lock ;
   unsigned short hardsect_size ;
   int __ddv_genhd_no ;
   int __ddv_queue_alive ;
};
struct request {
   struct list_head queuelist ;
   struct list_head donelist ;
   request_queue_t *q ;
   unsigned long flags ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   struct bio *bio ;
   void *completion_data ;
   struct gendisk *rq_disk ;
   sector_t sector ;
   unsigned long nr_sectors ;
   unsigned int current_nr_sectors ;
   char *buffer ;
   int errors ;
   unsigned short nr_phys_segments ;
   unsigned char cmd[16] ;
};
struct ddv_genhd {
   struct gendisk *gd ;
   struct inode inode ;
   struct file file ;
   struct request current_request ;
   int requests_open ;
};
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
typedef int pci_power_t;
struct pci_bus;
struct pci_dev {
   struct pci_bus *bus ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   u64 dma_mask ;
   struct device dev ;
   unsigned int irq ;
   struct resource resource[12] ;
};
struct pci_bus {
   unsigned char number ;
};
struct pci_driver {
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
};
struct ddv_pci_driver {
   struct pci_driver *pci_driver ;
   struct pci_dev pci_dev ;
   unsigned int no_pci_device_id ;
   int dev_initialized ;
};
struct registered_irq {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   void *dev_id ;
};
struct ddv_tasklet {
   struct tasklet_struct *tasklet ;
   unsigned short is_running ;
};
struct ddv_timer {
   struct timer_list *timer ;
};
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
struct proc_dir_entry {
   int something ;
};
struct file;
struct dentry;
struct inode;
typedef unsigned char cc_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
struct tty_struct;
struct tty_struct;
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   unsigned long flags ;
   int count ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned int receive_room ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   void *disc_data ;
   void *driver_data ;
   unsigned char closing : 1 ;
};
struct ddv_tty_driver {
   struct tty_driver driver ;
   unsigned short allocated ;
   unsigned short registered ;
};
extern void __VERIFIER_assume(int) ;
void __VERIFIER_assert(int phi , char *txt ) ;
int current_execution_context  ;
__inline static int assert_context_process(void) 
{ 

  {
  return (0);
}
}
int (*_ddv_module_init)(void)  ;
void (*_ddv_module_exit)(void)  ;
int call_ddv(void) ;
unsigned long jiffies  ;
__inline void init_timer(struct timer_list *timer ) ;
__inline void add_timer_on(struct timer_list *timer , int cpu ) ;
__inline void add_timer(struct timer_list *timer ) ;
__inline int del_timer(struct timer_list *timer ) ;
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) ;
__inline void spin_lock_init(spinlock_t *lock ) ;
__inline void spin_lock(spinlock_t *lock ) ;
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) ;
__inline void spin_lock_irq(spinlock_t *lock ) ;
__inline void spin_lock_bh(spinlock_t *lock ) ;
__inline void spin_unlock(spinlock_t *lock ) ;
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
__inline void spin_unlock_irq(spinlock_t *lock ) ;
__inline void spin_unlock_bh(spinlock_t *lock ) ;
__inline void init_waitqueue_head(wait_queue_head_t *q ) ;
__inline void wake_up(wait_queue_head_t *q ) ;
__inline void wake_up_all(wait_queue_head_t *q ) ;
__inline void wake_up_interruptible(wait_queue_head_t *q ) ;
__inline void sleep_on(wait_queue_head_t *q ) ;
__inline void interruptible_sleep_on(wait_queue_head_t *q ) ;
__inline extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__mutex_attr ) 
{ pthread_mutex_t i ;

  {
  i.locked = (_Bool)0;
  *__mutex = i;
  return (0);
}
}
__inline extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) 
{ 

  {
  return (0);
}
}
void __VERIFIER_atomic_begin(void) ;
void __VERIFIER_atomic_end(void) ;
__inline extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) 
{ _Bool __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
  __VERIFIER_atomic_begin();
  __cil_tmp2 = __mutex->locked;
  __cil_tmp3 = ! __cil_tmp2;
  __VERIFIER_assume(__cil_tmp3);
  __mutex->locked = (_Bool)1;
  __VERIFIER_atomic_end();
  }
  return (0);
}
}
__inline extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) 
{ 

  {
  __mutex->locked = (_Bool)0;
  return (0);
}
}
extern void *malloc(size_t size ) ;
short __VERIFIER_nondet_short(void) ;
unsigned short __VERIFIER_nondet_ushort(void) ;
int __VERIFIER_nondet_int(void) ;
unsigned int __VERIFIER_nondet_uint(void) ;
long __VERIFIER_nondet_long(void) ;
unsigned long __VERIFIER_nondet_ulong(void) ;
char __VERIFIER_nondet_char(void) ;
unsigned char __VERIFIER_nondet_uchar(void) ;
unsigned int __VERIFIER_nondet_unsigned(void) ;
loff_t __VERIFIER_nondet_loff_t(void) ;
size_t __VERIFIER_nondet_size_t(void) ;
sector_t __VERIFIER_nondet_sector_t(void) ;
char *__VERIFIER_nondet_pchar(void) ;
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
__inline unsigned long __get_free_page(gfp_t gfp_mask ) ;
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) ;
__inline struct page *alloc_page(gfp_t gfp_mask ) ;
void kfree(void const   *addr ) ;
void *kmalloc(size_t size , gfp_t flags ) ;
void *kzalloc(size_t size , gfp_t flags ) ;
int test_and_set_bit(int nr , unsigned long *addr ) ;
void clear_bit(int nr , unsigned long volatile   *addr ) ;
void schedule(void) ;
long schedule_timeout(long timeout ) ;
int printk(char const   *fmt  , ...) ;
void __module_get(struct module *module ) ;
int misc_register(struct miscdevice *misc ) ;
int misc_deregister(struct miscdevice *misc ) ;
__inline void sema_init(struct semaphore *sem , int val ) ;
__inline void init_MUTEX(struct semaphore *sem ) ;
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) ;
__inline void down(struct semaphore *sem ) ;
__inline int down_interruptible(struct semaphore *sem ) ;
__inline int down_trylock(struct semaphore *sem ) ;
__inline void up(struct semaphore *sem ) ;
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) ;
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) ;
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) ;
__inline int unregister_chrdev(unsigned int major , char const   *name ) ;
int register_blkdev(unsigned int major , char const   *name ) ;
int unregister_blkdev(unsigned int major , char const   *name ) ;
loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
int nonseekable_open(struct inode *inode , struct file *filp ) ;
__inline struct resource *request_region(unsigned long start , unsigned long len ,
                                         char const   *name ) ;
__inline void release_region(unsigned long start , unsigned long len ) ;
struct resource *request_mem_region(unsigned long start , unsigned long len , char const   *name ) ;
void release_mem_region(unsigned long start , unsigned long len ) ;
int register_reboot_notifier(struct notifier_block *dummy ) ;
int unregister_reboot_notifier(struct notifier_block *dummy ) ;
__inline unsigned char inb(unsigned int port ) ;
__inline void outb(unsigned char byte , unsigned int port ) ;
__inline unsigned short inw(unsigned int port ) ;
__inline void outw(unsigned short word , unsigned int port ) ;
__inline unsigned int inl(unsigned int port ) ;
__inline void outl(unsigned int doubleword , unsigned int port ) ;
__inline unsigned char inb_p(unsigned int port ) ;
__inline void outb_p(unsigned char byte , unsigned int port ) ;
__inline unsigned short inw_p(unsigned int port ) ;
__inline void outw_p(unsigned short word , unsigned int port ) ;
__inline unsigned int inl_p(unsigned int port ) ;
__inline void outl_p(unsigned int doubleword , unsigned int port ) ;
__inline int __get_user(int size , void *ptr ) ;
__inline int get_user(int size , void *ptr ) ;
__inline int __put_user(int size , void *ptr ) ;
__inline int put_user(int size , void *ptr ) ;
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) ;
static unsigned short zf_readw(unsigned char port ) 
{ unsigned short tmp ;

  {
  {
  outb(port, 536U);
  tmp = inw(538U);
  }
  return (tmp);
}
}
char _ddv_module_author[44]  = 
  {      (char )'F',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'n',      (char )'d',      (char )'o', 
        (char )' ',      (char )'F',      (char )'u',      (char )'g', 
        (char )'a',      (char )'n',      (char )'t',      (char )'i', 
        (char )' ',      (char )'<',      (char )'f',      (char )'u', 
        (char )'g',      (char )'a',      (char )'n',      (char )'t', 
        (char )'i',      (char )'@',      (char )'c',      (char )'o', 
        (char )'n',      (char )'e',      (char )'c',      (char )'t', 
        (char )'i',      (char )'v',      (char )'a',      (char )'.', 
        (char )'c',      (char )'o',      (char )'m',      (char )'.', 
        (char )'b',      (char )'r',      (char )'>',      (char )'\000'};
char _ddv_module_description[31]  = 
  {      (char )'M',      (char )'a',      (char )'c',      (char )'h', 
        (char )'Z',      (char )' ',      (char )'Z',      (char )'F', 
        (char )'-',      (char )'L',      (char )'o',      (char )'g', 
        (char )'i',      (char )'c',      (char )' ',      (char )'W', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )'d',      (char )'o',      (char )'g',      (char )' ', 
        (char )'d',      (char )'r',      (char )'i',      (char )'v', 
        (char )'e',      (char )'r',      (char )'\000'};
char _ddv_module_license[4]  = {      (char )'G',      (char )'P',      (char )'L',      (char )'\000'};
static int nowayout  =    0;
char _ddv_module_param_nowayout[75]  = 
  {      (char )'W',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )'d',      (char )'o',      (char )'g', 
        (char )' ',      (char )'c',      (char )'a',      (char )'n', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'s', 
        (char )'t',      (char )'o',      (char )'p',      (char )'p', 
        (char )'e',      (char )'d',      (char )' ',      (char )'o', 
        (char )'n',      (char )'c',      (char )'e',      (char )' ', 
        (char )'s',      (char )'t',      (char )'a',      (char )'r', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'(',      (char )'d',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )'=',      (char )'C',      (char )'O',      (char )'N', 
        (char )'F',      (char )'I',      (char )'G',      (char )'_', 
        (char )'W',      (char )'A',      (char )'T',      (char )'C', 
        (char )'H',      (char )'D',      (char )'O',      (char )'G', 
        (char )'_',      (char )'N',      (char )'O',      (char )'W', 
        (char )'A',      (char )'Y',      (char )'O',      (char )'U', 
        (char )'T',      (char )')',      (char )'\000'};
static struct watchdog_info zf_info  =    {(__u32 )33024, (__u32 )1, {(__u8 )'Z', (__u8 )'F', (__u8 )'-', (__u8 )'L', (__u8 )'o',
                               (__u8 )'g', (__u8 )'i', (__u8 )'c', (__u8 )' ', (__u8 )'w',
                               (__u8 )'a', (__u8 )'t', (__u8 )'c', (__u8 )'h', (__u8 )'d',
                               (__u8 )'o', (__u8 )'g', (__u8 )'\000', (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0}};
static int action  =    0;
char _ddv_module_param_action[73]  = 
  {      (char )'a',      (char )'f',      (char )'t',      (char )'e', 
        (char )'r',      (char )' ',      (char )'w',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )'d', 
        (char )'o',      (char )'g',      (char )' ',      (char )'r', 
        (char )'e',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )',',      (char )' ',      (char )'g', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )':', 
        (char )' ',      (char )'0',      (char )' ',      (char )'=', 
        (char )' ',      (char )'R',      (char )'E',      (char )'S', 
        (char )'E',      (char )'T',      (char )'(',      (char )'*', 
        (char )')',      (char )' ',      (char )' ',      (char )'1', 
        (char )' ',      (char )'=',      (char )' ',      (char )'S', 
        (char )'M',      (char )'I',      (char )' ',      (char )' ', 
        (char )'2',      (char )' ',      (char )'=',      (char )' ', 
        (char )'N',      (char )'M',      (char )'I',      (char )' ', 
        (char )' ',      (char )'3',      (char )' ',      (char )'=', 
        (char )' ',      (char )'S',      (char )'C',      (char )'I', 
        (char )'\000'};
static int zf_action  =    2048;
static unsigned long zf_is_open  ;
static char zf_expect_close  ;
static spinlock_t zf_lock  ;
static spinlock_t zf_port_lock  ;
static struct timer_list zf_timer  ;
static unsigned long next_heartbeat  =    0UL;
__inline static void zf_set_status(unsigned char new ) 
{ 

  {
  {
  outb((unsigned char)18, 536U);
  outb(new, 537U);
  }
  return;
}
}
__inline static unsigned short zf_get_control(void) 
{ unsigned short tmp ;

  {
  {
  tmp = zf_readw((unsigned char)16);
  }
  return (tmp);
}
}
__inline static void zf_set_control(unsigned short new ) 
{ 

  {
  {
  outb((unsigned char)16, 536U);
  outw(new, 538U);
  }
  return;
}
}
__inline static void zf_set_timer(unsigned short new , unsigned char n ) 
{ int tmp ;
  int __cil_tmp4 ;
  unsigned char __cil_tmp5 ;

  {
  if ((int )n == 0) {
    goto switch_0_0;
  } else {
    if ((int )n == 1) {
      goto switch_0_1;
    } else {
      {
      goto switch_0_default;
      if (0) {
        switch_0_0: /* CIL Label */ 
        {
        outb((unsigned char)12, 536U);
        outw(new, 538U);
        }
        switch_0_1: /* CIL Label */ 
        {
        outb((unsigned char)14, 536U);
        }
        {
        __cil_tmp4 = (int )new;
        if (__cil_tmp4 > 255) {
          tmp = 255;
        } else {
          tmp = (int )new;
        }
        }
        {
        __cil_tmp5 = (unsigned char )tmp;
        outb(__cil_tmp5, 537U);
        }
        switch_0_default: /* CIL Label */ ;
        return;
      } else {
        switch_0_break: /* CIL Label */ ;
      }
      }
    }
  }
}
}
static void zf_timer_off(void) 
{ unsigned int ctrl_reg ;
  unsigned long flags ;
  unsigned short tmp ;
  unsigned short __cil_tmp4 ;

  {
  {
  ctrl_reg = 0U;
  del_timer(& zf_timer);
  spin_lock_irqsave(& zf_port_lock, flags);
  tmp = zf_get_control();
  ctrl_reg = (unsigned int )tmp;
  ctrl_reg = ctrl_reg | 3U;
  ctrl_reg = ctrl_reg & 4294967292U;
  __cil_tmp4 = (unsigned short )ctrl_reg;
  zf_set_control(__cil_tmp4);
  spin_unlock_irqrestore(& zf_port_lock, flags);
  printk("<6>machzwd: Watchdog timer is now disabled\n");
  }
  return;
}
}
static void zf_timer_on(void) 
{ unsigned int ctrl_reg ;
  unsigned long flags ;
  unsigned short tmp ;
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned short __cil_tmp6 ;

  {
  {
  ctrl_reg = 0U;
  spin_lock_irqsave(& zf_port_lock, flags);
  outb((unsigned char)15, 536U);
  outb((unsigned char)255, 537U);
  zf_set_timer((unsigned short)65535, (unsigned char)0);
  next_heartbeat = jiffies + 1000UL;
  zf_timer.expires = jiffies + 50UL;
  add_timer(& zf_timer);
  tmp = zf_get_control();
  ctrl_reg = (unsigned int )tmp;
  __cil_tmp4 = 1 | zf_action;
  __cil_tmp5 = (unsigned int )__cil_tmp4;
  ctrl_reg = ctrl_reg | __cil_tmp5;
  __cil_tmp6 = (unsigned short )ctrl_reg;
  zf_set_control(__cil_tmp6);
  spin_unlock_irqrestore(& zf_port_lock, flags);
  printk("<6>machzwd: Watchdog timer is now enabled\n");
  }
  return;
}
}
static void zf_ping(unsigned long data ) 
{ unsigned int ctrl_reg ;
  unsigned long flags ;
  unsigned short tmp ;
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  unsigned short __cil_tmp8 ;
  unsigned short __cil_tmp9 ;

  {
  {
  ctrl_reg = 0U;
  outb((unsigned char)14, 536U);
  outb((unsigned char)255, 537U);
  }
  {
  __cil_tmp5 = (long )next_heartbeat;
  __cil_tmp6 = (long )jiffies;
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
  if (__cil_tmp7 < 0L) {
    {
    spin_lock_irqsave(& zf_port_lock, flags);
    tmp = zf_get_control();
    ctrl_reg = (unsigned int )tmp;
    ctrl_reg = ctrl_reg | 16U;
    __cil_tmp8 = (unsigned short )ctrl_reg;
    zf_set_control(__cil_tmp8);
    ctrl_reg = ctrl_reg & 4294967279U;
    __cil_tmp9 = (unsigned short )ctrl_reg;
    zf_set_control(__cil_tmp9);
    spin_unlock_irqrestore(& zf_port_lock, flags);
    zf_timer.expires = jiffies + 50UL;
    add_timer(& zf_timer);
    }
  } else {
    {
    printk("<2>machzwd: I will reset your machine\n");
    }
  }
  }
  return;
}
}
static ssize_t zf_write(struct file *file , char const   *buf , size_t count , loff_t *ppos ) 
{ size_t ofs ;
  char c ;
  int tmp ;
  int __cil_tmp8 ;
  char const   *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
  if (count) {
    if (! nowayout) {
      zf_expect_close = (char)0;
      ofs = 0U;
      {
      while (1) {
        while_1_continue: /* CIL Label */ ;
        if (ofs != count) {

        } else {
          goto while_1_break;
        }
        {
        __cil_tmp8 = (int )c;
        __cil_tmp9 = buf + ofs;
        __cil_tmp10 = (void *)__cil_tmp9;
        tmp = get_user(__cil_tmp8, __cil_tmp10);
        }
        if (tmp) {
          return (-14);
        } else {

        }
        {
        __cil_tmp11 = (int )c;
        if (__cil_tmp11 == 86) {
          zf_expect_close = (char)42;
        } else {

        }
        }
        ofs = ofs + 1U;
      }
      while_1_break: /* CIL Label */ ;
      }
    } else {

    }
    next_heartbeat = jiffies + 1000UL;
  } else {

  }
  return ((int )count);
}
}
static int zf_ioctl(struct inode *inode , struct file *file , unsigned int cmd , unsigned long arg ) 
{ void *argp ;
  int *p ;
  unsigned long tmp ;
  int tmp___0 ;
  void const   *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
  argp = (void *)arg;
  p = (int *)argp;
  if ((int )cmd == (__cil_tmp15 | __cil_tmp10)) {
    goto switch_2_exp_0;
  } else {
    if ((int )cmd == (__cil_tmp23 | __cil_tmp17)) {
      goto switch_2_exp_1;
    } else {
      if ((int )cmd == (__cil_tmp30 | __cil_tmp24)) {
        goto switch_2_exp_2;
      } else {
        {
        goto switch_2_default;
        if (0) {
          switch_2_exp_0: /* CIL Label */ 
          {
          __cil_tmp10 = 40UL << 16;
          __cil_tmp11 = 87 << 8;
          __cil_tmp12 = (unsigned int )__cil_tmp11;
          __cil_tmp13 = 2U << 30;
          __cil_tmp14 = __cil_tmp13 | __cil_tmp12;
          __cil_tmp15 = (unsigned long )__cil_tmp14;
          {
          __cil_tmp9 = (void const   *)(& zf_info);
          tmp = copy_to_user(argp, __cil_tmp9, 40UL);
          }
          }
          if (tmp) {
            return (-14);
          } else {

          }
          goto switch_2_break;
          switch_2_exp_1: /* CIL Label */ 
          {
          __cil_tmp17 = 4UL << 16;
          __cil_tmp18 = 87 << 8;
          __cil_tmp19 = (unsigned int )__cil_tmp18;
          __cil_tmp20 = 2U << 30;
          __cil_tmp21 = __cil_tmp20 | __cil_tmp19;
          __cil_tmp22 = __cil_tmp21 | 1U;
          __cil_tmp23 = (unsigned long )__cil_tmp22;
          {
          __cil_tmp16 = (void *)p;
          tmp___0 = put_user(0, __cil_tmp16);
          }
          }
          return (tmp___0);
          switch_2_exp_2: /* CIL Label */ 
          {
          __cil_tmp24 = 4UL << 16;
          __cil_tmp25 = 87 << 8;
          __cil_tmp26 = (unsigned int )__cil_tmp25;
          __cil_tmp27 = 2U << 30;
          __cil_tmp28 = __cil_tmp27 | __cil_tmp26;
          __cil_tmp29 = __cil_tmp28 | 5U;
          __cil_tmp30 = (unsigned long )__cil_tmp29;
          {
          zf_ping(0UL);
          }
          }
          goto switch_2_break;
          switch_2_default: /* CIL Label */ ;
          return (-25);
        } else {
          switch_2_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return (0);
}
}
static int zf_open(struct inode *inode , struct file *file ) 
{ int tmp ;
  int tmp___0 ;
  struct module *__cil_tmp5 ;

  {
  {
  spin_lock(& zf_lock);
  tmp = test_and_set_bit(0, & zf_is_open);
  }
  if (tmp) {
    {
    spin_unlock(& zf_lock);
    }
    return (-16);
  } else {

  }
  if (nowayout) {
    {
    __cil_tmp5 = (struct module *)0;
    __module_get(__cil_tmp5);
    }
  } else {

  }
  {
  spin_unlock(& zf_lock);
  zf_timer_on();
  tmp___0 = nonseekable_open(inode, file);
  }
  return (tmp___0);
}
}
static int zf_close(struct inode *inode , struct file *file ) 
{ int __cil_tmp3 ;
  unsigned long volatile   *__cil_tmp4 ;

  {
  {
  __cil_tmp3 = (int )zf_expect_close;
  if (__cil_tmp3 == 42) {
    {
    zf_timer_off();
    }
  } else {
    {
    del_timer(& zf_timer);
    printk("<3>machzwd: device file closed unexpectedly. Will not stop the WDT!\n");
    }
  }
  }
  {
  spin_lock(& zf_lock);
  __cil_tmp4 = (unsigned long volatile   *)(& zf_is_open);
  clear_bit(0, __cil_tmp4);
  spin_unlock(& zf_lock);
  zf_expect_close = (char)0;
  }
  return (0);
}
}
static int zf_notify_sys(struct notifier_block *this , unsigned long code , void *unused ) 
{ 

  {
  if (code == 1UL) {
    {
    zf_timer_off();
    }
  } else {
    if (code == 2UL) {
      {
      zf_timer_off();
      }
    } else {

    }
  }
  return (0);
}
}
static struct file_operations  const  zf_fops  = 
     {(struct module *)0, & no_llseek, (ssize_t (*)(struct file * , char * , size_t  ,
                                                  loff_t * ))0, & zf_write, (int (*)(struct file * ,
                                                                                     void * ,
                                                                                     int (*)(void * ,
                                                                                             char const   * ,
                                                                                             int  ,
                                                                                             loff_t  ,
                                                                                             ino_t  ,
                                                                                             unsigned int  ) ))0,
    (unsigned int (*)(struct file * , struct poll_table_struct * ))0, & zf_ioctl,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & zf_open, (int (*)(struct file * ))0,
    & zf_close, (int (*)(struct file * , struct dentry * , int datasync ))0, (int (*)(int  ,
                                                                                      struct file * ,
                                                                                      int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct iovec  const  * ,
                                                                         unsigned long  ,
                                                                         loff_t * ))0,
    (ssize_t (*)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ))0,
    (ssize_t (*)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                              struct page * , unsigned long  ,
                                                              unsigned long  ) , void * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file *filp ,
                                                                       unsigned long arg ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (int (*)(struct inode * ))0};
static struct miscdevice zf_miscdev  =    {130, "watchdog", (struct file_operations *)(& zf_fops)};
static struct notifier_block zf_notifier  =    {& zf_notify_sys, (struct notifier_block *)0, 0};
static void zf_show_action(int act ) 
{ char *str[4] ;

  {
  {
  str[0] = (char *)"RESET";
  str[1] = (char *)"SMI";
  str[2] = (char *)"NMI";
  str[3] = (char *)"SCI";
  printk("<6>machzwd: Watchdog using action = %s\n", str[act]);
  }
  return;
}
}
static int zf_init(void) 
{ int ret ;
  unsigned short tmp ;
  struct resource *tmp___0 ;

  {
  {
  printk("<6>machzwd: MachZ ZF-Logic Watchdog driver initializing.\n");
  tmp = zf_readw((unsigned char)2);
  ret = (int )tmp;
  }
  if (! ret) {
    {
    printk("<4>machzwd: no ZF-Logic found\n");
    }
    return (-19);
  } else {
    if (ret == 65535) {
      {
      printk("<4>machzwd: no ZF-Logic found\n");
      }
      return (-19);
    } else {

    }
  }
  if (action <= 3) {
    if (action >= 0) {
      zf_action = zf_action >> action;
    } else {
      action = 0;
    }
  } else {
    action = 0;
  }
  {
  zf_show_action(action);
  spin_lock_init(& zf_lock);
  spin_lock_init(& zf_port_lock);
  ret = misc_register(& zf_miscdev);
  }
  if (ret) {
    {
    printk("<3>can\'t misc_register on minor=%d\n", 130);
    }
    goto out;
  } else {

  }
  {
  tmp___0 = request_region(536UL, 3UL, "MachZ ZFL WDT");
  }
  if (tmp___0) {

  } else {
    {
    printk("<3>cannot reserve I/O ports at %d\n", 536);
    ret = -16;
    }
    goto no_region;
  }
  {
  ret = register_reboot_notifier(& zf_notifier);
  }
  if (ret) {
    {
    printk("<3>can\'t register reboot notifier (err=%d)\n", ret);
    }
    goto no_reboot;
  } else {

  }
  {
  zf_set_status((unsigned char)0);
  zf_set_control((unsigned short)0);
  init_timer(& zf_timer);
  zf_timer.function = & zf_ping;
  zf_timer.data = 0UL;
  }
  return (0);
  no_reboot: 
  {
  release_region(536UL, 3UL);
  }
  no_region: 
  {
  misc_deregister(& zf_miscdev);
  }
  out: 
  return (ret);
}
}
static void zf_exit(void) 
{ 

  {
  {
  zf_timer_off();
  misc_deregister(& zf_miscdev);
  unregister_reboot_notifier(& zf_notifier);
  release_region(536UL, 3UL);
  }
  return;
}
}
int (*_ddv_tmp_init)(void)  =    & zf_init;
void (*_ddv_tmp_exit)(void)  =    & zf_exit;
int main(void) 
{ 

  {
  {
  _ddv_module_init = & zf_init;
  _ddv_module_exit = & zf_exit;
  call_ddv();
  }
  return (0);
}
}
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) ;
__inline struct cdev *cdev_alloc(void) ;
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) ;
__inline void cdev_del(struct cdev *p ) ;
struct cdev fixed_cdev[1]  ;
int fixed_cdev_used  =    0;
short number_cdev_registered  =    (short)0;
struct ddv_cdev cdev_registered[1]  ;
void call_cdev_functions(void) ;
void add_disk(struct gendisk *disk ) ;
void del_gendisk(struct gendisk *gp ) ;
struct gendisk *alloc_disk(int minors ) ;
__inline int schedule_work(struct work_struct *work ) ;
__inline void mutex_init(struct mutex *lock ) ;
__inline void mutex_lock(struct mutex *lock ) ;
__inline void mutex_unlock(struct mutex *lock ) ;
__inline void tasklet_schedule(struct tasklet_struct *t ) ;
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) ;
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) ;
void free_irq(unsigned int irq , void *dev_id ) ;
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) ;
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) ;
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) ;
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) ;
void blk_cleanup_queue(request_queue_t *q ) ;
void end_request(struct request *req , int uptodate ) ;
short number_genhd_registered  =    (short)0;
short number_fixed_genhd_used  =    (short)0;
struct gendisk fixed_gendisk[10]  ;
struct ddv_genhd genhd_registered[10]  ;
void call_genhd_functions(void) ;
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
__inline int pci_register_driver(struct pci_driver *driver ) ;
__inline void pci_unregister_driver(struct pci_driver *driver ) ;
__inline int pci_enable_device(struct pci_dev *dev ) ;
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) ;
__inline void pci_release_regions(struct pci_dev *pdev ) ;
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) ;
__inline void pci_release_region(struct pci_dev *pdev , int bar ) ;
struct ddv_pci_driver registered_pci_driver  ;
int pci_probe_device(void) ;
void pci_remove_device(void) ;
void call_pci_functions(void) ;
struct registered_irq registered_irq[16]  ;
void call_interrupt_handler(void) ;
short number_tasklet_registered  =    (short)0;
struct ddv_tasklet tasklet_registered[1]  ;
void call_tasklet_functions(void) ;
short number_timer_registered  =    (short)0;
struct ddv_timer timer_registered[1]  ;
void call_timer_functions(void) ;
struct work_struct *shared_workqueue[10]  ;
__inline void call_shared_workqueue_functions(void) ;
spinlock_t kernel_lock  ;
void init_kernel(void) 
{ int i ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
  spin_lock_init(& kernel_lock);
  i = 0;
  }
  {
  while (1) {
    while_3_continue: /* CIL Label */ ;
    if (i < 10) {

    } else {
      goto while_3_break;
    }
    __cil_tmp2 = (void *)0;
    shared_workqueue[i] = (struct work_struct *)__cil_tmp2;
    i = i + 1;
  }
  while_3_break: /* CIL Label */ ;
  }
  i = 0;
  {
  while (1) {
    while_4_continue: /* CIL Label */ ;
    if (i < 1) {

    } else {
      goto while_4_break;
    }
    __cil_tmp3 = (void *)0;
    tasklet_registered[i].tasklet = (struct tasklet_struct *)__cil_tmp3;
    tasklet_registered[i].is_running = (unsigned short)0;
    i = i + 1;
  }
  while_4_break: /* CIL Label */ ;
  }
  return;
}
}
void ddv(void) 
{ unsigned short random ;

  {
  {
  while (1) {
    while_5_continue: /* CIL Label */ ;
    {
    random = __VERIFIER_nondet_ushort();
    }
    if ((int )random == 1) {
      goto switch_6_1;
    } else {
      if ((int )random == 2) {
        goto switch_6_2;
      } else {
        if ((int )random == 3) {
          goto switch_6_3;
        } else {
          if ((int )random == 4) {
            goto switch_6_4;
          } else {
            if ((int )random == 5) {
              goto switch_6_5;
            } else {
              {
              goto switch_6_default;
              if (0) {
                switch_6_1: /* CIL Label */ 
                {
                current_execution_context = 1;
                call_cdev_functions();
                }
                goto switch_6_break;
                switch_6_2: /* CIL Label */ 
                {
                current_execution_context = 2;
                call_timer_functions();
                }
                goto switch_6_break;
                switch_6_3: /* CIL Label */ 
                {
                current_execution_context = 2;
                call_interrupt_handler();
                }
                goto switch_6_break;
                switch_6_4: /* CIL Label */ 
                {
                current_execution_context = 1;
                call_shared_workqueue_functions();
                }
                goto switch_6_break;
                switch_6_5: /* CIL Label */ 
                {
                current_execution_context = 2;
                call_tasklet_functions();
                }
                goto switch_6_break;
                switch_6_default: /* CIL Label */ ;
                goto switch_6_break;
              } else {
                switch_6_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
    if (random) {

    } else {
      goto while_5_break;
    }
  }
  while_5_break: /* CIL Label */ ;
  }
  return;
}
}
int call_ddv(void) 
{ int err ;

  {
  {
  current_execution_context = 1;
  init_kernel();
  err = (*_ddv_module_init)();
  }
  if (err) {
    return (-1);
  } else {

  }
  {
  ddv();
  current_execution_context = 1;
  (*_ddv_module_exit)();
  }
  return (0);
}
}
void call_cdev_functions(void) 
{ int cdev_no ;
  int result ;
  loff_t loff_t_value ;
  int int_value ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  char char_value ;
  size_t size_t_value ;
  unsigned short tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  struct file_operations *__cil_tmp15 ;
  struct file_operations *__cil_tmp16 ;
  loff_t (*__cil_tmp17)(struct file * , loff_t  , int  ) ;
  struct file *__cil_tmp18 ;
  struct file_operations *__cil_tmp19 ;
  struct file_operations *__cil_tmp20 ;
  ssize_t (*__cil_tmp21)(struct file * , char * , size_t  , loff_t * ) ;
  struct file *__cil_tmp22 ;
  struct file_operations *__cil_tmp23 ;
  struct file_operations *__cil_tmp24 ;
  ssize_t (*__cil_tmp25)(struct file * , char const   * , size_t  , loff_t * ) ;
  struct file *__cil_tmp26 ;
  char const   *__cil_tmp27 ;
  struct file_operations *__cil_tmp28 ;
  struct file_operations *__cil_tmp29 ;
  int (*__cil_tmp30)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
  struct inode *__cil_tmp31 ;
  struct file *__cil_tmp32 ;
  struct file_operations *__cil_tmp33 ;
  struct file_operations *__cil_tmp34 ;
  int (*__cil_tmp35)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp36 ;
  struct file *__cil_tmp37 ;
  struct file_operations *__cil_tmp38 ;
  struct file_operations *__cil_tmp39 ;
  int (*__cil_tmp40)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp41 ;
  struct file *__cil_tmp42 ;

  {
  {
  __cil_tmp13 = (int )number_cdev_registered;
  if (__cil_tmp13 == 0) {
    return;
  } else {

  }
  }
  {
  tmp = __VERIFIER_nondet_ushort();
  cdev_no = (int )tmp;
  }
  if (0 <= cdev_no) {
    {
    __cil_tmp14 = (int )number_cdev_registered;
    if (cdev_no < __cil_tmp14) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    }
  } else {
    tmp___0 = 0;
  }
  {
  __VERIFIER_assume(tmp___0);
  tmp___1 = __VERIFIER_nondet_ushort();
  }
  if ((int )tmp___1 == 0) {
    goto switch_7_0;
  } else {
    if ((int )tmp___1 == 1) {
      goto switch_7_1;
    } else {
      if ((int )tmp___1 == 2) {
        goto switch_7_2;
      } else {
        if ((int )tmp___1 == 3) {
          goto switch_7_3;
        } else {
          if ((int )tmp___1 == 4) {
            goto switch_7_4;
          } else {
            if ((int )tmp___1 == 5) {
              goto switch_7_5;
            } else {
              if ((int )tmp___1 == 6) {
                goto switch_7_6;
              } else {
                if ((int )tmp___1 == 7) {
                  goto switch_7_7;
                } else {
                  if ((int )tmp___1 == 8) {
                    goto switch_7_8;
                  } else {
                    if ((int )tmp___1 == 9) {
                      goto switch_7_9;
                    } else {
                      if ((int )tmp___1 == 10) {
                        goto switch_7_10;
                      } else {
                        if ((int )tmp___1 == 11) {
                          goto switch_7_11;
                        } else {
                          if ((int )tmp___1 == 12) {
                            goto switch_7_12;
                          } else {
                            if ((int )tmp___1 == 13) {
                              goto switch_7_13;
                            } else {
                              if ((int )tmp___1 == 14) {
                                goto switch_7_14;
                              } else {
                                if ((int )tmp___1 == 15) {
                                  goto switch_7_15;
                                } else {
                                  if ((int )tmp___1 == 16) {
                                    goto switch_7_16;
                                  } else {
                                    if ((int )tmp___1 == 17) {
                                      goto switch_7_17;
                                    } else {
                                      if ((int )tmp___1 == 18) {
                                        goto switch_7_18;
                                      } else {
                                        if ((int )tmp___1 == 19) {
                                          goto switch_7_19;
                                        } else {
                                          if ((int )tmp___1 == 20) {
                                            goto switch_7_20;
                                          } else {
                                            if ((int )tmp___1 == 21) {
                                              goto switch_7_21;
                                            } else {
                                              if ((int )tmp___1 == 22) {
                                                goto switch_7_22;
                                              } else {
                                                if ((int )tmp___1 == 23) {
                                                  goto switch_7_23;
                                                } else {
                                                  if ((int )tmp___1 == 24) {
                                                    goto switch_7_24;
                                                  } else {
                                                    if ((int )tmp___1 == 25) {
                                                      goto switch_7_25;
                                                    } else {
                                                      if ((int )tmp___1 == 26) {
                                                        goto switch_7_26;
                                                      } else {
                                                        {
                                                        goto switch_7_default;
                                                        if (0) {
                                                          switch_7_0: /* CIL Label */ 
                                                          {
                                                          __cil_tmp15 = (cdev_registered[cdev_no].cdevp)->ops;
                                                          if (__cil_tmp15->llseek) {
                                                            {
                                                            loff_t_value = __VERIFIER_nondet_loff_t();
                                                            int_value = __VERIFIER_nondet_int();
                                                            __cil_tmp16 = (cdev_registered[cdev_no].cdevp)->ops;
                                                            __cil_tmp17 = __cil_tmp16->llseek;
                                                            __cil_tmp18 = & cdev_registered[cdev_no].filp;
                                                            (*__cil_tmp17)(__cil_tmp18,
                                                                           loff_t_value,
                                                                           int_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_1: /* CIL Label */ 
                                                          {
                                                          __cil_tmp19 = (cdev_registered[cdev_no].cdevp)->ops;
                                                          if (__cil_tmp19->read) {
                                                            {
                                                            char_value = __VERIFIER_nondet_char();
                                                            size_t_value = __VERIFIER_nondet_size_t();
                                                            __cil_tmp20 = (cdev_registered[cdev_no].cdevp)->ops;
                                                            __cil_tmp21 = __cil_tmp20->read;
                                                            __cil_tmp22 = & cdev_registered[cdev_no].filp;
                                                            (*__cil_tmp21)(__cil_tmp22,
                                                                           & char_value,
                                                                           size_t_value,
                                                                           & loff_t_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_2: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_3: /* CIL Label */ 
                                                          {
                                                          __cil_tmp23 = (cdev_registered[cdev_no].cdevp)->ops;
                                                          if (__cil_tmp23->write) {
                                                            {
                                                            char_value = __VERIFIER_nondet_char();
                                                            size_t_value = __VERIFIER_nondet_size_t();
                                                            __cil_tmp24 = (cdev_registered[cdev_no].cdevp)->ops;
                                                            __cil_tmp25 = __cil_tmp24->write;
                                                            __cil_tmp26 = & cdev_registered[cdev_no].filp;
                                                            __cil_tmp27 = (char const   *)(& char_value);
                                                            (*__cil_tmp25)(__cil_tmp26,
                                                                           __cil_tmp27,
                                                                           size_t_value,
                                                                           & loff_t_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_4: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_5: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_6: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_7: /* CIL Label */ 
                                                          {
                                                          __cil_tmp28 = (cdev_registered[cdev_no].cdevp)->ops;
                                                          if (__cil_tmp28->ioctl) {
                                                            {
                                                            uint_value = __VERIFIER_nondet_uint();
                                                            ulong_value = __VERIFIER_nondet_ulong();
                                                            __cil_tmp29 = (cdev_registered[cdev_no].cdevp)->ops;
                                                            __cil_tmp30 = __cil_tmp29->ioctl;
                                                            __cil_tmp31 = & cdev_registered[cdev_no].inode;
                                                            __cil_tmp32 = & cdev_registered[cdev_no].filp;
                                                            (*__cil_tmp30)(__cil_tmp31,
                                                                           __cil_tmp32,
                                                                           uint_value,
                                                                           ulong_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_8: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_9: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_10: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_11: /* CIL Label */ 
                                                          {
                                                          __cil_tmp33 = (cdev_registered[cdev_no].cdevp)->ops;
                                                          if (__cil_tmp33->open) {
                                                            if (! cdev_registered[cdev_no].open) {
                                                              {
                                                              __cil_tmp34 = (cdev_registered[cdev_no].cdevp)->ops;
                                                              __cil_tmp35 = __cil_tmp34->open;
                                                              __cil_tmp36 = & cdev_registered[cdev_no].inode;
                                                              __cil_tmp37 = & cdev_registered[cdev_no].filp;
                                                              result = (*__cil_tmp35)(__cil_tmp36,
                                                                                      __cil_tmp37);
                                                              }
                                                              if (! result) {
                                                                cdev_registered[cdev_no].open = 1;
                                                              } else {

                                                              }
                                                            } else {

                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_12: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_13: /* CIL Label */ 
                                                          {
                                                          __cil_tmp38 = (cdev_registered[cdev_no].cdevp)->ops;
                                                          if (__cil_tmp38->release) {
                                                            if (cdev_registered[cdev_no].open) {
                                                              {
                                                              __cil_tmp39 = (cdev_registered[cdev_no].cdevp)->ops;
                                                              __cil_tmp40 = __cil_tmp39->release;
                                                              __cil_tmp41 = & cdev_registered[cdev_no].inode;
                                                              __cil_tmp42 = & cdev_registered[cdev_no].filp;
                                                              result = (*__cil_tmp40)(__cil_tmp41,
                                                                                      __cil_tmp42);
                                                              }
                                                              if (! result) {
                                                                cdev_registered[cdev_no].open = 0;
                                                              } else {

                                                              }
                                                            } else {

                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_14: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_15: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_16: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_17: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_18: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_19: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_20: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_21: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_22: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_23: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_24: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_25: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_26: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_default: /* CIL Label */ ;
                                                          goto switch_7_break;
                                                        } else {
                                                          switch_7_break: /* CIL Label */ ;
                                                        }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
int create_request(int genhd_no ) 
{ struct request rq ;

  {
  {
  rq.cmd_type = (enum rq_cmd_type_bits )1;
  rq.rq_disk = genhd_registered[genhd_no].gd;
  rq.sector = __VERIFIER_nondet_sector_t();
  rq.current_nr_sectors = __VERIFIER_nondet_uint();
  rq.buffer = __VERIFIER_nondet_pchar();
  genhd_registered[genhd_no].current_request = rq;
  genhd_registered[genhd_no].requests_open = 1;
  }
  return (0);
}
}
void call_rq_function(int genhd_no ) 
{ void *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct request_queue *__cil_tmp4 ;
  request_fn_proc *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct request_queue *__cil_tmp7 ;
  struct request_queue *__cil_tmp8 ;
  spinlock_t *__cil_tmp9 ;
  struct request_queue *__cil_tmp10 ;
  struct request_queue *__cil_tmp11 ;
  request_fn_proc *__cil_tmp12 ;
  struct request_queue *__cil_tmp13 ;
  struct request_queue *__cil_tmp14 ;
  spinlock_t *__cil_tmp15 ;
  struct request_queue *__cil_tmp16 ;

  {
  {
  __cil_tmp2 = (void *)0;
  __cil_tmp3 = (unsigned long )__cil_tmp2;
  __cil_tmp4 = (genhd_registered[genhd_no].gd)->queue;
  __cil_tmp5 = __cil_tmp4->request_fn;
  __cil_tmp6 = (unsigned long )__cil_tmp5;
  if (__cil_tmp6 != __cil_tmp3) {
    {
    __cil_tmp7 = (genhd_registered[genhd_no].gd)->queue;
    if (__cil_tmp7->__ddv_queue_alive) {
      {
      __cil_tmp8 = (genhd_registered[genhd_no].gd)->queue;
      __cil_tmp9 = __cil_tmp8->queue_lock;
      spin_lock(__cil_tmp9);
      create_request(genhd_no);
      __cil_tmp10 = (genhd_registered[genhd_no].gd)->queue;
      __cil_tmp10->__ddv_genhd_no = genhd_no;
      __cil_tmp11 = (genhd_registered[genhd_no].gd)->queue;
      __cil_tmp12 = __cil_tmp11->request_fn;
      __cil_tmp13 = (genhd_registered[genhd_no].gd)->queue;
      (*__cil_tmp12)(__cil_tmp13);
      __cil_tmp14 = (genhd_registered[genhd_no].gd)->queue;
      __cil_tmp15 = __cil_tmp14->queue_lock;
      spin_unlock(__cil_tmp15);
      }
      return;
    } else {

    }
    }
  } else {

  }
  }
  {
  __cil_tmp16 = (genhd_registered[genhd_no].gd)->queue;
  if (__cil_tmp16->make_request_fn) {
    return;
  } else {

  }
  }
  return;
}
}
void call_genhd_functions(void) 
{ unsigned short genhd_no ;
  unsigned short function_no ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  void *tmp ;
  struct hd_geometry hdg ;
  struct block_device blk_dev ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  struct block_device_operations *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  struct block_device_operations *__cil_tmp16 ;
  int (*__cil_tmp17)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp18 ;
  struct file *__cil_tmp19 ;
  struct block_device_operations *__cil_tmp20 ;
  struct block_device_operations *__cil_tmp21 ;
  int (*__cil_tmp22)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp23 ;
  struct file *__cil_tmp24 ;
  struct block_device_operations *__cil_tmp25 ;
  struct block_device_operations *__cil_tmp26 ;
  int (*__cil_tmp27)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
  struct inode *__cil_tmp28 ;
  struct file *__cil_tmp29 ;
  struct block_device_operations *__cil_tmp30 ;
  struct block_device_operations *__cil_tmp31 ;
  int (*__cil_tmp32)(struct gendisk * ) ;
  struct block_device_operations *__cil_tmp33 ;
  struct block_device_operations *__cil_tmp34 ;
  int (*__cil_tmp35)(struct gendisk * ) ;
  struct block_device_operations *__cil_tmp36 ;
  struct block_device_operations *__cil_tmp37 ;
  int (*__cil_tmp38)(struct block_device * , struct hd_geometry * ) ;

  {
  {
  __cil_tmp9 = (int )number_genhd_registered;
  if (__cil_tmp9 == 0) {
    return;
  } else {

  }
  }
  {
  genhd_no = __VERIFIER_nondet_ushort();
  __cil_tmp10 = (int )number_genhd_registered;
  __cil_tmp11 = (int )genhd_no;
  __cil_tmp12 = __cil_tmp11 < __cil_tmp10;
  __VERIFIER_assume(__cil_tmp12);
  function_no = __VERIFIER_nondet_ushort();
  }
  if ((int )function_no == 0) {
    goto switch_8_0;
  } else {
    if ((int )function_no == 1) {
      goto switch_8_1;
    } else {
      if ((int )function_no == 2) {
        goto switch_8_2;
      } else {
        if ((int )function_no == 3) {
          goto switch_8_3;
        } else {
          if ((int )function_no == 4) {
            goto switch_8_4;
          } else {
            if ((int )function_no == 5) {
              goto switch_8_5;
            } else {
              if ((int )function_no == 6) {
                goto switch_8_6;
              } else {
                {
                goto switch_8_default;
                if (0) {
                  switch_8_0: /* CIL Label */ 
                  {
                  __cil_tmp13 = (int )genhd_no;
                  call_rq_function(__cil_tmp13);
                  }
                  goto switch_8_break;
                  switch_8_1: /* CIL Label */ 
                  {
                  __cil_tmp14 = (genhd_registered[genhd_no].gd)->fops;
                  if (__cil_tmp14->open) {
                    {
                    __cil_tmp15 = (unsigned int )32UL;
                    tmp = malloc(__cil_tmp15);
                    genhd_registered[genhd_no].inode.i_bdev = (struct block_device *)tmp;
                    (genhd_registered[genhd_no].inode.i_bdev)->bd_disk = genhd_registered[genhd_no].gd;
                    __cil_tmp16 = (genhd_registered[genhd_no].gd)->fops;
                    __cil_tmp17 = __cil_tmp16->open;
                    __cil_tmp18 = & genhd_registered[genhd_no].inode;
                    __cil_tmp19 = & genhd_registered[genhd_no].file;
                    (*__cil_tmp17)(__cil_tmp18, __cil_tmp19);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_2: /* CIL Label */ 
                  {
                  __cil_tmp20 = (genhd_registered[genhd_no].gd)->fops;
                  if (__cil_tmp20->release) {
                    {
                    __cil_tmp21 = (genhd_registered[genhd_no].gd)->fops;
                    __cil_tmp22 = __cil_tmp21->release;
                    __cil_tmp23 = & genhd_registered[genhd_no].inode;
                    __cil_tmp24 = & genhd_registered[genhd_no].file;
                    (*__cil_tmp22)(__cil_tmp23, __cil_tmp24);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_3: /* CIL Label */ 
                  {
                  __cil_tmp25 = (genhd_registered[genhd_no].gd)->fops;
                  if (__cil_tmp25->ioctl) {
                    {
                    uint_value = __VERIFIER_nondet_uint();
                    ulong_value = __VERIFIER_nondet_ulong();
                    __cil_tmp26 = (genhd_registered[genhd_no].gd)->fops;
                    __cil_tmp27 = __cil_tmp26->ioctl;
                    __cil_tmp28 = & genhd_registered[genhd_no].inode;
                    __cil_tmp29 = & genhd_registered[genhd_no].file;
                    (*__cil_tmp27)(__cil_tmp28, __cil_tmp29, uint_value, ulong_value);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_4: /* CIL Label */ 
                  {
                  __cil_tmp30 = (genhd_registered[genhd_no].gd)->fops;
                  if (__cil_tmp30->media_changed) {
                    {
                    __cil_tmp31 = (genhd_registered[genhd_no].gd)->fops;
                    __cil_tmp32 = __cil_tmp31->media_changed;
                    (*__cil_tmp32)(genhd_registered[genhd_no].gd);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_5: /* CIL Label */ 
                  {
                  __cil_tmp33 = (genhd_registered[genhd_no].gd)->fops;
                  if (__cil_tmp33->revalidate_disk) {
                    {
                    __cil_tmp34 = (genhd_registered[genhd_no].gd)->fops;
                    __cil_tmp35 = __cil_tmp34->revalidate_disk;
                    (*__cil_tmp35)(genhd_registered[genhd_no].gd);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_6: /* CIL Label */ 
                  {
                  __cil_tmp36 = (genhd_registered[genhd_no].gd)->fops;
                  if (__cil_tmp36->getgeo) {
                    {
                    blk_dev.bd_disk = genhd_registered[genhd_no].gd;
                    __cil_tmp37 = (genhd_registered[genhd_no].gd)->fops;
                    __cil_tmp38 = __cil_tmp37->getgeo;
                    (*__cil_tmp38)(& blk_dev, & hdg);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_default: /* CIL Label */ ;
                  goto switch_8_break;
                } else {
                  switch_8_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
void call_interrupt_handler(void) 
{ unsigned short i ;
  struct pt_regs regs ;
  int tmp ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  i = (unsigned short )tmp;
  __cil_tmp4 = (int )i;
  __cil_tmp5 = __cil_tmp4 < 16;
  __VERIFIER_assume(__cil_tmp5);
  }
  if (registered_irq[i].handler) {
    {
    __cil_tmp6 = (int )i;
    (*(registered_irq[i].handler))(__cil_tmp6, registered_irq[i].dev_id, & regs);
    }
  } else {

  }
  return;
}
}
void create_pci_dev(void) 
{ 

  {
  return;
}
}
int pci_probe_device(void) 
{ int err ;
  unsigned int dev_id ;
  int __cil_tmp3 ;
  int (*__cil_tmp4)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
  struct pci_dev *__cil_tmp5 ;
  struct pci_device_id  const  *__cil_tmp6 ;
  struct pci_device_id  const  *__cil_tmp7 ;

  {
  {
  registered_pci_driver.no_pci_device_id = 1U;
  dev_id = __VERIFIER_nondet_uint();
  __cil_tmp3 = dev_id < registered_pci_driver.no_pci_device_id;
  __VERIFIER_assume(__cil_tmp3);
  __cil_tmp4 = (registered_pci_driver.pci_driver)->probe;
  __cil_tmp5 = & registered_pci_driver.pci_dev;
  __cil_tmp6 = (registered_pci_driver.pci_driver)->id_table;
  __cil_tmp7 = __cil_tmp6 + dev_id;
  err = (*__cil_tmp4)(__cil_tmp5, __cil_tmp7);
  }
  if (! err) {
    registered_pci_driver.dev_initialized = 1;
  } else {

  }
  return (err);
}
}
void pci_remove_device(void) 
{ void (*__cil_tmp1)(struct pci_dev *dev ) ;
  struct pci_dev *__cil_tmp2 ;

  {
  {
  __cil_tmp1 = (registered_pci_driver.pci_driver)->remove;
  __cil_tmp2 = & registered_pci_driver.pci_dev;
  (*__cil_tmp1)(__cil_tmp2);
  registered_pci_driver.dev_initialized = 0;
  }
  return;
}
}
void call_pci_functions(void) 
{ unsigned int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_uint();
  }
  if ((int )tmp == 0) {
    goto switch_9_0;
  } else {
    if ((int )tmp == 1) {
      goto switch_9_1;
    } else {
      {
      goto switch_9_default;
      if (0) {
        switch_9_0: /* CIL Label */ 
        if (! registered_pci_driver.dev_initialized) {
          {
          pci_probe_device();
          }
        } else {

        }
        goto switch_9_break;
        switch_9_1: /* CIL Label */ 
        if (registered_pci_driver.dev_initialized) {
          {
          pci_remove_device();
          }
        } else {

        }
        goto switch_9_break;
        switch_9_default: /* CIL Label */ ;
        goto switch_9_break;
      } else {
        switch_9_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
void call_tasklet_functions(void) 
{ unsigned int i ;
  int __cil_tmp2 ;
  void *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  atomic_t __cil_tmp6 ;
  void (*__cil_tmp7)(unsigned long  ) ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
  __cil_tmp2 = i < 1U;
  __VERIFIER_assume(__cil_tmp2);
  }
  {
  __cil_tmp3 = (void *)0;
  __cil_tmp4 = (unsigned long )__cil_tmp3;
  __cil_tmp5 = (unsigned long )tasklet_registered[i].tasklet;
  if (__cil_tmp5 != __cil_tmp4) {
    {
    __cil_tmp6 = (tasklet_registered[i].tasklet)->count;
    if (__cil_tmp6 == 0) {
      {
      tasklet_registered[i].is_running = (unsigned short)1;
      __cil_tmp7 = (tasklet_registered[i].tasklet)->func;
      __cil_tmp8 = (tasklet_registered[i].tasklet)->data;
      (*__cil_tmp7)(__cil_tmp8);
      tasklet_registered[i].is_running = (unsigned short)0;
      __cil_tmp9 = (void *)0;
      tasklet_registered[i].tasklet = (struct tasklet_struct *)__cil_tmp9;
      }
    } else {

    }
    }
  } else {

  }
  }
  return;
}
}
void call_timer_functions(void) 
{ unsigned short i ;
  unsigned short tmp ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  void (*__cil_tmp6)(unsigned long  ) ;
  unsigned long __cil_tmp7 ;

  {
  {
  tmp = __VERIFIER_nondet_ushort();
  i = tmp;
  __cil_tmp3 = (int )number_timer_registered;
  __cil_tmp4 = (int )i;
  __cil_tmp5 = __cil_tmp4 < __cil_tmp3;
  __VERIFIER_assume(__cil_tmp5);
  }
  if ((timer_registered[i].timer)->__ddv_active) {
    {
    __cil_tmp6 = (timer_registered[i].timer)->function;
    __cil_tmp7 = (timer_registered[i].timer)->data;
    (*__cil_tmp6)(__cil_tmp7);
    }
  } else {

  }
  return;
}
}
__inline int pci_enable_device(struct pci_dev *dev ) 
{ int i ;
  unsigned int tmp ;
  unsigned short tmp___0 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  i = 0;
  {
  while (1) {
    while_10_continue: /* CIL Label */ ;
    if (i < 12) {

    } else {
      goto while_10_break;
    }
    {
    dev->resource[i].flags = 256UL;
    tmp = __VERIFIER_nondet_uint();
    dev->resource[i].start = (unsigned long )tmp;
    tmp___0 = __VERIFIER_nondet_ushort();
    __cil_tmp5 = (unsigned long )tmp___0;
    __cil_tmp6 = dev->resource[i].start;
    dev->resource[i].end = __cil_tmp6 + __cil_tmp5;
    i = i + 1;
    }
  }
  while_10_break: /* CIL Label */ ;
  }
  return (0);
}
}
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) 
{ void *tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
  __cil_tmp5 = (void *)0;
  __cil_tmp6 = (unsigned long )__cil_tmp5;
  __cil_tmp7 = (unsigned long )from;
  if (__cil_tmp7 == __cil_tmp6) {
    {
    __cil_tmp8 = (unsigned int )432UL;
    tmp = malloc(__cil_tmp8);
    from = (struct pci_dev *)tmp;
    }
  } else {

  }
  }
  {
  tmp___0 = __VERIFIER_nondet_int();
  }
  if (tmp___0) {
    {
    from->vendor = __VERIFIER_nondet_ushort();
    from->device = __VERIFIER_nondet_ushort();
    from->irq = __VERIFIER_nondet_uint();
    __cil_tmp9 = from->irq;
    __cil_tmp10 = __cil_tmp9 < 16U;
    __VERIFIER_assume(__cil_tmp10);
    }
    return (from);
  } else {
    {
    __cil_tmp11 = (void *)0;
    return ((struct pci_dev *)__cil_tmp11);
    }
  }
}
}
__inline int pci_register_driver(struct pci_driver *driver ) 
{ int tmp ;
  unsigned long __cil_tmp3 ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  }
  if (tmp) {
    registered_pci_driver.pci_driver = driver;
    __cil_tmp3 = 8UL / 32UL;
    registered_pci_driver.no_pci_device_id = (unsigned int )__cil_tmp3;
    registered_pci_driver.dev_initialized = 0;
    return (0);
  } else {
    return (-1);
  }
}
}
__inline void pci_unregister_driver(struct pci_driver *driver ) 
{ void *__cil_tmp2 ;

  {
  __cil_tmp2 = (void *)0;
  registered_pci_driver.pci_driver = (struct pci_driver *)__cil_tmp2;
  registered_pci_driver.no_pci_device_id = 0U;
  return;
}
}
__inline void pci_release_region(struct pci_dev *pdev , int bar ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;

  {
  {
  __cil_tmp6 = pdev->resource[bar].start;
  if (__cil_tmp6 == 0UL) {
    {
    __cil_tmp7 = pdev->resource[bar].start;
    __cil_tmp8 = pdev->resource[bar].end;
    if (__cil_tmp8 == __cil_tmp7) {
      tmp = 0UL;
    } else {
      __cil_tmp9 = pdev->resource[bar].start;
      __cil_tmp10 = pdev->resource[bar].end;
      __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
      tmp = __cil_tmp11 + 1UL;
    }
    }
  } else {
    __cil_tmp12 = pdev->resource[bar].start;
    __cil_tmp13 = pdev->resource[bar].end;
    __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
    tmp = __cil_tmp14 + 1UL;
  }
  }
  if (tmp == 0UL) {
    return;
  } else {

  }
  {
  __cil_tmp15 = pdev->resource[bar].flags;
  if (__cil_tmp15 & 256UL) {
    {
    __cil_tmp16 = pdev->resource[bar].start;
    if (__cil_tmp16 == 0UL) {
      {
      __cil_tmp17 = pdev->resource[bar].start;
      __cil_tmp18 = pdev->resource[bar].end;
      if (__cil_tmp18 == __cil_tmp17) {
        tmp___0 = 0UL;
      } else {
        __cil_tmp19 = pdev->resource[bar].start;
        __cil_tmp20 = pdev->resource[bar].end;
        __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
        tmp___0 = __cil_tmp21 + 1UL;
      }
      }
    } else {
      __cil_tmp22 = pdev->resource[bar].start;
      __cil_tmp23 = pdev->resource[bar].end;
      __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
      tmp___0 = __cil_tmp24 + 1UL;
    }
    }
    {
    __cil_tmp25 = pdev->resource[bar].start;
    release_region(__cil_tmp25, tmp___0);
    }
  } else {
    {
    __cil_tmp26 = pdev->resource[bar].flags;
    if (__cil_tmp26 & 512UL) {
      {
      __cil_tmp27 = pdev->resource[bar].start;
      if (__cil_tmp27 == 0UL) {
        {
        __cil_tmp28 = pdev->resource[bar].start;
        __cil_tmp29 = pdev->resource[bar].end;
        if (__cil_tmp29 == __cil_tmp28) {
          tmp___1 = 0UL;
        } else {
          __cil_tmp30 = pdev->resource[bar].start;
          __cil_tmp31 = pdev->resource[bar].end;
          __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
          tmp___1 = __cil_tmp32 + 1UL;
        }
        }
      } else {
        __cil_tmp33 = pdev->resource[bar].start;
        __cil_tmp34 = pdev->resource[bar].end;
        __cil_tmp35 = __cil_tmp34 - __cil_tmp33;
        tmp___1 = __cil_tmp35 + 1UL;
      }
      }
      {
      __cil_tmp36 = pdev->resource[bar].start;
      release_mem_region(__cil_tmp36, tmp___1);
      }
    } else {

    }
    }
  }
  }
  return;
}
}
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  struct resource *tmp___1 ;
  unsigned long tmp___2 ;
  struct resource *tmp___3 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;

  {
  {
  __cil_tmp9 = pdev->resource[bar].start;
  if (__cil_tmp9 == 0UL) {
    {
    __cil_tmp10 = pdev->resource[bar].start;
    __cil_tmp11 = pdev->resource[bar].end;
    if (__cil_tmp11 == __cil_tmp10) {
      tmp = 0UL;
    } else {
      __cil_tmp12 = pdev->resource[bar].start;
      __cil_tmp13 = pdev->resource[bar].end;
      __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
      tmp = __cil_tmp14 + 1UL;
    }
    }
  } else {
    __cil_tmp15 = pdev->resource[bar].start;
    __cil_tmp16 = pdev->resource[bar].end;
    __cil_tmp17 = __cil_tmp16 - __cil_tmp15;
    tmp = __cil_tmp17 + 1UL;
  }
  }
  if (tmp == 0UL) {
    return (0);
  } else {

  }
  {
  __cil_tmp18 = pdev->resource[bar].flags;
  if (__cil_tmp18 & 256UL) {
    {
    __cil_tmp19 = pdev->resource[bar].start;
    if (__cil_tmp19 == 0UL) {
      {
      __cil_tmp20 = pdev->resource[bar].start;
      __cil_tmp21 = pdev->resource[bar].end;
      if (__cil_tmp21 == __cil_tmp20) {
        tmp___0 = 0UL;
      } else {
        __cil_tmp22 = pdev->resource[bar].start;
        __cil_tmp23 = pdev->resource[bar].end;
        __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
        tmp___0 = __cil_tmp24 + 1UL;
      }
      }
    } else {
      __cil_tmp25 = pdev->resource[bar].start;
      __cil_tmp26 = pdev->resource[bar].end;
      __cil_tmp27 = __cil_tmp26 - __cil_tmp25;
      tmp___0 = __cil_tmp27 + 1UL;
    }
    }
    {
    __cil_tmp28 = pdev->resource[bar].start;
    tmp___1 = request_region(__cil_tmp28, tmp___0, res_name);
    }
    if (tmp___1) {

    } else {
      return (-16);
    }
  } else {
    {
    __cil_tmp29 = pdev->resource[bar].flags;
    if (__cil_tmp29 & 512UL) {
      {
      __cil_tmp30 = pdev->resource[bar].start;
      if (__cil_tmp30 == 0UL) {
        {
        __cil_tmp31 = pdev->resource[bar].start;
        __cil_tmp32 = pdev->resource[bar].end;
        if (__cil_tmp32 == __cil_tmp31) {
          tmp___2 = 0UL;
        } else {
          __cil_tmp33 = pdev->resource[bar].start;
          __cil_tmp34 = pdev->resource[bar].end;
          __cil_tmp35 = __cil_tmp34 - __cil_tmp33;
          tmp___2 = __cil_tmp35 + 1UL;
        }
        }
      } else {
        __cil_tmp36 = pdev->resource[bar].start;
        __cil_tmp37 = pdev->resource[bar].end;
        __cil_tmp38 = __cil_tmp37 - __cil_tmp36;
        tmp___2 = __cil_tmp38 + 1UL;
      }
      }
      {
      __cil_tmp39 = pdev->resource[bar].start;
      tmp___3 = request_mem_region(__cil_tmp39, tmp___2, res_name);
      }
      if (tmp___3) {

      } else {
        return (-16);
      }
    } else {

    }
    }
  }
  }
  return (0);
}
}
__inline void pci_release_regions(struct pci_dev *pdev ) 
{ int i ;

  {
  i = 0;
  {
  while (1) {
    while_11_continue: /* CIL Label */ ;
    if (i < 6) {

    } else {
      goto while_11_break;
    }
    {
    pci_release_region(pdev, i);
    i = i + 1;
    }
  }
  while_11_break: /* CIL Label */ ;
  }
  return;
}
}
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ int i ;
  int tmp ;

  {
  i = 0;
  {
  while (1) {
    while_12_continue: /* CIL Label */ ;
    if (i < 6) {

    } else {
      goto while_12_break;
    }
    {
    tmp = pci_request_region(pdev, i, res_name);
    }
    if (tmp) {
      goto err_out;
    } else {

    }
    i = i + 1;
  }
  while_12_break: /* CIL Label */ ;
  }
  return (0);
  err_out: 
  {
  while (1) {
    while_13_continue: /* CIL Label */ ;
    i = i - 1;
    if (i >= 0) {

    } else {
      goto while_13_break;
    }
    {
    pci_release_region(pdev, i);
    }
  }
  while_13_break: /* CIL Label */ ;
  }
  return (-16);
}
}
__inline int __get_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
  assert_context_process();
  tmp = __VERIFIER_nondet_int();
  }
  return (tmp);
}
}
__inline int get_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
  assert_context_process();
  tmp = __VERIFIER_nondet_int();
  }
  return (tmp);
}
}
__inline int __put_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
  assert_context_process();
  tmp = __VERIFIER_nondet_int();
  }
  return (tmp);
}
}
__inline int put_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
  assert_context_process();
  tmp = __VERIFIER_nondet_int();
  }
  return (tmp);
}
}
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
  assert_context_process();
  tmp = __VERIFIER_nondet_ulong();
  }
  return (tmp);
}
}
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
  assert_context_process();
  tmp = __VERIFIER_nondet_ulong();
  }
  return (tmp);
}
}
int register_blkdev(unsigned int major , char const   *name ) 
{ int result ;
  int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  result = tmp;
  }
  return (result);
}
}
int unregister_blkdev(unsigned int major , char const   *name ) 
{ 

  {
  return (0);
}
}
struct gendisk *alloc_disk(int minors ) 
{ struct gendisk *gd ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
  __cil_tmp3 = (int )number_fixed_genhd_used;
  if (__cil_tmp3 < 10) {
    gd = & fixed_gendisk[number_fixed_genhd_used];
    gd->minors = minors;
    __cil_tmp4 = (int )number_fixed_genhd_used;
    __cil_tmp5 = __cil_tmp4 + 1;
    number_fixed_genhd_used = (short )__cil_tmp5;
    return (gd);
  } else {
    {
    __cil_tmp6 = (void *)0;
    return ((struct gendisk *)__cil_tmp6);
    }
  }
  }
}
}
void add_disk(struct gendisk *disk ) 
{ void *tmp ;
  int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
  __cil_tmp3 = (int )number_genhd_registered;
  if (__cil_tmp3 < 10) {
    {
    genhd_registered[number_genhd_registered].gd = disk;
    __cil_tmp4 = (unsigned int )32UL;
    tmp = malloc(__cil_tmp4);
    genhd_registered[number_genhd_registered].inode.i_bdev = (struct block_device *)tmp;
    (genhd_registered[number_genhd_registered].inode.i_bdev)->bd_disk = disk;
    __cil_tmp5 = (int )number_genhd_registered;
    __cil_tmp6 = __cil_tmp5 + 1;
    number_genhd_registered = (short )__cil_tmp6;
    }
  } else {

  }
  }
  return;
}
}
void del_gendisk(struct gendisk *gp ) 
{ int i ;
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  i = 0;
  {
  while (1) {
    while_14_continue: /* CIL Label */ ;
    {
    __cil_tmp3 = (int )number_genhd_registered;
    if (i < __cil_tmp3) {

    } else {
      goto while_14_break;
    }
    }
    {
    __cil_tmp4 = (unsigned long )gp;
    __cil_tmp5 = (unsigned long )genhd_registered[i].gd;
    if (__cil_tmp5 == __cil_tmp4) {
      __cil_tmp6 = (void *)0;
      genhd_registered[i].gd = (struct gendisk *)__cil_tmp6;
    } else {

    }
    }
    i = i + 1;
  }
  while_14_break: /* CIL Label */ ;
  }
  return;
}
}
request_queue_t fixed_request_queue[10]  ;
int number_request_queue_used  =    0;
request_queue_t *get_fixed_request_queue(void) 
{ int tmp ;
  void *__cil_tmp2 ;

  {
  if (number_request_queue_used < 10) {
    tmp = number_request_queue_used;
    number_request_queue_used = number_request_queue_used + 1;
    return (& fixed_request_queue[tmp]);
  } else {
    {
    __cil_tmp2 = (void *)0;
    return ((request_queue_t *)__cil_tmp2);
    }
  }
}
}
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) 
{ request_queue_t *queue ;
  int tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  }
  if (tmp) {
    {
    queue = get_fixed_request_queue();
    queue->queue_lock = lock;
    queue->request_fn = rfn;
    __cil_tmp5 = (void *)0;
    queue->make_request_fn = (make_request_fn *)__cil_tmp5;
    queue->__ddv_queue_alive = 1;
    }
    return (queue);
  } else {
    {
    __cil_tmp6 = (void *)0;
    return ((request_queue_t *)__cil_tmp6);
    }
  }
}
}
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) 
{ request_queue_t *queue ;
  int tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  }
  if (tmp) {
    {
    queue = get_fixed_request_queue();
    __cil_tmp4 = (void *)0;
    queue->request_fn = (request_fn_proc *)__cil_tmp4;
    __cil_tmp5 = (void *)0;
    queue->make_request_fn = (make_request_fn *)__cil_tmp5;
    queue->__ddv_queue_alive = 1;
    }
    return (queue);
  } else {
    {
    __cil_tmp6 = (void *)0;
    return ((request_queue_t *)__cil_tmp6);
    }
  }
}
}
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) 
{ 

  {
  q->make_request_fn = mfn;
  return;
}
}
void end_request(struct request *req , int uptodate ) 
{ int genhd_no ;
  struct gendisk *__cil_tmp4 ;
  struct request_queue *__cil_tmp5 ;

  {
  __cil_tmp4 = req->rq_disk;
  __cil_tmp5 = __cil_tmp4->queue;
  genhd_no = __cil_tmp5->__ddv_genhd_no;
  genhd_registered[genhd_no].requests_open = 0;
  return;
}
}
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) 
{ 

  {
  q->hardsect_size = size;
  return;
}
}
void blk_cleanup_queue(request_queue_t *q ) 
{ 

  {
  q->__ddv_queue_alive = 0;
  return;
}
}
struct proc_dir_entry *proc_root_driver  ;
int misc_register(struct miscdevice *misc ) 
{ int i ;
  dev_t dev ;
  int tmp ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  struct cdev *__cil_tmp8 ;

  {
  if (fixed_cdev_used < 1) {
    {
    i = fixed_cdev_used;
    fixed_cdev_used = fixed_cdev_used + 1;
    fixed_cdev[i].owner = (struct module *)0;
    fixed_cdev[i].ops = misc->fops;
    __cil_tmp5 = misc->minor;
    __cil_tmp6 = 10 << 20;
    __cil_tmp7 = __cil_tmp6 | __cil_tmp5;
    dev = (unsigned int )__cil_tmp7;
    __cil_tmp8 = & fixed_cdev[i];
    tmp = cdev_add(__cil_tmp8, dev, 0U);
    }
    return (tmp);
  } else {
    return (-1);
  }
}
}
struct tty_driver *alloc_tty_driver(int lines ) ;
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
struct ddv_tty_driver global_tty_driver  ;
struct tty_driver *alloc_tty_driver(int lines ) 
{ void *__cil_tmp2 ;

  {
  if (! global_tty_driver.allocated) {
    global_tty_driver.driver.magic = 21506;
    global_tty_driver.driver.num = lines;
  } else {
    {
    __cil_tmp2 = (void *)0;
    return ((struct tty_driver *)__cil_tmp2);
    }
  }
  return ((struct tty_driver *)0);
}
}
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) 
{ int (*__cil_tmp3)(struct tty_struct *tty , struct file *filp ) ;
  void (*__cil_tmp4)(struct tty_struct *tty , struct file *filp ) ;
  int (*__cil_tmp5)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
  void (*__cil_tmp6)(struct tty_struct *tty , unsigned char ch ) ;
  void (*__cil_tmp7)(struct tty_struct *tty ) ;
  int (*__cil_tmp8)(struct tty_struct *tty ) ;
  int (*__cil_tmp9)(struct tty_struct *tty ) ;
  int (*__cil_tmp10)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                     unsigned long arg ) ;
  void (*__cil_tmp11)(struct tty_struct *tty , struct termios *old ) ;
  void (*__cil_tmp12)(struct tty_struct *tty ) ;
  void (*__cil_tmp13)(struct tty_struct *tty ) ;
  void (*__cil_tmp14)(struct tty_struct *tty ) ;
  void (*__cil_tmp15)(struct tty_struct *tty ) ;
  void (*__cil_tmp16)(struct tty_struct *tty ) ;
  void (*__cil_tmp17)(struct tty_struct *tty , int state ) ;
  void (*__cil_tmp18)(struct tty_struct *tty ) ;
  void (*__cil_tmp19)(struct tty_struct *tty ) ;
  void (*__cil_tmp20)(struct tty_struct *tty , int timeout ) ;
  void (*__cil_tmp21)(struct tty_struct *tty , char ch ) ;
  int (*__cil_tmp22)(char *page , char **start , off_t off , int count , int *eof ,
                     void *data ) ;
  int (*__cil_tmp23)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
  int (*__cil_tmp24)(struct tty_struct *tty , struct file *file ) ;
  int (*__cil_tmp25)(struct tty_struct *tty , struct file *file , unsigned int set ,
                     unsigned int clear ) ;

  {
  __cil_tmp3 = op->open;
  driver->open = (int (*)(struct tty_struct *tty , struct file *filp ))__cil_tmp3;
  __cil_tmp4 = op->close;
  driver->close = (void (*)(struct tty_struct *tty , struct file *filp ))__cil_tmp4;
  __cil_tmp5 = op->write;
  driver->write = (int (*)(struct tty_struct *tty , unsigned char const   *buf , int count ))__cil_tmp5;
  __cil_tmp6 = op->put_char;
  driver->put_char = (void (*)(struct tty_struct *tty , unsigned char ch ))__cil_tmp6;
  __cil_tmp7 = op->flush_chars;
  driver->flush_chars = (void (*)(struct tty_struct *tty ))__cil_tmp7;
  __cil_tmp8 = op->write_room;
  driver->write_room = (int (*)(struct tty_struct *tty ))__cil_tmp8;
  __cil_tmp9 = op->chars_in_buffer;
  driver->chars_in_buffer = (int (*)(struct tty_struct *tty ))__cil_tmp9;
  __cil_tmp10 = op->ioctl;
  driver->ioctl = (int (*)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                           unsigned long arg ))__cil_tmp10;
  __cil_tmp11 = op->set_termios;
  driver->set_termios = (void (*)(struct tty_struct *tty , struct termios *old ))__cil_tmp11;
  __cil_tmp12 = op->throttle;
  driver->throttle = (void (*)(struct tty_struct *tty ))__cil_tmp12;
  __cil_tmp13 = op->unthrottle;
  driver->unthrottle = (void (*)(struct tty_struct *tty ))__cil_tmp13;
  __cil_tmp14 = op->stop;
  driver->stop = (void (*)(struct tty_struct *tty ))__cil_tmp14;
  __cil_tmp15 = op->start;
  driver->start = (void (*)(struct tty_struct *tty ))__cil_tmp15;
  __cil_tmp16 = op->hangup;
  driver->hangup = (void (*)(struct tty_struct *tty ))__cil_tmp16;
  __cil_tmp17 = op->break_ctl;
  driver->break_ctl = (void (*)(struct tty_struct *tty , int state ))__cil_tmp17;
  __cil_tmp18 = op->flush_buffer;
  driver->flush_buffer = (void (*)(struct tty_struct *tty ))__cil_tmp18;
  __cil_tmp19 = op->set_ldisc;
  driver->set_ldisc = (void (*)(struct tty_struct *tty ))__cil_tmp19;
  __cil_tmp20 = op->wait_until_sent;
  driver->wait_until_sent = (void (*)(struct tty_struct *tty , int timeout ))__cil_tmp20;
  __cil_tmp21 = op->send_xchar;
  driver->send_xchar = (void (*)(struct tty_struct *tty , char ch ))__cil_tmp21;
  __cil_tmp22 = op->read_proc;
  driver->read_proc = (int (*)(char *page , char **start , off_t off , int count ,
                               int *eof , void *data ))__cil_tmp22;
  __cil_tmp23 = op->write_proc;
  driver->write_proc = (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                                void *data ))__cil_tmp23;
  __cil_tmp24 = op->tiocmget;
  driver->tiocmget = (int (*)(struct tty_struct *tty , struct file *file ))__cil_tmp24;
  __cil_tmp25 = op->tiocmset;
  driver->tiocmset = (int (*)(struct tty_struct *tty , struct file *file , unsigned int set ,
                              unsigned int clear ))__cil_tmp25;
  return;
}
}
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) 
{ int major ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  return_value = tmp;
  }
  if (return_value == 0) {
    tmp___0 = 1;
  } else {
    if (return_value == -1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  {
  __VERIFIER_assume(tmp___0);
  }
  if (return_value == 0) {
    {
    tmp___1 = __VERIFIER_nondet_uint();
    major = (int )tmp___1;
    __cil_tmp10 = major << 20;
    __cil_tmp11 = (unsigned int )__cil_tmp10;
    *dev = __cil_tmp11 | baseminor;
    }
  } else {

  }
  return (return_value);
}
}
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) 
{ int return_value ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  return_value = tmp;
  }
  if (return_value == 0) {
    tmp___0 = 1;
  } else {
    if (return_value == -1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  {
  __VERIFIER_assume(tmp___0);
  }
  return (return_value);
}
}
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) 
{ struct cdev *cdev ;
  int err ;
  int tmp ;
  unsigned int __cil_tmp7 ;
  void const   *__cil_tmp8 ;

  {
  {
  tmp = register_chrdev_region(0U, 256U, name);
  major = (unsigned int )tmp;
  cdev = cdev_alloc();
  cdev->owner = fops->owner;
  cdev->ops = fops;
  __cil_tmp7 = major << 20;
  err = cdev_add(cdev, __cil_tmp7, 256U);
  }
  if (err) {
    {
    __cil_tmp8 = (void const   *)cdev;
    kfree(__cil_tmp8);
    }
    return (err);
  } else {

  }
  return ((int )major);
}
}
__inline int unregister_chrdev(unsigned int major , char const   *name ) 
{ 

  {
  return (0);
}
}
__inline struct cdev *cdev_alloc(void) 
{ int tmp ;

  {
  if (fixed_cdev_used < 1) {
    tmp = fixed_cdev_used;
    fixed_cdev_used = fixed_cdev_used + 1;
    return (& fixed_cdev[tmp]);
  } else {

  }
  return ((struct cdev *)0);
}
}
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) 
{ 

  {
  cdev->ops = fops;
  return;
}
}
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) 
{ int return_value ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
  p->dev = dev;
  p->count = count;
  tmp = __VERIFIER_nondet_int();
  return_value = tmp;
  }
  if (return_value == 0) {
    tmp___0 = 1;
  } else {
    if (return_value == -1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  {
  __VERIFIER_assume(tmp___0);
  }
  if (return_value == 0) {
    {
    __cil_tmp7 = (int )number_cdev_registered;
    if (__cil_tmp7 < 1) {
      cdev_registered[number_cdev_registered].cdevp = p;
      cdev_registered[number_cdev_registered].inode.i_rdev = dev;
      cdev_registered[number_cdev_registered].inode.i_cdev = p;
      cdev_registered[number_cdev_registered].open = 0;
      __cil_tmp8 = (int )number_cdev_registered;
      __cil_tmp9 = __cil_tmp8 + 1;
      number_cdev_registered = (short )__cil_tmp9;
    } else {
      return (-1);
    }
    }
  } else {

  }
  return (return_value);
}
}
__inline void cdev_del(struct cdev *p ) 
{ int i ;
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  i = 0;
  {
  while (1) {
    while_15_continue: /* CIL Label */ ;
    {
    __cil_tmp3 = (int )number_cdev_registered;
    if (i < __cil_tmp3) {

    } else {
      goto while_15_break;
    }
    }
    {
    __cil_tmp4 = (unsigned long )p;
    __cil_tmp5 = (unsigned long )cdev_registered[i].cdevp;
    if (__cil_tmp5 == __cil_tmp4) {
      cdev_registered[i].cdevp = (struct cdev *)0;
      return;
    } else {

    }
    }
    i = i + 1;
  }
  while_15_break: /* CIL Label */ ;
  }
  return;
}
}
__inline void mutex_init(struct mutex *lock ) 
{ 

  {
  lock->locked = 0;
  lock->init = 1;
  return;
}
}
__inline void mutex_lock(struct mutex *lock ) 
{ 

  {
  {
  __VERIFIER_atomic_begin();
  assert_context_process();
  lock->locked = 1;
  __VERIFIER_atomic_end();
  }
  return;
}
}
__inline void mutex_unlock(struct mutex *lock ) 
{ 

  {
  {
  assert_context_process();
  lock->locked = 0;
  }
  return;
}
}
int ddv_ioport_request_start  ;
int ddv_ioport_request_len  ;
__inline struct resource *request_region(unsigned long start , unsigned long len ,
                                         char const   *name ) 
{ struct resource *resource ;
  void *tmp ;
  unsigned int __cil_tmp7 ;

  {
  {
  __cil_tmp7 = (unsigned int )32UL;
  tmp = malloc(__cil_tmp7);
  resource = (struct resource *)tmp;
  ddv_ioport_request_start = (int )start;
  ddv_ioport_request_len = (int )len;
  }
  return (resource);
}
}
__inline void release_region(unsigned long start , unsigned long len ) 
{ unsigned int i ;

  {
  i = 0U;
  ddv_ioport_request_start = 0;
  ddv_ioport_request_len = 0;
  return;
}
}
__inline unsigned char inb(unsigned int port ) 
{ unsigned char tmp ;

  {
  {
  tmp = __VERIFIER_nondet_uchar();
  }
  return (tmp);
}
}
__inline void outb(unsigned char byte , unsigned int port ) 
{ 

  {
  return;
}
}
__inline unsigned short inw(unsigned int port ) 
{ unsigned short tmp ;

  {
  {
  tmp = __VERIFIER_nondet_ushort();
  }
  return (tmp);
}
}
__inline void outw(unsigned short word , unsigned int port ) 
{ 

  {
  return;
}
}
__inline unsigned int inl(unsigned int port ) 
{ unsigned int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_unsigned();
  }
  return (tmp);
}
}
__inline void outl(unsigned int doubleword , unsigned int port ) 
{ 

  {
  return;
}
}
__inline unsigned char inb_p(unsigned int port ) 
{ int tmp ;
  unsigned char tmp___0 ;
  unsigned int __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  __cil_tmp4 = (unsigned int )ddv_ioport_request_start;
  if (port >= __cil_tmp4) {
    {
    __cil_tmp5 = ddv_ioport_request_start + ddv_ioport_request_len;
    __cil_tmp6 = (unsigned int )__cil_tmp5;
    if (port < __cil_tmp6) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    }
  } else {
    tmp = 0;
  }
  }
  {
  __cil_tmp7 = (char *)"I/O port is requested";
  __VERIFIER_assert(tmp, __cil_tmp7);
  tmp___0 = __VERIFIER_nondet_uchar();
  }
  return (tmp___0);
}
}
__inline void outb_p(unsigned char byte , unsigned int port ) 
{ 

  {
  return;
}
}
__inline unsigned short inw_p(unsigned int port ) 
{ unsigned short tmp ;

  {
  {
  tmp = __VERIFIER_nondet_ushort();
  }
  return (tmp);
}
}
__inline void outw_p(unsigned short word , unsigned int port ) 
{ 

  {
  return;
}
}
__inline unsigned int inl_p(unsigned int port ) 
{ unsigned int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_unsigned();
  }
  return (tmp);
}
}
__inline void outl_p(unsigned int doubleword , unsigned int port ) 
{ 

  {
  return;
}
}
void schedule(void) 
{ 

  {
  {
  assert_context_process();
  }
  return;
}
}
long schedule_timeout(long timeout ) 
{ long tmp ;

  {
  {
  assert_context_process();
  tmp = __VERIFIER_nondet_long();
  }
  return (tmp);
}
}
__inline void sema_init(struct semaphore *sem , int val ) 
{ 

  {
  sem->init = 1;
  sem->locked = 0;
  return;
}
}
__inline void init_MUTEX(struct semaphore *sem ) 
{ 

  {
  sem->init = 1;
  sem->locked = 0;
  return;
}
}
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 

  {
  sem->init = 1;
  sem->locked = 1;
  return;
}
}
__inline void down(struct semaphore *sem ) 
{ 

  {
  {
  __VERIFIER_atomic_begin();
  assert_context_process();
  sem->locked = 1;
  __VERIFIER_atomic_end();
  }
  return;
}
}
__inline int down_interruptible(struct semaphore *sem ) 
{ int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  }
  if (tmp) {
    {
    __VERIFIER_atomic_begin();
    assert_context_process();
    sem->locked = 1;
    __VERIFIER_atomic_end();
    }
    return (0);
  } else {
    return (-1);
  }
}
}
__inline int down_trylock(struct semaphore *sem ) 
{ int __cil_tmp2 ;

  {
  {
  __VERIFIER_atomic_begin();
  assert_context_process();
  }
  {
  __cil_tmp2 = sem->locked;
  if (__cil_tmp2 == 0) {
    sem->locked = 1;
    return (0);
  } else {
    return (1);
  }
  }
  {
  __VERIFIER_atomic_end();
  }
  return (0);
}
}
__inline void up(struct semaphore *sem ) 
{ 

  {
  {
  assert_context_process();
  sem->locked = 0;
  }
  return;
}
}
__inline void tasklet_schedule(struct tasklet_struct *t ) 
{ int i ;
  int next_free ;
  void *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  next_free = -1;
  i = 0;
  {
  while (1) {
    while_16_continue: /* CIL Label */ ;
    if (i < 1) {

    } else {
      goto while_16_break;
    }
    {
    __cil_tmp4 = (void *)0;
    __cil_tmp5 = (unsigned long )__cil_tmp4;
    __cil_tmp6 = (unsigned long )tasklet_registered[i].tasklet;
    if (__cil_tmp6 == __cil_tmp5) {
      next_free = i;
    } else {

    }
    }
    {
    __cil_tmp7 = (unsigned long )t;
    __cil_tmp8 = (unsigned long )tasklet_registered[i].tasklet;
    if (__cil_tmp8 == __cil_tmp7) {
      {
      __cil_tmp9 = (int )tasklet_registered[i].is_running;
      if (__cil_tmp9 == 0) {
        return;
      } else {

      }
      }
    } else {

    }
    }
    i = i + 1;
  }
  while_16_break: /* CIL Label */ ;
  }
  if (next_free == -1) {

  } else {

  }
  tasklet_registered[next_free].tasklet = t;
  tasklet_registered[next_free].is_running = (unsigned short)0;
  return;
}
}
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) 
{ 

  {
  t->count = 0;
  t->init = 0;
  t->func = func;
  t->data = data;
  return;
}
}
__inline void spin_lock_init(spinlock_t *lock ) 
{ 

  {
  lock->init = 1;
  lock->locked = 0;
  return;
}
}
__inline void spin_lock(spinlock_t *lock ) 
{ 

  {
  {
  __VERIFIER_atomic_begin();
  lock->locked = 1;
  __VERIFIER_atomic_end();
  }
  return;
}
}
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) 
{ 

  {
  {
  __VERIFIER_atomic_begin();
  lock->locked = 1;
  __VERIFIER_atomic_end();
  }
  return;
}
}
__inline void spin_lock_irq(spinlock_t *lock ) 
{ 

  {
  {
  __VERIFIER_atomic_begin();
  lock->locked = 1;
  __VERIFIER_atomic_end();
  }
  return;
}
}
__inline void spin_lock_bh(spinlock_t *lock ) 
{ 

  {
  {
  __VERIFIER_atomic_begin();
  lock->locked = 1;
  __VERIFIER_atomic_end();
  }
  return;
}
}
__inline void spin_unlock(spinlock_t *lock ) 
{ 

  {
  lock->locked = 0;
  return;
}
}
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 

  {
  lock->locked = 0;
  return;
}
}
__inline void spin_unlock_irq(spinlock_t *lock ) 
{ 

  {
  lock->locked = 0;
  return;
}
}
__inline void spin_unlock_bh(spinlock_t *lock ) 
{ 

  {
  lock->locked = 0;
  return;
}
}
__inline void init_timer(struct timer_list *timer ) 
{ int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
  __cil_tmp2 = (int )number_timer_registered;
  if (__cil_tmp2 < 1) {
    timer->__ddv_active = (short)0;
    timer->__ddv_init = (short)1;
    timer_registered[number_timer_registered].timer = timer;
    __cil_tmp3 = (int )number_timer_registered;
    __cil_tmp4 = __cil_tmp3 + 1;
    number_timer_registered = (short )__cil_tmp4;
  } else {

  }
  }
  return;
}
}
__inline void add_timer(struct timer_list *timer ) 
{ 

  {
  timer->__ddv_active = (short)1;
  return;
}
}
__inline void add_timer_on(struct timer_list *timer , int cpu ) 
{ 

  {
  {
  add_timer(timer);
  }
  return;
}
}
__inline int del_timer(struct timer_list *timer ) 
{ 

  {
  timer->__ddv_active = (short)0;
  return (0);
}
}
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 

  {
  timer->expires = expires;
  timer->__ddv_active = (short)1;
  return (0);
}
}
__inline void init_waitqueue_head(wait_queue_head_t *q ) 
{ 

  {
  q->init = 1;
  return;
}
}
__inline void wake_up(wait_queue_head_t *q ) 
{ 

  {
  return;
}
}
__inline void wake_up_all(wait_queue_head_t *q ) 
{ 

  {
  return;
}
}
__inline void wake_up_interruptible(wait_queue_head_t *q ) 
{ 

  {
  return;
}
}
__inline void sleep_on(wait_queue_head_t *q ) 
{ 

  {
  return;
}
}
__inline void interruptible_sleep_on(wait_queue_head_t *q ) 
{ 

  {
  return;
}
}
__inline int schedule_work(struct work_struct *work ) 
{ int i ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  i = 0;
  {
  while (1) {
    while_17_continue: /* CIL Label */ ;
    if (i < 10) {

    } else {
      goto while_17_break;
    }
    {
    __cil_tmp3 = (unsigned long )work;
    __cil_tmp4 = (unsigned long )shared_workqueue[i];
    if (__cil_tmp4 == __cil_tmp3) {
      return (0);
    } else {

    }
    }
    {
    __cil_tmp5 = (void *)0;
    __cil_tmp6 = (unsigned long )__cil_tmp5;
    __cil_tmp7 = (unsigned long )shared_workqueue[i];
    if (__cil_tmp7 == __cil_tmp6) {
      shared_workqueue[i] = work;
      return (1);
    } else {

    }
    }
    i = i + 1;
  }
  while_17_break: /* CIL Label */ ;
  }
  return (-1);
}
}
__inline void call_shared_workqueue_functions(void) 
{ unsigned short i ;
  unsigned short tmp ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  void (*__cil_tmp8)(void * ) ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  tmp = __VERIFIER_nondet_ushort();
  i = tmp;
  __cil_tmp3 = (int )i;
  __cil_tmp4 = __cil_tmp3 < 10;
  __VERIFIER_assume(__cil_tmp4);
  }
  {
  __cil_tmp5 = (void *)0;
  __cil_tmp6 = (unsigned long )__cil_tmp5;
  __cil_tmp7 = (unsigned long )shared_workqueue[i];
  if (__cil_tmp7 != __cil_tmp6) {
    {
    __cil_tmp8 = (shared_workqueue[i])->func;
    __cil_tmp9 = (shared_workqueue[i])->data;
    (*__cil_tmp8)(__cil_tmp9);
    __cil_tmp10 = (void *)0;
    shared_workqueue[i] = (struct work_struct *)__cil_tmp10;
    }
  } else {

  }
  }
  return;
}
}
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) 
{ int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  }
  if (tmp) {
    registered_irq[irq].handler = handler;
    registered_irq[irq].dev_id = dev_id;
    return (0);
  } else {
    return (-1);
  }
}
}
void free_irq(unsigned int irq , void *dev_id ) 
{ void *__cil_tmp3 ;

  {
  __cil_tmp3 = (void *)0;
  registered_irq[irq].handler = (irqreturn_t (*)(int  , void * , struct pt_regs * ))__cil_tmp3;
  registered_irq[irq].dev_id = (void *)0;
  return;
}
}
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) 
{ 

  {
  if (gfp_mask & 16U) {
    {
    assert_context_process();
    }
  } else {

  }
  return (0UL);
}
}
__inline unsigned long __get_free_page(gfp_t gfp_mask ) 
{ 

  {
  if (gfp_mask & 16U) {
    {
    assert_context_process();
    }
  } else {

  }
  return (0UL);
}
}
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) 
{ 

  {
  if (gfp_mask & 16U) {
    {
    assert_context_process();
    }
  } else {

  }
  return (0UL);
}
}
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 

  {
  if (gfp_mask & 16U) {
    {
    assert_context_process();
    }
  } else {

  }
  return ((struct page *)0);
}
}
__inline struct page *alloc_page(gfp_t gfp_mask ) 
{ 

  {
  if (gfp_mask & 16U) {
    {
    assert_context_process();
    }
  } else {

  }
  return ((struct page *)0);
}
}
void *kmalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  if (flags & 16U) {
    {
    assert_context_process();
    }
  } else {

  }
  {
  tmp = malloc(size);
  }
  return (tmp);
}
}
void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  if (flags & 16U) {
    {
    assert_context_process();
    }
  } else {

  }
  {
  tmp = malloc(size);
  }
  return (tmp);
}
}
void *vmalloc(unsigned long size ) ;
void *vmalloc(unsigned long size ) 
{ void *tmp ;
  unsigned int __cil_tmp3 ;

  {
  {
  __cil_tmp3 = (unsigned int )size;
  tmp = malloc(__cil_tmp3);
  }
  return (tmp);
}
}
int printk(char const   *fmt  , ...) 
{ 

  {
  return (0);
}
}
unsigned short __VERIFIER_nondet_ushort(void) 
{ unsigned short us ;

  {
  return (us);
}
}
unsigned long __VERIFIER_nondet_ulong(void) 
{ unsigned long ul ;

  {
  return (ul);
}
}
short __VERIFIER_nondet_short(void) 
{ short s ;

  {
  return (s);
}
}
int __VERIFIER_nondet_int(void) 
{ int i ;

  {
  return (i);
}
}
char __VERIFIER_nondet_char(void) 
{ char c ;

  {
  return (c);
}
}
size_t __VERIFIER_nondet_size_t(void) 
{ size_t s ;

  {
  return (s);
}
}
unsigned int __VERIFIER_nondet_uint(void) 
{ unsigned int ui ;

  {
  return (ui);
}
}
unsigned char __VERIFIER_nondet_uchar(void) 
{ unsigned char uc ;

  {
  return (uc);
}
}
unsigned int __VERIFIER_nondet_unsigned(void) 
{ unsigned int u ;

  {
  return (u);
}
}
long __VERIFIER_nondet_long(void) 
{ long l ;

  {
  return (l);
}
}
char *__VERIFIER_nondet_pchar(void) 
{ char *pc ;

  {
  return (pc);
}
}
loff_t __VERIFIER_nondet_loff_t(void) 
{ loff_t l ;

  {
  return (l);
}
}
sector_t __VERIFIER_nondet_sector_t(void) 
{ sector_t s ;

  {
  return (s);
}
}
loff_t no_llseek(struct file *file , loff_t offset , int origin ) 
{ loff_t l ;

  {
  return (l);
}
}
void __VERIFIER_assert(int phi , char *txt ) 
{ 

  {
  if (! phi) {
    ERROR: __VERIFIER_error();
  } else {

  }
  return;
}
}
int nonseekable_open(struct inode *inode , struct file *filp ) 
{ int i ;

  {
  return (i);
}
}
void __module_get(struct module *module ) 
{ 

  {
  return;
}
}
int test_and_set_bit(int nr , unsigned long *addr ) 
{ unsigned int bit ;
  unsigned long old ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  __cil_tmp5 = nr & 31;
  __cil_tmp6 = 1 << __cil_tmp5;
  bit = (unsigned int )__cil_tmp6;
  __cil_tmp7 = nr >> 5;
  addr = addr + __cil_tmp7;
  old = *addr;
  __cil_tmp8 = (unsigned long )bit;
  *addr = old | __cil_tmp8;
  {
  __cil_tmp9 = (unsigned long )bit;
  __cil_tmp10 = old & __cil_tmp9;
  return (__cil_tmp10 != 0UL);
  }
}
}
void clear_bit(int nr , unsigned long volatile   *addr ) 
{ unsigned int bit ;
  unsigned long old ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long volatile   __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;

  {
  __cil_tmp5 = nr & 31;
  __cil_tmp6 = 1 << __cil_tmp5;
  bit = (unsigned int )__cil_tmp6;
  __cil_tmp7 = nr >> 5;
  addr = addr + __cil_tmp7;
  __cil_tmp8 = *addr;
  old = (unsigned long )__cil_tmp8;
  __cil_tmp9 = ~ bit;
  __cil_tmp10 = (unsigned long )__cil_tmp9;
  __cil_tmp11 = old & __cil_tmp10;
  *addr = (unsigned long volatile   )__cil_tmp11;
  return;
}
}
int register_reboot_notifier(struct notifier_block *dummy ) 
{ int i ;

  {
  return (i);
}
}
int misc_deregister(struct miscdevice *misc ) 
{ int i ;

  {
  return (i);
}
}
int unregister_reboot_notifier(struct notifier_block *dummy ) 
{ int i ;

  {
  return (i);
}
}
void release_mem_region(unsigned long start , unsigned long len ) 
{ 

  {
  return;
}
}
void kfree(void const   *addr ) 
{ 

  {
  return;
}
}
struct resource *request_mem_region(unsigned long start , unsigned long len , char const   *name ) 
{ void *tmp ;
  unsigned int __cil_tmp5 ;

  {
  {
  __cil_tmp5 = (unsigned int )32UL;
  tmp = malloc(__cil_tmp5);
  }
  return ((struct resource *)tmp);
}
}
void __VERIFIER_atomic_begin(void) 
{ 

  {
  return;
}
}
void __VERIFIER_atomic_end(void) 
{ 

  {
  return;
}
}
