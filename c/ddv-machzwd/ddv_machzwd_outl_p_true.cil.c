/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 4 "/ddverify-2010-04-30/models/seq1/include/asm/posix_types.h"
typedef unsigned long __kernel_ino_t;
#line 5 "/ddverify-2010-04-30/models/seq1/include/asm/posix_types.h"
typedef unsigned short __kernel_mode_t;
#line 7 "/ddverify-2010-04-30/models/seq1/include/asm/posix_types.h"
typedef long __kernel_off_t;
#line 12 "/ddverify-2010-04-30/models/seq1/include/asm/posix_types.h"
typedef unsigned int __kernel_size_t;
#line 13 "/ddverify-2010-04-30/models/seq1/include/asm/posix_types.h"
typedef int __kernel_ssize_t;
#line 4 "/ddverify-2010-04-30/models/seq1/include/asm/types.h"
typedef unsigned short umode_t;
#line 7 "/ddverify-2010-04-30/models/seq1/include/asm/types.h"
typedef unsigned char __u8;
#line 13 "/ddverify-2010-04-30/models/seq1/include/asm/types.h"
typedef unsigned int __u32;
#line 30 "/ddverify-2010-04-30/models/seq1/include/asm/types.h"
typedef unsigned long long u64;
#line 9 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 11 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 12 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 13 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 15 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 30 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef long long loff_t;
#line 38 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 43 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 88 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef unsigned int gfp_t;
#line 91 "/ddverify-2010-04-30/models/seq1/include/linux/types.h"
typedef unsigned long sector_t;
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/timer.h"
struct timer_list {
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   short __ddv_active ;
   short __ddv_init ;
};
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_1 {
   int init ;
   int locked ;
};
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_1 spinlock_t;
#line 9 "/ddverify-2010-04-30/models/seq1/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 16 "/ddverify-2010-04-30/models/seq1/include/linux/wait.h"
struct __wait_queue_head {
   int number_process_waiting ;
   int wakeup ;
   int init ;
};
#line 22 "/ddverify-2010-04-30/models/seq1/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 25 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
struct __pthread_mutex_t_struct {
   _Bool locked ;
};
#line 30 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
struct __pthread_mutexattr_t_struct {
   int dummy ;
};
#line 52 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
typedef struct __pthread_mutex_t_struct pthread_mutex_t;
#line 53 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
typedef struct __pthread_mutexattr_t_struct pthread_mutexattr_t;
#line 6 "/ddverify-2010-04-30/models/seq1/include/asm/atomic.h"
typedef int atomic_t;
#line 67 "/ddverify-2010-04-30/models/seq1/include/linux/gfp.h"
struct page;
#line 24 "/ddverify-2010-04-30/models/seq1/include/linux/module.h"
struct module {
   int something ;
};
#line 34 "/ddverify-2010-04-30/models/seq1/include/linux/miscdevice.h"
struct file_operations;
#line 34 "/ddverify-2010-04-30/models/seq1/include/linux/miscdevice.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations *fops ;
};
#line 9 "/ddverify-2010-04-30/models/seq1/include/linux/watchdog.h"
struct watchdog_info {
   __u32 options ;
   __u32 firmware_version ;
   __u8 identity[32] ;
};
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/dcache.h"
struct inode;
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/dcache.h"
struct dentry {
   struct inode *d_inode ;
};
#line 4 "/ddverify-2010-04-30/models/seq1/include/asm/semaphore.h"
struct semaphore {
   int init ;
   int locked ;
};
#line 82 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct hd_geometry;
#line 82
struct hd_geometry;
#line 83
struct iovec;
#line 83
struct iovec;
#line 84
struct poll_table_struct;
#line 84
struct poll_table_struct;
#line 85
struct vm_area_struct;
#line 85
struct vm_area_struct;
#line 87
struct page;
#line 90 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct address_space {
   struct inode *host ;
};
#line 94 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct file {
   struct dentry *f_dentry ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   void *private_data ;
   struct address_space *f_mapping ;
};
#line 105
struct gendisk;
#line 105 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct block_device {
   struct inode *bd_inode ;
   struct gendisk *bd_disk ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
};
#line 113
struct cdev;
#line 113 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   struct block_device *i_bdev ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct cdev *i_cdev ;
};
#line 122 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_12 {
   size_t written ;
   size_t count ;
};
#line 122 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_12 read_descriptor_t;
#line 130 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct file_lock {
   int something ;
};
#line 134 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   int (*open_exec)(struct inode * ) ;
};
#line 168 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , unsigned long * ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   struct module *owner ;
};
#line 18 "/ddverify-2010-04-30/models/seq1/include/linux/ioport.h"
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
};
#line 15 "/ddverify-2010-04-30/models/seq1/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *self , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 53 "/ddverify-2010-04-30/models/seq1/include/linux/reboot.h"
struct pt_regs;
#line 53
struct pt_regs;
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/cdev.h"
struct cdev {
   struct module *owner ;
   struct file_operations *ops ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/ddverify-2010-04-30/models/seq1/include/ddverify/cdev.h"
struct ddv_cdev {
   struct cdev *cdevp ;
   struct file filp ;
   struct inode inode ;
   int open ;
};
#line 8 "/ddverify-2010-04-30/models/seq1/include/linux/sysfs.h"
struct module;
#line 8 "/ddverify-2010-04-30/models/seq1/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 8 "/ddverify-2010-04-30/models/seq1/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 25 "/ddverify-2010-04-30/models/seq1/include/linux/device.h"
struct device {
   void *driver_data ;
   void (*release)(struct device *dev ) ;
};
#line 17 "/ddverify-2010-04-30/models/seq1/include/linux/genhd.h"
struct request_queue;
#line 17 "/ddverify-2010-04-30/models/seq1/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   char devfs_name[64] ;
};
#line 12 "/ddverify-2010-04-30/models/seq1/include/linux/workqueue.h"
struct work_struct {
   unsigned long pending ;
   void (*func)(void * ) ;
   void *data ;
   int init ;
};
#line 20 "/ddverify-2010-04-30/models/seq1/include/linux/mutex.h"
struct mutex {
   int locked ;
   int init ;
};
#line 9 "/ddverify-2010-04-30/models/seq1/include/linux/mm_types.h"
struct page {
   int something ;
};
#line 4 "/ddverify-2010-04-30/models/seq1/include/asm/ptrace.h"
struct pt_regs {
   int something ;
};
#line 28 "/ddverify-2010-04-30/models/seq1/include/linux/interrupt.h"
typedef int irqreturn_t;
#line 34 "/ddverify-2010-04-30/models/seq1/include/linux/interrupt.h"
struct tasklet_struct {
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
   int init ;
};
#line 11 "/ddverify-2010-04-30/models/seq1/include/linux/backing-dev.h"
struct backing_dev_info {
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
};
#line 6 "/ddverify-2010-04-30/models/seq1/include/linux/bio.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 13
struct bio;
#line 13
struct bio;
#line 14 "/ddverify-2010-04-30/models/seq1/include/linux/bio.h"
typedef int bio_end_io_t(struct bio * , unsigned int  , int  );
#line 17 "/ddverify-2010-04-30/models/seq1/include/linux/bio.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned short bi_phys_segments ;
   unsigned int bi_size ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
};
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/elevator.h"
struct request;
#line 22 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
struct request_queue;
#line 23 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
typedef struct request_queue request_queue_t;
#line 25 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
typedef void request_fn_proc(request_queue_t *q );
#line 26 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
typedef int make_request_fn(request_queue_t *q , struct bio *bio );
#line 27 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
typedef void unplug_fn(request_queue_t * );
#line 32
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_FLUSH = 7,
    REQ_TYPE_SPECIAL = 8,
    REQ_TYPE_LINUX_BLOCK = 9,
    REQ_TYPE_ATA_CMD = 10,
    REQ_TYPE_ATA_TASK = 11,
    REQ_TYPE_ATA_TASKFILE = 12,
    REQ_TYPE_ATA_PC = 13
} ;
#line 54 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
struct request_queue {
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   unplug_fn *unplug_fn ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   spinlock_t *queue_lock ;
   unsigned short hardsect_size ;
   int __ddv_genhd_no ;
   int __ddv_queue_alive ;
};
#line 90 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct list_head donelist ;
   request_queue_t *q ;
   unsigned long flags ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   struct bio *bio ;
   void *completion_data ;
   struct gendisk *rq_disk ;
   sector_t sector ;
   unsigned long nr_sectors ;
   unsigned int current_nr_sectors ;
   char *buffer ;
   int errors ;
   unsigned short nr_phys_segments ;
   unsigned char cmd[16] ;
};
#line 15 "/ddverify-2010-04-30/models/seq1/include/ddverify/genhd.h"
struct ddv_genhd {
   struct gendisk *gd ;
   struct inode inode ;
   struct file file ;
   struct request current_request ;
   int requests_open ;
};
#line 6 "/ddverify-2010-04-30/models/seq1/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 10 "/ddverify-2010-04-30/models/seq1/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 40 "/ddverify-2010-04-30/models/seq1/include/linux/pci.h"
typedef int pci_power_t;
#line 43
struct pci_bus;
#line 43 "/ddverify-2010-04-30/models/seq1/include/linux/pci.h"
struct pci_dev {
   struct pci_bus *bus ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   u64 dma_mask ;
   struct device dev ;
   unsigned int irq ;
   struct resource resource[12] ;
};
#line 62 "/ddverify-2010-04-30/models/seq1/include/linux/pci.h"
struct pci_bus {
   unsigned char number ;
};
#line 67 "/ddverify-2010-04-30/models/seq1/include/linux/pci.h"
struct pci_driver {
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
};
#line 6 "/ddverify-2010-04-30/models/seq1/include/ddverify/pci.h"
struct ddv_pci_driver {
   struct pci_driver *pci_driver ;
   struct pci_dev pci_dev ;
   unsigned int no_pci_device_id ;
   int dev_initialized ;
};
#line 9 "/ddverify-2010-04-30/models/seq1/include/ddverify/interrupt.h"
struct registered_irq {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   void *dev_id ;
};
#line 10 "/ddverify-2010-04-30/models/seq1/include/ddverify/tasklet.h"
struct ddv_tasklet {
   struct tasklet_struct *tasklet ;
   unsigned short is_running ;
};
#line 10 "/ddverify-2010-04-30/models/seq1/include/ddverify/timer.h"
struct ddv_timer {
   struct timer_list *timer ;
};
#line 4 "/ddverify-2010-04-30/models/seq1/include/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 7 "/ddverify-2010-04-30/models/seq1/include/linux/proc_fs.h"
struct proc_dir_entry {
   int something ;
};
#line 9 "/ddverify-2010-04-30/models/seq1/include/linux/seq_file.h"
struct file;
#line 11
struct dentry;
#line 12
struct inode;
#line 6 "/ddverify-2010-04-30/models/seq1/include/asm/termbits.h"
typedef unsigned char cc_t;
#line 8 "/ddverify-2010-04-30/models/seq1/include/asm/termbits.h"
typedef unsigned int tcflag_t;
#line 11 "/ddverify-2010-04-30/models/seq1/include/asm/termbits.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
#line 9 "/ddverify-2010-04-30/models/seq1/include/linux/tty_driver.h"
struct tty_struct;
#line 9
struct tty_struct;
#line 12 "/ddverify-2010-04-30/models/seq1/include/linux/tty_driver.h"
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 43 "/ddverify-2010-04-30/models/seq1/include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 113 "/ddverify-2010-04-30/models/seq1/include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   unsigned long flags ;
   int count ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned int receive_room ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   void *disc_data ;
   void *driver_data ;
   unsigned char closing : 1 ;
};
#line 7 "/ddverify-2010-04-30/models/seq1/include/ddverify/tty.h"
struct ddv_tty_driver {
   struct tty_driver driver ;
   unsigned short allocated ;
   unsigned short registered ;
};
#line 2 "/ddverify-2010-04-30/models/seq1/include/ddverify/ddverify.h"
void __VERIFIER_assume(int phi ) ;
#line 3
void __VERIFIER_assert(int phi , char *txt ) ;
#line 12 "/ddverify-2010-04-30/models/seq1/include/ddverify/ddverify.h"
int current_execution_context  ;
#line 32 "/ddverify-2010-04-30/models/seq1/include/ddverify/ddverify.h"
__inline static int assert_context_process(void) 
{ 

  {
#line 34
  return (0);
}
}
#line 42 "/ddverify-2010-04-30/models/seq1/include/ddverify/ddverify.h"
int (*_ddv_module_init)(void)  ;
#line 43 "/ddverify-2010-04-30/models/seq1/include/ddverify/ddverify.h"
void (*_ddv_module_exit)(void)  ;
#line 45
int call_ddv(void) ;
#line 7 "/ddverify-2010-04-30/models/seq1/include/linux/jiffies.h"
unsigned long jiffies  ;
#line 26 "/ddverify-2010-04-30/models/seq1/include/linux/timer.h"
__inline void init_timer(struct timer_list *timer ) ;
#line 27
__inline void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 28
__inline void add_timer(struct timer_list *timer ) ;
#line 29
__inline int del_timer(struct timer_list *timer ) ;
#line 30
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 9 "/ddverify-2010-04-30/models/seq1/include/linux/spinlock.h"
__inline void spin_lock_init(spinlock_t *lock ) ;
#line 10
__inline void spin_lock(spinlock_t *lock ) ;
#line 11
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) ;
#line 12
__inline void spin_lock_irq(spinlock_t *lock ) ;
#line 13
__inline void spin_lock_bh(spinlock_t *lock ) ;
#line 15
__inline void spin_unlock(spinlock_t *lock ) ;
#line 16
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 17
__inline void spin_unlock_irq(spinlock_t *lock ) ;
#line 18
__inline void spin_unlock_bh(spinlock_t *lock ) ;
#line 62 "/ddverify-2010-04-30/models/seq1/include/linux/wait.h"
__inline void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 69
__inline void wake_up(wait_queue_head_t *q ) ;
#line 71
__inline void wake_up_all(wait_queue_head_t *q ) ;
#line 73
__inline void wake_up_interruptible(wait_queue_head_t *q ) ;
#line 86
__inline void sleep_on(wait_queue_head_t *q ) ;
#line 88
__inline void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 186 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
__inline extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__mutex_attr ) 
{ pthread_mutex_t i ;

  {
#line 190
  i.locked = (_Bool)0;
#line 191
  *__mutex = i;
#line 192
  return (0);
}
}
#line 194 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
__inline extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) 
{ 

  {
#line 196
  return (0);
}
}
#line 200
void __VERIFIER_atomic_begin(void) ;
#line 201
void __VERIFIER_atomic_end(void) ;
#line 203 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
__inline extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) 
{ _Bool __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 206
  __VERIFIER_atomic_begin();
#line 207
  __cil_tmp2 = __mutex->locked;
#line 207
  __cil_tmp3 = ! __cil_tmp2;
#line 207
  __VERIFIER_assume(__cil_tmp3);
#line 208
  __mutex->locked = (_Bool)1;
#line 209
  __VERIFIER_atomic_end();
  }
#line 210
  return (0);
}
}
#line 213 "/ddverify-2010-04-30/models/seq1/include/ddverify/pthread.h"
__inline extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) 
{ 

  {
#line 215
  __mutex->locked = (_Bool)0;
#line 216
  return (0);
}
}
#line 10 "/ddverify-2010-04-30/models/seq1/include/ddverify/satabs.h"
extern void *malloc(size_t size ) ;
#line 15
short __VERIFIER_nondet_short(void) ;
#line 16
unsigned short __VERIFIER_nondet_ushort(void) ;
#line 17
int __VERIFIER_nondet_int(void) ;
#line 18
unsigned int __VERIFIER_nondet_uint(void) ;
#line 19
long __VERIFIER_nondet_long(void) ;
#line 20
unsigned long __VERIFIER_nondet_ulong(void) ;
#line 21
char __VERIFIER_nondet_char(void) ;
#line 22
unsigned char __VERIFIER_nondet_uchar(void) ;
#line 23
unsigned int __VERIFIER_nondet_unsigned(void) ;
#line 24
loff_t __VERIFIER_nondet_loff_t(void) ;
#line 25
size_t __VERIFIER_nondet_size_t(void) ;
#line 26
sector_t __VERIFIER_nondet_sector_t(void) ;
#line 28
char *__VERIFIER_nondet_pchar(void) ;
#line 55 "/ddverify-2010-04-30/models/seq1/include/linux/gfp.h"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 57
__inline unsigned long __get_free_page(gfp_t gfp_mask ) ;
#line 59
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 70
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 72
__inline struct page *alloc_page(gfp_t gfp_mask ) ;
#line 8 "/ddverify-2010-04-30/models/seq1/include/linux/slab.h"
void kfree(void const   *addr ) ;
#line 10
void *kmalloc(size_t size , gfp_t flags ) ;
#line 12
void *kzalloc(size_t size , gfp_t flags ) ;
#line 6 "/ddverify-2010-04-30/models/seq1/include/asm/bitops.h"
int test_and_set_bit(int nr , unsigned long *addr ) ;
#line 10
void clear_bit(int nr , unsigned long volatile   *addr ) ;
#line 43 "/ddverify-2010-04-30/models/seq1/include/linux/sched.h"
void schedule(void) ;
#line 45
long schedule_timeout(long timeout ) ;
#line 34 "/ddverify-2010-04-30/models/seq1/include/linux/kernel.h"
int printk(char const   *fmt  , ...) ;
#line 30 "/ddverify-2010-04-30/models/seq1/include/linux/module.h"
void __module_get(struct module *module ) ;
#line 40 "/ddverify-2010-04-30/models/seq1/include/linux/miscdevice.h"
int misc_register(struct miscdevice *misc ) ;
#line 41
int misc_deregister(struct miscdevice *misc ) ;
#line 23 "/ddverify-2010-04-30/models/seq1/include/asm/semaphore.h"
__inline void sema_init(struct semaphore *sem , int val ) ;
#line 25
__inline void init_MUTEX(struct semaphore *sem ) ;
#line 27
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) ;
#line 29
__inline void down(struct semaphore *sem ) ;
#line 31
__inline int down_interruptible(struct semaphore *sem ) ;
#line 33
__inline int down_trylock(struct semaphore *sem ) ;
#line 35
__inline void up(struct semaphore *sem ) ;
#line 195 "/ddverify-2010-04-30/models/seq1/include/linux/fs.h"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) ;
#line 196
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) ;
#line 199
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) ;
#line 200
__inline int unregister_chrdev(unsigned int major , char const   *name ) ;
#line 207
int register_blkdev(unsigned int major , char const   *name ) ;
#line 208
int unregister_blkdev(unsigned int major , char const   *name ) ;
#line 223
loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
#line 233
int nonseekable_open(struct inode *inode , struct file *filp ) ;
#line 90 "/ddverify-2010-04-30/models/seq1/include/linux/ioport.h"
__inline struct resource *request_region(unsigned long start , unsigned long len ,
                                         char const   *name ) ;
#line 92
__inline void release_region(unsigned long start , unsigned long len ) ;
#line 96
struct resource *request_mem_region(unsigned long start , unsigned long len , char const   *name ) ;
#line 98
void release_mem_region(unsigned long start , unsigned long len ) ;
#line 40 "/ddverify-2010-04-30/models/seq1/include/linux/reboot.h"
int register_reboot_notifier(struct notifier_block *dummy ) ;
#line 41
int unregister_reboot_notifier(struct notifier_block *dummy ) ;
#line 14 "/ddverify-2010-04-30/models/seq1/include/asm/io.h"
__inline unsigned char inb(unsigned int port ) ;
#line 15
__inline void outb(unsigned char byte , unsigned int port ) ;
#line 16
__inline unsigned short inw(unsigned int port ) ;
#line 17
__inline void outw(unsigned short word , unsigned int port ) ;
#line 18
__inline unsigned int inl(unsigned int port ) ;
#line 19
__inline void outl(unsigned int doubleword , unsigned int port ) ;
#line 23
__inline unsigned char inb_p(unsigned int port ) ;
#line 24
__inline void outb_p(unsigned char byte , unsigned int port ) ;
#line 25
__inline unsigned short inw_p(unsigned int port ) ;
#line 26
__inline void outw_p(unsigned short word , unsigned int port ) ;
#line 27
__inline unsigned int inl_p(unsigned int port ) ;
#line 28
__inline void outl_p(unsigned int doubleword , unsigned int port ) ;
#line 41 "/ddverify-2010-04-30/models/seq1/include/asm/uaccess.h"
__inline int __get_user(int size , void *ptr ) ;
#line 43
__inline int get_user(int size , void *ptr ) ;
#line 46
__inline int __put_user(int size , void *ptr ) ;
#line 48
__inline int put_user(int size , void *ptr ) ;
#line 51
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 53
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) ;
#line 84 "machzwd.c"
static unsigned short zf_readw(unsigned char port ) 
{ unsigned short tmp ;

  {
  {
#line 86
  outb(port, 536U);
#line 87
  tmp = inw(538U);
  }
#line 87
  return (tmp);
}
}
#line 91 "machzwd.c"
char _ddv_module_author[44]  = 
#line 91
  {      (char )'F',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'n',      (char )'d',      (char )'o', 
        (char )' ',      (char )'F',      (char )'u',      (char )'g', 
        (char )'a',      (char )'n',      (char )'t',      (char )'i', 
        (char )' ',      (char )'<',      (char )'f',      (char )'u', 
        (char )'g',      (char )'a',      (char )'n',      (char )'t', 
        (char )'i',      (char )'@',      (char )'c',      (char )'o', 
        (char )'n',      (char )'e',      (char )'c',      (char )'t', 
        (char )'i',      (char )'v',      (char )'a',      (char )'.', 
        (char )'c',      (char )'o',      (char )'m',      (char )'.', 
        (char )'b',      (char )'r',      (char )'>',      (char )'\000'};
#line 92 "machzwd.c"
char _ddv_module_description[31]  = 
#line 92
  {      (char )'M',      (char )'a',      (char )'c',      (char )'h', 
        (char )'Z',      (char )' ',      (char )'Z',      (char )'F', 
        (char )'-',      (char )'L',      (char )'o',      (char )'g', 
        (char )'i',      (char )'c',      (char )' ',      (char )'W', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )'d',      (char )'o',      (char )'g',      (char )' ', 
        (char )'d',      (char )'r',      (char )'i',      (char )'v', 
        (char )'e',      (char )'r',      (char )'\000'};
#line 93 "machzwd.c"
char _ddv_module_license[4]  = {      (char )'G',      (char )'P',      (char )'L',      (char )'\000'};
#line 96 "machzwd.c"
static int nowayout  =    0;
#line 98 "machzwd.c"
char _ddv_module_param_nowayout[75]  = 
#line 98
  {      (char )'W',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )'d',      (char )'o',      (char )'g', 
        (char )' ',      (char )'c',      (char )'a',      (char )'n', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'s', 
        (char )'t',      (char )'o',      (char )'p',      (char )'p', 
        (char )'e',      (char )'d',      (char )' ',      (char )'o', 
        (char )'n',      (char )'c',      (char )'e',      (char )' ', 
        (char )'s',      (char )'t',      (char )'a',      (char )'r', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'(',      (char )'d',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )'=',      (char )'C',      (char )'O',      (char )'N', 
        (char )'F',      (char )'I',      (char )'G',      (char )'_', 
        (char )'W',      (char )'A',      (char )'T',      (char )'C', 
        (char )'H',      (char )'D',      (char )'O',      (char )'G', 
        (char )'_',      (char )'N',      (char )'O',      (char )'W', 
        (char )'A',      (char )'Y',      (char )'O',      (char )'U', 
        (char )'T',      (char )')',      (char )'\000'};
#line 102 "machzwd.c"
static struct watchdog_info zf_info  =    {(__u32 )33024, (__u32 )1, {(__u8 )'Z', (__u8 )'F', (__u8 )'-', (__u8 )'L', (__u8 )'o',
                               (__u8 )'g', (__u8 )'i', (__u8 )'c', (__u8 )' ', (__u8 )'w',
                               (__u8 )'a', (__u8 )'t', (__u8 )'c', (__u8 )'h', (__u8 )'d',
                               (__u8 )'o', (__u8 )'g', (__u8 )'\000', (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0, (unsigned char)0, (unsigned char)0,
                               (unsigned char)0}};
#line 117 "machzwd.c"
static int action  =    0;
#line 119 "machzwd.c"
char _ddv_module_param_action[73]  = 
#line 119
  {      (char )'a',      (char )'f',      (char )'t',      (char )'e', 
        (char )'r',      (char )' ',      (char )'w',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )'d', 
        (char )'o',      (char )'g',      (char )' ',      (char )'r', 
        (char )'e',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )',',      (char )' ',      (char )'g', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )':', 
        (char )' ',      (char )'0',      (char )' ',      (char )'=', 
        (char )' ',      (char )'R',      (char )'E',      (char )'S', 
        (char )'E',      (char )'T',      (char )'(',      (char )'*', 
        (char )')',      (char )' ',      (char )' ',      (char )'1', 
        (char )' ',      (char )'=',      (char )' ',      (char )'S', 
        (char )'M',      (char )'I',      (char )' ',      (char )' ', 
        (char )'2',      (char )' ',      (char )'=',      (char )' ', 
        (char )'N',      (char )'M',      (char )'I',      (char )' ', 
        (char )' ',      (char )'3',      (char )' ',      (char )'=', 
        (char )' ',      (char )'S',      (char )'C',      (char )'I', 
        (char )'\000'};
#line 121 "machzwd.c"
static int zf_action  =    2048;
#line 122 "machzwd.c"
static unsigned long zf_is_open  ;
#line 123 "machzwd.c"
static char zf_expect_close  ;
#line 124 "machzwd.c"
static spinlock_t zf_lock  ;
#line 125 "machzwd.c"
static spinlock_t zf_port_lock  ;
#line 126 "machzwd.c"
static struct timer_list zf_timer  ;
#line 127 "machzwd.c"
static unsigned long next_heartbeat  =    0UL;
#line 146 "machzwd.c"
__inline static void zf_set_status(unsigned char new ) 
{ 

  {
  {
#line 148
  outb((unsigned char)18, 536U);
#line 148
  outb(new, 537U);
  }
#line 149
  return;
}
}
#line 154 "machzwd.c"
__inline static unsigned short zf_get_control(void) 
{ unsigned short tmp ;

  {
  {
#line 156
  tmp = zf_readw((unsigned char)16);
  }
#line 156
  return (tmp);
}
}
#line 159 "machzwd.c"
__inline static void zf_set_control(unsigned short new ) 
{ 

  {
  {
#line 161
  outb((unsigned char)16, 536U);
#line 161
  outw(new, 538U);
  }
#line 162
  return;
}
}
#line 170 "machzwd.c"
__inline static void zf_set_timer(unsigned short new , unsigned char n ) 
{ int tmp ;
  int __cil_tmp4 ;
  unsigned char __cil_tmp5 ;

  {
#line 173
  if ((int )n == 0) {
    goto switch_0_0;
  } else {
#line 175
    if ((int )n == 1) {
      goto switch_0_1;
    } else {
      {
      goto switch_0_default;
#line 172
      if (0) {
        switch_0_0: /* CIL Label */ 
        {
#line 174
        outb((unsigned char)12, 536U);
#line 174
        outw(new, 538U);
        }
        switch_0_1: /* CIL Label */ 
        {
#line 176
        outb((unsigned char)14, 536U);
        }
        {
#line 176
        __cil_tmp4 = (int )new;
#line 176
        if (__cil_tmp4 > 255) {
#line 176
          tmp = 255;
        } else {
#line 176
          tmp = (int )new;
        }
        }
        {
#line 176
        __cil_tmp5 = (unsigned char )tmp;
#line 176
        outb(__cil_tmp5, 537U);
        }
        switch_0_default: /* CIL Label */ ;
#line 178
        return;
      } else {
        switch_0_break: /* CIL Label */ ;
      }
      }
    }
  }
}
}
#line 185 "machzwd.c"
static void zf_timer_off(void) 
{ unsigned int ctrl_reg ;
  unsigned long flags ;
  unsigned short tmp ;
  unsigned short __cil_tmp4 ;

  {
  {
#line 187
  ctrl_reg = 0U;
#line 191
  del_timer(& zf_timer);
#line 193
  spin_lock_irqsave(& zf_port_lock, flags);
#line 195
  tmp = zf_get_control();
#line 195
  ctrl_reg = (unsigned int )tmp;
#line 196
  ctrl_reg = ctrl_reg | 3U;
#line 197
  ctrl_reg = ctrl_reg & 4294967292U;
#line 198
  __cil_tmp4 = (unsigned short )ctrl_reg;
#line 198
  zf_set_control(__cil_tmp4);
#line 199
  spin_unlock_irqrestore(& zf_port_lock, flags);
#line 201
  printk("<6>machzwd: Watchdog timer is now disabled\n");
  }
#line 202
  return;
}
}
#line 208 "machzwd.c"
static void zf_timer_on(void) 
{ unsigned int ctrl_reg ;
  unsigned long flags ;
  unsigned short tmp ;
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned short __cil_tmp6 ;

  {
  {
#line 210
  ctrl_reg = 0U;
#line 213
  spin_lock_irqsave(& zf_port_lock, flags);
#line 215
  outb((unsigned char)15, 536U);
#line 215
  outb((unsigned char)255, 537U);
#line 217
  zf_set_timer((unsigned short)65535, (unsigned char)0);
#line 220
  next_heartbeat = jiffies + 1000UL;
#line 223
  zf_timer.expires = jiffies + 50UL;
#line 225
  add_timer(& zf_timer);
#line 228
  tmp = zf_get_control();
#line 228
  ctrl_reg = (unsigned int )tmp;
#line 229
  __cil_tmp4 = 1 | zf_action;
#line 229
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 229
  ctrl_reg = ctrl_reg | __cil_tmp5;
#line 230
  __cil_tmp6 = (unsigned short )ctrl_reg;
#line 230
  zf_set_control(__cil_tmp6);
#line 231
  spin_unlock_irqrestore(& zf_port_lock, flags);
#line 233
  printk("<6>machzwd: Watchdog timer is now enabled\n");
  }
#line 234
  return;
}
}
#line 237 "machzwd.c"
static void zf_ping(unsigned long data ) 
{ unsigned int ctrl_reg ;
  unsigned long flags ;
  unsigned short tmp ;
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  unsigned short __cil_tmp8 ;
  unsigned short __cil_tmp9 ;

  {
  {
#line 239
  ctrl_reg = 0U;
#line 242
  outb((unsigned char)14, 536U);
#line 242
  outb((unsigned char)255, 537U);
  }
  {
#line 244
  __cil_tmp5 = (long )next_heartbeat;
#line 244
  __cil_tmp6 = (long )jiffies;
#line 244
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
#line 244
  if (__cil_tmp7 < 0L) {
    {
#line 253
    spin_lock_irqsave(& zf_port_lock, flags);
#line 254
    tmp = zf_get_control();
#line 254
    ctrl_reg = (unsigned int )tmp;
#line 255
    ctrl_reg = ctrl_reg | 16U;
#line 256
    __cil_tmp8 = (unsigned short )ctrl_reg;
#line 256
    zf_set_control(__cil_tmp8);
#line 259
    ctrl_reg = ctrl_reg & 4294967279U;
#line 260
    __cil_tmp9 = (unsigned short )ctrl_reg;
#line 260
    zf_set_control(__cil_tmp9);
#line 261
    spin_unlock_irqrestore(& zf_port_lock, flags);
#line 263
    zf_timer.expires = jiffies + 50UL;
#line 264
    add_timer(& zf_timer);
    }
  } else {
    {
#line 266
    printk("<2>machzwd: I will reset your machine\n");
    }
  }
  }
#line 268
  return;
}
}
#line 270 "machzwd.c"
static ssize_t zf_write(struct file *file , char const   *buf , size_t count , loff_t *ppos ) 
{ size_t ofs ;
  char c ;
  int tmp ;
  int __cil_tmp8 ;
  char const   *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 274
  if (count) {
#line 280
    if (! nowayout) {
#line 287
      zf_expect_close = (char)0;
#line 290
      ofs = 0U;
      {
#line 290
      while (1) {
        while_1_continue: /* CIL Label */ ;
#line 290
        if (ofs != count) {

        } else {
          goto while_1_break;
        }
        {
#line 292
        __cil_tmp8 = (int )c;
#line 292
        __cil_tmp9 = buf + ofs;
#line 292
        __cil_tmp10 = (void *)__cil_tmp9;
#line 292
        tmp = get_user(__cil_tmp8, __cil_tmp10);
        }
#line 292
        if (tmp) {
#line 293
          return (-14);
        } else {

        }
        {
#line 294
        __cil_tmp11 = (int )c;
#line 294
        if (__cil_tmp11 == 86) {
#line 295
          zf_expect_close = (char)42;
        } else {

        }
        }
#line 290
        ofs = ofs + 1U;
      }
      while_1_break: /* CIL Label */ ;
      }
    } else {

    }
#line 305
    next_heartbeat = jiffies + 1000UL;
  } else {

  }
#line 310
  return ((int )count);
}
}
#line 313 "machzwd.c"
static int zf_ioctl(struct inode *inode , struct file *file , unsigned int cmd , unsigned long arg ) 
{ void *argp ;
  int *p ;
  unsigned long tmp ;
  int tmp___0 ;
  void const   *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 316
  argp = (void *)arg;
#line 317
  p = (int *)argp;
#line 319
  if ((int )cmd == (__cil_tmp15 | __cil_tmp10)) {
    goto switch_2_exp_0;
  } else {
#line 324
    if ((int )cmd == (__cil_tmp23 | __cil_tmp17)) {
      goto switch_2_exp_1;
    } else {
#line 327
      if ((int )cmd == (__cil_tmp30 | __cil_tmp24)) {
        goto switch_2_exp_2;
      } else {
        {
        goto switch_2_default;
#line 318
        if (0) {
          switch_2_exp_0: /* CIL Label */ 
          {
#line 320
          __cil_tmp10 = 40UL << 16;
#line 320
          __cil_tmp11 = 87 << 8;
#line 320
          __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 320
          __cil_tmp13 = 2U << 30;
#line 320
          __cil_tmp14 = __cil_tmp13 | __cil_tmp12;
#line 320
          __cil_tmp15 = (unsigned long )__cil_tmp14;
          {
#line 320
          __cil_tmp9 = (void const   *)(& zf_info);
#line 320
          tmp = copy_to_user(argp, __cil_tmp9, 40UL);
          }
          }
#line 320
          if (tmp) {
#line 321
            return (-14);
          } else {

          }
          goto switch_2_break;
          switch_2_exp_1: /* CIL Label */ 
          {
#line 325
          __cil_tmp17 = 4UL << 16;
#line 325
          __cil_tmp18 = 87 << 8;
#line 325
          __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 325
          __cil_tmp20 = 2U << 30;
#line 325
          __cil_tmp21 = __cil_tmp20 | __cil_tmp19;
#line 325
          __cil_tmp22 = __cil_tmp21 | 1U;
#line 325
          __cil_tmp23 = (unsigned long )__cil_tmp22;
          {
#line 325
          __cil_tmp16 = (void *)p;
#line 325
          tmp___0 = put_user(0, __cil_tmp16);
          }
          }
#line 325
          return (tmp___0);
          switch_2_exp_2: /* CIL Label */ 
          {
#line 328
          __cil_tmp24 = 4UL << 16;
#line 328
          __cil_tmp25 = 87 << 8;
#line 328
          __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 328
          __cil_tmp27 = 2U << 30;
#line 328
          __cil_tmp28 = __cil_tmp27 | __cil_tmp26;
#line 328
          __cil_tmp29 = __cil_tmp28 | 5U;
#line 328
          __cil_tmp30 = (unsigned long )__cil_tmp29;
          {
#line 328
          zf_ping(0UL);
          }
          }
          goto switch_2_break;
          switch_2_default: /* CIL Label */ ;
#line 332
          return (-25);
        } else {
          switch_2_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 335
  return (0);
}
}
#line 338 "machzwd.c"
static int zf_open(struct inode *inode , struct file *file ) 
{ int tmp ;
  int tmp___0 ;
  struct module *__cil_tmp5 ;

  {
  {
#line 340
  spin_lock(& zf_lock);
#line 341
  tmp = test_and_set_bit(0, & zf_is_open);
  }
#line 341
  if (tmp) {
    {
#line 342
    spin_unlock(& zf_lock);
    }
#line 343
    return (-16);
  } else {

  }
#line 346
  if (nowayout) {
    {
#line 347
    __cil_tmp5 = (struct module *)0;
#line 347
    __module_get(__cil_tmp5);
    }
  } else {

  }
  {
#line 349
  spin_unlock(& zf_lock);
#line 351
  zf_timer_on();
#line 353
  tmp___0 = nonseekable_open(inode, file);
  }
#line 353
  return (tmp___0);
}
}
#line 356 "machzwd.c"
static int zf_close(struct inode *inode , struct file *file ) 
{ int __cil_tmp3 ;
  unsigned long volatile   *__cil_tmp4 ;

  {
  {
#line 358
  __cil_tmp3 = (int )zf_expect_close;
#line 358
  if (__cil_tmp3 == 42) {
    {
#line 359
    zf_timer_off();
    }
  } else {
    {
#line 361
    del_timer(& zf_timer);
#line 362
    printk("<3>machzwd: device file closed unexpectedly. Will not stop the WDT!\n");
    }
  }
  }
  {
#line 365
  spin_lock(& zf_lock);
#line 366
  __cil_tmp4 = (unsigned long volatile   *)(& zf_is_open);
#line 366
  clear_bit(0, __cil_tmp4);
#line 367
  spin_unlock(& zf_lock);
#line 369
  zf_expect_close = (char)0;
  }
#line 371
  return (0);
}
}
#line 378 "machzwd.c"
static int zf_notify_sys(struct notifier_block *this , unsigned long code , void *unused ) 
{ 

  {
#line 381
  if (code == 1UL) {
    {
#line 382
    zf_timer_off();
    }
  } else {
#line 381
    if (code == 2UL) {
      {
#line 382
      zf_timer_off();
      }
    } else {

    }
  }
#line 385
  return (0);
}
}
#line 391 "machzwd.c"
static struct file_operations  const  zf_fops  = 
#line 391
     {(struct module *)0, & no_llseek, (ssize_t (*)(struct file * , char * , size_t  ,
                                                  loff_t * ))0, & zf_write, (int (*)(struct file * ,
                                                                                     void * ,
                                                                                     int (*)(void * ,
                                                                                             char const   * ,
                                                                                             int  ,
                                                                                             loff_t  ,
                                                                                             ino_t  ,
                                                                                             unsigned int  ) ))0,
    (unsigned int (*)(struct file * , struct poll_table_struct * ))0, & zf_ioctl,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & zf_open, (int (*)(struct file * ))0,
    & zf_close, (int (*)(struct file * , struct dentry * , int datasync ))0, (int (*)(int  ,
                                                                                      struct file * ,
                                                                                      int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct iovec  const  * ,
                                                                         unsigned long  ,
                                                                         loff_t * ))0,
    (ssize_t (*)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ))0,
    (ssize_t (*)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                              struct page * , unsigned long  ,
                                                              unsigned long  ) , void * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file *filp ,
                                                                       unsigned long arg ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (int (*)(struct inode * ))0};
#line 400 "machzwd.c"
static struct miscdevice zf_miscdev  =    {130, "watchdog", (struct file_operations *)(& zf_fops)};
#line 411 "machzwd.c"
static struct notifier_block zf_notifier  =    {& zf_notify_sys, (struct notifier_block *)0, 0};
#line 415 "machzwd.c"
static void zf_show_action(int act ) 
{ char *str[4] ;

  {
  {
#line 417
  str[0] = (char *)"RESET";
#line 417
  str[1] = (char *)"SMI";
#line 417
  str[2] = (char *)"NMI";
#line 417
  str[3] = (char *)"SCI";
#line 419
  printk("<6>machzwd: Watchdog using action = %s\n", str[act]);
  }
#line 420
  return;
}
}
#line 422 "machzwd.c"
static int zf_init(void) 
{ int ret ;
  unsigned short tmp ;
  struct resource *tmp___0 ;

  {
  {
#line 426
  printk("<6>machzwd: MachZ ZF-Logic Watchdog driver initializing.\n");
#line 428
  tmp = zf_readw((unsigned char)2);
#line 428
  ret = (int )tmp;
  }
#line 429
  if (! ret) {
    {
#line 430
    printk("<4>machzwd: no ZF-Logic found\n");
    }
#line 431
    return (-19);
  } else {
#line 429
    if (ret == 65535) {
      {
#line 430
      printk("<4>machzwd: no ZF-Logic found\n");
      }
#line 431
      return (-19);
    } else {

    }
  }
#line 434
  if (action <= 3) {
#line 434
    if (action >= 0) {
#line 435
      zf_action = zf_action >> action;
    } else {
#line 437
      action = 0;
    }
  } else {
#line 437
    action = 0;
  }
  {
#line 439
  zf_show_action(action);
#line 441
  spin_lock_init(& zf_lock);
#line 442
  spin_lock_init(& zf_port_lock);
#line 444
  ret = misc_register(& zf_miscdev);
  }
#line 445
  if (ret) {
    {
#line 446
    printk("<3>can\'t misc_register on minor=%d\n", 130);
    }
    goto out;
  } else {

  }
  {
#line 451
  tmp___0 = request_region(536UL, 3UL, "MachZ ZFL WDT");
  }
#line 451
  if (tmp___0) {

  } else {
    {
#line 452
    printk("<3>cannot reserve I/O ports at %d\n", 536);
#line 454
    ret = -16;
    }
    goto no_region;
  }
  {
#line 458
  ret = register_reboot_notifier(& zf_notifier);
  }
#line 459
  if (ret) {
    {
#line 460
    printk("<3>can\'t register reboot notifier (err=%d)\n", ret);
    }
    goto no_reboot;
  } else {

  }
  {
#line 465
  zf_set_status((unsigned char)0);
#line 466
  zf_set_control((unsigned short)0);
#line 469
  init_timer(& zf_timer);
#line 470
  zf_timer.function = & zf_ping;
#line 471
  zf_timer.data = 0UL;
  }
#line 473
  return (0);
  no_reboot: 
  {
#line 476
  release_region(536UL, 3UL);
  }
  no_region: 
  {
#line 478
  misc_deregister(& zf_miscdev);
  }
  out: 
#line 480
  return (ret);
}
}
#line 484 "machzwd.c"
static void zf_exit(void) 
{ 

  {
  {
#line 486
  zf_timer_off();
#line 488
  misc_deregister(& zf_miscdev);
#line 489
  unregister_reboot_notifier(& zf_notifier);
#line 490
  release_region(536UL, 3UL);
  }
#line 491
  return;
}
}
#line 493 "machzwd.c"
int (*_ddv_tmp_init)(void)  =    & zf_init;
#line 494 "machzwd.c"
void (*_ddv_tmp_exit)(void)  =    & zf_exit;
#line 4 "concatenated.c"
int main(void) 
{ 

  {
  {
#line 6
  _ddv_module_init = & zf_init;
#line 7
  _ddv_module_exit = & zf_exit;
#line 8
  call_ddv();
  }
#line 10
  return (0);
}
}
#line 11 "/ddverify-2010-04-30/models/seq1/include/linux/cdev.h"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) ;
#line 13
__inline struct cdev *cdev_alloc(void) ;
#line 17
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) ;
#line 19
__inline void cdev_del(struct cdev *p ) ;
#line 12 "/ddverify-2010-04-30/models/seq1/include/ddverify/fixed_cdev.h"
struct cdev fixed_cdev[1]  ;
#line 13 "/ddverify-2010-04-30/models/seq1/include/ddverify/fixed_cdev.h"
int fixed_cdev_used  =    0;
#line 11 "/ddverify-2010-04-30/models/seq1/include/ddverify/cdev.h"
short number_cdev_registered  =    (short)0;
#line 22 "/ddverify-2010-04-30/models/seq1/include/ddverify/cdev.h"
struct ddv_cdev cdev_registered[1]  ;
#line 24
void call_cdev_functions(void) ;
#line 33 "/ddverify-2010-04-30/models/seq1/include/linux/genhd.h"
void add_disk(struct gendisk *disk ) ;
#line 35
void del_gendisk(struct gendisk *gp ) ;
#line 37
struct gendisk *alloc_disk(int minors ) ;
#line 46 "/ddverify-2010-04-30/models/seq1/include/linux/workqueue.h"
__inline int schedule_work(struct work_struct *work ) ;
#line 32 "/ddverify-2010-04-30/models/seq1/include/linux/mutex.h"
__inline void mutex_init(struct mutex *lock ) ;
#line 34
__inline void mutex_lock(struct mutex *lock ) ;
#line 36
__inline void mutex_unlock(struct mutex *lock ) ;
#line 50 "/ddverify-2010-04-30/models/seq1/include/linux/interrupt.h"
__inline void tasklet_schedule(struct tasklet_struct *t ) ;
#line 65
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) ;
#line 75
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) ;
#line 78
void free_irq(unsigned int irq , void *dev_id ) ;
#line 192 "/ddverify-2010-04-30/models/seq1/include/linux/blkdev.h"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) ;
#line 194
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) ;
#line 196
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) ;
#line 198
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) ;
#line 200
void blk_cleanup_queue(request_queue_t *q ) ;
#line 220
void end_request(struct request *req , int uptodate ) ;
#line 12 "/ddverify-2010-04-30/models/seq1/include/ddverify/genhd.h"
short number_genhd_registered  =    (short)0;
#line 13 "/ddverify-2010-04-30/models/seq1/include/ddverify/genhd.h"
short number_fixed_genhd_used  =    (short)0;
#line 24 "/ddverify-2010-04-30/models/seq1/include/ddverify/genhd.h"
struct gendisk fixed_gendisk[10]  ;
#line 25 "/ddverify-2010-04-30/models/seq1/include/ddverify/genhd.h"
struct ddv_genhd genhd_registered[10]  ;
#line 27
void call_genhd_functions(void) ;
#line 87 "/ddverify-2010-04-30/models/seq1/include/linux/pci.h"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 141
__inline int pci_register_driver(struct pci_driver *driver ) ;
#line 143
__inline void pci_unregister_driver(struct pci_driver *driver ) ;
#line 145
__inline int pci_enable_device(struct pci_dev *dev ) ;
#line 152
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) ;
#line 154
__inline void pci_release_regions(struct pci_dev *pdev ) ;
#line 156
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) ;
#line 158
__inline void pci_release_region(struct pci_dev *pdev , int bar ) ;
#line 14 "/ddverify-2010-04-30/models/seq1/include/ddverify/pci.h"
struct ddv_pci_driver registered_pci_driver  ;
#line 16
int pci_probe_device(void) ;
#line 17
void pci_remove_device(void) ;
#line 19
void call_pci_functions(void) ;
#line 14 "/ddverify-2010-04-30/models/seq1/include/ddverify/interrupt.h"
struct registered_irq registered_irq[16]  ;
#line 16
void call_interrupt_handler(void) ;
#line 8 "/ddverify-2010-04-30/models/seq1/include/ddverify/tasklet.h"
short number_tasklet_registered  =    (short)0;
#line 15 "/ddverify-2010-04-30/models/seq1/include/ddverify/tasklet.h"
struct ddv_tasklet tasklet_registered[1]  ;
#line 17
void call_tasklet_functions(void) ;
#line 8 "/ddverify-2010-04-30/models/seq1/include/ddverify/timer.h"
short number_timer_registered  =    (short)0;
#line 14 "/ddverify-2010-04-30/models/seq1/include/ddverify/timer.h"
struct ddv_timer timer_registered[1]  ;
#line 16
void call_timer_functions(void) ;
#line 8 "/ddverify-2010-04-30/models/seq1/include/ddverify/workqueue.h"
struct work_struct *shared_workqueue[10]  ;
#line 10
__inline void call_shared_workqueue_functions(void) ;
#line 7 "/ddverify-2010-04-30/models/seq1/include/linux/smp_lock.h"
spinlock_t kernel_lock  ;
#line 26 "concatenated.c"
void init_kernel(void) 
{ int i ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 30
  spin_lock_init(& kernel_lock);
#line 32
  i = 0;
  }
  {
#line 32
  while (1) {
    while_3_continue: /* CIL Label */ ;
#line 32
    if (i < 10) {

    } else {
      goto while_3_break;
    }
#line 33
    __cil_tmp2 = (void *)0;
#line 33
    shared_workqueue[i] = (struct work_struct *)__cil_tmp2;
#line 32
    i = i + 1;
  }
  while_3_break: /* CIL Label */ ;
  }
#line 36
  i = 0;
  {
#line 36
  while (1) {
    while_4_continue: /* CIL Label */ ;
#line 36
    if (i < 1) {

    } else {
      goto while_4_break;
    }
#line 37
    __cil_tmp3 = (void *)0;
#line 37
    tasklet_registered[i].tasklet = (struct tasklet_struct *)__cil_tmp3;
#line 38
    tasklet_registered[i].is_running = (unsigned short)0;
#line 36
    i = i + 1;
  }
  while_4_break: /* CIL Label */ ;
  }
#line 40
  return;
}
}
#line 42 "concatenated.c"
void ddv(void) 
{ unsigned short random ;

  {
  {
#line 46
  while (1) {
    while_5_continue: /* CIL Label */ ;
    {
#line 47
    random = __VERIFIER_nondet_ushort();
    }
#line 50
    if ((int )random == 1) {
      goto switch_6_1;
    } else {
#line 61
      if ((int )random == 2) {
        goto switch_6_2;
      } else {
#line 66
        if ((int )random == 3) {
          goto switch_6_3;
        } else {
#line 71
          if ((int )random == 4) {
            goto switch_6_4;
          } else {
#line 76
            if ((int )random == 5) {
              goto switch_6_5;
            } else {
              {
              goto switch_6_default;
#line 49
              if (0) {
                switch_6_1: /* CIL Label */ 
                {
#line 51
                current_execution_context = 1;
#line 53
                call_cdev_functions();
                }
                goto switch_6_break;
                switch_6_2: /* CIL Label */ 
                {
#line 62
                current_execution_context = 2;
#line 63
                call_timer_functions();
                }
                goto switch_6_break;
                switch_6_3: /* CIL Label */ 
                {
#line 67
                current_execution_context = 2;
#line 68
                call_interrupt_handler();
                }
                goto switch_6_break;
                switch_6_4: /* CIL Label */ 
                {
#line 72
                current_execution_context = 1;
#line 73
                call_shared_workqueue_functions();
                }
                goto switch_6_break;
                switch_6_5: /* CIL Label */ 
                {
#line 77
                current_execution_context = 2;
#line 78
                call_tasklet_functions();
                }
                goto switch_6_break;
                switch_6_default: /* CIL Label */ ;
                goto switch_6_break;
              } else {
                switch_6_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
#line 46
    if (random) {

    } else {
      goto while_5_break;
    }
  }
  while_5_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "concatenated.c"
int call_ddv(void) 
{ int err ;

  {
  {
#line 98
  current_execution_context = 1;
#line 100
  init_kernel();
#line 102
  err = (*_ddv_module_init)();
  }
#line 104
  if (err) {
#line 105
    return (-1);
  } else {

  }
  {
#line 108
  ddv();
#line 110
  current_execution_context = 1;
#line 111
  (*_ddv_module_exit)();
  }
#line 113
  return (0);
}
}
#line 119 "concatenated.c"
void call_cdev_functions(void) 
{ int cdev_no ;
  int result ;
  loff_t loff_t_value ;
  int int_value ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  char char_value ;
  size_t size_t_value ;
  unsigned short tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  struct file_operations *__cil_tmp15 ;
  struct file_operations *__cil_tmp16 ;
  loff_t (*__cil_tmp17)(struct file * , loff_t  , int  ) ;
  struct file *__cil_tmp18 ;
  struct file_operations *__cil_tmp19 ;
  struct file_operations *__cil_tmp20 ;
  ssize_t (*__cil_tmp21)(struct file * , char * , size_t  , loff_t * ) ;
  struct file *__cil_tmp22 ;
  struct file_operations *__cil_tmp23 ;
  struct file_operations *__cil_tmp24 ;
  ssize_t (*__cil_tmp25)(struct file * , char const   * , size_t  , loff_t * ) ;
  struct file *__cil_tmp26 ;
  char const   *__cil_tmp27 ;
  struct file_operations *__cil_tmp28 ;
  struct file_operations *__cil_tmp29 ;
  int (*__cil_tmp30)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
  struct inode *__cil_tmp31 ;
  struct file *__cil_tmp32 ;
  struct file_operations *__cil_tmp33 ;
  struct file_operations *__cil_tmp34 ;
  int (*__cil_tmp35)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp36 ;
  struct file *__cil_tmp37 ;
  struct file_operations *__cil_tmp38 ;
  struct file_operations *__cil_tmp39 ;
  int (*__cil_tmp40)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp41 ;
  struct file *__cil_tmp42 ;

  {
  {
#line 130
  __cil_tmp13 = (int )number_cdev_registered;
#line 130
  if (__cil_tmp13 == 0) {
#line 131
    return;
  } else {

  }
  }
  {
#line 134
  tmp = __VERIFIER_nondet_ushort();
#line 134
  cdev_no = (int )tmp;
  }
#line 135
  if (0 <= cdev_no) {
    {
#line 135
    __cil_tmp14 = (int )number_cdev_registered;
#line 135
    if (cdev_no < __cil_tmp14) {
#line 135
      tmp___0 = 1;
    } else {
#line 135
      tmp___0 = 0;
    }
    }
  } else {
#line 135
    tmp___0 = 0;
  }
  {
#line 135
  __VERIFIER_assume(tmp___0);
#line 137
  tmp___1 = __VERIFIER_nondet_ushort();
  }
#line 138
  if ((int )tmp___1 == 0) {
    goto switch_7_0;
  } else {
#line 148
    if ((int )tmp___1 == 1) {
      goto switch_7_1;
    } else {
#line 159
      if ((int )tmp___1 == 2) {
        goto switch_7_2;
      } else {
#line 162
        if ((int )tmp___1 == 3) {
          goto switch_7_3;
        } else {
#line 173
          if ((int )tmp___1 == 4) {
            goto switch_7_4;
          } else {
#line 176
            if ((int )tmp___1 == 5) {
              goto switch_7_5;
            } else {
#line 179
              if ((int )tmp___1 == 6) {
                goto switch_7_6;
              } else {
#line 182
                if ((int )tmp___1 == 7) {
                  goto switch_7_7;
                } else {
#line 194
                  if ((int )tmp___1 == 8) {
                    goto switch_7_8;
                  } else {
#line 197
                    if ((int )tmp___1 == 9) {
                      goto switch_7_9;
                    } else {
#line 200
                      if ((int )tmp___1 == 10) {
                        goto switch_7_10;
                      } else {
#line 203
                        if ((int )tmp___1 == 11) {
                          goto switch_7_11;
                        } else {
#line 214
                          if ((int )tmp___1 == 12) {
                            goto switch_7_12;
                          } else {
#line 217
                            if ((int )tmp___1 == 13) {
                              goto switch_7_13;
                            } else {
#line 228
                              if ((int )tmp___1 == 14) {
                                goto switch_7_14;
                              } else {
#line 231
                                if ((int )tmp___1 == 15) {
                                  goto switch_7_15;
                                } else {
#line 234
                                  if ((int )tmp___1 == 16) {
                                    goto switch_7_16;
                                  } else {
#line 237
                                    if ((int )tmp___1 == 17) {
                                      goto switch_7_17;
                                    } else {
#line 240
                                      if ((int )tmp___1 == 18) {
                                        goto switch_7_18;
                                      } else {
#line 243
                                        if ((int )tmp___1 == 19) {
                                          goto switch_7_19;
                                        } else {
#line 246
                                          if ((int )tmp___1 == 20) {
                                            goto switch_7_20;
                                          } else {
#line 249
                                            if ((int )tmp___1 == 21) {
                                              goto switch_7_21;
                                            } else {
#line 252
                                              if ((int )tmp___1 == 22) {
                                                goto switch_7_22;
                                              } else {
#line 255
                                                if ((int )tmp___1 == 23) {
                                                  goto switch_7_23;
                                                } else {
#line 258
                                                  if ((int )tmp___1 == 24) {
                                                    goto switch_7_24;
                                                  } else {
#line 261
                                                    if ((int )tmp___1 == 25) {
                                                      goto switch_7_25;
                                                    } else {
#line 264
                                                      if ((int )tmp___1 == 26) {
                                                        goto switch_7_26;
                                                      } else {
                                                        {
                                                        goto switch_7_default;
#line 137
                                                        if (0) {
                                                          switch_7_0: /* CIL Label */ 
                                                          {
#line 139
                                                          __cil_tmp15 = (cdev_registered[cdev_no].cdevp)->ops;
#line 139
                                                          if (__cil_tmp15->llseek) {
                                                            {
#line 140
                                                            loff_t_value = __VERIFIER_nondet_loff_t();
#line 141
                                                            int_value = __VERIFIER_nondet_int();
#line 143
                                                            __cil_tmp16 = (cdev_registered[cdev_no].cdevp)->ops;
#line 143
                                                            __cil_tmp17 = __cil_tmp16->llseek;
#line 143
                                                            __cil_tmp18 = & cdev_registered[cdev_no].filp;
#line 143
                                                            (*__cil_tmp17)(__cil_tmp18,
                                                                           loff_t_value,
                                                                           int_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_1: /* CIL Label */ 
                                                          {
#line 149
                                                          __cil_tmp19 = (cdev_registered[cdev_no].cdevp)->ops;
#line 149
                                                          if (__cil_tmp19->read) {
                                                            {
#line 150
                                                            char_value = __VERIFIER_nondet_char();
#line 151
                                                            size_t_value = __VERIFIER_nondet_size_t();
#line 153
                                                            __cil_tmp20 = (cdev_registered[cdev_no].cdevp)->ops;
#line 153
                                                            __cil_tmp21 = __cil_tmp20->read;
#line 153
                                                            __cil_tmp22 = & cdev_registered[cdev_no].filp;
#line 153
                                                            (*__cil_tmp21)(__cil_tmp22,
                                                                           & char_value,
                                                                           size_t_value,
                                                                           & loff_t_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_2: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_3: /* CIL Label */ 
                                                          {
#line 163
                                                          __cil_tmp23 = (cdev_registered[cdev_no].cdevp)->ops;
#line 163
                                                          if (__cil_tmp23->write) {
                                                            {
#line 164
                                                            char_value = __VERIFIER_nondet_char();
#line 165
                                                            size_t_value = __VERIFIER_nondet_size_t();
#line 167
                                                            __cil_tmp24 = (cdev_registered[cdev_no].cdevp)->ops;
#line 167
                                                            __cil_tmp25 = __cil_tmp24->write;
#line 167
                                                            __cil_tmp26 = & cdev_registered[cdev_no].filp;
#line 167
                                                            __cil_tmp27 = (char const   *)(& char_value);
#line 167
                                                            (*__cil_tmp25)(__cil_tmp26,
                                                                           __cil_tmp27,
                                                                           size_t_value,
                                                                           & loff_t_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_4: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_5: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_6: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_7: /* CIL Label */ 
                                                          {
#line 183
                                                          __cil_tmp28 = (cdev_registered[cdev_no].cdevp)->ops;
#line 183
                                                          if (__cil_tmp28->ioctl) {
                                                            {
#line 184
                                                            uint_value = __VERIFIER_nondet_uint();
#line 185
                                                            ulong_value = __VERIFIER_nondet_ulong();
#line 187
                                                            __cil_tmp29 = (cdev_registered[cdev_no].cdevp)->ops;
#line 187
                                                            __cil_tmp30 = __cil_tmp29->ioctl;
#line 187
                                                            __cil_tmp31 = & cdev_registered[cdev_no].inode;
#line 187
                                                            __cil_tmp32 = & cdev_registered[cdev_no].filp;
#line 187
                                                            (*__cil_tmp30)(__cil_tmp31,
                                                                           __cil_tmp32,
                                                                           uint_value,
                                                                           ulong_value);
                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_8: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_9: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_10: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_11: /* CIL Label */ 
                                                          {
#line 204
                                                          __cil_tmp33 = (cdev_registered[cdev_no].cdevp)->ops;
#line 204
                                                          if (__cil_tmp33->open) {
#line 204
                                                            if (! cdev_registered[cdev_no].open) {
                                                              {
#line 206
                                                              __cil_tmp34 = (cdev_registered[cdev_no].cdevp)->ops;
#line 206
                                                              __cil_tmp35 = __cil_tmp34->open;
#line 206
                                                              __cil_tmp36 = & cdev_registered[cdev_no].inode;
#line 206
                                                              __cil_tmp37 = & cdev_registered[cdev_no].filp;
#line 206
                                                              result = (*__cil_tmp35)(__cil_tmp36,
                                                                                      __cil_tmp37);
                                                              }
#line 209
                                                              if (! result) {
#line 210
                                                                cdev_registered[cdev_no].open = 1;
                                                              } else {

                                                              }
                                                            } else {

                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_12: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_13: /* CIL Label */ 
                                                          {
#line 218
                                                          __cil_tmp38 = (cdev_registered[cdev_no].cdevp)->ops;
#line 218
                                                          if (__cil_tmp38->release) {
#line 218
                                                            if (cdev_registered[cdev_no].open) {
                                                              {
#line 220
                                                              __cil_tmp39 = (cdev_registered[cdev_no].cdevp)->ops;
#line 220
                                                              __cil_tmp40 = __cil_tmp39->release;
#line 220
                                                              __cil_tmp41 = & cdev_registered[cdev_no].inode;
#line 220
                                                              __cil_tmp42 = & cdev_registered[cdev_no].filp;
#line 220
                                                              result = (*__cil_tmp40)(__cil_tmp41,
                                                                                      __cil_tmp42);
                                                              }
#line 223
                                                              if (! result) {
#line 224
                                                                cdev_registered[cdev_no].open = 0;
                                                              } else {

                                                              }
                                                            } else {

                                                            }
                                                          } else {

                                                          }
                                                          }
                                                          goto switch_7_break;
                                                          switch_7_14: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_15: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_16: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_17: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_18: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_19: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_20: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_21: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_22: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_23: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_24: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_25: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_26: /* CIL Label */ 
                                                          goto switch_7_break;
                                                          switch_7_default: /* CIL Label */ ;
                                                          goto switch_7_break;
                                                        } else {
                                                          switch_7_break: /* CIL Label */ ;
                                                        }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 270
  return;
}
}
#line 277 "concatenated.c"
int create_request(int genhd_no ) 
{ struct request rq ;

  {
  {
#line 281
  rq.cmd_type = (enum rq_cmd_type_bits )1;
#line 282
  rq.rq_disk = genhd_registered[genhd_no].gd;
#line 283
  rq.sector = __VERIFIER_nondet_sector_t();
#line 284
  rq.current_nr_sectors = __VERIFIER_nondet_uint();
#line 285
  rq.buffer = __VERIFIER_nondet_pchar();
#line 287
  genhd_registered[genhd_no].current_request = rq;
#line 288
  genhd_registered[genhd_no].requests_open = 1;
  }
#line 289
  return (0);
}
}
#line 291 "concatenated.c"
void call_rq_function(int genhd_no ) 
{ void *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct request_queue *__cil_tmp4 ;
  request_fn_proc *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct request_queue *__cil_tmp7 ;
  struct request_queue *__cil_tmp8 ;
  spinlock_t *__cil_tmp9 ;
  struct request_queue *__cil_tmp10 ;
  struct request_queue *__cil_tmp11 ;
  request_fn_proc *__cil_tmp12 ;
  struct request_queue *__cil_tmp13 ;
  struct request_queue *__cil_tmp14 ;
  spinlock_t *__cil_tmp15 ;
  struct request_queue *__cil_tmp16 ;

  {
  {
#line 293
  __cil_tmp2 = (void *)0;
#line 293
  __cil_tmp3 = (unsigned long )__cil_tmp2;
#line 293
  __cil_tmp4 = (genhd_registered[genhd_no].gd)->queue;
#line 293
  __cil_tmp5 = __cil_tmp4->request_fn;
#line 293
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 293
  if (__cil_tmp6 != __cil_tmp3) {
    {
#line 293
    __cil_tmp7 = (genhd_registered[genhd_no].gd)->queue;
#line 293
    if (__cil_tmp7->__ddv_queue_alive) {
      {
#line 296
      __cil_tmp8 = (genhd_registered[genhd_no].gd)->queue;
#line 296
      __cil_tmp9 = __cil_tmp8->queue_lock;
#line 296
      spin_lock(__cil_tmp9);
#line 298
      create_request(genhd_no);
#line 299
      __cil_tmp10 = (genhd_registered[genhd_no].gd)->queue;
#line 299
      __cil_tmp10->__ddv_genhd_no = genhd_no;
#line 301
      __cil_tmp11 = (genhd_registered[genhd_no].gd)->queue;
#line 301
      __cil_tmp12 = __cil_tmp11->request_fn;
#line 301
      __cil_tmp13 = (genhd_registered[genhd_no].gd)->queue;
#line 301
      (*__cil_tmp12)(__cil_tmp13);
#line 304
      __cil_tmp14 = (genhd_registered[genhd_no].gd)->queue;
#line 304
      __cil_tmp15 = __cil_tmp14->queue_lock;
#line 304
      spin_unlock(__cil_tmp15);
      }
#line 306
      return;
    } else {

    }
    }
  } else {

  }
  }
  {
#line 309
  __cil_tmp16 = (genhd_registered[genhd_no].gd)->queue;
#line 309
  if (__cil_tmp16->make_request_fn) {
#line 310
    return;
  } else {

  }
  }
#line 312
  return;
}
}
#line 314 "concatenated.c"
void call_genhd_functions(void) 
{ unsigned short genhd_no ;
  unsigned short function_no ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  void *tmp ;
  struct hd_geometry hdg ;
  struct block_device blk_dev ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  struct block_device_operations *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  struct block_device_operations *__cil_tmp16 ;
  int (*__cil_tmp17)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp18 ;
  struct file *__cil_tmp19 ;
  struct block_device_operations *__cil_tmp20 ;
  struct block_device_operations *__cil_tmp21 ;
  int (*__cil_tmp22)(struct inode * , struct file * ) ;
  struct inode *__cil_tmp23 ;
  struct file *__cil_tmp24 ;
  struct block_device_operations *__cil_tmp25 ;
  struct block_device_operations *__cil_tmp26 ;
  int (*__cil_tmp27)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
  struct inode *__cil_tmp28 ;
  struct file *__cil_tmp29 ;
  struct block_device_operations *__cil_tmp30 ;
  struct block_device_operations *__cil_tmp31 ;
  int (*__cil_tmp32)(struct gendisk * ) ;
  struct block_device_operations *__cil_tmp33 ;
  struct block_device_operations *__cil_tmp34 ;
  int (*__cil_tmp35)(struct gendisk * ) ;
  struct block_device_operations *__cil_tmp36 ;
  struct block_device_operations *__cil_tmp37 ;
  int (*__cil_tmp38)(struct block_device * , struct hd_geometry * ) ;

  {
  {
#line 321
  __cil_tmp9 = (int )number_genhd_registered;
#line 321
  if (__cil_tmp9 == 0) {
#line 322
    return;
  } else {

  }
  }
  {
#line 325
  genhd_no = __VERIFIER_nondet_ushort();
#line 326
  __cil_tmp10 = (int )number_genhd_registered;
#line 326
  __cil_tmp11 = (int )genhd_no;
#line 326
  __cil_tmp12 = __cil_tmp11 < __cil_tmp10;
#line 326
  __VERIFIER_assume(__cil_tmp12);
#line 329
  function_no = __VERIFIER_nondet_ushort();
  }
#line 332
  if ((int )function_no == 0) {
    goto switch_8_0;
  } else {
#line 336
    if ((int )function_no == 1) {
      goto switch_8_1;
    } else {
#line 346
      if ((int )function_no == 2) {
        goto switch_8_2;
      } else {
#line 353
        if ((int )function_no == 3) {
          goto switch_8_3;
        } else {
#line 364
          if ((int )function_no == 4) {
            goto switch_8_4;
          } else {
#line 370
            if ((int )function_no == 5) {
              goto switch_8_5;
            } else {
#line 376
              if ((int )function_no == 6) {
                goto switch_8_6;
              } else {
                {
                goto switch_8_default;
#line 331
                if (0) {
                  switch_8_0: /* CIL Label */ 
                  {
#line 333
                  __cil_tmp13 = (int )genhd_no;
#line 333
                  call_rq_function(__cil_tmp13);
                  }
                  goto switch_8_break;
                  switch_8_1: /* CIL Label */ 
                  {
#line 337
                  __cil_tmp14 = (genhd_registered[genhd_no].gd)->fops;
#line 337
                  if (__cil_tmp14->open) {
                    {
#line 338
                    __cil_tmp15 = (unsigned int )32UL;
#line 338
                    tmp = malloc(__cil_tmp15);
#line 338
                    genhd_registered[genhd_no].inode.i_bdev = (struct block_device *)tmp;
#line 339
                    (genhd_registered[genhd_no].inode.i_bdev)->bd_disk = genhd_registered[genhd_no].gd;
#line 341
                    __cil_tmp16 = (genhd_registered[genhd_no].gd)->fops;
#line 341
                    __cil_tmp17 = __cil_tmp16->open;
#line 341
                    __cil_tmp18 = & genhd_registered[genhd_no].inode;
#line 341
                    __cil_tmp19 = & genhd_registered[genhd_no].file;
#line 341
                    (*__cil_tmp17)(__cil_tmp18, __cil_tmp19);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_2: /* CIL Label */ 
                  {
#line 347
                  __cil_tmp20 = (genhd_registered[genhd_no].gd)->fops;
#line 347
                  if (__cil_tmp20->release) {
                    {
#line 348
                    __cil_tmp21 = (genhd_registered[genhd_no].gd)->fops;
#line 348
                    __cil_tmp22 = __cil_tmp21->release;
#line 348
                    __cil_tmp23 = & genhd_registered[genhd_no].inode;
#line 348
                    __cil_tmp24 = & genhd_registered[genhd_no].file;
#line 348
                    (*__cil_tmp22)(__cil_tmp23, __cil_tmp24);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_3: /* CIL Label */ 
                  {
#line 354
                  __cil_tmp25 = (genhd_registered[genhd_no].gd)->fops;
#line 354
                  if (__cil_tmp25->ioctl) {
                    {
#line 355
                    uint_value = __VERIFIER_nondet_uint();
#line 356
                    ulong_value = __VERIFIER_nondet_ulong();
#line 357
                    __cil_tmp26 = (genhd_registered[genhd_no].gd)->fops;
#line 357
                    __cil_tmp27 = __cil_tmp26->ioctl;
#line 357
                    __cil_tmp28 = & genhd_registered[genhd_no].inode;
#line 357
                    __cil_tmp29 = & genhd_registered[genhd_no].file;
#line 357
                    (*__cil_tmp27)(__cil_tmp28, __cil_tmp29, uint_value, ulong_value);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_4: /* CIL Label */ 
                  {
#line 365
                  __cil_tmp30 = (genhd_registered[genhd_no].gd)->fops;
#line 365
                  if (__cil_tmp30->media_changed) {
                    {
#line 366
                    __cil_tmp31 = (genhd_registered[genhd_no].gd)->fops;
#line 366
                    __cil_tmp32 = __cil_tmp31->media_changed;
#line 366
                    (*__cil_tmp32)(genhd_registered[genhd_no].gd);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_5: /* CIL Label */ 
                  {
#line 371
                  __cil_tmp33 = (genhd_registered[genhd_no].gd)->fops;
#line 371
                  if (__cil_tmp33->revalidate_disk) {
                    {
#line 372
                    __cil_tmp34 = (genhd_registered[genhd_no].gd)->fops;
#line 372
                    __cil_tmp35 = __cil_tmp34->revalidate_disk;
#line 372
                    (*__cil_tmp35)(genhd_registered[genhd_no].gd);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_6: /* CIL Label */ 
                  {
#line 377
                  __cil_tmp36 = (genhd_registered[genhd_no].gd)->fops;
#line 377
                  if (__cil_tmp36->getgeo) {
                    {
#line 381
                    blk_dev.bd_disk = genhd_registered[genhd_no].gd;
#line 383
                    __cil_tmp37 = (genhd_registered[genhd_no].gd)->fops;
#line 383
                    __cil_tmp38 = __cil_tmp37->getgeo;
#line 383
                    (*__cil_tmp38)(& blk_dev, & hdg);
                    }
                  } else {

                  }
                  }
                  goto switch_8_break;
                  switch_8_default: /* CIL Label */ ;
                  goto switch_8_break;
                } else {
                  switch_8_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
      }
    }
  }
#line 390
  return;
}
}
#line 400 "concatenated.c"
void call_interrupt_handler(void) 
{ unsigned short i ;
  struct pt_regs regs ;
  int tmp ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 405
  tmp = __VERIFIER_nondet_int();
#line 405
  i = (unsigned short )tmp;
#line 406
  __cil_tmp4 = (int )i;
#line 406
  __cil_tmp5 = __cil_tmp4 < 16;
#line 406
  __VERIFIER_assume(__cil_tmp5);
  }
#line 408
  if (registered_irq[i].handler) {
    {
#line 409
    __cil_tmp6 = (int )i;
#line 409
    (*(registered_irq[i].handler))(__cil_tmp6, registered_irq[i].dev_id, & regs);
    }
  } else {

  }
#line 412
  return;
}
}
#line 438 "concatenated.c"
void create_pci_dev(void) 
{ 

  {
#line 440
  return;
}
}
#line 442 "concatenated.c"
int pci_probe_device(void) 
{ int err ;
  unsigned int dev_id ;
  int __cil_tmp3 ;
  int (*__cil_tmp4)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
  struct pci_dev *__cil_tmp5 ;
  struct pci_device_id  const  *__cil_tmp6 ;
  struct pci_device_id  const  *__cil_tmp7 ;

  {
  {
#line 447
  registered_pci_driver.no_pci_device_id = 1U;
#line 449
  dev_id = __VERIFIER_nondet_uint();
#line 450
  __cil_tmp3 = dev_id < registered_pci_driver.no_pci_device_id;
#line 450
  __VERIFIER_assume(__cil_tmp3);
#line 452
  __cil_tmp4 = (registered_pci_driver.pci_driver)->probe;
#line 452
  __cil_tmp5 = & registered_pci_driver.pci_dev;
#line 452
  __cil_tmp6 = (registered_pci_driver.pci_driver)->id_table;
#line 452
  __cil_tmp7 = __cil_tmp6 + dev_id;
#line 452
  err = (*__cil_tmp4)(__cil_tmp5, __cil_tmp7);
  }
#line 455
  if (! err) {
#line 456
    registered_pci_driver.dev_initialized = 1;
  } else {

  }
#line 459
  return (err);
}
}
#line 462 "concatenated.c"
void pci_remove_device(void) 
{ void (*__cil_tmp1)(struct pci_dev *dev ) ;
  struct pci_dev *__cil_tmp2 ;

  {
  {
#line 464
  __cil_tmp1 = (registered_pci_driver.pci_driver)->remove;
#line 464
  __cil_tmp2 = & registered_pci_driver.pci_dev;
#line 464
  (*__cil_tmp1)(__cil_tmp2);
#line 466
  registered_pci_driver.dev_initialized = 0;
  }
#line 467
  return;
}
}
#line 469 "concatenated.c"
void call_pci_functions(void) 
{ unsigned int tmp ;

  {
  {
#line 471
  tmp = __VERIFIER_nondet_uint();
  }
#line 472
  if ((int )tmp == 0) {
    goto switch_9_0;
  } else {
#line 478
    if ((int )tmp == 1) {
      goto switch_9_1;
    } else {
      {
      goto switch_9_default;
#line 471
      if (0) {
        switch_9_0: /* CIL Label */ 
#line 473
        if (! registered_pci_driver.dev_initialized) {
          {
#line 474
          pci_probe_device();
          }
        } else {

        }
        goto switch_9_break;
        switch_9_1: /* CIL Label */ 
#line 479
        if (registered_pci_driver.dev_initialized) {
          {
#line 480
          pci_remove_device();
          }
        } else {

        }
        goto switch_9_break;
        switch_9_default: /* CIL Label */ ;
        goto switch_9_break;
      } else {
        switch_9_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 487
  return;
}
}
#line 490 "concatenated.c"
void call_tasklet_functions(void) 
{ unsigned int i ;
  int __cil_tmp2 ;
  void *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  atomic_t __cil_tmp6 ;
  void (*__cil_tmp7)(unsigned long  ) ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 493
  __cil_tmp2 = i < 1U;
#line 493
  __VERIFIER_assume(__cil_tmp2);
  }
  {
#line 495
  __cil_tmp3 = (void *)0;
#line 495
  __cil_tmp4 = (unsigned long )__cil_tmp3;
#line 495
  __cil_tmp5 = (unsigned long )tasklet_registered[i].tasklet;
#line 495
  if (__cil_tmp5 != __cil_tmp4) {
    {
#line 495
    __cil_tmp6 = (tasklet_registered[i].tasklet)->count;
#line 495
    if (__cil_tmp6 == 0) {
      {
#line 497
      tasklet_registered[i].is_running = (unsigned short)1;
#line 498
      __cil_tmp7 = (tasklet_registered[i].tasklet)->func;
#line 498
      __cil_tmp8 = (tasklet_registered[i].tasklet)->data;
#line 498
      (*__cil_tmp7)(__cil_tmp8);
#line 499
      tasklet_registered[i].is_running = (unsigned short)0;
#line 500
      __cil_tmp9 = (void *)0;
#line 500
      tasklet_registered[i].tasklet = (struct tasklet_struct *)__cil_tmp9;
      }
    } else {

    }
    }
  } else {

  }
  }
#line 502
  return;
}
}
#line 506 "concatenated.c"
void call_timer_functions(void) 
{ unsigned short i ;
  unsigned short tmp ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  void (*__cil_tmp6)(unsigned long  ) ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 508
  tmp = __VERIFIER_nondet_ushort();
#line 508
  i = tmp;
#line 510
  __cil_tmp3 = (int )number_timer_registered;
#line 510
  __cil_tmp4 = (int )i;
#line 510
  __cil_tmp5 = __cil_tmp4 < __cil_tmp3;
#line 510
  __VERIFIER_assume(__cil_tmp5);
  }
#line 512
  if ((timer_registered[i].timer)->__ddv_active) {
    {
#line 513
    __cil_tmp6 = (timer_registered[i].timer)->function;
#line 513
    __cil_tmp7 = (timer_registered[i].timer)->data;
#line 513
    (*__cil_tmp6)(__cil_tmp7);
    }
  } else {

  }
#line 515
  return;
}
}
#line 523 "concatenated.c"
__inline int pci_enable_device(struct pci_dev *dev ) 
{ int i ;
  unsigned int tmp ;
  unsigned short tmp___0 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
#line 527
  i = 0;
  {
#line 527
  while (1) {
    while_10_continue: /* CIL Label */ ;
#line 527
    if (i < 12) {

    } else {
      goto while_10_break;
    }
    {
#line 528
    dev->resource[i].flags = 256UL;
#line 529
    tmp = __VERIFIER_nondet_uint();
#line 529
    dev->resource[i].start = (unsigned long )tmp;
#line 530
    tmp___0 = __VERIFIER_nondet_ushort();
#line 530
    __cil_tmp5 = (unsigned long )tmp___0;
#line 530
    __cil_tmp6 = dev->resource[i].start;
#line 530
    dev->resource[i].end = __cil_tmp6 + __cil_tmp5;
#line 527
    i = i + 1;
    }
  }
  while_10_break: /* CIL Label */ ;
  }
#line 532
  return (0);
}
}
#line 534 "concatenated.c"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) 
{ void *tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 536
  __cil_tmp5 = (void *)0;
#line 536
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 536
  __cil_tmp7 = (unsigned long )from;
#line 536
  if (__cil_tmp7 == __cil_tmp6) {
    {
#line 537
    __cil_tmp8 = (unsigned int )432UL;
#line 537
    tmp = malloc(__cil_tmp8);
#line 537
    from = (struct pci_dev *)tmp;
    }
  } else {

  }
  }
  {
#line 540
  tmp___0 = __VERIFIER_nondet_int();
  }
#line 540
  if (tmp___0) {
    {
#line 541
    from->vendor = __VERIFIER_nondet_ushort();
#line 542
    from->device = __VERIFIER_nondet_ushort();
#line 543
    from->irq = __VERIFIER_nondet_uint();
#line 544
    __cil_tmp9 = from->irq;
#line 544
    __cil_tmp10 = __cil_tmp9 < 16U;
#line 544
    __VERIFIER_assume(__cil_tmp10);
    }
#line 546
    return (from);
  } else {
    {
#line 548
    __cil_tmp11 = (void *)0;
#line 548
    return ((struct pci_dev *)__cil_tmp11);
    }
  }
}
}
#line 552 "concatenated.c"
__inline int pci_register_driver(struct pci_driver *driver ) 
{ int tmp ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 554
  tmp = __VERIFIER_nondet_int();
  }
#line 554
  if (tmp) {
#line 555
    registered_pci_driver.pci_driver = driver;
#line 556
    __cil_tmp3 = 8UL / 32UL;
#line 556
    registered_pci_driver.no_pci_device_id = (unsigned int )__cil_tmp3;
#line 557
    registered_pci_driver.dev_initialized = 0;
#line 559
    return (0);
  } else {
#line 561
    return (-1);
  }
}
}
#line 565 "concatenated.c"
__inline void pci_unregister_driver(struct pci_driver *driver ) 
{ void *__cil_tmp2 ;

  {
#line 567
  __cil_tmp2 = (void *)0;
#line 567
  registered_pci_driver.pci_driver = (struct pci_driver *)__cil_tmp2;
#line 568
  registered_pci_driver.no_pci_device_id = 0U;
#line 569
  return;
}
}
#line 571 "concatenated.c"
__inline void pci_release_region(struct pci_dev *pdev , int bar ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;

  {
  {
#line 573
  __cil_tmp6 = pdev->resource[bar].start;
#line 573
  if (__cil_tmp6 == 0UL) {
    {
#line 573
    __cil_tmp7 = pdev->resource[bar].start;
#line 573
    __cil_tmp8 = pdev->resource[bar].end;
#line 573
    if (__cil_tmp8 == __cil_tmp7) {
#line 573
      tmp = 0UL;
    } else {
#line 573
      __cil_tmp9 = pdev->resource[bar].start;
#line 573
      __cil_tmp10 = pdev->resource[bar].end;
#line 573
      __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
#line 573
      tmp = __cil_tmp11 + 1UL;
    }
    }
  } else {
#line 573
    __cil_tmp12 = pdev->resource[bar].start;
#line 573
    __cil_tmp13 = pdev->resource[bar].end;
#line 573
    __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 573
    tmp = __cil_tmp14 + 1UL;
  }
  }
#line 573
  if (tmp == 0UL) {
#line 574
    return;
  } else {

  }
  {
#line 575
  __cil_tmp15 = pdev->resource[bar].flags;
#line 575
  if (__cil_tmp15 & 256UL) {
    {
#line 576
    __cil_tmp16 = pdev->resource[bar].start;
#line 576
    if (__cil_tmp16 == 0UL) {
      {
#line 576
      __cil_tmp17 = pdev->resource[bar].start;
#line 576
      __cil_tmp18 = pdev->resource[bar].end;
#line 576
      if (__cil_tmp18 == __cil_tmp17) {
#line 576
        tmp___0 = 0UL;
      } else {
#line 576
        __cil_tmp19 = pdev->resource[bar].start;
#line 576
        __cil_tmp20 = pdev->resource[bar].end;
#line 576
        __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
#line 576
        tmp___0 = __cil_tmp21 + 1UL;
      }
      }
    } else {
#line 576
      __cil_tmp22 = pdev->resource[bar].start;
#line 576
      __cil_tmp23 = pdev->resource[bar].end;
#line 576
      __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
#line 576
      tmp___0 = __cil_tmp24 + 1UL;
    }
    }
    {
#line 576
    __cil_tmp25 = pdev->resource[bar].start;
#line 576
    release_region(__cil_tmp25, tmp___0);
    }
  } else {
    {
#line 578
    __cil_tmp26 = pdev->resource[bar].flags;
#line 578
    if (__cil_tmp26 & 512UL) {
      {
#line 579
      __cil_tmp27 = pdev->resource[bar].start;
#line 579
      if (__cil_tmp27 == 0UL) {
        {
#line 579
        __cil_tmp28 = pdev->resource[bar].start;
#line 579
        __cil_tmp29 = pdev->resource[bar].end;
#line 579
        if (__cil_tmp29 == __cil_tmp28) {
#line 579
          tmp___1 = 0UL;
        } else {
#line 579
          __cil_tmp30 = pdev->resource[bar].start;
#line 579
          __cil_tmp31 = pdev->resource[bar].end;
#line 579
          __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 579
          tmp___1 = __cil_tmp32 + 1UL;
        }
        }
      } else {
#line 579
        __cil_tmp33 = pdev->resource[bar].start;
#line 579
        __cil_tmp34 = pdev->resource[bar].end;
#line 579
        __cil_tmp35 = __cil_tmp34 - __cil_tmp33;
#line 579
        tmp___1 = __cil_tmp35 + 1UL;
      }
      }
      {
#line 579
      __cil_tmp36 = pdev->resource[bar].start;
#line 579
      release_mem_region(__cil_tmp36, tmp___1);
      }
    } else {

    }
    }
  }
  }
#line 581
  return;
}
}
#line 583 "concatenated.c"
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  struct resource *tmp___1 ;
  unsigned long tmp___2 ;
  struct resource *tmp___3 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;

  {
  {
#line 585
  __cil_tmp9 = pdev->resource[bar].start;
#line 585
  if (__cil_tmp9 == 0UL) {
    {
#line 585
    __cil_tmp10 = pdev->resource[bar].start;
#line 585
    __cil_tmp11 = pdev->resource[bar].end;
#line 585
    if (__cil_tmp11 == __cil_tmp10) {
#line 585
      tmp = 0UL;
    } else {
#line 585
      __cil_tmp12 = pdev->resource[bar].start;
#line 585
      __cil_tmp13 = pdev->resource[bar].end;
#line 585
      __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 585
      tmp = __cil_tmp14 + 1UL;
    }
    }
  } else {
#line 585
    __cil_tmp15 = pdev->resource[bar].start;
#line 585
    __cil_tmp16 = pdev->resource[bar].end;
#line 585
    __cil_tmp17 = __cil_tmp16 - __cil_tmp15;
#line 585
    tmp = __cil_tmp17 + 1UL;
  }
  }
#line 585
  if (tmp == 0UL) {
#line 586
    return (0);
  } else {

  }
  {
#line 588
  __cil_tmp18 = pdev->resource[bar].flags;
#line 588
  if (__cil_tmp18 & 256UL) {
    {
#line 589
    __cil_tmp19 = pdev->resource[bar].start;
#line 589
    if (__cil_tmp19 == 0UL) {
      {
#line 589
      __cil_tmp20 = pdev->resource[bar].start;
#line 589
      __cil_tmp21 = pdev->resource[bar].end;
#line 589
      if (__cil_tmp21 == __cil_tmp20) {
#line 589
        tmp___0 = 0UL;
      } else {
#line 589
        __cil_tmp22 = pdev->resource[bar].start;
#line 589
        __cil_tmp23 = pdev->resource[bar].end;
#line 589
        __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
#line 589
        tmp___0 = __cil_tmp24 + 1UL;
      }
      }
    } else {
#line 589
      __cil_tmp25 = pdev->resource[bar].start;
#line 589
      __cil_tmp26 = pdev->resource[bar].end;
#line 589
      __cil_tmp27 = __cil_tmp26 - __cil_tmp25;
#line 589
      tmp___0 = __cil_tmp27 + 1UL;
    }
    }
    {
#line 589
    __cil_tmp28 = pdev->resource[bar].start;
#line 589
    tmp___1 = request_region(__cil_tmp28, tmp___0, res_name);
    }
#line 589
    if (tmp___1) {

    } else {
#line 591
      return (-16);
    }
  } else {
    {
#line 593
    __cil_tmp29 = pdev->resource[bar].flags;
#line 593
    if (__cil_tmp29 & 512UL) {
      {
#line 594
      __cil_tmp30 = pdev->resource[bar].start;
#line 594
      if (__cil_tmp30 == 0UL) {
        {
#line 594
        __cil_tmp31 = pdev->resource[bar].start;
#line 594
        __cil_tmp32 = pdev->resource[bar].end;
#line 594
        if (__cil_tmp32 == __cil_tmp31) {
#line 594
          tmp___2 = 0UL;
        } else {
#line 594
          __cil_tmp33 = pdev->resource[bar].start;
#line 594
          __cil_tmp34 = pdev->resource[bar].end;
#line 594
          __cil_tmp35 = __cil_tmp34 - __cil_tmp33;
#line 594
          tmp___2 = __cil_tmp35 + 1UL;
        }
        }
      } else {
#line 594
        __cil_tmp36 = pdev->resource[bar].start;
#line 594
        __cil_tmp37 = pdev->resource[bar].end;
#line 594
        __cil_tmp38 = __cil_tmp37 - __cil_tmp36;
#line 594
        tmp___2 = __cil_tmp38 + 1UL;
      }
      }
      {
#line 594
      __cil_tmp39 = pdev->resource[bar].start;
#line 594
      tmp___3 = request_mem_region(__cil_tmp39, tmp___2, res_name);
      }
#line 594
      if (tmp___3) {

      } else {
#line 596
        return (-16);
      }
    } else {

    }
    }
  }
  }
#line 599
  return (0);
}
}
#line 602 "concatenated.c"
__inline void pci_release_regions(struct pci_dev *pdev ) 
{ int i ;

  {
#line 606
  i = 0;
  {
#line 606
  while (1) {
    while_11_continue: /* CIL Label */ ;
#line 606
    if (i < 6) {

    } else {
      goto while_11_break;
    }
    {
#line 607
    pci_release_region(pdev, i);
#line 606
    i = i + 1;
    }
  }
  while_11_break: /* CIL Label */ ;
  }
#line 608
  return;
}
}
#line 610 "concatenated.c"
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ int i ;
  int tmp ;

  {
#line 614
  i = 0;
  {
#line 614
  while (1) {
    while_12_continue: /* CIL Label */ ;
#line 614
    if (i < 6) {

    } else {
      goto while_12_break;
    }
    {
#line 615
    tmp = pci_request_region(pdev, i, res_name);
    }
#line 615
    if (tmp) {
      goto err_out;
    } else {

    }
#line 614
    i = i + 1;
  }
  while_12_break: /* CIL Label */ ;
  }
#line 617
  return (0);
  err_out: 
  {
#line 620
  while (1) {
    while_13_continue: /* CIL Label */ ;
#line 620
    i = i - 1;
#line 620
    if (i >= 0) {

    } else {
      goto while_13_break;
    }
    {
#line 621
    pci_release_region(pdev, i);
    }
  }
  while_13_break: /* CIL Label */ ;
  }
#line 623
  return (-16);
}
}
#line 629 "concatenated.c"
__inline int __get_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
#line 632
  assert_context_process();
#line 634
  tmp = __VERIFIER_nondet_int();
  }
#line 634
  return (tmp);
}
}
#line 637 "concatenated.c"
__inline int get_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
#line 640
  assert_context_process();
#line 642
  tmp = __VERIFIER_nondet_int();
  }
#line 642
  return (tmp);
}
}
#line 645 "concatenated.c"
__inline int __put_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
#line 648
  assert_context_process();
#line 650
  tmp = __VERIFIER_nondet_int();
  }
#line 650
  return (tmp);
}
}
#line 653 "concatenated.c"
__inline int put_user(int size , void *ptr ) 
{ int tmp ;

  {
  {
#line 656
  assert_context_process();
#line 658
  tmp = __VERIFIER_nondet_int();
  }
#line 658
  return (tmp);
}
}
#line 661 "concatenated.c"
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
#line 664
  assert_context_process();
#line 666
  tmp = __VERIFIER_nondet_ulong();
  }
#line 666
  return (tmp);
}
}
#line 669 "concatenated.c"
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
#line 672
  assert_context_process();
#line 674
  tmp = __VERIFIER_nondet_ulong();
  }
#line 674
  return (tmp);
}
}
#line 681 "concatenated.c"
int register_blkdev(unsigned int major , char const   *name ) 
{ int result ;
  int tmp ;

  {
  {
#line 683
  tmp = __VERIFIER_nondet_int();
#line 683
  result = tmp;
  }
#line 689
  return (result);
}
}
#line 692 "concatenated.c"
int unregister_blkdev(unsigned int major , char const   *name ) 
{ 

  {
#line 694
  return (0);
}
}
#line 697 "concatenated.c"
struct gendisk *alloc_disk(int minors ) 
{ struct gendisk *gd ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 701
  __cil_tmp3 = (int )number_fixed_genhd_used;
#line 701
  if (__cil_tmp3 < 10) {
#line 702
    gd = & fixed_gendisk[number_fixed_genhd_used];
#line 703
    gd->minors = minors;
#line 705
    __cil_tmp4 = (int )number_fixed_genhd_used;
#line 705
    __cil_tmp5 = __cil_tmp4 + 1;
#line 705
    number_fixed_genhd_used = (short )__cil_tmp5;
#line 707
    return (gd);
  } else {
    {
#line 709
    __cil_tmp6 = (void *)0;
#line 709
    return ((struct gendisk *)__cil_tmp6);
    }
  }
  }
}
}
#line 713 "concatenated.c"
void add_disk(struct gendisk *disk ) 
{ void *tmp ;
  int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 715
  __cil_tmp3 = (int )number_genhd_registered;
#line 715
  if (__cil_tmp3 < 10) {
    {
#line 716
    genhd_registered[number_genhd_registered].gd = disk;
#line 717
    __cil_tmp4 = (unsigned int )32UL;
#line 717
    tmp = malloc(__cil_tmp4);
#line 717
    genhd_registered[number_genhd_registered].inode.i_bdev = (struct block_device *)tmp;
#line 718
    (genhd_registered[number_genhd_registered].inode.i_bdev)->bd_disk = disk;
#line 720
    __cil_tmp5 = (int )number_genhd_registered;
#line 720
    __cil_tmp6 = __cil_tmp5 + 1;
#line 720
    number_genhd_registered = (short )__cil_tmp6;
    }
  } else {

  }
  }
#line 722
  return;
}
}
#line 724 "concatenated.c"
void del_gendisk(struct gendisk *gp ) 
{ int i ;
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 728
  i = 0;
  {
#line 728
  while (1) {
    while_14_continue: /* CIL Label */ ;
    {
#line 728
    __cil_tmp3 = (int )number_genhd_registered;
#line 728
    if (i < __cil_tmp3) {

    } else {
      goto while_14_break;
    }
    }
    {
#line 729
    __cil_tmp4 = (unsigned long )gp;
#line 729
    __cil_tmp5 = (unsigned long )genhd_registered[i].gd;
#line 729
    if (__cil_tmp5 == __cil_tmp4) {
#line 730
      __cil_tmp6 = (void *)0;
#line 730
      genhd_registered[i].gd = (struct gendisk *)__cil_tmp6;
    } else {

    }
    }
#line 728
    i = i + 1;
  }
  while_14_break: /* CIL Label */ ;
  }
#line 733
  return;
}
}
#line 6 "/ddverify-2010-04-30/models/seq1/include/ddverify/blkdev.h"
request_queue_t fixed_request_queue[10]  ;
#line 8 "/ddverify-2010-04-30/models/seq1/include/ddverify/blkdev.h"
int number_request_queue_used  =    0;
#line 740 "concatenated.c"
request_queue_t *get_fixed_request_queue(void) 
{ int tmp ;
  void *__cil_tmp2 ;

  {
#line 742
  if (number_request_queue_used < 10) {
#line 743
    tmp = number_request_queue_used;
#line 743
    number_request_queue_used = number_request_queue_used + 1;
#line 743
    return (& fixed_request_queue[tmp]);
  } else {
    {
#line 745
    __cil_tmp2 = (void *)0;
#line 745
    return ((request_queue_t *)__cil_tmp2);
    }
  }
}
}
#line 749 "concatenated.c"
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) 
{ request_queue_t *queue ;
  int tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 753
  tmp = __VERIFIER_nondet_int();
  }
#line 753
  if (tmp) {
    {
#line 754
    queue = get_fixed_request_queue();
#line 756
    queue->queue_lock = lock;
#line 757
    queue->request_fn = rfn;
#line 758
    __cil_tmp5 = (void *)0;
#line 758
    queue->make_request_fn = (make_request_fn *)__cil_tmp5;
#line 759
    queue->__ddv_queue_alive = 1;
    }
#line 761
    return (queue);
  } else {
    {
#line 763
    __cil_tmp6 = (void *)0;
#line 763
    return ((request_queue_t *)__cil_tmp6);
    }
  }
}
}
#line 767 "concatenated.c"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) 
{ request_queue_t *queue ;
  int tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 771
  tmp = __VERIFIER_nondet_int();
  }
#line 771
  if (tmp) {
    {
#line 772
    queue = get_fixed_request_queue();
#line 774
    __cil_tmp4 = (void *)0;
#line 774
    queue->request_fn = (request_fn_proc *)__cil_tmp4;
#line 775
    __cil_tmp5 = (void *)0;
#line 775
    queue->make_request_fn = (make_request_fn *)__cil_tmp5;
#line 776
    queue->__ddv_queue_alive = 1;
    }
#line 778
    return (queue);
  } else {
    {
#line 780
    __cil_tmp6 = (void *)0;
#line 780
    return ((request_queue_t *)__cil_tmp6);
    }
  }
}
}
#line 784 "concatenated.c"
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) 
{ 

  {
#line 786
  q->make_request_fn = mfn;
#line 787
  return;
}
}
#line 789 "concatenated.c"
void end_request(struct request *req , int uptodate ) 
{ int genhd_no ;
  struct gendisk *__cil_tmp4 ;
  struct request_queue *__cil_tmp5 ;

  {
#line 791
  __cil_tmp4 = req->rq_disk;
#line 791
  __cil_tmp5 = __cil_tmp4->queue;
#line 791
  genhd_no = __cil_tmp5->__ddv_genhd_no;
#line 793
  genhd_registered[genhd_no].requests_open = 0;
#line 794
  return;
}
}
#line 797 "concatenated.c"
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) 
{ 

  {
#line 799
  q->hardsect_size = size;
#line 800
  return;
}
}
#line 802 "concatenated.c"
void blk_cleanup_queue(request_queue_t *q ) 
{ 

  {
#line 804
  q->__ddv_queue_alive = 0;
#line 805
  return;
}
}
#line 11 "/ddverify-2010-04-30/models/seq1/include/linux/proc_fs.h"
struct proc_dir_entry *proc_root_driver  ;
#line 823 "concatenated.c"
int misc_register(struct miscdevice *misc ) 
{ int i ;
  dev_t dev ;
  int tmp ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  struct cdev *__cil_tmp8 ;

  {
#line 828
  if (fixed_cdev_used < 1) {
    {
#line 829
    i = fixed_cdev_used;
#line 830
    fixed_cdev_used = fixed_cdev_used + 1;
#line 832
    fixed_cdev[i].owner = (struct module *)0;
#line 833
    fixed_cdev[i].ops = misc->fops;
#line 835
    __cil_tmp5 = misc->minor;
#line 835
    __cil_tmp6 = 10 << 20;
#line 835
    __cil_tmp7 = __cil_tmp6 | __cil_tmp5;
#line 835
    dev = (unsigned int )__cil_tmp7;
#line 837
    __cil_tmp8 = & fixed_cdev[i];
#line 837
    tmp = cdev_add(__cil_tmp8, dev, 0U);
    }
#line 837
    return (tmp);
  } else {
#line 839
    return (-1);
  }
}
}
#line 97 "/ddverify-2010-04-30/models/seq1/include/linux/tty_driver.h"
struct tty_driver *alloc_tty_driver(int lines ) ;
#line 101
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
#line 13 "/ddverify-2010-04-30/models/seq1/include/ddverify/tty.h"
struct ddv_tty_driver global_tty_driver  ;
#line 845 "concatenated.c"
struct tty_driver *alloc_tty_driver(int lines ) 
{ void *__cil_tmp2 ;

  {
#line 847
  if (! global_tty_driver.allocated) {
#line 848
    global_tty_driver.driver.magic = 21506;
#line 849
    global_tty_driver.driver.num = lines;
  } else {
    {
#line 851
    __cil_tmp2 = (void *)0;
#line 851
    return ((struct tty_driver *)__cil_tmp2);
    }
  }
#line 853
  return ((struct tty_driver *)0);
}
}
#line 855 "concatenated.c"
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) 
{ int (*__cil_tmp3)(struct tty_struct *tty , struct file *filp ) ;
  void (*__cil_tmp4)(struct tty_struct *tty , struct file *filp ) ;
  int (*__cil_tmp5)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
  void (*__cil_tmp6)(struct tty_struct *tty , unsigned char ch ) ;
  void (*__cil_tmp7)(struct tty_struct *tty ) ;
  int (*__cil_tmp8)(struct tty_struct *tty ) ;
  int (*__cil_tmp9)(struct tty_struct *tty ) ;
  int (*__cil_tmp10)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                     unsigned long arg ) ;
  void (*__cil_tmp11)(struct tty_struct *tty , struct termios *old ) ;
  void (*__cil_tmp12)(struct tty_struct *tty ) ;
  void (*__cil_tmp13)(struct tty_struct *tty ) ;
  void (*__cil_tmp14)(struct tty_struct *tty ) ;
  void (*__cil_tmp15)(struct tty_struct *tty ) ;
  void (*__cil_tmp16)(struct tty_struct *tty ) ;
  void (*__cil_tmp17)(struct tty_struct *tty , int state ) ;
  void (*__cil_tmp18)(struct tty_struct *tty ) ;
  void (*__cil_tmp19)(struct tty_struct *tty ) ;
  void (*__cil_tmp20)(struct tty_struct *tty , int timeout ) ;
  void (*__cil_tmp21)(struct tty_struct *tty , char ch ) ;
  int (*__cil_tmp22)(char *page , char **start , off_t off , int count , int *eof ,
                     void *data ) ;
  int (*__cil_tmp23)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
  int (*__cil_tmp24)(struct tty_struct *tty , struct file *file ) ;
  int (*__cil_tmp25)(struct tty_struct *tty , struct file *file , unsigned int set ,
                     unsigned int clear ) ;

  {
#line 858
  __cil_tmp3 = op->open;
#line 858
  driver->open = (int (*)(struct tty_struct *tty , struct file *filp ))__cil_tmp3;
#line 859
  __cil_tmp4 = op->close;
#line 859
  driver->close = (void (*)(struct tty_struct *tty , struct file *filp ))__cil_tmp4;
#line 860
  __cil_tmp5 = op->write;
#line 860
  driver->write = (int (*)(struct tty_struct *tty , unsigned char const   *buf , int count ))__cil_tmp5;
#line 861
  __cil_tmp6 = op->put_char;
#line 861
  driver->put_char = (void (*)(struct tty_struct *tty , unsigned char ch ))__cil_tmp6;
#line 862
  __cil_tmp7 = op->flush_chars;
#line 862
  driver->flush_chars = (void (*)(struct tty_struct *tty ))__cil_tmp7;
#line 863
  __cil_tmp8 = op->write_room;
#line 863
  driver->write_room = (int (*)(struct tty_struct *tty ))__cil_tmp8;
#line 864
  __cil_tmp9 = op->chars_in_buffer;
#line 864
  driver->chars_in_buffer = (int (*)(struct tty_struct *tty ))__cil_tmp9;
#line 865
  __cil_tmp10 = op->ioctl;
#line 865
  driver->ioctl = (int (*)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                           unsigned long arg ))__cil_tmp10;
#line 866
  __cil_tmp11 = op->set_termios;
#line 866
  driver->set_termios = (void (*)(struct tty_struct *tty , struct termios *old ))__cil_tmp11;
#line 867
  __cil_tmp12 = op->throttle;
#line 867
  driver->throttle = (void (*)(struct tty_struct *tty ))__cil_tmp12;
#line 868
  __cil_tmp13 = op->unthrottle;
#line 868
  driver->unthrottle = (void (*)(struct tty_struct *tty ))__cil_tmp13;
#line 869
  __cil_tmp14 = op->stop;
#line 869
  driver->stop = (void (*)(struct tty_struct *tty ))__cil_tmp14;
#line 870
  __cil_tmp15 = op->start;
#line 870
  driver->start = (void (*)(struct tty_struct *tty ))__cil_tmp15;
#line 871
  __cil_tmp16 = op->hangup;
#line 871
  driver->hangup = (void (*)(struct tty_struct *tty ))__cil_tmp16;
#line 872
  __cil_tmp17 = op->break_ctl;
#line 872
  driver->break_ctl = (void (*)(struct tty_struct *tty , int state ))__cil_tmp17;
#line 873
  __cil_tmp18 = op->flush_buffer;
#line 873
  driver->flush_buffer = (void (*)(struct tty_struct *tty ))__cil_tmp18;
#line 874
  __cil_tmp19 = op->set_ldisc;
#line 874
  driver->set_ldisc = (void (*)(struct tty_struct *tty ))__cil_tmp19;
#line 875
  __cil_tmp20 = op->wait_until_sent;
#line 875
  driver->wait_until_sent = (void (*)(struct tty_struct *tty , int timeout ))__cil_tmp20;
#line 876
  __cil_tmp21 = op->send_xchar;
#line 876
  driver->send_xchar = (void (*)(struct tty_struct *tty , char ch ))__cil_tmp21;
#line 877
  __cil_tmp22 = op->read_proc;
#line 877
  driver->read_proc = (int (*)(char *page , char **start , off_t off , int count ,
                               int *eof , void *data ))__cil_tmp22;
#line 878
  __cil_tmp23 = op->write_proc;
#line 878
  driver->write_proc = (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                                void *data ))__cil_tmp23;
#line 879
  __cil_tmp24 = op->tiocmget;
#line 879
  driver->tiocmget = (int (*)(struct tty_struct *tty , struct file *file ))__cil_tmp24;
#line 880
  __cil_tmp25 = op->tiocmset;
#line 880
  driver->tiocmset = (int (*)(struct tty_struct *tty , struct file *file , unsigned int set ,
                              unsigned int clear ))__cil_tmp25;
#line 881
  return;
}
}
#line 890 "concatenated.c"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) 
{ int major ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
  {
#line 893
  tmp = __VERIFIER_nondet_int();
#line 893
  return_value = tmp;
  }
#line 894
  if (return_value == 0) {
#line 894
    tmp___0 = 1;
  } else {
#line 894
    if (return_value == -1) {
#line 894
      tmp___0 = 1;
    } else {
#line 894
      tmp___0 = 0;
    }
  }
  {
#line 894
  __VERIFIER_assume(tmp___0);
  }
#line 896
  if (return_value == 0) {
    {
#line 897
    tmp___1 = __VERIFIER_nondet_uint();
#line 897
    major = (int )tmp___1;
#line 898
    __cil_tmp10 = major << 20;
#line 898
    __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 898
    *dev = __cil_tmp11 | baseminor;
    }
  } else {

  }
#line 901
  return (return_value);
}
}
#line 904 "concatenated.c"
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) 
{ int return_value ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 906
  tmp = __VERIFIER_nondet_int();
#line 906
  return_value = tmp;
  }
#line 907
  if (return_value == 0) {
#line 907
    tmp___0 = 1;
  } else {
#line 907
    if (return_value == -1) {
#line 907
      tmp___0 = 1;
    } else {
#line 907
      tmp___0 = 0;
    }
  }
  {
#line 907
  __VERIFIER_assume(tmp___0);
  }
#line 909
  return (return_value);
}
}
#line 914 "concatenated.c"
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) 
{ struct cdev *cdev ;
  int err ;
  int tmp ;
  unsigned int __cil_tmp7 ;
  void const   *__cil_tmp8 ;

  {
  {
#line 921
  tmp = register_chrdev_region(0U, 256U, name);
#line 921
  major = (unsigned int )tmp;
#line 923
  cdev = cdev_alloc();
#line 924
  cdev->owner = fops->owner;
#line 925
  cdev->ops = fops;
#line 927
  __cil_tmp7 = major << 20;
#line 927
  err = cdev_add(cdev, __cil_tmp7, 256U);
  }
#line 929
  if (err) {
    {
#line 930
    __cil_tmp8 = (void const   *)cdev;
#line 930
    kfree(__cil_tmp8);
    }
#line 931
    return (err);
  } else {

  }
#line 934
  return ((int )major);
}
}
#line 937 "concatenated.c"
__inline int unregister_chrdev(unsigned int major , char const   *name ) 
{ 

  {
#line 939
  return (0);
}
}
#line 942 "concatenated.c"
__inline struct cdev *cdev_alloc(void) 
{ int tmp ;

  {
#line 944
  if (fixed_cdev_used < 1) {
#line 945
    tmp = fixed_cdev_used;
#line 945
    fixed_cdev_used = fixed_cdev_used + 1;
#line 945
    return (& fixed_cdev[tmp]);
  } else {

  }
#line 947
  return ((struct cdev *)0);
}
}
#line 949 "concatenated.c"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) 
{ 

  {
#line 951
  cdev->ops = fops;
#line 952
  return;
}
}
#line 954 "concatenated.c"
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) 
{ int return_value ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 956
  p->dev = dev;
#line 957
  p->count = count;
#line 959
  tmp = __VERIFIER_nondet_int();
#line 959
  return_value = tmp;
  }
#line 960
  if (return_value == 0) {
#line 960
    tmp___0 = 1;
  } else {
#line 960
    if (return_value == -1) {
#line 960
      tmp___0 = 1;
    } else {
#line 960
      tmp___0 = 0;
    }
  }
  {
#line 960
  __VERIFIER_assume(tmp___0);
  }
#line 962
  if (return_value == 0) {
    {
#line 963
    __cil_tmp7 = (int )number_cdev_registered;
#line 963
    if (__cil_tmp7 < 1) {
#line 965
      cdev_registered[number_cdev_registered].cdevp = p;
#line 966
      cdev_registered[number_cdev_registered].inode.i_rdev = dev;
#line 967
      cdev_registered[number_cdev_registered].inode.i_cdev = p;
#line 968
      cdev_registered[number_cdev_registered].open = 0;
#line 970
      __cil_tmp8 = (int )number_cdev_registered;
#line 970
      __cil_tmp9 = __cil_tmp8 + 1;
#line 970
      number_cdev_registered = (short )__cil_tmp9;
    } else {
#line 972
      return (-1);
    }
    }
  } else {

  }
#line 976
  return (return_value);
}
}
#line 979 "concatenated.c"
__inline void cdev_del(struct cdev *p ) 
{ int i ;
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
#line 983
  i = 0;
  {
#line 983
  while (1) {
    while_15_continue: /* CIL Label */ ;
    {
#line 983
    __cil_tmp3 = (int )number_cdev_registered;
#line 983
    if (i < __cil_tmp3) {

    } else {
      goto while_15_break;
    }
    }
    {
#line 984
    __cil_tmp4 = (unsigned long )p;
#line 984
    __cil_tmp5 = (unsigned long )cdev_registered[i].cdevp;
#line 984
    if (__cil_tmp5 == __cil_tmp4) {
#line 985
      cdev_registered[i].cdevp = (struct cdev *)0;
#line 987
      return;
    } else {

    }
    }
#line 983
    i = i + 1;
  }
  while_15_break: /* CIL Label */ ;
  }
#line 990
  return;
}
}
#line 994 "concatenated.c"
__inline void mutex_init(struct mutex *lock ) 
{ 

  {
#line 1000
  lock->locked = 0;
#line 1001
  lock->init = 1;
#line 1002
  return;
}
}
#line 1004 "concatenated.c"
__inline void mutex_lock(struct mutex *lock ) 
{ 

  {
  {
#line 1007
  __VERIFIER_atomic_begin();
#line 1008
  assert_context_process();
#line 1013
  lock->locked = 1;
#line 1014
  __VERIFIER_atomic_end();
  }
#line 1015
  return;
}
}
#line 1017 "concatenated.c"
__inline void mutex_unlock(struct mutex *lock ) 
{ 

  {
  {
#line 1020
  assert_context_process();
#line 1024
  lock->locked = 0;
  }
#line 1025
  return;
}
}
#line 1031 "concatenated.c"
int ddv_ioport_request_start  ;
#line 1032 "concatenated.c"
int ddv_ioport_request_len  ;
#line 1034 "concatenated.c"
__inline struct resource *request_region(unsigned long start , unsigned long len ,
                                         char const   *name ) 
{ struct resource *resource ;
  void *tmp ;
  unsigned int __cil_tmp7 ;

  {
  {
#line 1037
  __cil_tmp7 = (unsigned int )32UL;
#line 1037
  tmp = malloc(__cil_tmp7);
#line 1037
  resource = (struct resource *)tmp;
#line 1042
  ddv_ioport_request_start = (int )start;
#line 1043
  ddv_ioport_request_len = (int )len;
  }
#line 1045
  return (resource);
}
}
#line 1048 "concatenated.c"
__inline void release_region(unsigned long start , unsigned long len ) 
{ unsigned int i ;

  {
#line 1050
  i = 0U;
#line 1056
  ddv_ioport_request_start = 0;
#line 1057
  ddv_ioport_request_len = 0;
#line 1058
  return;
}
}
#line 1060 "concatenated.c"
__inline unsigned char inb(unsigned int port ) 
{ unsigned char tmp ;

  {
  {
#line 1062
  tmp = __VERIFIER_nondet_uchar();
  }
#line 1062
  return (tmp);
}
}
#line 1065 "concatenated.c"
__inline void outb(unsigned char byte , unsigned int port ) 
{ 

  {
#line 1067
  return;
}
}
#line 1069 "concatenated.c"
__inline unsigned short inw(unsigned int port ) 
{ unsigned short tmp ;

  {
  {
#line 1071
  tmp = __VERIFIER_nondet_ushort();
  }
#line 1071
  return (tmp);
}
}
#line 1074 "concatenated.c"
__inline void outw(unsigned short word , unsigned int port ) 
{ 

  {
#line 1076
  return;
}
}
#line 1078 "concatenated.c"
__inline unsigned int inl(unsigned int port ) 
{ unsigned int tmp ;

  {
  {
#line 1080
  tmp = __VERIFIER_nondet_unsigned();
  }
#line 1080
  return (tmp);
}
}
#line 1083 "concatenated.c"
__inline void outl(unsigned int doubleword , unsigned int port ) 
{ 

  {
#line 1085
  return;
}
}
#line 1087 "concatenated.c"
__inline unsigned char inb_p(unsigned int port ) 
{ unsigned char tmp ;

  {
  {
#line 1089
  tmp = __VERIFIER_nondet_uchar();
  }
#line 1089
  return (tmp);
}
}
#line 1092 "concatenated.c"
__inline void outb_p(unsigned char byte , unsigned int port ) 
{ 

  {
#line 1094
  return;
}
}
#line 1096 "concatenated.c"
__inline unsigned short inw_p(unsigned int port ) 
{ unsigned short tmp ;

  {
  {
#line 1098
  tmp = __VERIFIER_nondet_ushort();
  }
#line 1098
  return (tmp);
}
}
#line 1101 "concatenated.c"
__inline void outw_p(unsigned short word , unsigned int port ) 
{ 

  {
#line 1103
  return;
}
}
#line 1105 "concatenated.c"
__inline unsigned int inl_p(unsigned int port ) 
{ unsigned int tmp ;

  {
  {
#line 1107
  tmp = __VERIFIER_nondet_unsigned();
  }
#line 1107
  return (tmp);
}
}
#line 1110 "concatenated.c"
__inline void outl_p(unsigned int doubleword , unsigned int port ) 
{ int tmp ;
  unsigned int __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1113
  __cil_tmp4 = (unsigned int )ddv_ioport_request_start;
#line 1113
  if (port >= __cil_tmp4) {
    {
#line 1113
    __cil_tmp5 = ddv_ioport_request_start + ddv_ioport_request_len;
#line 1113
    __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 1113
    if (port < __cil_tmp6) {
#line 1113
      tmp = 1;
    } else {
#line 1113
      tmp = 0;
    }
    }
  } else {
#line 1113
    tmp = 0;
  }
  }
  {
#line 1113
  __cil_tmp7 = (char *)"I/O port is requested";
#line 1113
  __VERIFIER_assert(tmp, __cil_tmp7);
  }
#line 1114
  return;
}
}
#line 1122 "concatenated.c"
void schedule(void) 
{ 

  {
  {
#line 1124
  assert_context_process();
  }
#line 1125
  return;
}
}
#line 1127 "concatenated.c"
long schedule_timeout(long timeout ) 
{ long tmp ;

  {
  {
#line 1129
  assert_context_process();
#line 1131
  tmp = __VERIFIER_nondet_long();
  }
#line 1131
  return (tmp);
}
}
#line 1138 "concatenated.c"
__inline void sema_init(struct semaphore *sem , int val ) 
{ 

  {
#line 1140
  sem->init = 1;
#line 1141
  sem->locked = 0;
#line 1142
  return;
}
}
#line 1144 "concatenated.c"
__inline void init_MUTEX(struct semaphore *sem ) 
{ 

  {
#line 1146
  sem->init = 1;
#line 1147
  sem->locked = 0;
#line 1148
  return;
}
}
#line 1150 "concatenated.c"
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 

  {
#line 1152
  sem->init = 1;
#line 1153
  sem->locked = 1;
#line 1154
  return;
}
}
#line 1156 "concatenated.c"
__inline void down(struct semaphore *sem ) 
{ 

  {
  {
#line 1159
  __VERIFIER_atomic_begin();
#line 1160
  assert_context_process();
#line 1165
  sem->locked = 1;
#line 1166
  __VERIFIER_atomic_end();
  }
#line 1167
  return;
}
}
#line 1169 "concatenated.c"
__inline int down_interruptible(struct semaphore *sem ) 
{ int tmp ;

  {
  {
#line 1171
  tmp = __VERIFIER_nondet_int();
  }
#line 1171
  if (tmp) {
    {
#line 1173
    __VERIFIER_atomic_begin();
#line 1174
    assert_context_process();
#line 1179
    sem->locked = 1;
#line 1180
    __VERIFIER_atomic_end();
    }
#line 1182
    return (0);
  } else {
#line 1184
    return (-1);
  }
}
}
#line 1188 "concatenated.c"
__inline int down_trylock(struct semaphore *sem ) 
{ int __cil_tmp2 ;

  {
  {
#line 1191
  __VERIFIER_atomic_begin();
#line 1192
  assert_context_process();
  }
  {
#line 1198
  __cil_tmp2 = sem->locked;
#line 1198
  if (__cil_tmp2 == 0) {
#line 1199
    sem->locked = 1;
#line 1200
    return (0);
  } else {
#line 1202
    return (1);
  }
  }
  {
#line 1205
  __VERIFIER_atomic_end();
  }
#line 1207
  return (0);
}
}
#line 1210 "concatenated.c"
__inline void up(struct semaphore *sem ) 
{ 

  {
  {
#line 1213
  assert_context_process();
#line 1217
  sem->locked = 0;
  }
#line 1218
  return;
}
}
#line 1222 "concatenated.c"
__inline void tasklet_schedule(struct tasklet_struct *t ) 
{ int i ;
  int next_free ;
  void *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1225
  next_free = -1;
#line 1231
  i = 0;
  {
#line 1231
  while (1) {
    while_16_continue: /* CIL Label */ ;
#line 1231
    if (i < 1) {

    } else {
      goto while_16_break;
    }
    {
#line 1232
    __cil_tmp4 = (void *)0;
#line 1232
    __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 1232
    __cil_tmp6 = (unsigned long )tasklet_registered[i].tasklet;
#line 1232
    if (__cil_tmp6 == __cil_tmp5) {
#line 1233
      next_free = i;
    } else {

    }
    }
    {
#line 1235
    __cil_tmp7 = (unsigned long )t;
#line 1235
    __cil_tmp8 = (unsigned long )tasklet_registered[i].tasklet;
#line 1235
    if (__cil_tmp8 == __cil_tmp7) {
      {
#line 1235
      __cil_tmp9 = (int )tasklet_registered[i].is_running;
#line 1235
      if (__cil_tmp9 == 0) {
#line 1237
        return;
      } else {

      }
      }
    } else {

    }
    }
#line 1231
    i = i + 1;
  }
  while_16_break: /* CIL Label */ ;
  }
#line 1241
  if (next_free == -1) {

  } else {

  }
#line 1245
  tasklet_registered[next_free].tasklet = t;
#line 1246
  tasklet_registered[next_free].is_running = (unsigned short)0;
#line 1247
  return;
}
}
#line 1249 "concatenated.c"
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) 
{ 

  {
#line 1253
  t->count = 0;
#line 1254
  t->init = 0;
#line 1255
  t->func = func;
#line 1256
  t->data = data;
#line 1257
  return;
}
}
#line 1261 "concatenated.c"
__inline void spin_lock_init(spinlock_t *lock ) 
{ 

  {
#line 1263
  lock->init = 1;
#line 1264
  lock->locked = 0;
#line 1265
  return;
}
}
#line 1267 "concatenated.c"
__inline void spin_lock(spinlock_t *lock ) 
{ 

  {
  {
#line 1270
  __VERIFIER_atomic_begin();
#line 1275
  lock->locked = 1;
#line 1276
  __VERIFIER_atomic_end();
  }
#line 1277
  return;
}
}
#line 1279 "concatenated.c"
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) 
{ 

  {
  {
#line 1282
  __VERIFIER_atomic_begin();
#line 1287
  lock->locked = 1;
#line 1288
  __VERIFIER_atomic_end();
  }
#line 1289
  return;
}
}
#line 1291 "concatenated.c"
__inline void spin_lock_irq(spinlock_t *lock ) 
{ 

  {
  {
#line 1294
  __VERIFIER_atomic_begin();
#line 1299
  lock->locked = 1;
#line 1300
  __VERIFIER_atomic_end();
  }
#line 1301
  return;
}
}
#line 1303 "concatenated.c"
__inline void spin_lock_bh(spinlock_t *lock ) 
{ 

  {
  {
#line 1306
  __VERIFIER_atomic_begin();
#line 1311
  lock->locked = 1;
#line 1312
  __VERIFIER_atomic_end();
  }
#line 1313
  return;
}
}
#line 1315 "concatenated.c"
__inline void spin_unlock(spinlock_t *lock ) 
{ 

  {
#line 1321
  lock->locked = 0;
#line 1322
  return;
}
}
#line 1324 "concatenated.c"
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 

  {
#line 1330
  lock->locked = 0;
#line 1331
  return;
}
}
#line 1333 "concatenated.c"
__inline void spin_unlock_irq(spinlock_t *lock ) 
{ 

  {
#line 1339
  lock->locked = 0;
#line 1340
  return;
}
}
#line 1342 "concatenated.c"
__inline void spin_unlock_bh(spinlock_t *lock ) 
{ 

  {
#line 1348
  lock->locked = 0;
#line 1349
  return;
}
}
#line 1353 "concatenated.c"
__inline void init_timer(struct timer_list *timer ) 
{ int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 1355
  __cil_tmp2 = (int )number_timer_registered;
#line 1355
  if (__cil_tmp2 < 1) {
#line 1356
    timer->__ddv_active = (short)0;
#line 1357
    timer->__ddv_init = (short)1;
#line 1358
    timer_registered[number_timer_registered].timer = timer;
#line 1360
    __cil_tmp3 = (int )number_timer_registered;
#line 1360
    __cil_tmp4 = __cil_tmp3 + 1;
#line 1360
    number_timer_registered = (short )__cil_tmp4;
  } else {

  }
  }
#line 1362
  return;
}
}
#line 1364 "concatenated.c"
__inline void add_timer(struct timer_list *timer ) 
{ 

  {
#line 1370
  timer->__ddv_active = (short)1;
#line 1371
  return;
}
}
#line 1373 "concatenated.c"
__inline void add_timer_on(struct timer_list *timer , int cpu ) 
{ 

  {
  {
#line 1376
  add_timer(timer);
  }
#line 1377
  return;
}
}
#line 1379 "concatenated.c"
__inline int del_timer(struct timer_list *timer ) 
{ 

  {
#line 1381
  timer->__ddv_active = (short)0;
#line 1382
  return (0);
}
}
#line 1384 "concatenated.c"
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 

  {
#line 1390
  timer->expires = expires;
#line 1391
  timer->__ddv_active = (short)1;
#line 1392
  return (0);
}
}
#line 1395 "concatenated.c"
__inline void init_waitqueue_head(wait_queue_head_t *q ) 
{ 

  {
#line 1397
  q->init = 1;
#line 1398
  return;
}
}
#line 1400 "concatenated.c"
__inline void wake_up(wait_queue_head_t *q ) 
{ 

  {
#line 1406
  return;
}
}
#line 1408 "concatenated.c"
__inline void wake_up_all(wait_queue_head_t *q ) 
{ 

  {
#line 1414
  return;
}
}
#line 1416 "concatenated.c"
__inline void wake_up_interruptible(wait_queue_head_t *q ) 
{ 

  {
#line 1422
  return;
}
}
#line 1424 "concatenated.c"
__inline void sleep_on(wait_queue_head_t *q ) 
{ 

  {
#line 1430
  return;
}
}
#line 1432 "concatenated.c"
__inline void interruptible_sleep_on(wait_queue_head_t *q ) 
{ 

  {
#line 1438
  return;
}
}
#line 1443 "concatenated.c"
__inline int schedule_work(struct work_struct *work ) 
{ int i ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
#line 1452
  i = 0;
  {
#line 1452
  while (1) {
    while_17_continue: /* CIL Label */ ;
#line 1452
    if (i < 10) {

    } else {
      goto while_17_break;
    }
    {
#line 1453
    __cil_tmp3 = (unsigned long )work;
#line 1453
    __cil_tmp4 = (unsigned long )shared_workqueue[i];
#line 1453
    if (__cil_tmp4 == __cil_tmp3) {
#line 1454
      return (0);
    } else {

    }
    }
    {
#line 1457
    __cil_tmp5 = (void *)0;
#line 1457
    __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 1457
    __cil_tmp7 = (unsigned long )shared_workqueue[i];
#line 1457
    if (__cil_tmp7 == __cil_tmp6) {
#line 1458
      shared_workqueue[i] = work;
#line 1460
      return (1);
    } else {

    }
    }
#line 1452
    i = i + 1;
  }
  while_17_break: /* CIL Label */ ;
  }
#line 1465
  return (-1);
}
}
#line 1468 "concatenated.c"
__inline void call_shared_workqueue_functions(void) 
{ unsigned short i ;
  unsigned short tmp ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  void (*__cil_tmp8)(void * ) ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 1470
  tmp = __VERIFIER_nondet_ushort();
#line 1470
  i = tmp;
#line 1471
  __cil_tmp3 = (int )i;
#line 1471
  __cil_tmp4 = __cil_tmp3 < 10;
#line 1471
  __VERIFIER_assume(__cil_tmp4);
  }
  {
#line 1473
  __cil_tmp5 = (void *)0;
#line 1473
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 1473
  __cil_tmp7 = (unsigned long )shared_workqueue[i];
#line 1473
  if (__cil_tmp7 != __cil_tmp6) {
    {
#line 1474
    __cil_tmp8 = (shared_workqueue[i])->func;
#line 1474
    __cil_tmp9 = (shared_workqueue[i])->data;
#line 1474
    (*__cil_tmp8)(__cil_tmp9);
#line 1475
    __cil_tmp10 = (void *)0;
#line 1475
    shared_workqueue[i] = (struct work_struct *)__cil_tmp10;
    }
  } else {

  }
  }
#line 1477
  return;
}
}
#line 1481 "concatenated.c"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) 
{ int tmp ;

  {
  {
#line 1484
  tmp = __VERIFIER_nondet_int();
  }
#line 1484
  if (tmp) {
#line 1485
    registered_irq[irq].handler = handler;
#line 1486
    registered_irq[irq].dev_id = dev_id;
#line 1488
    return (0);
  } else {
#line 1490
    return (-1);
  }
}
}
#line 1494 "concatenated.c"
void free_irq(unsigned int irq , void *dev_id ) 
{ void *__cil_tmp3 ;

  {
#line 1496
  __cil_tmp3 = (void *)0;
#line 1496
  registered_irq[irq].handler = (irqreturn_t (*)(int  , void * , struct pt_regs * ))__cil_tmp3;
#line 1497
  registered_irq[irq].dev_id = (void *)0;
#line 1498
  return;
}
}
#line 1503 "concatenated.c"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) 
{ 

  {
#line 1506
  if (gfp_mask & 16U) {
    {
#line 1507
    assert_context_process();
    }
  } else {

  }
#line 1509
  return (0UL);
}
}
#line 1511 "concatenated.c"
__inline unsigned long __get_free_page(gfp_t gfp_mask ) 
{ 

  {
#line 1514
  if (gfp_mask & 16U) {
    {
#line 1515
    assert_context_process();
    }
  } else {

  }
#line 1517
  return (0UL);
}
}
#line 1519 "concatenated.c"
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) 
{ 

  {
#line 1522
  if (gfp_mask & 16U) {
    {
#line 1523
    assert_context_process();
    }
  } else {

  }
#line 1525
  return (0UL);
}
}
#line 1536 "concatenated.c"
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 

  {
#line 1539
  if (gfp_mask & 16U) {
    {
#line 1540
    assert_context_process();
    }
  } else {

  }
#line 1542
  return ((struct page *)0);
}
}
#line 1544 "concatenated.c"
__inline struct page *alloc_page(gfp_t gfp_mask ) 
{ 

  {
#line 1547
  if (gfp_mask & 16U) {
    {
#line 1548
    assert_context_process();
    }
  } else {

  }
#line 1550
  return ((struct page *)0);
}
}
#line 1556 "concatenated.c"
void *kmalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 1558
  if (flags & 16U) {
    {
#line 1559
    assert_context_process();
    }
  } else {

  }
  {
#line 1562
  tmp = malloc(size);
  }
#line 1562
  return (tmp);
}
}
#line 1565 "concatenated.c"
void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 1567
  if (flags & 16U) {
    {
#line 1568
    assert_context_process();
    }
  } else {

  }
  {
#line 1571
  tmp = malloc(size);
  }
#line 1571
  return (tmp);
}
}
#line 6 "/ddverify-2010-04-30/models/seq1/include/linux/vmalloc.h"
void *vmalloc(unsigned long size ) ;
#line 1606 "concatenated.c"
void *vmalloc(unsigned long size ) 
{ void *tmp ;
  unsigned int __cil_tmp3 ;

  {
  {
#line 1608
  __cil_tmp3 = (unsigned int )size;
#line 1608
  tmp = malloc(__cil_tmp3);
  }
#line 1608
  return (tmp);
}
}
#line 1610 "concatenated.c"
int printk(char const   *fmt  , ...) 
{ 

  {
#line 1612
  return (0);
}
}
#line 1615 "concatenated.c"
unsigned short __VERIFIER_nondet_ushort(void) 
{ unsigned short us ;

  {
#line 1615
  return (us);
}
}
#line 1616 "concatenated.c"
unsigned long __VERIFIER_nondet_ulong(void) 
{ unsigned long ul ;

  {
#line 1616
  return (ul);
}
}
#line 1617 "concatenated.c"
short __VERIFIER_nondet_short(void) 
{ short s ;

  {
#line 1617
  return (s);
}
}
#line 1618 "concatenated.c"
int __VERIFIER_nondet_int(void) 
{ int i ;

  {
#line 1618
  return (i);
}
}
#line 1619 "concatenated.c"
char __VERIFIER_nondet_char(void) 
{ char c ;

  {
#line 1619
  return (c);
}
}
#line 1620 "concatenated.c"
size_t __VERIFIER_nondet_size_t(void) 
{ size_t s ;

  {
#line 1620
  return (s);
}
}
#line 1621 "concatenated.c"
unsigned int __VERIFIER_nondet_uint(void) 
{ unsigned int ui ;

  {
#line 1621
  return (ui);
}
}
#line 1622 "concatenated.c"
unsigned char __VERIFIER_nondet_uchar(void) 
{ unsigned char uc ;

  {
#line 1622
  return (uc);
}
}
#line 1623 "concatenated.c"
unsigned int __VERIFIER_nondet_unsigned(void) 
{ unsigned int u ;

  {
#line 1623
  return (u);
}
}
#line 1624 "concatenated.c"
long __VERIFIER_nondet_long(void) 
{ long l ;

  {
#line 1624
  return (l);
}
}
#line 1625 "concatenated.c"
char *__VERIFIER_nondet_pchar(void) 
{ char *pc ;

  {
#line 1625
  return (pc);
}
}
#line 1626 "concatenated.c"
loff_t __VERIFIER_nondet_loff_t(void) 
{ loff_t l ;

  {
#line 1626
  return (l);
}
}
#line 1627 "concatenated.c"
sector_t __VERIFIER_nondet_sector_t(void) 
{ sector_t s ;

  {
#line 1627
  return (s);
}
}
#line 1628 "concatenated.c"
loff_t no_llseek(struct file *file , loff_t offset , int origin ) 
{ loff_t l ;

  {
#line 1628
  return (l);
}
}
#line 1633 "concatenated.c"
void __VERIFIER_assume(int phi ) 
{ 

  {
  {
#line 1633
  while (1) {
    while_18_continue: /* CIL Label */ ;
#line 1633
    if (! phi) {

    } else {
      goto while_18_break;
    }
  }
  while_18_break: /* CIL Label */ ;
  }
#line 1633
  return;
}
}
#line 1634 "concatenated.c"
void __VERIFIER_assert(int phi , char *txt ) 
{ 

  {
#line 1634
  if (! phi) {
    ERROR: 
    goto ERROR;
  } else {

  }
#line 1634
  return;
}
}
#line 1636 "concatenated.c"
int nonseekable_open(struct inode *inode , struct file *filp ) 
{ int i ;

  {
#line 1636
  return (i);
}
}
#line 1637 "concatenated.c"
void __module_get(struct module *module ) 
{ 

  {
#line 1637
  return;
}
}
#line 1638 "concatenated.c"
int test_and_set_bit(int nr , unsigned long *addr ) 
{ unsigned int bit ;
  unsigned long old ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
#line 1640
  __cil_tmp5 = nr & 31;
#line 1640
  __cil_tmp6 = 1 << __cil_tmp5;
#line 1640
  bit = (unsigned int )__cil_tmp6;
#line 1641
  __cil_tmp7 = nr >> 5;
#line 1641
  addr = addr + __cil_tmp7;
#line 1642
  old = *addr;
#line 1643
  __cil_tmp8 = (unsigned long )bit;
#line 1643
  *addr = old | __cil_tmp8;
  {
#line 1644
  __cil_tmp9 = (unsigned long )bit;
#line 1644
  __cil_tmp10 = old & __cil_tmp9;
#line 1644
  return (__cil_tmp10 != 0UL);
  }
}
}
#line 1647 "concatenated.c"
void clear_bit(int nr , unsigned long volatile   *addr ) 
{ unsigned int bit ;
  unsigned long old ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long volatile   __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;

  {
#line 1649
  __cil_tmp5 = nr & 31;
#line 1649
  __cil_tmp6 = 1 << __cil_tmp5;
#line 1649
  bit = (unsigned int )__cil_tmp6;
#line 1650
  __cil_tmp7 = nr >> 5;
#line 1650
  addr = addr + __cil_tmp7;
#line 1651
  __cil_tmp8 = *addr;
#line 1651
  old = (unsigned long )__cil_tmp8;
#line 1652
  __cil_tmp9 = ~ bit;
#line 1652
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 1652
  __cil_tmp11 = old & __cil_tmp10;
#line 1652
  *addr = (unsigned long volatile   )__cil_tmp11;
#line 1653
  return;
}
}
#line 1655 "concatenated.c"
int register_reboot_notifier(struct notifier_block *dummy ) 
{ int i ;

  {
#line 1655
  return (i);
}
}
#line 1656 "concatenated.c"
int misc_deregister(struct miscdevice *misc ) 
{ int i ;

  {
#line 1656
  return (i);
}
}
#line 1657 "concatenated.c"
int unregister_reboot_notifier(struct notifier_block *dummy ) 
{ int i ;

  {
#line 1657
  return (i);
}
}
#line 1658 "concatenated.c"
void release_mem_region(unsigned long start , unsigned long len ) 
{ 

  {
#line 1658
  return;
}
}
#line 1659 "concatenated.c"
void kfree(void const   *addr ) 
{ 

  {
#line 1659
  return;
}
}
#line 1661 "concatenated.c"
struct resource *request_mem_region(unsigned long start , unsigned long len , char const   *name ) 
{ void *tmp ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 1663
  __cil_tmp5 = (unsigned int )32UL;
#line 1663
  tmp = malloc(__cil_tmp5);
  }
#line 1663
  return ((struct resource *)tmp);
}
}
#line 1666 "concatenated.c"
void __VERIFIER_atomic_begin(void) 
{ 

  {
#line 1666
  return;
}
}
#line 1667 "concatenated.c"
void __VERIFIER_atomic_end(void) 
{ 

  {
#line 1667
  return;
}
}
