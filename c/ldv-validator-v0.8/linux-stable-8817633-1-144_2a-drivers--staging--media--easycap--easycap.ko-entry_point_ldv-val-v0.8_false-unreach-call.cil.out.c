extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 42 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 45 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_pid_t;
#line 16 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_uid_t;
#line 17 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_gid_t;
#line 18 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_size_t;
#line 19 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_ssize_t;
#line 21 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_time_t;
#line 23 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_clock_t;
#line 24 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_timer_t;
#line 25 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_clockid_t;
#line 32 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef long long __kernel_loff_t;
#line 41 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_uid_t __kernel_uid32_t;
#line 42 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_gid_t __kernel_gid32_t;
#line 21 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 24 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 27 "include/linux/types.h"
typedef unsigned short umode_t;
#line 30 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 35 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 38 "include/linux/types.h"
typedef _Bool bool;
#line 40 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 41 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 54 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 63 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 68 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 78 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 111 "include/linux/types.h"
typedef __s32 int32_t;
#line 117 "include/linux/types.h"
typedef __u32 uint32_t;
#line 142 "include/linux/types.h"
typedef unsigned long sector_t;
#line 143 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 155 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 178 "include/linux/types.h"
typedef __u16 __le16;
#line 180 "include/linux/types.h"
typedef __u32 __le32;
#line 202 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 203 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 215 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 215 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 220 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 220 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 221 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 226
struct hlist_node;
#line 226 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 230 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 241 "include/linux/types.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head * ) ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 38 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   kernel_ulong_t driver_info ;
};
#line 215 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 245 "include/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 267 "include/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 335 "include/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 355 "include/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 594 "include/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 673 "include/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 732 "include/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 782 "include/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 792 "include/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 816 "include/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 881
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 903
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 55 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/alternative.h"
struct module;
#line 146 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 42 "include/linux/dynamic_debug.h"
struct device;
#line 53 "include/linux/dynamic_debug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 71 "include/asm-generic/bug.h"
struct completion;
#line 72
struct pt_regs;
#line 332 "include/linux/kernel.h"
struct pid;
#line 54 "include/linux/delay.h"
struct timespec;
#line 55
struct compat_timespec;
#line 56 "include/linux/delay.h"
struct __anonstruct_futex_10 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 56 "include/linux/delay.h"
struct __anonstruct_nanosleep_11 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 56
struct pollfd;
#line 56 "include/linux/delay.h"
struct __anonstruct_poll_12 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 56 "include/linux/delay.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct_futex_10 futex ;
   struct __anonstruct_nanosleep_11 nanosleep ;
   struct __anonstruct_poll_12 poll ;
};
#line 56 "include/linux/delay.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_9 __annonCompField4 ;
};
#line 59 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/page_types.h"
struct page;
#line 21 "include/asm-generic/getorder.h"
struct task_struct;
#line 22
struct exec_domain;
#line 23
struct mm_struct;
#line 215 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/segment.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 125 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_14 {
   unsigned int a ;
   unsigned int b ;
};
#line 125 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_15 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 125 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_13 {
   struct __anonstruct____missing_field_name_14 __annonCompField5 ;
   struct __anonstruct____missing_field_name_15 __annonCompField6 ;
};
#line 125 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_13 __annonCompField7 ;
};
#line 13 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 192 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 194 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_17 {
   pgdval_t pgd ;
};
#line 194 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_17 pgd_t;
#line 282 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 290
struct file;
#line 305
struct seq_file;
#line 337
struct thread_struct;
#line 339
struct cpumask;
#line 327 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 301 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/ptrace.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 203 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 203 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_20 __annonCompField8 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 13 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 636 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 233 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/paravirt.h"
struct jump_label_key;
#line 91 "include/linux/personality.h"
struct map_segment;
#line 91 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 277 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 295 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 295 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 295 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField12 ;
   struct __anonstruct____missing_field_name_26 __annonCompField13 ;
};
#line 295 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 295 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField15 ;
};
#line 329 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 350 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 355 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 361 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 367 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 375 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct fpu {
   union thread_xstate *state ;
};
#line 421
struct kmem_cache;
#line 422
struct perf_event;
#line 423 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 622 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_29 {
   unsigned long seg ;
};
#line 622 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_29 mm_segment_t;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 131 "include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 149 "include/linux/preempt.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 29 "include/linux/irqnr.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 187 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 14 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 27 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_94 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 27 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_94 __annonCompField17 ;
};
#line 28 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/rwlock.h"
struct __anonstruct____missing_field_name_96 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_95 {
   s64 lock ;
   struct __anonstruct____missing_field_name_96 __annonCompField18 ;
};
#line 33 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_95 arch_rwlock_t;
#line 34 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/rwlock.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_98 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_97 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_98 __annonCompField19 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_97 __annonCompField20 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_99 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_99 rwlock_t;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 233 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 312 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 105 "include/linux/debugobjects.h"
struct tvec_base;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 289 "include/linux/timer.h"
struct hrtimer;
#line 290
enum hrtimer_restart;
#line 302
struct work_struct;
#line 45 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 86 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 28 "include/linux/wait.h"
struct __wait_queue;
#line 28 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 31 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 49 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 54 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 665 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 262
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 269
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 277
struct wakeup_source;
#line 458 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 463
struct pm_qos_constraints;
#line 463 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   ktime_t suspend_time ;
   s64 max_time_suspended_ns ;
   struct pm_subsys_data *subsys_data ;
   struct pm_qos_constraints *constraints ;
};
#line 521 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_101 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_101 nodemask_t;
#line 83 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/numa.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 22 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_102 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_102 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 669 "include/linux/mmzone.h"
struct rw_semaphore;
#line 670 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 187 "include/linux/rcupdate.h"
struct notifier_block;
#line 232 "include/linux/srcu.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 60 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 336 "include/linux/irq.h"
struct proc_dir_entry;
#line 338
struct irqaction;
#line 41 "include/asm-generic/sections.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 189 "include/linux/hardirq.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 108 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 176 "include/linux/rbtree.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned long active_bases ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 28 "include/linux/bug.h"
struct kref {
   atomic_t refcount ;
};
#line 37 "include/linux/jump_label.h"
struct jump_label_key {
   atomic_t enabled ;
};
#line 128
struct tracepoint;
#line 129 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct jump_label_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 94 "include/linux/interrupt.h"
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   unsigned long flags ;
   void *dev_id ;
   void *percpu_dev_id ;
   struct irqaction *next ;
   int irq ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
   unsigned long thread_mask ;
   char const   *name ;
   struct proc_dir_entry *dir ;
};
#line 708
struct sock;
#line 709
struct kobject;
#line 710
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 716 "include/linux/interrupt.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 33 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 62 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 98 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 117
struct sysfs_dirent;
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 215
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct dma_map_ops;
#line 67 "include/linux/klist.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 17 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/device.h"
struct device_private;
#line 18
struct device_driver;
#line 19
struct driver_private;
#line 20
struct class;
#line 21
struct subsys_private;
#line 22
struct bus_type;
#line 23
struct device_node;
#line 24
struct iommu_ops;
#line 25 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 51 "include/linux/device.h"
struct device_attribute;
#line 51
struct driver_attribute;
#line 51 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 125
struct device_type;
#line 182 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 247 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 305
struct class_attribute;
#line 305 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 400 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 453 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 480 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 563 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 573
struct dma_coherent_mem;
#line 573 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
};
#line 686 "include/linux/device.h"
struct wakeup_source {
   char *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned char active : 1 ;
};
#line 999
struct block_device;
#line 92 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 92 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
#line 100 "include/linux/dcache.h"
struct inode;
#line 100
struct dentry_operations;
#line 100
struct super_block;
#line 100 "include/linux/dcache.h"
union __anonunion_d_u_130 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 100 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_130 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
#line 151 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 430 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 112 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 56 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 56 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 258
struct prio_tree_node;
#line 258 "include/linux/radix-tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 19 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 27 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 111
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 118
struct pid_namespace;
#line 118 "include/linux/prio_tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct rcu_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 93 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 96 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 104
struct user_namespace;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "include/linux/fiemap.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 43
struct export_operations;
#line 45
struct iovec;
#line 46
struct kiocb;
#line 47
struct pipe_inode_info;
#line 48
struct poll_table_struct;
#line 49
struct kstatfs;
#line 50
struct cred;
#line 429 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 119 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 185 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 186 "include/linux/quota.h"
typedef long long qsize_t;
#line 189 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 211
struct quota_format_type;
#line 212 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 271 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 324 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 340 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 386 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 417
struct address_space;
#line 418
struct writeback_control;
#line 419
enum migrate_mode;
#line 419
enum migrate_mode;
#line 580 "include/linux/fs.h"
union __anonunion_arg_133 {
   char *buf ;
   void *data ;
};
#line 580 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_132 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_133 arg ;
   int error ;
};
#line 580 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_132 read_descriptor_t;
#line 583 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 637
struct backing_dev_info;
#line 638 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
};
#line 659
struct request_queue;
#line 660
struct hd_struct;
#line 660
struct gendisk;
#line 660 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 732
struct posix_acl;
#line 733
struct inode_operations;
#line 733 "include/linux/fs.h"
union __anonunion____missing_field_name_134 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 733 "include/linux/fs.h"
union __anonunion____missing_field_name_135 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
#line 733
struct file_operations;
#line 733
struct file_lock;
#line 733
struct cdev;
#line 733 "include/linux/fs.h"
union __anonunion____missing_field_name_136 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 733 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   uid_t i_uid ;
   gid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_134 __annonCompField31 ;
   dev_t i_rdev ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   blkcnt_t i_blocks ;
   loff_t i_size ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_135 __annonCompField32 ;
   atomic_t i_count ;
   unsigned int i_blkbits ;
   u64 i_version ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_136 __annonCompField33 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 936 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 944 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 967 "include/linux/fs.h"
union __anonunion_f_u_137 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 967 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_137 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 1106
struct files_struct;
#line 1106 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1107 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1112 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_release_private)(struct file_lock * ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 165 "include/linux/nfs.h"
struct nlm_lockowner;
#line 166 "include/linux/nfs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 18 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 19 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 23
struct fasync_struct;
#line 23 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_139 {
   struct list_head link ;
   int state ;
};
#line 23 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_138 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_139 afs ;
};
#line 23 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_138 fl_u ;
};
#line 1215 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
#line 1407
struct file_system_type;
#line 1407
struct super_operations;
#line 1407
struct xattr_handler;
#line 1407
struct mtd_info;
#line 1407 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1552 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1591 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
};
#line 1626 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1823 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 55 "include/linux/sched.h"
union __anonunion____missing_field_name_141 {
   unsigned long index ;
   void *freelist ;
};
#line 55 "include/linux/sched.h"
struct __anonstruct____missing_field_name_145 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 55 "include/linux/sched.h"
union __anonunion____missing_field_name_144 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_145 __annonCompField35 ;
};
#line 55 "include/linux/sched.h"
struct __anonstruct____missing_field_name_143 {
   union __anonunion____missing_field_name_144 __annonCompField36 ;
   atomic_t _count ;
};
#line 55 "include/linux/sched.h"
union __anonunion____missing_field_name_142 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_143 __annonCompField37 ;
};
#line 55 "include/linux/sched.h"
struct __anonstruct____missing_field_name_140 {
   union __anonunion____missing_field_name_141 __annonCompField34 ;
   union __anonunion____missing_field_name_142 __annonCompField38 ;
};
#line 55 "include/linux/sched.h"
struct __anonstruct____missing_field_name_147 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 55 "include/linux/sched.h"
union __anonunion____missing_field_name_146 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_147 __annonCompField40 ;
};
#line 55 "include/linux/sched.h"
union __anonunion____missing_field_name_148 {
   unsigned long private ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 55 "include/linux/sched.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct____missing_field_name_140 __annonCompField39 ;
   union __anonunion____missing_field_name_146 __annonCompField41 ;
   union __anonunion____missing_field_name_148 __annonCompField42 ;
   unsigned long debug_flags ;
};
#line 192 "include/linux/mm_types.h"
struct __anonstruct_vm_set_150 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 192 "include/linux/mm_types.h"
union __anonunion_shared_149 {
   struct __anonstruct_vm_set_150 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 192
struct anon_vma;
#line 192
struct vm_operations_struct;
#line 192
struct mempolicy;
#line 192 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_149 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 255 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 261 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 274 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 287
struct linux_binfmt;
#line 287
struct mmu_notifier_mm;
#line 287 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 98 "include/linux/sem.h"
struct sem_undo_list;
#line 98 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 107
struct siginfo;
#line 32 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_151 {
   unsigned long sig[1U] ;
};
#line 32 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_151 sigset_t;
#line 17 "include/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "include/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "include/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "include/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 126 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 173 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 185 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_153 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__timer_154 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__rt_155 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_156 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_157 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_158 {
   long _band ;
   int _fd ;
};
#line 11 "include/asm-generic/siginfo.h"
union __anonunion__sifields_152 {
   int _pad[28U] ;
   struct __anonstruct__kill_153 _kill ;
   struct __anonstruct__timer_154 _timer ;
   struct __anonstruct__rt_155 _rt ;
   struct __anonstruct__sigchld_156 _sigchld ;
   struct __anonstruct__sigfault_157 _sigfault ;
   struct __anonstruct__sigpoll_158 _sigpoll ;
};
#line 11 "include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_152 _sifields ;
};
#line 94 "include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 14 "include/linux/signal.h"
struct user_struct;
#line 24 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 10 "include/linux/seccomp.h"
struct __anonstruct_seccomp_t_161 {
   int mode ;
};
#line 10 "include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_161 seccomp_t;
#line 26 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 85 "include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 835 "include/linux/sysctl.h"
struct nsproxy;
#line 29 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 33
struct key;
#line 34
struct signal_struct;
#line 35
struct key_type;
#line 37
struct keyring_list;
#line 115
struct key_user;
#line 115 "include/linux/key.h"
union __anonunion____missing_field_name_164 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 115 "include/linux/key.h"
union __anonunion_type_data_165 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 115 "include/linux/key.h"
union __anonunion_payload_166 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 115 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_164 __annonCompField45 ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_165 type_data ;
   union __anonunion_payload_166 payload ;
};
#line 313
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32U] ;
   gid_t *blocks[0U] ;
};
#line 77 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 91 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 264
struct llist_node;
#line 65 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 186
struct futex_pi_state;
#line 187
struct robust_list_head;
#line 188
struct bio_list;
#line 189
struct fs_struct;
#line 190
struct perf_event_context;
#line 191
struct blk_plug;
#line 150 "include/linux/sched.h"
struct cfs_rq;
#line 44 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 106 "include/linux/aio_abi.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 54 "include/linux/uio.h"
struct kioctx;
#line 55 "include/linux/uio.h"
union __anonunion_ki_obj_167 {
   void *user ;
   struct task_struct *tsk ;
};
#line 55
struct eventfd_ctx;
#line 55 "include/linux/uio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_167 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 162 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 178 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 406 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 449 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 457 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 464 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 481 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 517
struct autogroup;
#line 518
struct tty_struct;
#line 518
struct taskstats;
#line 518
struct tty_audit_buf;
#line 518 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 687 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
   atomic_long_t locked_vm ;
};
#line 732
struct reclaim_state;
#line 733 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 748 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1054
struct io_context;
#line 1077
struct rq;
#line 1078 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1144 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1149 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1184 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1210
struct rt_rq;
#line 1210 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1234
struct mem_cgroup;
#line 1234 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1589
struct css_set;
#line 1589
struct compat_robust_list_head;
#line 1589 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct cred *replacement_session_keyring ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   int mems_allowed_change_disable ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
};
#line 253 "include/linux/pm_runtime.h"
struct usb_device;
#line 254
struct usb_driver;
#line 255
struct wusb_dev;
#line 256
struct ep_device;
#line 257 "include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
};
#line 75 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
   unsigned char *extra ;
   int extralen ;
};
#line 89
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 96 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char reset_running : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 219 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 230 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 294 "include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 306 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 318
struct mon_bus;
#line 318 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   struct dentry *usbfs_dentry ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 362
struct usb_tt;
#line 363 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   struct device *usb_classdev ;
   struct dentry *usbfs_dentry ;
   int maxchild ;
   struct usb_device *children[31U] ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
};
#line 662 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 792 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 804 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char soft_unbind : 1 ;
};
#line 978 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1020
struct urb;
#line 1021 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned char poisoned : 1 ;
};
#line 1038
struct scatterlist;
#line 1038 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 6 "include/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "include/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "include/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 30 "include/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "include/asm-generic/termbits.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 138 "include/asm-generic/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
#line 16 "include/linux/termios.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 34 "include/linux/cdev.h"
struct tty_driver;
#line 35
struct serial_icounter_struct;
#line 36 "include/linux/cdev.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
#line 290 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   int flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
#line 48 "include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};
#line 116 "include/linux/pps_kernel.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
#line 153 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
};
#line 158 "include/linux/tty_ldisc.h"
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0U] ;
};
#line 75 "include/linux/tty.h"
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
#line 95
struct tty_port;
#line 96 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   void (*drop)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
#line 222 "include/linux/tty.h"
struct tty_port {
   struct tty_struct *tty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 244 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios *termios ;
   struct ktermios *termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   struct tty_bufhead buf ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned int column ;
   unsigned char lnext : 1 ;
   unsigned char erasing : 1 ;
   unsigned char raw : 1 ;
   unsigned char real_raw : 1 ;
   unsigned char icanon : 1 ;
   unsigned char closing : 1 ;
   unsigned char echo_overrun : 1 ;
   unsigned short minimum_to_wake ;
   unsigned long overrun_time ;
   int num_overrun ;
   unsigned long process_char_map[4U] ;
   char *read_buf ;
   int read_head ;
   int read_tail ;
   int read_cnt ;
   unsigned long read_flags[64U] ;
   unsigned char *echo_buf ;
   unsigned int echo_pos ;
   unsigned int echo_cnt ;
   int canon_data ;
   unsigned long canon_head ;
   unsigned int canon_column ;
   struct mutex atomic_read_lock ;
   struct mutex atomic_write_lock ;
   struct mutex output_lock ;
   struct mutex echo_lock ;
   unsigned char *write_buf ;
   int write_cnt ;
   spinlock_t read_lock ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 86 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   int node ;
   unsigned int stat[24U] ;
};
#line 52 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 63 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 73 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 34 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct snd_pcm_substream;
#line 18 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 19 "include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 23 "include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 24 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 193 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 201 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 445
struct kernel_param;
#line 446 "include/linux/elf.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 49 "include/linux/moduleparam.h"
struct kparam_string;
#line 49
struct kparam_array;
#line 49 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_173 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 49 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   u16 flags ;
   union __anonunion____missing_field_name_173 __annonCompField47 ;
};
#line 64 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 425 "include/linux/moduleparam.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 45 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 200
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 206 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 221
struct module_sect_attrs;
#line 221
struct module_notes_attrs;
#line 221
struct ftrace_event_call;
#line 221 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 28 "include/linux/of.h"
typedef u32 phandle;
#line 30 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
#line 39 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
#line 600 "include/linux/i2c.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 34 "include/linux/poll.h"
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long key ;
};
#line 38 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 177 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 194 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
};
#line 85 "include/sound/core.h"
struct snd_card;
#line 94
struct snd_info_entry;
#line 94
struct snd_shutdown_f_ops;
#line 94
struct snd_mixer_oss;
#line 94 "include/sound/core.h"
struct snd_card {
   int number ;
   char id[16U] ;
   char driver[16U] ;
   char shortname[32U] ;
   char longname[80U] ;
   char mixername[80U] ;
   char components[128U] ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_card * ) ;
   struct list_head devices ;
   unsigned int last_numid ;
   struct rw_semaphore controls_rwsem ;
   rwlock_t ctl_files_rwlock ;
   int controls_count ;
   int user_ctl_count ;
   struct list_head controls ;
   struct list_head ctl_files ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_id ;
   struct proc_dir_entry *proc_root_link ;
   struct list_head files_list ;
   struct snd_shutdown_f_ops *s_f_ops ;
   spinlock_t files_lock ;
   int shutdown ;
   int free_on_last_close ;
   wait_queue_head_t shutdown_sleep ;
   struct device *dev ;
   struct device *card_dev ;
   unsigned int power_state ;
   struct mutex power_lock ;
   wait_queue_head_t power_sleep ;
   struct snd_mixer_oss *mixer_oss ;
   int mixer_oss_change_count ;
};
#line 143 "include/sound/asound.h"
typedef unsigned long snd_pcm_uframes_t;
#line 144 "include/sound/asound.h"
typedef long snd_pcm_sframes_t;
#line 168 "include/sound/asound.h"
typedef int snd_pcm_access_t;
#line 176 "include/sound/asound.h"
typedef int snd_pcm_format_t;
#line 244 "include/sound/asound.h"
typedef int snd_pcm_subformat_t;
#line 265 "include/sound/asound.h"
typedef int snd_pcm_state_t;
#line 272 "include/sound/asound.h"
union snd_pcm_sync_id {
   unsigned char id[16U] ;
   unsigned short id16[8U] ;
   unsigned int id32[4U] ;
};
#line 306 "include/sound/asound.h"
struct snd_interval {
   unsigned int min ;
   unsigned int max ;
   unsigned char openmin : 1 ;
   unsigned char openmax : 1 ;
   unsigned char integer : 1 ;
   unsigned char empty : 1 ;
};
#line 348 "include/sound/asound.h"
struct snd_mask {
   __u32 bits[8U] ;
};
#line 354 "include/sound/asound.h"
struct snd_pcm_hw_params {
   unsigned int flags ;
   struct snd_mask masks[3U] ;
   struct snd_mask mres[5U] ;
   struct snd_interval intervals[12U] ;
   struct snd_interval ires[9U] ;
   unsigned int rmask ;
   unsigned int cmask ;
   unsigned int info ;
   unsigned int msbits ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   snd_pcm_uframes_t fifo_size ;
   unsigned char reserved[64U] ;
};
#line 413 "include/sound/asound.h"
struct snd_pcm_mmap_status {
   snd_pcm_state_t state ;
   int pad1 ;
   snd_pcm_uframes_t hw_ptr ;
   struct timespec tstamp ;
   snd_pcm_state_t suspended_state ;
};
#line 421 "include/sound/asound.h"
struct snd_pcm_mmap_control {
   snd_pcm_uframes_t appl_ptr ;
   snd_pcm_uframes_t avail_min ;
};
#line 901 "include/sound/asound.h"
struct snd_dma_device {
   int type ;
   struct device *dev ;
};
#line 36 "include/sound/memalloc.h"
struct snd_dma_buffer {
   struct snd_dma_device dev ;
   unsigned char *area ;
   dma_addr_t addr ;
   size_t bytes ;
   void *private_data ;
};
#line 63 "include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
};
#line 34 "include/linux/pm_qos.h"
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 40 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 96 "include/linux/pm_qos.h"
struct snd_pcm_oss_setup {
   char *task_name ;
   unsigned char disable : 1 ;
   unsigned char direct : 1 ;
   unsigned char block : 1 ;
   unsigned char nonblock : 1 ;
   unsigned char partialfrag : 1 ;
   unsigned char nosilence : 1 ;
   unsigned char buggyptr : 1 ;
   unsigned int periods ;
   unsigned int period_size ;
   struct snd_pcm_oss_setup *next ;
};
#line 38 "include/sound/pcm_oss.h"
struct snd_pcm_plugin;
#line 38 "include/sound/pcm_oss.h"
struct snd_pcm_oss_runtime {
   unsigned char params : 1 ;
   unsigned char prepare : 1 ;
   unsigned char trigger : 1 ;
   unsigned char sync_trigger : 1 ;
   int rate ;
   int format ;
   unsigned int channels ;
   unsigned int fragshift ;
   unsigned int maxfrags ;
   unsigned int subdivision ;
   size_t period_bytes ;
   size_t period_frames ;
   size_t period_ptr ;
   unsigned int periods ;
   size_t buffer_bytes ;
   size_t bytes ;
   size_t mmap_bytes ;
   char *buffer ;
   size_t buffer_used ;
   struct mutex params_lock ;
   struct snd_pcm_plugin *plugin_first ;
   struct snd_pcm_plugin *plugin_last ;
   unsigned int prev_hw_ptr_period ;
};
#line 70 "include/sound/pcm_oss.h"
struct snd_pcm_oss_substream {
   unsigned char oss : 1 ;
   struct snd_pcm_oss_setup setup ;
};
#line 75 "include/sound/pcm_oss.h"
struct snd_pcm_oss_stream {
   struct snd_pcm_oss_setup *setup_list ;
   struct mutex setup_mutex ;
   struct snd_info_entry *proc_entry ;
};
#line 82 "include/sound/pcm_oss.h"
struct snd_pcm_oss {
   int reg ;
   unsigned int reg_mask ;
};
#line 88 "include/sound/pcm_oss.h"
struct snd_pcm_hardware {
   unsigned int info ;
   u64 formats ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int channels_min ;
   unsigned int channels_max ;
   size_t buffer_bytes_max ;
   size_t period_bytes_min ;
   size_t period_bytes_max ;
   unsigned int periods_min ;
   unsigned int periods_max ;
   size_t fifo_size ;
};
#line 60 "include/sound/pcm.h"
struct snd_pcm_ops {
   int (*open)(struct snd_pcm_substream * ) ;
   int (*close)(struct snd_pcm_substream * ) ;
   int (*ioctl)(struct snd_pcm_substream * , unsigned int  , void * ) ;
   int (*hw_params)(struct snd_pcm_substream * , struct snd_pcm_hw_params * ) ;
   int (*hw_free)(struct snd_pcm_substream * ) ;
   int (*prepare)(struct snd_pcm_substream * ) ;
   int (*trigger)(struct snd_pcm_substream * , int  ) ;
   snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream * ) ;
   int (*copy)(struct snd_pcm_substream * , int  , snd_pcm_uframes_t  , void * , snd_pcm_uframes_t  ) ;
   int (*silence)(struct snd_pcm_substream * , int  , snd_pcm_uframes_t  , snd_pcm_uframes_t  ) ;
   struct page *(*page)(struct snd_pcm_substream * , unsigned long  ) ;
   int (*mmap)(struct snd_pcm_substream * , struct vm_area_struct * ) ;
   int (*ack)(struct snd_pcm_substream * ) ;
};
#line 210
struct snd_pcm_hw_rule;
#line 213 "include/sound/pcm.h"
struct snd_pcm_hw_rule {
   unsigned int cond ;
   int (*func)(struct snd_pcm_hw_params * , struct snd_pcm_hw_rule * ) ;
   int var ;
   int deps[4U] ;
   void *private ;
};
#line 222 "include/sound/pcm.h"
struct snd_pcm_hw_constraints {
   struct snd_mask masks[3U] ;
   struct snd_interval intervals[12U] ;
   unsigned int rules_num ;
   unsigned int rules_all ;
   struct snd_pcm_hw_rule *rules ;
};
#line 270
struct snd_pcm_hwptr_log;
#line 271 "include/sound/pcm.h"
struct snd_pcm_runtime {
   struct snd_pcm_substream *trigger_master ;
   struct timespec trigger_tstamp ;
   int overrange ;
   snd_pcm_uframes_t avail_max ;
   snd_pcm_uframes_t hw_ptr_base ;
   snd_pcm_uframes_t hw_ptr_interrupt ;
   unsigned long hw_ptr_jiffies ;
   unsigned long hw_ptr_buffer_jiffies ;
   snd_pcm_sframes_t delay ;
   snd_pcm_access_t access ;
   snd_pcm_format_t format ;
   snd_pcm_subformat_t subformat ;
   unsigned int rate ;
   unsigned int channels ;
   snd_pcm_uframes_t period_size ;
   unsigned int periods ;
   snd_pcm_uframes_t buffer_size ;
   snd_pcm_uframes_t min_align ;
   size_t byte_align ;
   unsigned int frame_bits ;
   unsigned int sample_bits ;
   unsigned int info ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   unsigned char no_period_wakeup : 1 ;
   int tstamp_mode ;
   unsigned int period_step ;
   snd_pcm_uframes_t start_threshold ;
   snd_pcm_uframes_t stop_threshold ;
   snd_pcm_uframes_t silence_threshold ;
   snd_pcm_uframes_t silence_size ;
   snd_pcm_uframes_t boundary ;
   snd_pcm_uframes_t silence_start ;
   snd_pcm_uframes_t silence_filled ;
   union snd_pcm_sync_id sync ;
   struct snd_pcm_mmap_status *status ;
   struct snd_pcm_mmap_control *control ;
   snd_pcm_uframes_t twake ;
   wait_queue_head_t sleep ;
   wait_queue_head_t tsleep ;
   struct fasync_struct *fasync ;
   void *private_data ;
   void (*private_free)(struct snd_pcm_runtime * ) ;
   struct snd_pcm_hardware hw ;
   struct snd_pcm_hw_constraints hw_constraints ;
   void (*transfer_ack_begin)(struct snd_pcm_substream * ) ;
   void (*transfer_ack_end)(struct snd_pcm_substream * ) ;
   unsigned int timer_resolution ;
   int tstamp_type ;
   unsigned char *dma_area ;
   dma_addr_t dma_addr ;
   size_t dma_bytes ;
   struct snd_dma_buffer *dma_buffer_p ;
   struct snd_pcm_oss_runtime oss ;
   struct snd_pcm_hwptr_log *hwptr_log ;
};
#line 359 "include/sound/pcm.h"
struct snd_pcm_group {
   spinlock_t lock ;
   struct list_head substreams ;
   int count ;
};
#line 366
struct snd_pcm;
#line 366
struct snd_pcm_str;
#line 366
struct snd_timer;
#line 366 "include/sound/pcm.h"
struct snd_pcm_substream {
   struct snd_pcm *pcm ;
   struct snd_pcm_str *pstr ;
   void *private_data ;
   int number ;
   char name[32U] ;
   int stream ;
   struct pm_qos_request latency_pm_qos_req ;
   size_t buffer_bytes_max ;
   struct snd_dma_buffer dma_buffer ;
   unsigned int dma_buf_id ;
   size_t dma_max ;
   struct snd_pcm_ops *ops ;
   struct snd_pcm_runtime *runtime ;
   struct snd_timer *timer ;
   unsigned char timer_running : 1 ;
   struct snd_pcm_substream *next ;
   struct list_head link_list ;
   struct snd_pcm_group self_group ;
   struct snd_pcm_group *group ;
   void *file ;
   int ref_count ;
   atomic_t mmap_count ;
   unsigned int f_flags ;
   void (*pcm_release)(struct snd_pcm_substream * ) ;
   struct pid *pid ;
   struct snd_pcm_oss_substream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   struct snd_info_entry *proc_hw_params_entry ;
   struct snd_info_entry *proc_sw_params_entry ;
   struct snd_info_entry *proc_status_entry ;
   struct snd_info_entry *proc_prealloc_entry ;
   struct snd_info_entry *proc_prealloc_max_entry ;
   unsigned char hw_opened : 1 ;
};
#line 417 "include/sound/pcm.h"
struct snd_pcm_str {
   int stream ;
   struct snd_pcm *pcm ;
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct snd_pcm_substream *substream ;
   struct snd_pcm_oss_stream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   unsigned int xrun_debug ;
   struct snd_info_entry *proc_xrun_debug_entry ;
};
#line 439 "include/sound/pcm.h"
struct snd_pcm {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   unsigned int info_flags ;
   unsigned short dev_class ;
   unsigned short dev_subclass ;
   char id[64U] ;
   char name[80U] ;
   struct snd_pcm_str streams[2U] ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_pcm * ) ;
   struct device *dev ;
   struct snd_pcm_oss oss ;
};
#line 354 "include/sound/pcm_params.h"
struct snd_info_buffer {
   char *buffer ;
   unsigned int curr ;
   unsigned int size ;
   unsigned int len ;
   int stop ;
   int error ;
};
#line 36 "include/sound/info.h"
struct snd_info_entry_text {
   void (*read)(struct snd_info_entry * , struct snd_info_buffer * ) ;
   void (*write)(struct snd_info_entry * , struct snd_info_buffer * ) ;
};
#line 47 "include/sound/info.h"
struct snd_info_entry_ops {
   int (*open)(struct snd_info_entry * , unsigned short  , void ** ) ;
   int (*release)(struct snd_info_entry * , unsigned short  , void * ) ;
   ssize_t (*read)(struct snd_info_entry * , void * , struct file * , char * , size_t  ,
                   loff_t  ) ;
   ssize_t (*write)(struct snd_info_entry * , void * , struct file * , char const   * ,
                    size_t  , loff_t  ) ;
   loff_t (*llseek)(struct snd_info_entry * , void * , struct file * , loff_t  , int  ) ;
   unsigned int (*poll)(struct snd_info_entry * , void * , struct file * , poll_table * ) ;
   int (*ioctl)(struct snd_info_entry * , void * , struct file * , unsigned int  ,
                unsigned long  ) ;
   int (*mmap)(struct snd_info_entry * , void * , struct inode * , struct file * ,
               struct vm_area_struct * ) ;
};
#line 70 "include/sound/info.h"
union __anonunion_c_189 {
   struct snd_info_entry_text text ;
   struct snd_info_entry_ops *ops ;
};
#line 70 "include/sound/info.h"
struct snd_info_entry {
   char const   *name ;
   umode_t mode ;
   long size ;
   unsigned short content ;
   union __anonunion_c_189 c ;
   struct snd_info_entry *parent ;
   struct snd_card *card ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_info_entry * ) ;
   struct proc_dir_entry *p ;
   struct mutex access ;
   struct list_head children ;
   struct list_head list ;
};
#line 236 "include/sound/control.h"
enum v4l2_field {
    V4L2_FIELD_ANY = 0,
    V4L2_FIELD_NONE = 1,
    V4L2_FIELD_TOP = 2,
    V4L2_FIELD_BOTTOM = 3,
    V4L2_FIELD_INTERLACED = 4,
    V4L2_FIELD_SEQ_TB = 5,
    V4L2_FIELD_SEQ_BT = 6,
    V4L2_FIELD_ALTERNATE = 7,
    V4L2_FIELD_INTERLACED_TB = 8,
    V4L2_FIELD_INTERLACED_BT = 9
} ;
#line 249
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 263
enum v4l2_tuner_type {
    V4L2_TUNER_RADIO = 1,
    V4L2_TUNER_ANALOG_TV = 2,
    V4L2_TUNER_DIGITAL_TV = 3
} ;
#line 275
enum v4l2_colorspace {
    V4L2_COLORSPACE_SMPTE170M = 1,
    V4L2_COLORSPACE_SMPTE240M = 2,
    V4L2_COLORSPACE_REC709 = 3,
    V4L2_COLORSPACE_BT878 = 4,
    V4L2_COLORSPACE_470_SYSTEM_M = 5,
    V4L2_COLORSPACE_470_SYSTEM_BG = 6,
    V4L2_COLORSPACE_JPEG = 7,
    V4L2_COLORSPACE_SRGB = 8
} ;
#line 286
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 294 "include/sound/control.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __s32 width ;
   __s32 height ;
};
#line 232 "include/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 249 "include/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   enum v4l2_field field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   enum v4l2_colorspace colorspace ;
   __u32 priv ;
};
#line 436 "include/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 449 "include/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 458 "include/linux/videodev2.h"
union __anonunion____missing_field_name_192 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 458 "include/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion____missing_field_name_192 __annonCompField48 ;
   __u32 reserved[2U] ;
};
#line 477 "include/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 486 "include/linux/videodev2.h"
union __anonunion____missing_field_name_193 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 486 "include/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion____missing_field_name_193 __annonCompField49 ;
   __u32 reserved[2U] ;
};
#line 675 "include/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 697 "include/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   enum v4l2_field field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 707 "include/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 719 "include/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 732 "include/linux/videodev2.h"
struct v4l2_cropcap {
   enum v4l2_buf_type type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 742 "include/linux/videodev2.h"
struct v4l2_crop {
   enum v4l2_buf_type type ;
   struct v4l2_rect c ;
};
#line 794 "include/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 795 "include/linux/videodev2.h"
struct v4l2_standard {
   __u32 index ;
   v4l2_std_id id ;
   __u8 name[24U] ;
   struct v4l2_fract frameperiod ;
   __u32 framelines ;
   __u32 reserved[4U] ;
};
#line 930 "include/linux/videodev2.h"
struct v4l2_dv_preset {
   __u32 preset ;
   __u32 reserved[4U] ;
};
#line 938 "include/linux/videodev2.h"
struct v4l2_dv_enum_preset {
   __u32 index ;
   __u32 preset ;
   __u8 name[32U] ;
   __u32 width ;
   __u32 height ;
   __u32 reserved[4U] ;
};
#line 950 "include/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 reserved[16U] ;
};
#line 1002 "include/linux/videodev2.h"
union __anonunion____missing_field_name_196 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1002 "include/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
};
#line 1085 "include/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1102 "include/linux/videodev2.h"
union __anonunion____missing_field_name_197 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
};
#line 1102 "include/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
};
#line 1113 "include/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1121
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8
} ;
#line 1132 "include/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   enum v4l2_ctrl_type type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1156 "include/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   __u8 name[32U] ;
   __u32 reserved ;
};
#line 1496 "include/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   enum v4l2_tuner_type type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1753 "include/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1763 "include/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   enum v4l2_tuner_type type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1899 "include/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1920 "include/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1942 "include/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   enum v4l2_buf_type type ;
   __u32 reserved[3U] ;
};
#line 1966 "include/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 2021 "include/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u16 bytesperline ;
   __u16 reserved[7U] ;
};
#line 2038 "include/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   enum v4l2_field field ;
   enum v4l2_colorspace colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 reserved[11U] ;
};
#line 2060 "include/linux/videodev2.h"
union __anonunion_fmt_201 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   __u8 raw_data[200U] ;
};
#line 2060 "include/linux/videodev2.h"
struct v4l2_format {
   enum v4l2_buf_type type ;
   union __anonunion_fmt_201 fmt ;
};
#line 2082 "include/linux/videodev2.h"
union __anonunion_parm_202 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 2082 "include/linux/videodev2.h"
struct v4l2_streamparm {
   enum v4l2_buf_type type ;
   union __anonunion_parm_202 parm ;
};
#line 2147 "include/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2157 "include/linux/videodev2.h"
union __anonunion____missing_field_name_205 {
   __u32 addr ;
   char name[32U] ;
};
#line 2157 "include/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion____missing_field_name_205 __annonCompField55 ;
};
#line 2179 "include/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 2186 "include/linux/videodev2.h"
struct v4l2_dbg_chip_ident {
   struct v4l2_dbg_match match ;
   __u32 ident ;
   __u32 revision ;
};
#line 126 "include/linux/media.h"
struct media_pipeline {

};
#line 129
struct media_pad;
#line 129 "include/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 38 "include/media/media-entity.h"
struct media_entity;
#line 38 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 44 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
};
#line 48
struct media_device;
#line 48 "include/media/media-entity.h"
struct __anonstruct_v4l_211 {
   u32 major ;
   u32 minor ;
};
#line 48 "include/media/media-entity.h"
struct __anonstruct_fb_212 {
   u32 major ;
   u32 minor ;
};
#line 48 "include/media/media-entity.h"
struct __anonstruct_alsa_213 {
   u32 card ;
   u32 device ;
   u32 subdevice ;
};
#line 48 "include/media/media-entity.h"
union __anonunion_info_210 {
   struct __anonstruct_v4l_211 v4l ;
   struct __anonstruct_fb_212 fb ;
   struct __anonstruct_alsa_213 alsa ;
   int dvb ;
};
#line 48 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_210 info ;
};
#line 147
struct video_device;
#line 148
struct v4l2_device;
#line 149
struct v4l2_ctrl_handler;
#line 150 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 56 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 71
struct v4l2_ioctl_ops;
#line 71 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct device *parent ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int debug ;
   v4l2_std_id tvnorms ;
   v4l2_std_id current_norm ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   struct mutex *lock ;
};
#line 202 "include/media/v4l2-dev.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 52 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 96 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_pad * , struct media_pad * , u32  ) ;
};
#line 90 "include/media/media-device.h"
enum v4l2_mbus_pixelcode {
    V4L2_MBUS_FMT_FIXED = 1,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_BE = 4097,
    V4L2_MBUS_FMT_RGB444_2X8_PADHI_LE = 4098,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE = 4099,
    V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE = 4100,
    V4L2_MBUS_FMT_BGR565_2X8_BE = 4101,
    V4L2_MBUS_FMT_BGR565_2X8_LE = 4102,
    V4L2_MBUS_FMT_RGB565_2X8_BE = 4103,
    V4L2_MBUS_FMT_RGB565_2X8_LE = 4104,
    V4L2_MBUS_FMT_Y8_1X8 = 8193,
    V4L2_MBUS_FMT_UYVY8_1_5X8 = 8194,
    V4L2_MBUS_FMT_VYUY8_1_5X8 = 8195,
    V4L2_MBUS_FMT_YUYV8_1_5X8 = 8196,
    V4L2_MBUS_FMT_YVYU8_1_5X8 = 8197,
    V4L2_MBUS_FMT_UYVY8_2X8 = 8198,
    V4L2_MBUS_FMT_VYUY8_2X8 = 8199,
    V4L2_MBUS_FMT_YUYV8_2X8 = 8200,
    V4L2_MBUS_FMT_YVYU8_2X8 = 8201,
    V4L2_MBUS_FMT_Y10_1X10 = 8202,
    V4L2_MBUS_FMT_YUYV10_2X10 = 8203,
    V4L2_MBUS_FMT_YVYU10_2X10 = 8204,
    V4L2_MBUS_FMT_Y12_1X12 = 8211,
    V4L2_MBUS_FMT_UYVY8_1X16 = 8207,
    V4L2_MBUS_FMT_VYUY8_1X16 = 8208,
    V4L2_MBUS_FMT_YUYV8_1X16 = 8209,
    V4L2_MBUS_FMT_YVYU8_1X16 = 8210,
    V4L2_MBUS_FMT_YUYV10_1X20 = 8205,
    V4L2_MBUS_FMT_YVYU10_1X20 = 8206,
    V4L2_MBUS_FMT_SBGGR8_1X8 = 12289,
    V4L2_MBUS_FMT_SGBRG8_1X8 = 12307,
    V4L2_MBUS_FMT_SGRBG8_1X8 = 12290,
    V4L2_MBUS_FMT_SRGGB8_1X8 = 12308,
    V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8 = 12299,
    V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8 = 12300,
    V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8 = 12297,
    V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8 = 12301,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE = 12291,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE = 12292,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE = 12293,
    V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE = 12294,
    V4L2_MBUS_FMT_SBGGR10_1X10 = 12295,
    V4L2_MBUS_FMT_SGBRG10_1X10 = 12302,
    V4L2_MBUS_FMT_SGRBG10_1X10 = 12298,
    V4L2_MBUS_FMT_SRGGB10_1X10 = 12303,
    V4L2_MBUS_FMT_SBGGR12_1X12 = 12296,
    V4L2_MBUS_FMT_SGBRG12_1X12 = 12304,
    V4L2_MBUS_FMT_SGRBG12_1X12 = 12305,
    V4L2_MBUS_FMT_SRGGB12_1X12 = 12306,
    V4L2_MBUS_FMT_JPEG_1X8 = 16385
} ;
#line 142 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u32 reserved[7U] ;
};
#line 118 "include/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 52 "include/linux/v4l2-subdev.h"
struct v4l2_subdev_crop {
   __u32 which ;
   __u32 pad ;
   struct v4l2_rect rect ;
   __u32 reserved[8U] ;
};
#line 65 "include/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 reserved[9U] ;
};
#line 78 "include/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 reserved[9U] ;
};
#line 95 "include/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 106 "include/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 110 "include/media/v4l2-common.h"
struct v4l2_subdev;
#line 111
struct v4l2_subdev_ops;
#line 171 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 212 "include/media/v4l2-common.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
};
#line 100 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 106 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 106 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 107
struct tuner_setup;
#line 108 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 58 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 115 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*g_chip_ident)(struct v4l2_subdev * , struct v4l2_dbg_chip_ident * ) ;
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 175 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 201 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 228 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*enum_framesizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*enum_frameintervals)(struct v4l2_subdev * , struct v4l2_frmivalenum * ) ;
   int (*enum_dv_presets)(struct v4l2_subdev * , struct v4l2_dv_enum_preset * ) ;
   int (*s_dv_preset)(struct v4l2_subdev * , struct v4l2_dv_preset * ) ;
   int (*g_dv_preset)(struct v4l2_subdev * , struct v4l2_dv_preset * ) ;
   int (*query_dv_preset)(struct v4l2_subdev * , struct v4l2_dv_preset * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*enum_mbus_fmt)(struct v4l2_subdev * , unsigned int  , enum v4l2_mbus_pixelcode * ) ;
   int (*enum_mbus_fsizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*g_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*try_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*s_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
};
#line 324 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 364 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 379
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 383 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 431 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 450 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
   int (*get_crop)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_crop * ) ;
};
#line 469 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 481 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 502 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
};
#line 540 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct v4l2_mbus_framefmt *try_fmt ;
   struct v4l2_rect *try_crop ;
};
#line 597 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct mutex ioctl_lock ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 999 "include/linux/soundcard.h"
struct easycap;
#line 999 "include/linux/soundcard.h"
struct easycap_dongle {
   struct easycap *peasycap ;
   struct mutex mutex_video ;
   struct mutex mutex_audio ;
};
#line 231 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct data_buffer {
   struct list_head list_head ;
   void *pgo ;
   void *pto ;
   u16 kount ;
   u16 input ;
};
#line 239 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct data_urb {
   struct list_head list_head ;
   struct urb *purb ;
   int isbuf ;
   int length ;
};
#line 246 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct easycap_standard {
   u16 mask ;
   struct v4l2_standard v4l2_standard ;
};
#line 251 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct easycap_format {
   u16 mask ;
   char name[128U] ;
   struct v4l2_format v4l2_format ;
};
#line 256 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct inputset {
   int input ;
   int input_ok ;
   int standard_offset ;
   int standard_offset_ok ;
   int format_offset ;
   int format_offset_ok ;
   int brightness ;
   int brightness_ok ;
   int contrast ;
   int contrast_ok ;
   int saturation ;
   int saturation_ok ;
   int hue ;
   int hue_ok ;
};
#line 272 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct easycap {
   int isdongle ;
   int minor ;
   struct video_device video_device ;
   struct v4l2_device v4l2_device ;
   int status ;
   unsigned int audio_pages_per_fragment ;
   unsigned int audio_bytes_per_fragment ;
   unsigned int audio_buffer_page_many ;
   s16 oldaudio ;
   int ilk ;
   bool microphone ;
   struct usb_device *pusb_device ;
   struct usb_interface *pusb_interface ;
   struct kref kref ;
   int queued[6U] ;
   int done[6U] ;
   wait_queue_head_t wq_video ;
   wait_queue_head_t wq_audio ;
   wait_queue_head_t wq_trigger ;
   int input ;
   int polled ;
   int standard_offset ;
   int format_offset ;
   struct inputset inputset[6U] ;
   bool ntsc ;
   int fps ;
   int usec ;
   int tolerate ;
   int skip ;
   int skipped ;
   int lost[6U] ;
   int merit[180U] ;
   int video_interface ;
   int video_altsetting_on ;
   int video_altsetting_off ;
   int video_endpointnumber ;
   int video_isoc_maxframesize ;
   int video_isoc_buffer_size ;
   int video_isoc_framesperdesc ;
   int video_isoc_streaming ;
   int video_isoc_sequence ;
   int video_idle ;
   int video_eof ;
   int video_junk ;
   struct data_buffer video_isoc_buffer[16U] ;
   struct data_buffer field_buffer[4U][203U] ;
   struct data_buffer frame_buffer[6U][405U] ;
   struct list_head urb_video_head ;
   struct list_head *purb_video_head ;
   u8 cache[8U] ;
   u8 *pcache ;
   int video_mt ;
   int audio_mt ;
   u32 isequence ;
   int vma_many ;
   int field_fill ;
   int field_page ;
   int field_read ;
   int frame_fill ;
   int frame_read ;
   int frame_lock ;
   u32 pixelformat ;
   int width ;
   int height ;
   int bytesperpixel ;
   bool byteswaporder ;
   bool decimatepixel ;
   bool offerfields ;
   int frame_buffer_used ;
   int frame_buffer_many ;
   int videofieldamount ;
   int brightness ;
   int contrast ;
   int saturation ;
   int hue ;
   int allocation_video_urb ;
   int allocation_video_page ;
   int allocation_video_struct ;
   int registered_video ;
   struct snd_pcm_hardware alsa_hardware ;
   struct snd_card *psnd_card ;
   struct snd_pcm *psnd_pcm ;
   struct snd_pcm_substream *psubstream ;
   int dma_fill ;
   int dma_next ;
   int dma_read ;
   int audio_interface ;
   int audio_altsetting_on ;
   int audio_altsetting_off ;
   int audio_endpointnumber ;
   int audio_isoc_maxframesize ;
   int audio_isoc_buffer_size ;
   int audio_isoc_framesperdesc ;
   int audio_isoc_streaming ;
   int audio_idle ;
   int audio_eof ;
   int volume ;
   int mute ;
   s8 gain ;
   struct data_buffer audio_isoc_buffer[16U] ;
   struct list_head urb_audio_head ;
   struct list_head *purb_audio_head ;
   int audio_fill ;
   int audio_read ;
   int allocation_audio_urb ;
   int allocation_audio_page ;
   int allocation_audio_struct ;
   int registered_audio ;
   long long audio_sample ;
   long long audio_niveau ;
   long long audio_square ;
   struct data_buffer audio_buffer[] ;
};
#line 399 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
typedef int ldv_func_ret_type;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 419 "include/linux/quota.h"
enum migrate_mode;
#line 419
enum migrate_mode;
#line 566 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct stk1160config {
   u16 reg ;
   u16 set ;
};
#line 108 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
struct saa7113config {
   u8 reg ;
   u8 set ;
};
#line 22 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_suseconds_t;
#line 18 "include/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 419 "include/linux/quota.h"
enum migrate_mode;
#line 419
enum migrate_mode;
#line 269 "include/sound/control.h"
enum v4l2_memory {
    V4L2_MEMORY_MMAP = 1,
    V4L2_MEMORY_USERPTR = 2,
    V4L2_MEMORY_OVERLAY = 3
} ;
#line 237 "include/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 reserved[4U] ;
};
#line 290 "include/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   enum v4l2_buf_type type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 501 "include/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 544 "include/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   enum v4l2_buf_type type ;
   enum v4l2_memory memory ;
   __u32 reserved[2U] ;
};
#line 569 "include/linux/videodev2.h"
union __anonunion_m_194 {
   __u32 mem_offset ;
   unsigned long userptr ;
};
#line 569 "include/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_194 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 598 "include/linux/videodev2.h"
union __anonunion_m_195 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
};
#line 598 "include/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   enum v4l2_buf_type type ;
   __u32 bytesused ;
   __u32 flags ;
   enum v4l2_field field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   enum v4l2_memory memory ;
   union __anonunion_m_195 m ;
   __u32 length ;
   __u32 input ;
   __u32 reserved ;
};
#line 1020 "include/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1838 "include/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 419 "include/linux/quota.h"
enum migrate_mode;
#line 419
enum migrate_mode;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 419 "include/linux/quota.h"
enum migrate_mode;
#line 419
enum migrate_mode;
#line 305 "include/sound/asound.h"
typedef int snd_pcm_hw_param_t;
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 435 "include/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 437
  return ((int )((signed char )epd->bEndpointAddress) < 0);
}
}
#line 446 "include/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 449
  return ((int )((signed char )epd->bEndpointAddress) >= 0);
}
}
#line 499 "include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_isoc(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 502
  return (((int )epd->bmAttributes & 3) == 1);
}
}
#line 565 "include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_isoc_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 568
  tmp = usb_endpoint_xfer_isoc(epd);
#line 568
  if (tmp != 0) {
#line 568
    tmp___0 = usb_endpoint_dir_in(epd);
#line 568
    if (tmp___0 != 0) {
#line 568
      tmp___1 = 1;
    } else {
#line 568
      tmp___1 = 0;
    }
  } else {
#line 568
    tmp___1 = 0;
  }
#line 568
  return (tmp___1);
}
}
#line 309 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 311
  return ((int )((unsigned long )*(addr + (unsigned long )(nr / 64U)) >> ((int )nr & 63)) & 1);
}
}
#line 315 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 319
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 324
  return (oldbit);
}
}
#line 101 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 70 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 61 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/page_64_types.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 88 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3237;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3237;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3237;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3237;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3237: ;
#line 14
  return (pfo_ret__);
}
}
#line 55 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 62
extern char *strcpy(char * , char const   * ) ;
#line 23 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 35 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 93 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 95
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 82 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 84
  tmp = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
#line 84
  return (tmp);
}
}
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 37 "include/linux/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 


  {
#line 41
  next->prev = new;
#line 42
  new->next = next;
#line 43
  new->prev = prev;
#line 44
  prev->next = new;
#line 45
  return;
}
}
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 80 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 156
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 584
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 586
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 589
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 124 "include/linux/mutex.h"
__inline static int mutex_is_locked(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 126
  tmp = atomic_read((atomic_t const   *)(& lock->count));
#line 126
  return (tmp != 1);
}
}
#line 136
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
#line 169
extern void mutex_unlock(struct mutex * ) ;
#line 346 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
#line 361
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 30 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 32
  atomic_set(& kref->refcount, 1);
#line 33
  return;
}
}
#line 39 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
#line 41
  tmp = atomic_read((atomic_t const   *)(& kref->refcount));
#line 41
  __ret_warn_on = tmp == 0;
#line 41
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 41
  if (tmp___0 != 0L) {
#line 41
    warn_slowpath_null("include/linux/kref.h", 41);
  } else {

  }
#line 41
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 42
  atomic_inc(& kref->refcount);
#line 43
  return;
}
}
#line 31 "include/linux/jump_label.h"
__inline static int ldv_kref_put_13(struct kref *kref , void (*release)(struct kref * ) ) ;
#line 797 "include/linux/device.h"
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 798
extern int dev_set_drvdata(struct device * , void * ) ;
#line 363 "include/linux/sched.h"
extern void schedule(void) ;
#line 2521 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2523
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2523
  return (tmp);
}
}
#line 2547 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2549
  tmp = test_tsk_thread_flag(p, 2);
#line 2549
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2549
  return ((int )tmp___0);
}
}
#line 199 "include/linux/usb.h"
__inline static void *ldv_usb_get_intfdata_12(struct usb_interface *intf ) ;
#line 208
__inline static void ldv_usb_set_intfdata_8(struct usb_interface *intf , void *data ) ;
#line 212
__inline static void ldv_usb_set_intfdata_8(struct usb_interface *intf , void *data ) ;
#line 216
__inline static void ldv_usb_set_intfdata_8(struct usb_interface *intf , void *data ) ;
#line 515
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) ;
#line 623
extern struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface  const  * ,
                                                           unsigned int  ) ;
#line 947
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 951
int ldv_usb_register_driver_14(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                               char const   *ldv_func_arg3 ) ;
#line 958
extern void usb_deregister(struct usb_driver * ) ;
#line 961
void ldv_usb_deregister_15(struct usb_driver *arg ) ;
#line 1367
struct urb *ldv_usb_alloc_urb_7(int iso_packets , gfp_t mem_flags ) ;
#line 1371
struct urb *ldv_usb_alloc_urb_10(int iso_packets , gfp_t mem_flags ) ;
#line 1376
void ldv_usb_free_urb_3(struct urb *urb ) ;
#line 1380
void ldv_usb_free_urb_4(struct urb *urb ) ;
#line 1387
int ldv_usb_submit_urb_2(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1391
int ldv_usb_submit_urb_5(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1395
int ldv_usb_submit_urb_6(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1398
extern void usb_kill_urb(struct urb * ) ;
#line 1454
extern int usb_set_interface(struct usb_device * , int  , int  ) ;
#line 1558 "include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1561
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 6 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct urb *ldv_alloc_urb(void) ;
#line 7
void ldv_free_urb(struct urb *urb ) ;
#line 11
int ldv_submit_urb(struct urb *urb ) ;
#line 13
struct usb_device *ldv_interface_to_usbdev(void) ;
#line 23
void *ldv_usb_get_intfdata(void) ;
#line 24
void ldv_usb_set_intfdata(void *data ) ;
#line 161 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 218 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 265 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 280
  tmp___2 = __kmalloc(size, flags);
#line 280
  return (tmp___2);
}
}
#line 338 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 340
  tmp = kmalloc(size, flags | 32768U);
#line 340
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 30 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 32 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct usb_interface *easycap_usb_driver_group1  ;
#line 33 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct file *v4l2_fops_group0  ;
#line 34 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct snd_pcm_substream *easycap_alsa_pcm_ops_group0  ;
#line 35 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 36 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 37 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 38 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ref_cnt  ;
#line 39 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 40 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int usb_counter  ;
#line 41 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 42 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct vm_area_struct *easycap_vm_ops_group0  ;
#line 44
void ldv_usb_driver_2(void) ;
#line 45
void ldv_initialize_v4l2_file_operations_3(void) ;
#line 46
void ldv_initialize_vm_operations_struct_4(void) ;
#line 47
void ldv_initialize_snd_pcm_ops_1(void) ;
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 341 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 341
  tmp = constant_test_bit(15U, (unsigned long const volatile   *)(& page->flags));
#line 341
  return (tmp);
}
}
#line 391 "include/linux/mm.h"
extern bool __get_page_tail(struct page * ) ;
#line 393 "include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 395
  tmp___1 = PageTail((struct page  const  *)page);
#line 395
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 395
  if (tmp___2 != 0L) {
#line 396
    tmp = __get_page_tail(page);
#line 396
    tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 396
    if (tmp___0 != 0L) {
#line 397
      return;
    } else {

    }
  } else {

  }
#line 402
  tmp___3 = atomic_read((atomic_t const   *)(& page->__annonCompField39.__annonCompField38.__annonCompField37._count));
#line 402
  tmp___4 = ldv__builtin_expect(tmp___3 <= 0, 0L);
#line 402
  if (tmp___4 != 0L) {
#line 402
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (402), "i" (12UL));
    ldv_26978: ;
#line 402
    goto ldv_26978;
  } else {

  }
#line 403
  atomic_inc(& page->__annonCompField39.__annonCompField38.__annonCompField37._count);
#line 404
  return;
}
}
#line 290 "include/sound/core.h"
extern int snd_card_free(struct snd_card * ) ;
#line 136 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 143 "include/media/v4l2-dev.h"
__inline static int video_register_device(struct video_device *vdev , int type , int nr ) 
{ 
  int tmp ;

  {
#line 146
  tmp = __video_register_device(vdev, type, nr, 1, (vdev->fops)->owner);
#line 146
  return (tmp);
}
}
#line 159
extern void video_unregister_device(struct video_device * ) ;
#line 174 "include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
#line 176
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
#line 176
  return (tmp);
}
}
#line 179 "include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
#line 181
  dev_set_drvdata(& vdev->dev, data);
#line 182
  return;
}
}
#line 184
extern struct video_device *video_devdata(struct file * ) ;
#line 79 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 103
extern void v4l2_device_disconnect(struct v4l2_device * ) ;
#line 106
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 465 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
int easycap_newinput(struct easycap *peasycap , int input ) ;
#line 466
void easycap_testcard(struct easycap *peasycap , int field ) ;
#line 467
int easycap_isdongle(struct easycap *peasycap ) ;
#line 469
long easycap_unlocked_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) ;
#line 471
int easycap_video_dqbuf(struct easycap *peasycap , int mode ) ;
#line 472
int easycap_video_submit_urbs(struct easycap *peasycap ) ;
#line 473
int easycap_video_kill_urbs(struct easycap *peasycap ) ;
#line 474
int easycap_video_fillin_formats(void) ;
#line 476
int adjust_standard(struct easycap *peasycap , v4l2_std_id std_id ) ;
#line 477
int adjust_format(struct easycap *peasycap , u32 width , u32 height , u32 pixelformat ,
                  int field , bool try ) ;
#line 478
int adjust_brightness(struct easycap *peasycap , int value ) ;
#line 479
int adjust_contrast(struct easycap *peasycap , int value ) ;
#line 480
int adjust_saturation(struct easycap *peasycap , int value ) ;
#line 481
int adjust_hue(struct easycap *peasycap , int value ) ;
#line 487
int easycap_alsa_probe(struct easycap *peasycap ) ;
#line 488
int easycap_audio_kill_urbs(struct easycap *peasycap ) ;
#line 489
void easycap_alsa_complete(struct urb *purb ) ;
#line 498
int easycap_wakeup_device(struct usb_device *pusb_device ) ;
#line 500
int setup_stk(struct usb_device *p , bool ntsc ) ;
#line 501
int setup_saa(struct usb_device *p , bool ntsc ) ;
#line 502
int ready_saa(struct usb_device *p ) ;
#line 505
int select_input(struct usb_device *p , int input , int mode ) ;
#line 508
int read_saa(struct usb_device *p , u16 reg0 ) ;
#line 510
int start_100(struct usb_device *p ) ;
#line 511
int stop_100(struct usb_device *p ) ;
#line 523
char const   *strerror(int err ) ;
#line 535 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
int easycap_debug  ;
#line 561 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
bool easycap_readback  ;
#line 562
struct easycap_standard  const  easycap_standard[21U] ;
#line 563
struct easycap_format easycap_format[3361U] ;
#line 564
struct v4l2_queryctrl easycap_control[7U] ;
#line 565 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct easycap_dongle easycapdc60_dongle[8U]  ;
#line 50 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_bars  =    1;
#line 55 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_gain  =    16;
#line 59 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static bool easycap_ntsc  ;
#line 66 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static struct mutex mutex_dongle  ;
#line 67
static void easycap_complete(struct urb *purb ) ;
#line 68
static int reset(struct easycap *peasycap ) ;
#line 69
static int field2frame(struct easycap *peasycap ) ;
#line 70
static int redaub(struct easycap *peasycap , void *pad , void *pex , int much , int more ,
                  u8 mask , u8 margin , bool isuy ) ;
#line 74 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
char const   *strerror(int err ) 
{ 


  {
#line 77
  switch (err) {
  case 0: ;
#line 78
  return ("OK");
  case 12: ;
#line 79
  return ("ENOMEM");
  case 19: ;
#line 80
  return ("ENODEV");
  case 6: ;
#line 81
  return ("ENXIO");
  case 22: ;
#line 82
  return ("EINVAL");
  case 11: ;
#line 83
  return ("EAGAIN");
  case 27: ;
#line 84
  return ("EFBIG");
  case 32: ;
#line 85
  return ("EPIPE");
  case 90: ;
#line 86
  return ("EMSGSIZE");
  case 28: ;
#line 87
  return ("ENOSPC");
  case 115: ;
#line 88
  return ("EINPROGRESS");
  case 63: ;
#line 89
  return ("ENOSR");
  case 75: ;
#line 90
  return ("EOVERFLOW");
  case 71: ;
#line 91
  return ("EPROTO");
  case 84: ;
#line 92
  return ("EILSEQ");
  case 110: ;
#line 93
  return ("ETIMEDOUT");
  case 95: ;
#line 94
  return ("EOPNOTSUPP");
  case 96: ;
#line 95
  return ("EPFNOSUPPORT");
  case 97: ;
#line 96
  return ("EAFNOSUPPORT");
  case 98: ;
#line 97
  return ("EADDRINUSE");
  case 99: ;
#line 98
  return ("EADDRNOTAVAIL");
  case 105: ;
#line 99
  return ("ENOBUFS");
  case 106: ;
#line 100
  return ("EISCONN");
  case 107: ;
#line 101
  return ("ENOTCONN");
  case 108: ;
#line 102
  return ("ESHUTDOWN");
  case 2: ;
#line 103
  return ("ENOENT");
  case 104: ;
#line 104
  return ("ECONNRESET");
  case 62: ;
#line 105
  return ("ETIME");
  case 70: ;
#line 106
  return ("ECOMM");
  case 121: ;
#line 107
  return ("EREMOTEIO");
  case 18: ;
#line 108
  return ("EXDEV");
  case 1: ;
#line 109
  return ("EPERM");
  default: ;
#line 110
  return ("unknown");
  }
}
}
#line 122 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
int easycap_isdongle(struct easycap *peasycap ) 
{ 
  int k ;

  {
#line 125
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 126
    return (-2);
  } else {

  }
#line 127
  k = 0;
#line 127
  goto ldv_32929;
  ldv_32928: ;
#line 128
  if ((unsigned long )easycapdc60_dongle[k].peasycap == (unsigned long )peasycap) {
#line 129
    peasycap->isdongle = k;
#line 130
    return (k);
  } else {

  }
#line 127
  k = k + 1;
  ldv_32929: ;
#line 127
  if (k <= 7) {
#line 129
    goto ldv_32928;
  } else {

  }

#line 133
  return (-1);
}
}
#line 136 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_open(struct inode *inode , struct file *file ) 
{ 
  struct video_device *pvideo_device ;
  struct easycap *peasycap ;
  int rc ;
  void *tmp ;

  {
#line 142
  if (easycap_debug > 3) {
#line 142
    printk("<7>easycap:: %s: \n", "easycap_open");
  } else {

  }
#line 143
  printk("<7>easycap:: %s: ==========OPEN=========\n", "easycap_open");
#line 145
  pvideo_device = video_devdata(file);
#line 146
  if ((unsigned long )pvideo_device == (unsigned long )((struct video_device *)0)) {
#line 147
    printk("<7>easycap:: %s: OLD_ERROR: pvideo_device is NULL.\n", "easycap_open");
#line 148
    return (-14);
  } else {

  }
#line 150
  tmp = video_get_drvdata(pvideo_device);
#line 150
  peasycap = (struct easycap *)tmp;
#line 151
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 152
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_open");
#line 153
    return (-14);
  } else {

  }
#line 155
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 156
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_open");
#line 157
    return (-14);
  } else {

  }
#line 160
  if (easycap_debug > 15) {
#line 160
    printk("<7>easycap::%i%s: peasycap->pusb_device=%p\n", peasycap->isdongle, "easycap_open",
           peasycap->pusb_device);
  } else {

  }
#line 162
  file->private_data = (void *)peasycap;
#line 163
  rc = easycap_wakeup_device(peasycap->pusb_device);
#line 164
  if (rc != 0) {
#line 165
    printk("<7>easycap::%i%s: OLD_ERROR: wakeup_device() rc = %i\n", peasycap->isdongle,
           "easycap_open", rc);
#line 166
    if (rc == -19) {
#line 167
      printk("<7>easycap::%i%s: OLD_ERROR: wakeup_device() returned -ENODEV\n", peasycap->isdongle,
             "easycap_open");
    } else {
#line 169
      printk("<7>easycap::%i%s: OLD_ERROR: wakeup_device() rc = %i\n", peasycap->isdongle,
             "easycap_open", rc);
    }
#line 170
    return (rc);
  } else {

  }
#line 172
  if (easycap_debug > 7) {
#line 172
    printk("<7>easycap::%i%s: wakeup_device() OK\n", peasycap->isdongle, "easycap_open");
  } else {

  }
#line 173
  peasycap->input = 0;
#line 174
  rc = reset(peasycap);
#line 175
  if (rc != 0) {
#line 176
    printk("<7>easycap::%i%s: OLD_ERROR: reset() rc = %i\n", peasycap->isdongle, "easycap_open",
           rc);
#line 177
    return (-14);
  } else {

  }
#line 179
  return (0);
}
}
#line 191 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int reset(struct easycap *peasycap ) 
{ 
  struct easycap_standard  const  *peasycap_standard ;
  int fmtidx ;
  int input ;
  int rate ;
  bool ntsc ;
  bool other ;
  int rc ;
  int tmp ;

  {
#line 198
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 199
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "reset");
#line 200
    return (-14);
  } else {

  }
#line 202
  input = peasycap->input;
#line 215
  other = 0;
#line 216
  if (easycap_debug > 7) {
#line 216
    printk("<7>easycap::%i%s: peasycap->ntsc=%d\n", peasycap->isdongle, "reset", (int )peasycap->ntsc);
  } else {

  }
#line 218
  rate = ready_saa(peasycap->pusb_device);
#line 219
  if (rate < 0) {
#line 220
    if (easycap_debug > 7) {
#line 220
      printk("<7>easycap::%i%s: not ready to capture after %i ms ...\n", peasycap->isdongle,
             "reset", 500);
    } else {

    }
#line 221
    ntsc = (bool )(! ((int )peasycap->ntsc != 0));
#line 222
    if (easycap_debug > 7) {
#line 222
      printk("<7>easycap::%i%s: ... trying  %s ..\n", peasycap->isdongle, "reset",
             (int )ntsc ? (char *)"NTSC" : (char *)"PAL");
    } else {

    }
#line 223
    rc = setup_stk(peasycap->pusb_device, (int )ntsc);
#line 224
    if (rc != 0) {
#line 225
      printk("<7>easycap::%i%s: OLD_ERROR: setup_stk() rc = %i\n", peasycap->isdongle,
             "reset", rc);
#line 226
      return (-14);
    } else {

    }
#line 228
    rc = setup_saa(peasycap->pusb_device, (int )ntsc);
#line 229
    if (rc != 0) {
#line 230
      printk("<7>easycap::%i%s: OLD_ERROR: setup_saa() rc = %i\n", peasycap->isdongle,
             "reset", rc);
#line 231
      return (-14);
    } else {

    }
#line 234
    rate = ready_saa(peasycap->pusb_device);
#line 235
    if (rate < 0) {
#line 236
      if (easycap_debug > 7) {
#line 236
        printk("<7>easycap::%i%s: not ready to capture after %i ms\n", peasycap->isdongle,
               "reset", 500);
      } else {

      }
#line 237
      if (easycap_debug > 7) {
#line 237
        tmp = read_saa(peasycap->pusb_device, 31);
#line 237
        printk("<7>easycap::%i%s: ... saa register 0x1F has 0x%02X\n", peasycap->isdongle,
               "reset", tmp);
      } else {

      }
#line 239
      ntsc = peasycap->ntsc;
    } else {
#line 241
      if (easycap_debug > 7) {
#line 241
        printk("<7>easycap::%i%s: ... success at second try:  %i=rate\n", peasycap->isdongle,
               "reset", rate);
      } else {

      }
#line 242
      ntsc = rate > 1;
#line 243
      other = 1;
    }
  } else {
#line 246
    if (easycap_debug > 7) {
#line 246
      printk("<7>easycap::%i%s: ... success at first try:  %i=rate\n", peasycap->isdongle,
             "reset", rate);
    } else {

    }
#line 247
    ntsc = rate > 1;
  }
#line 249
  if (easycap_debug > 7) {
#line 249
    printk("<7>easycap::%i%s: ntsc=%d\n", peasycap->isdongle, "reset", (int )ntsc);
  } else {

  }
#line 252
  rc = setup_stk(peasycap->pusb_device, (int )ntsc);
#line 253
  if (rc != 0) {
#line 254
    printk("<7>easycap::%i%s: OLD_ERROR: setup_stk() rc = %i\n", peasycap->isdongle, "reset",
           rc);
#line 255
    return (-14);
  } else {

  }
#line 257
  rc = setup_saa(peasycap->pusb_device, (int )ntsc);
#line 258
  if (rc != 0) {
#line 259
    printk("<7>easycap::%i%s: OLD_ERROR: setup_saa() rc = %i\n", peasycap->isdongle, "reset",
           rc);
#line 260
    return (-14);
  } else {

  }
#line 263
  memset((void *)(& peasycap->merit), 0, 720UL);
#line 265
  peasycap->video_eof = 0;
#line 266
  peasycap->audio_eof = 0;
#line 274
  peasycap->input = -8192;
#line 275
  peasycap->standard_offset = -8192;
#line 276
  fmtidx = (int )ntsc;
#line 277
  if ((int )other) {
#line 278
    peasycap_standard = (struct easycap_standard  const  *)(& easycap_standard);
#line 279
    goto ldv_32952;
    ldv_32951: ;
#line 280
    if ((unsigned int )fmtidx == (unsigned int )peasycap_standard->v4l2_standard.index) {
#line 281
      peasycap->inputset[input].standard_offset = (int )(((long )peasycap_standard - (long )(& easycap_standard)) / 80L);
#line 283
      goto ldv_32950;
    } else {

    }
#line 285
    peasycap_standard = peasycap_standard + 1;
    ldv_32952: ;
#line 279
    if ((unsigned int )((unsigned short )peasycap_standard->mask) != 65535U) {
#line 281
      goto ldv_32951;
    } else {

    }
    ldv_32950: ;
#line 287
    if ((unsigned int )((unsigned short )peasycap_standard->mask) == 65535U) {
#line 288
      printk("<7>easycap::%i%s: OLD_ERROR: standard not found\n", peasycap->isdongle,
             "reset");
#line 289
      return (-22);
    } else {

    }
#line 291
    if (easycap_debug > 7) {
#line 291
      printk("<7>easycap::%i%s: %i=peasycap->inputset[%i].standard_offset\n", peasycap->isdongle,
             "reset", peasycap->inputset[input].standard_offset, input);
    } else {

    }
  } else {

  }
#line 294
  peasycap->format_offset = -8192;
#line 295
  peasycap->brightness = -8192;
#line 296
  peasycap->contrast = -8192;
#line 297
  peasycap->saturation = -8192;
#line 298
  peasycap->hue = -8192;
#line 300
  rc = easycap_newinput(peasycap, input);
#line 302
  if (rc != 0) {
#line 303
    printk("<7>easycap::%i%s: OLD_ERROR: newinput(.,%i) rc = %i\n", peasycap->isdongle,
           "reset", rc, input);
#line 304
    return (-14);
  } else {

  }
#line 306
  if (easycap_debug > 3) {
#line 306
    printk("<7>easycap::%i%s: restored input, standard and format\n", peasycap->isdongle,
           "reset");
  } else {

  }
#line 308
  if (easycap_debug > 7) {
#line 308
    printk("<7>easycap::%i%s: true=peasycap->ntsc %d\n", peasycap->isdongle, "reset",
           (int )peasycap->ntsc);
  } else {

  }
#line 310
  if (peasycap->input < 0) {
#line 311
    printk("<7>easycap::%i%s: MISTAKE:  %i=peasycap->input\n", peasycap->isdongle,
           "reset", peasycap->input);
#line 312
    return (-2);
  } else {

  }
#line 314
  if (peasycap->standard_offset < 0) {
#line 315
    printk("<7>easycap::%i%s: MISTAKE:  %i=peasycap->standard_offset\n", peasycap->isdongle,
           "reset", peasycap->standard_offset);
#line 317
    return (-2);
  } else {

  }
#line 319
  if (peasycap->format_offset < 0) {
#line 320
    printk("<7>easycap::%i%s: MISTAKE:  %i=peasycap->format_offset\n", peasycap->isdongle,
           "reset", peasycap->format_offset);
#line 322
    return (-2);
  } else {

  }
#line 324
  if (peasycap->brightness < 0) {
#line 325
    printk("<7>easycap::%i%s: MISTAKE:  %i=peasycap->brightness\n", peasycap->isdongle,
           "reset", peasycap->brightness);
#line 327
    return (-2);
  } else {

  }
#line 329
  if (peasycap->contrast < 0) {
#line 330
    printk("<7>easycap::%i%s: MISTAKE:  %i=peasycap->contrast\n", peasycap->isdongle,
           "reset", peasycap->contrast);
#line 331
    return (-2);
  } else {

  }
#line 333
  if (peasycap->saturation < 0) {
#line 334
    printk("<7>easycap::%i%s: MISTAKE:  %i=peasycap->saturation\n", peasycap->isdongle,
           "reset", peasycap->saturation);
#line 336
    return (-2);
  } else {

  }
#line 338
  if (peasycap->hue < 0) {
#line 339
    printk("<7>easycap::%i%s: MISTAKE:  %i=peasycap->hue\n", peasycap->isdongle, "reset",
           peasycap->hue);
#line 340
    return (-2);
  } else {

  }
#line 342
  return (0);
}
}
#line 361 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
int easycap_newinput(struct easycap *peasycap , int input ) 
{ 
  int rc ;
  int k ;
  int m ;
  int mood ;
  int off ;
  int inputnow ;
  int video_idlenow ;
  int audio_idlenow ;
  bool resubmit ;
  struct v4l2_pix_format *pix ;

  {
#line 367
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 368
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_newinput");
#line 369
    return (-14);
  } else {

  }
#line 371
  if (easycap_debug > 7) {
#line 371
    printk("<7>easycap::%i%s: %i=input sought\n", peasycap->isdongle, "easycap_newinput",
           input);
  } else {

  }
#line 373
  if (input < 0 && input > 5) {
#line 374
    return (-2);
  } else {

  }
#line 375
  inputnow = peasycap->input;
#line 376
  if (input == inputnow) {
#line 377
    return (0);
  } else {

  }
#line 386
  video_idlenow = peasycap->video_idle;
#line 387
  audio_idlenow = peasycap->audio_idle;
#line 389
  peasycap->video_idle = 1;
#line 390
  peasycap->audio_idle = 1;
#line 391
  if (peasycap->video_isoc_streaming != 0) {
#line 392
    resubmit = 1;
#line 393
    easycap_video_kill_urbs(peasycap);
  } else {
#line 395
    resubmit = 0;
  }
#line 398
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 399
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_newinput");
#line 400
    return (-19);
  } else {

  }
#line 402
  rc = usb_set_interface(peasycap->pusb_device, peasycap->video_interface, peasycap->video_altsetting_off);
#line 405
  if (rc != 0) {
#line 406
    printk("<7>easycap::%i%s: OLD_ERROR: usb_set_interface() rc = %i\n", peasycap->isdongle,
           "easycap_newinput", rc);
#line 407
    return (-14);
  } else {

  }
#line 409
  rc = stop_100(peasycap->pusb_device);
#line 410
  if (rc != 0) {
#line 411
    printk("<7>easycap::%i%s: OLD_ERROR: stop_100() rc = %i\n", peasycap->isdongle, "easycap_newinput",
           rc);
#line 412
    return (-14);
  } else {

  }
#line 414
  k = 0;
#line 414
  goto ldv_32971;
  ldv_32970: 
#line 415
  m = 0;
#line 415
  goto ldv_32968;
  ldv_32967: 
#line 416
  memset(peasycap->field_buffer[k][m].pgo, 0, 4096UL);
#line 415
  m = m + 1;
  ldv_32968: ;
#line 415
  if ((unsigned int )m <= 202U) {
#line 417
    goto ldv_32967;
  } else {

  }
#line 414
  k = k + 1;
  ldv_32971: ;
#line 414
  if (k <= 3) {
#line 416
    goto ldv_32970;
  } else {

  }
#line 418
  k = 0;
#line 418
  goto ldv_32977;
  ldv_32976: 
#line 419
  m = 0;
#line 419
  goto ldv_32974;
  ldv_32973: 
#line 420
  memset(peasycap->frame_buffer[k][m].pgo, 0, 4096UL);
#line 419
  m = m + 1;
  ldv_32974: ;
#line 419
  if ((unsigned int )m <= 404U) {
#line 421
    goto ldv_32973;
  } else {

  }
#line 418
  k = k + 1;
  ldv_32977: ;
#line 418
  if (k <= 5) {
#line 420
    goto ldv_32976;
  } else {

  }
#line 422
  peasycap->field_page = 0;
#line 423
  peasycap->field_read = 0;
#line 424
  peasycap->field_fill = 0;
#line 426
  peasycap->frame_read = 0;
#line 427
  peasycap->frame_fill = 0;
#line 428
  k = 0;
#line 428
  goto ldv_32980;
  ldv_32979: 
#line 429
  peasycap->frame_fill = peasycap->frame_fill + 1;
#line 430
  if (peasycap->frame_buffer_many <= peasycap->frame_fill) {
#line 431
    peasycap->frame_fill = 0;
  } else {

  }
#line 428
  k = k + 1;
  ldv_32980: ;
#line 428
  if (peasycap->input > k) {
#line 430
    goto ldv_32979;
  } else {

  }
#line 433
  peasycap->input = input;
#line 434
  select_input(peasycap->pusb_device, peasycap->input, 9);
#line 436
  if (peasycap->inputset[input].input == input) {
#line 437
    off = peasycap->inputset[input].standard_offset;
#line 438
    if (peasycap->standard_offset != off) {
#line 439
      rc = adjust_standard(peasycap, easycap_standard[off].v4l2_standard.id);
#line 441
      if (rc != 0) {
#line 442
        printk("<7>easycap::%i%s: OLD_ERROR: adjust_standard() rc = %i\n", peasycap->isdongle,
               "easycap_newinput", rc);
#line 443
        return (-14);
      } else {

      }
#line 445
      if (easycap_debug > 7) {
#line 445
        printk("<7>easycap::%i%s: %i=peasycap->standard_offset\n", peasycap->isdongle,
               "easycap_newinput", peasycap->standard_offset);
      } else {

      }
    } else
#line 448
    if (easycap_debug > 7) {
#line 448
      printk("<7>easycap::%i%s: %i=peasycap->standard_offset unchanged\n", peasycap->isdongle,
             "easycap_newinput", peasycap->standard_offset);
    } else {

    }
#line 451
    off = peasycap->inputset[input].format_offset;
#line 452
    if (peasycap->format_offset != off) {
#line 453
      pix = & easycap_format[off].v4l2_format.fmt.pix;
#line 455
      rc = adjust_format(peasycap, pix->width, pix->height, pix->pixelformat, (int )pix->field,
                         0);
#line 458
      if (rc < 0) {
#line 459
        printk("<7>easycap::%i%s: OLD_ERROR: adjust_format() rc = %i\n", peasycap->isdongle,
               "easycap_newinput", rc);
#line 460
        return (-14);
      } else {

      }
#line 462
      if (easycap_debug > 7) {
#line 462
        printk("<7>easycap::%i%s: %i=peasycap->format_offset\n", peasycap->isdongle,
               "easycap_newinput", peasycap->format_offset);
      } else {

      }
    } else
#line 465
    if (easycap_debug > 7) {
#line 465
      printk("<7>easycap::%i%s: %i=peasycap->format_offset unchanged\n", peasycap->isdongle,
             "easycap_newinput", peasycap->format_offset);
    } else {

    }
#line 468
    mood = peasycap->inputset[input].brightness;
#line 469
    if (peasycap->brightness != mood) {
#line 470
      rc = adjust_brightness(peasycap, mood);
#line 471
      if (rc != 0) {
#line 472
        printk("<7>easycap::%i%s: OLD_ERROR: adjust_brightness rc = %i\n", peasycap->isdongle,
               "easycap_newinput", rc);
#line 473
        return (-14);
      } else {

      }
#line 475
      if (easycap_debug > 7) {
#line 475
        printk("<7>easycap::%i%s: %i=peasycap->brightness\n", peasycap->isdongle,
               "easycap_newinput", peasycap->brightness);
      } else {

      }
    } else {

    }
#line 478
    mood = peasycap->inputset[input].contrast;
#line 479
    if (peasycap->contrast != mood) {
#line 480
      rc = adjust_contrast(peasycap, mood);
#line 481
      if (rc != 0) {
#line 482
        printk("<7>easycap::%i%s: OLD_ERROR: adjust_contrast rc = %i\n", peasycap->isdongle,
               "easycap_newinput", rc);
#line 483
        return (-14);
      } else {

      }
#line 485
      if (easycap_debug > 7) {
#line 485
        printk("<7>easycap::%i%s: %i=peasycap->contrast\n", peasycap->isdongle, "easycap_newinput",
               peasycap->contrast);
      } else {

      }
    } else {

    }
#line 487
    mood = peasycap->inputset[input].saturation;
#line 488
    if (peasycap->saturation != mood) {
#line 489
      rc = adjust_saturation(peasycap, mood);
#line 490
      if (rc != 0) {
#line 491
        printk("<7>easycap::%i%s: OLD_ERROR: adjust_saturation rc = %i\n", peasycap->isdongle,
               "easycap_newinput", rc);
#line 492
        return (-14);
      } else {

      }
#line 494
      if (easycap_debug > 7) {
#line 494
        printk("<7>easycap::%i%s: %i=peasycap->saturation\n", peasycap->isdongle,
               "easycap_newinput", peasycap->saturation);
      } else {

      }
    } else {

    }
#line 497
    mood = peasycap->inputset[input].hue;
#line 498
    if (peasycap->hue != mood) {
#line 499
      rc = adjust_hue(peasycap, mood);
#line 500
      if (rc != 0) {
#line 501
        printk("<7>easycap::%i%s: OLD_ERROR: adjust_hue rc = %i\n", peasycap->isdongle,
               "easycap_newinput", rc);
#line 502
        return (-14);
      } else {

      }
#line 504
      if (easycap_debug > 7) {
#line 504
        printk("<7>easycap::%i%s: %i=peasycap->hue\n", peasycap->isdongle, "easycap_newinput",
               peasycap->hue);
      } else {

      }
    } else {

    }
  } else {
#line 507
    printk("<7>easycap::%i%s: MISTAKE: easycap.inputset[%i] unpopulated\n", peasycap->isdongle,
           "easycap_newinput", input);
#line 508
    return (-2);
  }
#line 511
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 512
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_newinput");
#line 513
    return (-19);
  } else {

  }
#line 515
  rc = usb_set_interface(peasycap->pusb_device, peasycap->video_interface, peasycap->video_altsetting_on);
#line 518
  if (rc != 0) {
#line 519
    printk("<7>easycap::%i%s: OLD_ERROR: usb_set_interface() rc = %i\n", peasycap->isdongle,
           "easycap_newinput", rc);
#line 520
    return (-14);
  } else {

  }
#line 522
  rc = start_100(peasycap->pusb_device);
#line 523
  if (rc != 0) {
#line 524
    printk("<7>easycap::%i%s: OLD_ERROR: start_100() rc = %i\n", peasycap->isdongle, "easycap_newinput",
           rc);
#line 525
    return (-14);
  } else {

  }
#line 527
  if ((int )resubmit) {
#line 528
    easycap_video_submit_urbs(peasycap);
  } else {

  }
#line 530
  peasycap->video_isoc_sequence = 15;
#line 531
  peasycap->video_idle = video_idlenow;
#line 532
  peasycap->audio_idle = audio_idlenow;
#line 533
  peasycap->video_junk = 0;
#line 535
  return (0);
}
}
#line 538 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
int easycap_video_submit_urbs(struct easycap *peasycap ) 
{ 
  struct data_urb *pdata_urb ;
  struct urb *purb ;
  struct list_head *plist_head ;
  int j ;
  int isbad ;
  int nospc ;
  int m ;
  int rc ;
  int isbuf ;
  struct list_head  const  *__mptr ;
  unsigned int tmp ;
  char const   *tmp___0 ;

  {
#line 546
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 547
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_video_submit_urbs");
#line 548
    return (-14);
  } else {

  }
#line 551
  if ((unsigned long )peasycap->purb_video_head == (unsigned long )((struct list_head *)0)) {
#line 552
    printk("<7>easycap:: %s: OLD_ERROR: peasycap->urb_video_head uninitialized\n", "easycap_video_submit_urbs");
#line 553
    return (-14);
  } else {

  }
#line 555
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 556
    printk("<7>easycap:: %s: OLD_ERROR: peasycap->pusb_device is NULL\n", "easycap_video_submit_urbs");
#line 557
    return (-19);
  } else {

  }
#line 559
  if (peasycap->video_isoc_streaming == 0) {
#line 560
    if (easycap_debug > 3) {
#line 560
      printk("<7>easycap::%i%s: submission of all video urbs\n", peasycap->isdongle,
             "easycap_video_submit_urbs");
    } else {

    }
#line 561
    isbad = 0;
#line 561
    nospc = 0;
#line 561
    m = 0;
#line 562
    plist_head = (peasycap->purb_video_head)->next;
#line 562
    goto ldv_33002;
    ldv_33001: 
#line 563
    __mptr = (struct list_head  const  *)plist_head;
#line 563
    pdata_urb = (struct data_urb *)__mptr;
#line 565
    if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0) && (unsigned long )pdata_urb->purb != (unsigned long )((struct urb *)0)) {
#line 566
      purb = pdata_urb->purb;
#line 567
      isbuf = pdata_urb->isbuf;
#line 568
      purb->interval = 1;
#line 569
      purb->dev = peasycap->pusb_device;
#line 570
      tmp = __create_pipe(peasycap->pusb_device, (unsigned int )peasycap->video_endpointnumber);
#line 570
      purb->pipe = tmp | 128U;
#line 573
      purb->transfer_flags = 2U;
#line 574
      purb->transfer_buffer = peasycap->video_isoc_buffer[isbuf].pgo;
#line 576
      purb->transfer_buffer_length = (u32 )peasycap->video_isoc_buffer_size;
#line 578
      purb->complete = & easycap_complete;
#line 579
      purb->context = (void *)peasycap;
#line 580
      purb->start_frame = 0;
#line 581
      purb->number_of_packets = peasycap->video_isoc_framesperdesc;
#line 584
      j = 0;
#line 584
      goto ldv_32999;
      ldv_32998: 
#line 585
      purb->iso_frame_desc[j].offset = (unsigned int )(peasycap->video_isoc_maxframesize * j);
#line 587
      purb->iso_frame_desc[j].length = (unsigned int )peasycap->video_isoc_maxframesize;
#line 584
      j = j + 1;
      ldv_32999: ;
#line 584
      if (peasycap->video_isoc_framesperdesc > j) {
#line 586
        goto ldv_32998;
      } else {

      }
#line 591
      rc = ldv_usb_submit_urb_2(purb, 208U);
#line 592
      if (rc != 0) {
#line 593
        isbad = isbad + 1;
#line 594
        tmp___0 = strerror(rc);
#line 594
        printk("<7>easycap::%i%s: OLD_ERROR: usb_submit_urb() failed for urb with rc:-%s\n",
               peasycap->isdongle, "easycap_video_submit_urbs", tmp___0);
#line 597
        if (rc == -28) {
#line 598
          nospc = nospc + 1;
        } else {

        }
      } else {
#line 600
        m = m + 1;
      }
    } else {
#line 603
      isbad = isbad + 1;
    }
#line 562
    plist_head = plist_head->next;
    ldv_33002: ;
#line 562
    if ((unsigned long )peasycap->purb_video_head != (unsigned long )plist_head) {
#line 564
      goto ldv_33001;
    } else {

    }

#line 606
    if (nospc != 0) {
#line 607
      printk("<7>easycap::%i%s: -ENOSPC=usb_submit_urb() for %i urbs\n", peasycap->isdongle,
             "easycap_video_submit_urbs", nospc);
#line 608
      printk("<7>easycap::%i%s: .....  possibly inadequate USB bandwidth\n", peasycap->isdongle,
             "easycap_video_submit_urbs");
#line 609
      peasycap->video_eof = 1;
    } else {

    }
#line 612
    if (isbad != 0) {
#line 613
      easycap_video_kill_urbs(peasycap);
    } else {
#line 615
      peasycap->video_isoc_streaming = 1;
    }
  } else
#line 617
  if (easycap_debug > 3) {
#line 617
    printk("<7>easycap::%i%s: already streaming video urbs\n", peasycap->isdongle,
           "easycap_video_submit_urbs");
  } else {

  }
#line 619
  return (0);
}
}
#line 622 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
int easycap_audio_kill_urbs(struct easycap *peasycap ) 
{ 
  int m ;
  struct list_head *plist_head ;
  struct data_urb *pdata_urb ;
  struct list_head  const  *__mptr ;

  {
#line 628
  if (peasycap->audio_isoc_streaming == 0) {
#line 629
    return (0);
  } else {

  }
#line 631
  if ((unsigned long )peasycap->purb_audio_head == (unsigned long )((struct list_head *)0)) {
#line 632
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->purb_audio_head is NULL\n", peasycap->isdongle,
           "easycap_audio_kill_urbs");
#line 633
    return (-14);
  } else {

  }
#line 636
  peasycap->audio_isoc_streaming = 0;
#line 637
  m = 0;
#line 638
  plist_head = (peasycap->purb_audio_head)->next;
#line 638
  goto ldv_33014;
  ldv_33013: 
#line 639
  __mptr = (struct list_head  const  *)plist_head;
#line 639
  pdata_urb = (struct data_urb *)__mptr;
#line 640
  if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0) && (unsigned long )pdata_urb->purb != (unsigned long )((struct urb *)0)) {
#line 641
    usb_kill_urb(pdata_urb->purb);
#line 642
    m = m + 1;
  } else {

  }
#line 638
  plist_head = plist_head->next;
  ldv_33014: ;
#line 638
  if ((unsigned long )peasycap->purb_audio_head != (unsigned long )plist_head) {
#line 640
    goto ldv_33013;
  } else {

  }

#line 646
  if (easycap_debug > 3) {
#line 646
    printk("<7>easycap::%i%s: %i audio urbs killed\n", peasycap->isdongle, "easycap_audio_kill_urbs",
           m);
  } else {

  }
#line 648
  return (0);
}
}
#line 650 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
int easycap_video_kill_urbs(struct easycap *peasycap ) 
{ 
  int m ;
  struct list_head *plist_head ;
  struct data_urb *pdata_urb ;
  struct list_head  const  *__mptr ;

  {
#line 656
  if (peasycap->video_isoc_streaming == 0) {
#line 657
    return (0);
  } else {

  }
#line 659
  if ((unsigned long )peasycap->purb_video_head == (unsigned long )((struct list_head *)0)) {
#line 660
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->purb_video_head is NULL\n", peasycap->isdongle,
           "easycap_video_kill_urbs");
#line 661
    return (-14);
  } else {

  }
#line 664
  peasycap->video_isoc_streaming = 0;
#line 665
  if (easycap_debug > 3) {
#line 665
    printk("<7>easycap::%i%s: killing video urbs\n", peasycap->isdongle, "easycap_video_kill_urbs");
  } else {

  }
#line 666
  m = 0;
#line 667
  plist_head = (peasycap->purb_video_head)->next;
#line 667
  goto ldv_33026;
  ldv_33025: 
#line 668
  __mptr = (struct list_head  const  *)plist_head;
#line 668
  pdata_urb = (struct data_urb *)__mptr;
#line 669
  if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0) && (unsigned long )pdata_urb->purb != (unsigned long )((struct urb *)0)) {
#line 670
    usb_kill_urb(pdata_urb->purb);
#line 671
    m = m + 1;
  } else {

  }
#line 667
  plist_head = plist_head->next;
  ldv_33026: ;
#line 667
  if ((unsigned long )peasycap->purb_video_head != (unsigned long )plist_head) {
#line 669
    goto ldv_33025;
  } else {

  }

#line 674
  if (easycap_debug > 3) {
#line 674
    printk("<7>easycap::%i%s: %i video urbs killed\n", peasycap->isdongle, "easycap_video_kill_urbs",
           m);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_open_noinode(struct file *file ) 
{ 
  int tmp ;

  {
#line 683
  tmp = easycap_open((struct inode *)0, file);
#line 683
  return (tmp);
}
}
#line 686 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int videodev_release(struct video_device *pvideo_device ) 
{ 
  struct easycap *peasycap ;
  void *tmp ;
  int tmp___0 ;

  {
#line 690
  tmp = video_get_drvdata(pvideo_device);
#line 690
  peasycap = (struct easycap *)tmp;
#line 691
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 692
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "videodev_release");
#line 693
    printk("<7>easycap:: %s: ending unsuccessfully\n", "videodev_release");
#line 694
    return (-14);
  } else {

  }
#line 696
  tmp___0 = easycap_video_kill_urbs(peasycap);
#line 696
  if (tmp___0 != 0) {
#line 697
    printk("<7>easycap::%i%s: OLD_ERROR: easycap_video_kill_urbs() failed\n", peasycap->isdongle,
           "videodev_release");
#line 698
    return (-14);
  } else {

  }
#line 700
  if (easycap_debug > 3) {
#line 700
    printk("<7>easycap::%i%s: ending successfully\n", peasycap->isdongle, "videodev_release");
  } else {

  }
#line 701
  return (0);
}
}
#line 714 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static void easycap_delete(struct kref *pkref ) 
{ 
  struct easycap *peasycap ;
  struct data_urb *pdata_urb ;
  struct list_head *plist_head ;
  struct list_head *plist_next ;
  int k ;
  int m ;
  int gone ;
  int kd ;
  int allocation_video_urb ;
  int allocation_video_page ;
  int allocation_video_struct ;
  int allocation_audio_urb ;
  int allocation_audio_page ;
  int allocation_audio_struct ;
  int registered_video ;
  int registered_audio ;
  struct kref  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  int tmp ;

  {
#line 728
  __mptr = (struct kref  const  *)pkref;
#line 728
  peasycap = (struct easycap *)__mptr + 0xfffffffffffff870UL;
#line 729
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 730
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap is NULL: cannot perform deletions\n",
           peasycap->isdongle, "easycap_delete");
#line 731
    return;
  } else {

  }
#line 733
  kd = easycap_isdongle(peasycap);
#line 739
  if ((unsigned long )peasycap->purb_video_head != (unsigned long )((struct list_head *)0)) {
#line 740
    m = 0;
#line 741
    plist_head = (peasycap->purb_video_head)->next;
#line 741
    goto ldv_33061;
    ldv_33060: 
#line 742
    __mptr___0 = (struct list_head  const  *)plist_head;
#line 742
    pdata_urb = (struct data_urb *)__mptr___0;
#line 744
    if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0) && (unsigned long )pdata_urb->purb != (unsigned long )((struct urb *)0)) {
#line 745
      ldv_usb_free_urb_3(pdata_urb->purb);
#line 746
      pdata_urb->purb = (struct urb *)0;
#line 747
      peasycap->allocation_video_urb = peasycap->allocation_video_urb - 1;
#line 748
      m = m + 1;
    } else {

    }
#line 741
    plist_head = plist_head->next;
    ldv_33061: ;
#line 741
    if ((unsigned long )peasycap->purb_video_head != (unsigned long )plist_head) {
#line 743
      goto ldv_33060;
    } else {

    }

#line 752
    if (easycap_debug > 3) {
#line 752
      printk("<7>easycap::%i%s: %i video urbs freed\n", peasycap->isdongle, "easycap_delete",
             m);
    } else {

    }
#line 754
    if (easycap_debug > 3) {
#line 754
      printk("<7>easycap::%i%s: freeing video data_urb structures.\n", peasycap->isdongle,
             "easycap_delete");
    } else {

    }
#line 755
    m = 0;
#line 756
    plist_head = (peasycap->purb_video_head)->next;
#line 756
    plist_next = plist_head->next;
#line 756
    goto ldv_33066;
    ldv_33065: 
#line 758
    __mptr___1 = (struct list_head  const  *)plist_head;
#line 758
    pdata_urb = (struct data_urb *)__mptr___1;
#line 760
    if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0)) {
#line 761
      peasycap->allocation_video_struct = (int )((unsigned int )peasycap->allocation_video_struct - 32U);
#line 763
      kfree((void const   *)pdata_urb);
#line 764
      m = m + 1;
    } else {

    }
#line 756
    plist_head = plist_next;
#line 756
    plist_next = plist_head->next;
    ldv_33066: ;
#line 756
    if ((unsigned long )peasycap->purb_video_head != (unsigned long )plist_head) {
#line 758
      goto ldv_33065;
    } else {

    }

#line 767
    if (easycap_debug > 3) {
#line 767
      printk("<7>easycap::%i%s: %i video data_urb structures freed\n", peasycap->isdongle,
             "easycap_delete", m);
    } else {

    }
#line 768
    if (easycap_debug > 3) {
#line 768
      printk("<7>easycap::%i%s: setting peasycap->purb_video_head=NULL\n", peasycap->isdongle,
             "easycap_delete");
    } else {

    }
#line 769
    peasycap->purb_video_head = (struct list_head *)0;
  } else {

  }
#line 772
  if (easycap_debug > 3) {
#line 772
    printk("<7>easycap::%i%s: freeing video isoc buffers.\n", peasycap->isdongle,
           "easycap_delete");
  } else {

  }
#line 773
  m = 0;
#line 774
  k = 0;
#line 774
  goto ldv_33069;
  ldv_33068: ;
#line 775
  if ((unsigned long )peasycap->video_isoc_buffer[k].pgo != (unsigned long )((void *)0)) {
#line 776
    free_pages((unsigned long )peasycap->video_isoc_buffer[k].pgo, 3U);
#line 779
    peasycap->video_isoc_buffer[k].pgo = (void *)0;
#line 780
    peasycap->allocation_video_page = (int )((unsigned int )peasycap->allocation_video_page - 8U);
#line 782
    m = m + 1;
  } else {

  }
#line 774
  k = k + 1;
  ldv_33069: ;
#line 774
  if (k <= 15) {
#line 776
    goto ldv_33068;
  } else {

  }

#line 785
  if (easycap_debug > 3) {
#line 785
    printk("<7>easycap::%i%s: isoc video buffers freed: %i pages\n", peasycap->isdongle,
           "easycap_delete", m * 8);
  } else {

  }
#line 788
  if (easycap_debug > 3) {
#line 788
    printk("<7>easycap::%i%s: freeing video field buffers.\n", peasycap->isdongle,
           "easycap_delete");
  } else {

  }
#line 789
  gone = 0;
#line 790
  k = 0;
#line 790
  goto ldv_33075;
  ldv_33074: 
#line 791
  m = 0;
#line 791
  goto ldv_33072;
  ldv_33071: ;
#line 792
  if ((unsigned long )peasycap->field_buffer[k][m].pgo != (unsigned long )((void *)0)) {
#line 793
    free_pages((unsigned long )peasycap->field_buffer[k][m].pgo, 0U);
#line 795
    peasycap->field_buffer[k][m].pgo = (void *)0;
#line 796
    peasycap->allocation_video_page = peasycap->allocation_video_page + -1;
#line 797
    gone = gone + 1;
  } else {

  }
#line 791
  m = m + 1;
  ldv_33072: ;
#line 791
  if ((unsigned int )m <= 202U) {
#line 793
    goto ldv_33071;
  } else {

  }
#line 790
  k = k + 1;
  ldv_33075: ;
#line 790
  if (k <= 3) {
#line 792
    goto ldv_33074;
  } else {

  }

#line 801
  if (easycap_debug > 3) {
#line 801
    printk("<7>easycap::%i%s: video field buffers freed: %i pages\n", peasycap->isdongle,
           "easycap_delete", gone);
  } else {

  }
#line 803
  if (easycap_debug > 3) {
#line 803
    printk("<7>easycap::%i%s: freeing video frame buffers.\n", peasycap->isdongle,
           "easycap_delete");
  } else {

  }
#line 804
  gone = 0;
#line 805
  k = 0;
#line 805
  goto ldv_33081;
  ldv_33080: 
#line 806
  m = 0;
#line 806
  goto ldv_33078;
  ldv_33077: ;
#line 807
  if ((unsigned long )peasycap->frame_buffer[k][m].pgo != (unsigned long )((void *)0)) {
#line 808
    free_pages((unsigned long )peasycap->frame_buffer[k][m].pgo, 0U);
#line 810
    peasycap->frame_buffer[k][m].pgo = (void *)0;
#line 811
    peasycap->allocation_video_page = peasycap->allocation_video_page + -1;
#line 812
    gone = gone + 1;
  } else {

  }
#line 806
  m = m + 1;
  ldv_33078: ;
#line 806
  if ((unsigned int )m <= 404U) {
#line 808
    goto ldv_33077;
  } else {

  }
#line 805
  k = k + 1;
  ldv_33081: ;
#line 805
  if (k <= 5) {
#line 807
    goto ldv_33080;
  } else {

  }

#line 816
  if (easycap_debug > 3) {
#line 816
    printk("<7>easycap::%i%s: video frame buffers freed: %i pages\n", peasycap->isdongle,
           "easycap_delete", gone);
  } else {

  }
#line 822
  if ((unsigned long )peasycap->purb_audio_head != (unsigned long )((struct list_head *)0)) {
#line 823
    if (easycap_debug > 3) {
#line 823
      printk("<7>easycap::%i%s: freeing audio urbs\n", peasycap->isdongle, "easycap_delete");
    } else {

    }
#line 824
    m = 0;
#line 825
    plist_head = (peasycap->purb_audio_head)->next;
#line 825
    goto ldv_33086;
    ldv_33085: 
#line 826
    __mptr___2 = (struct list_head  const  *)plist_head;
#line 826
    pdata_urb = (struct data_urb *)__mptr___2;
#line 828
    if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0) && (unsigned long )pdata_urb->purb != (unsigned long )((struct urb *)0)) {
#line 829
      ldv_usb_free_urb_4(pdata_urb->purb);
#line 830
      pdata_urb->purb = (struct urb *)0;
#line 831
      peasycap->allocation_audio_urb = peasycap->allocation_audio_urb - 1;
#line 832
      m = m + 1;
    } else {

    }
#line 825
    plist_head = plist_head->next;
    ldv_33086: ;
#line 825
    if ((unsigned long )peasycap->purb_audio_head != (unsigned long )plist_head) {
#line 827
      goto ldv_33085;
    } else {

    }

#line 835
    if (easycap_debug > 3) {
#line 835
      printk("<7>easycap::%i%s: %i audio urbs freed\n", peasycap->isdongle, "easycap_delete",
             m);
    } else {

    }
#line 837
    if (easycap_debug > 3) {
#line 837
      printk("<7>easycap::%i%s: freeing audio data_urb structures.\n", peasycap->isdongle,
             "easycap_delete");
    } else {

    }
#line 838
    m = 0;
#line 839
    plist_head = (peasycap->purb_audio_head)->next;
#line 839
    plist_next = plist_head->next;
#line 839
    goto ldv_33091;
    ldv_33090: 
#line 841
    __mptr___3 = (struct list_head  const  *)plist_head;
#line 841
    pdata_urb = (struct data_urb *)__mptr___3;
#line 843
    if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0)) {
#line 844
      peasycap->allocation_audio_struct = (int )((unsigned int )peasycap->allocation_audio_struct - 32U);
#line 846
      kfree((void const   *)pdata_urb);
#line 847
      m = m + 1;
    } else {

    }
#line 839
    plist_head = plist_next;
#line 839
    plist_next = plist_head->next;
    ldv_33091: ;
#line 839
    if ((unsigned long )peasycap->purb_audio_head != (unsigned long )plist_head) {
#line 841
      goto ldv_33090;
    } else {

    }

#line 850
    if (easycap_debug > 3) {
#line 850
      printk("<7>easycap::%i%s: %i audio data_urb structures freed\n", peasycap->isdongle,
             "easycap_delete", m);
    } else {

    }
#line 851
    if (easycap_debug > 3) {
#line 851
      printk("<7>easycap::%i%s: setting peasycap->purb_audio_head=NULL\n", peasycap->isdongle,
             "easycap_delete");
    } else {

    }
#line 852
    peasycap->purb_audio_head = (struct list_head *)0;
  } else {

  }
#line 855
  if (easycap_debug > 3) {
#line 855
    printk("<7>easycap::%i%s: freeing audio isoc buffers.\n", peasycap->isdongle,
           "easycap_delete");
  } else {

  }
#line 856
  m = 0;
#line 857
  k = 0;
#line 857
  goto ldv_33094;
  ldv_33093: ;
#line 858
  if ((unsigned long )peasycap->audio_isoc_buffer[k].pgo != (unsigned long )((void *)0)) {
#line 859
    free_pages((unsigned long )peasycap->audio_isoc_buffer[k].pgo, 1U);
#line 862
    peasycap->audio_isoc_buffer[k].pgo = (void *)0;
#line 863
    peasycap->allocation_audio_page = (int )((unsigned int )peasycap->allocation_audio_page - 2U);
#line 865
    m = m + 1;
  } else {

  }
#line 857
  k = k + 1;
  ldv_33094: ;
#line 857
  if (k <= 15) {
#line 859
    goto ldv_33093;
  } else {

  }

#line 868
  if (easycap_debug > 3) {
#line 868
    printk("<7>easycap::%i%s: easyoss_delete(): isoc audio buffers freed: %i pages\n",
           peasycap->isdongle, "easycap_delete", m * 2);
  } else {

  }
#line 871
  if (easycap_debug > 3) {
#line 871
    printk("<7>easycap::%i%s: freeing easycap structure.\n", peasycap->isdongle, "easycap_delete");
  } else {

  }
#line 872
  allocation_video_urb = peasycap->allocation_video_urb;
#line 873
  allocation_video_page = peasycap->allocation_video_page;
#line 874
  allocation_video_struct = peasycap->allocation_video_struct;
#line 875
  registered_video = peasycap->registered_video;
#line 876
  allocation_audio_urb = peasycap->allocation_audio_urb;
#line 877
  allocation_audio_page = peasycap->allocation_audio_page;
#line 878
  allocation_audio_struct = peasycap->allocation_audio_struct;
#line 879
  registered_audio = peasycap->registered_audio;
#line 881
  if (kd >= 0 && kd <= 7) {
#line 882
    tmp = mutex_lock_interruptible_nested(& mutex_dongle, 0U);
#line 882
    if (tmp != 0) {
#line 883
      printk("<7>easycap:: %s: OLD_ERROR: cannot down mutex_dongle\n", "easycap_delete");
    } else {
#line 885
      if (easycap_debug > 3) {
#line 885
        printk("<7>easycap::%i%s: locked mutex_dongle\n", peasycap->isdongle, "easycap_delete");
      } else {

      }
#line 886
      easycapdc60_dongle[kd].peasycap = (struct easycap *)0;
#line 887
      mutex_unlock(& mutex_dongle);
#line 888
      if (easycap_debug > 3) {
#line 888
        printk("<7>easycap::%i%s: unlocked mutex_dongle\n", peasycap->isdongle, "easycap_delete");
      } else {

      }
#line 889
      if (easycap_debug > 3) {
#line 889
        printk("<7>easycap:: %s:    null-->dongle[%i].peasycap\n", "easycap_delete",
               kd);
      } else {

      }
#line 890
      allocation_video_struct = (int )((unsigned int )allocation_video_struct - 134768U);
    }
  } else {
#line 893
    printk("<7>easycap:: %s: OLD_ERROR: cannot purge dongle[].peasycap", "easycap_delete");
  }
#line 896
  kfree((void const   *)peasycap);
#line 899
  printk("<7>easycap:: %s: %8i=video urbs    after all deletions\n", "easycap_delete",
         allocation_video_urb);
#line 900
  printk("<7>easycap:: %s: %8i=video pages   after all deletions\n", "easycap_delete",
         allocation_video_page);
#line 901
  printk("<7>easycap:: %s: %8i=video structs after all deletions\n", "easycap_delete",
         allocation_video_struct);
#line 902
  printk("<7>easycap:: %s: %8i=video devices after all deletions\n", "easycap_delete",
         registered_video);
#line 903
  printk("<7>easycap:: %s: %8i=audio urbs    after all deletions\n", "easycap_delete",
         allocation_audio_urb);
#line 904
  printk("<7>easycap:: %s: %8i=audio pages   after all deletions\n", "easycap_delete",
         allocation_audio_page);
#line 905
  printk("<7>easycap:: %s: %8i=audio structs after all deletions\n", "easycap_delete",
         allocation_audio_struct);
#line 906
  printk("<7>easycap:: %s: %8i=audio devices after all deletions\n", "easycap_delete",
         registered_audio);
#line 908
  if (easycap_debug > 3) {
#line 908
    printk("<7>easycap:: %s: ending.\n", "easycap_delete");
  } else {

  }
#line 909
  return;
}
}
#line 912 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static unsigned int easycap_poll(struct file *file , poll_table *wait ) 
{ 
  struct easycap *peasycap ;
  int rc ;
  int kd ;
  int tmp ;
  int tmp___0 ;

  {
#line 917
  if (easycap_debug > 7) {
#line 917
    printk("<7>easycap:: %s: \n", "easycap_poll");
  } else {

  }
#line 919
  if ((unsigned long )wait == (unsigned long )((poll_table *)0)) {
#line 920
    if (easycap_debug > 7) {
#line 920
      printk("<7>easycap:: %s: WARNING:  poll table pointer is NULL ... continuing\n",
             "easycap_poll");
    } else {

    }
  } else {

  }
#line 921
  if ((unsigned long )file == (unsigned long )((struct file *)0)) {
#line 922
    printk("<7>easycap:: %s: OLD_ERROR:  file pointer is NULL\n", "easycap_poll");
#line 923
    return (4294966784U);
  } else {

  }
#line 925
  peasycap = (struct easycap *)file->private_data;
#line 926
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 927
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_poll");
#line 928
    return (4294967282U);
  } else {

  }
#line 930
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 931
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap->pusb_device is NULL\n", "easycap_poll");
#line 932
    return (4294967282U);
  } else {

  }
#line 935
  kd = easycap_isdongle(peasycap);
#line 936
  if (kd >= 0 && kd <= 7) {
#line 937
    tmp = mutex_lock_interruptible_nested(& easycapdc60_dongle[kd].mutex_video, 0U);
#line 937
    if (tmp != 0) {
#line 938
      printk("<7>easycap:: %s: OLD_ERROR: cannot down dongle[%i].mutex_video\n", "easycap_poll",
             kd);
#line 939
      return (4294966784U);
    } else {

    }
#line 941
    if (easycap_debug > 3) {
#line 941
      printk("<7>easycap::%i%s: locked dongle[%i].mutex_video\n", peasycap->isdongle,
             "easycap_poll", kd);
    } else {

    }
#line 947
    tmp___0 = easycap_isdongle(peasycap);
#line 947
    if (tmp___0 != kd) {
#line 948
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 949
      return (4294966784U);
    } else {

    }
#line 951
    if ((unsigned long )file == (unsigned long )((struct file *)0)) {
#line 952
      printk("<7>easycap:: %s: OLD_ERROR:  file is NULL\n", "easycap_poll");
#line 953
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 954
      return (4294966784U);
    } else {

    }
#line 956
    peasycap = (struct easycap *)file->private_data;
#line 957
    if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 958
      printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_poll");
#line 959
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 960
      return (4294966784U);
    } else {

    }
#line 962
    if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 963
      printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
             "easycap_poll");
#line 964
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 965
      return (4294966784U);
    } else {

    }
  } else {
#line 973
    return (4294966784U);
  }
#line 975
  rc = easycap_video_dqbuf(peasycap, 0);
#line 976
  peasycap->polled = 1;
#line 977
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 978
  if (rc != 0) {
#line 979
    return (8U);
  } else {

  }
#line 981
  return (65U);
}
}
#line 989 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
int easycap_video_dqbuf(struct easycap *peasycap , int mode ) 
{ 
  int input ;
  int ifield ;
  int miss ;
  int rc ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 994
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 995
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_video_dqbuf");
#line 996
    return (-14);
  } else {

  }
#line 998
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 999
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap->pusb_device is NULL\n", "easycap_video_dqbuf");
#line 1000
    return (-14);
  } else {

  }
#line 1002
  ifield = 0;
#line 1003
  if (easycap_debug > 7) {
#line 1003
    printk("<7>easycap::%i%s: %i=ifield\n", peasycap->isdongle, "easycap_video_dqbuf",
           ifield);
  } else {

  }
#line 1019
  input = peasycap->input;
#line 1020
  if (input >= 0 && input <= 5) {
#line 1021
    rc = read_saa(peasycap->pusb_device, 31);
#line 1022
    if (rc >= 0) {
#line 1023
      if ((rc & 64) != 0) {
#line 1024
        peasycap->lost[input] = peasycap->lost[input] + 1;
      } else {
#line 1026
        peasycap->lost[input] = peasycap->lost[input] + -2;
      }
#line 1028
      if (peasycap->lost[input] < 0) {
#line 1029
        peasycap->lost[input] = 0;
      } else
#line 1030
      if (peasycap->lost[input] > 100) {
#line 1031
        peasycap->lost[input] = 100;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1039
  miss = 0;
#line 1040
  goto ldv_33120;
  ldv_33119: ;
#line 1045
  if (mode != 0) {
#line 1046
    return (-11);
  } else {

  }
#line 1048
  if (easycap_debug > 7) {
#line 1048
    printk("<7>easycap::%i%s: first wait  on wq_video, %i=field_read %i=field_fill\n",
           peasycap->isdongle, "easycap_video_dqbuf", peasycap->field_read, peasycap->field_fill);
  } else {

  }
#line 1051
  __ret = 0;
#line 1051
  if ((peasycap->video_idle == 0 && peasycap->video_eof == 0) && ((peasycap->field_read == peasycap->field_fill || ((unsigned int )peasycap->field_buffer[peasycap->field_read][0].kount & 65280U) != 0U) || ((int )peasycap->field_buffer[peasycap->field_read][0].kount & 255) != ifield)) {
#line 1051
    tmp = get_current();
#line 1051
    __wait.flags = 0U;
#line 1051
    __wait.private = (void *)tmp;
#line 1051
    __wait.func = & autoremove_wake_function;
#line 1051
    __wait.task_list.next = & __wait.task_list;
#line 1051
    __wait.task_list.prev = & __wait.task_list;
    ldv_33117: 
#line 1051
    prepare_to_wait(& peasycap->wq_video, & __wait, 1);
#line 1051
    if ((peasycap->video_idle != 0 || peasycap->video_eof != 0) || ((peasycap->field_read != peasycap->field_fill && ((unsigned int )peasycap->field_buffer[peasycap->field_read][0].kount & 65280U) == 0U) && ((int )peasycap->field_buffer[peasycap->field_read][0].kount & 255) == ifield)) {
#line 1051
      goto ldv_33115;
    } else {

    }
#line 1051
    tmp___0 = get_current();
#line 1051
    tmp___1 = signal_pending(tmp___0);
#line 1051
    if (tmp___1 == 0) {
#line 1051
      schedule();
#line 1051
      goto ldv_33116;
    } else {

    }
#line 1051
    __ret = -512;
#line 1051
    goto ldv_33115;
    ldv_33116: ;
#line 1051
    goto ldv_33117;
    ldv_33115: 
#line 1051
    finish_wait(& peasycap->wq_video, & __wait);
  } else {

  }
#line 1051
  if (__ret != 0) {
#line 1056
    printk("<7>easycap::%i%s: aborted by signal\n", peasycap->isdongle, "easycap_video_dqbuf");
#line 1057
    return (-5);
  } else {

  }
#line 1059
  if (peasycap->video_idle != 0) {
#line 1060
    if (easycap_debug > 7) {
#line 1060
      printk("<7>easycap::%i%s: %i=peasycap->video_idle returning -EAGAIN\n", peasycap->isdongle,
             "easycap_video_dqbuf", peasycap->video_idle);
    } else {

    }
#line 1062
    return (-11);
  } else {

  }
#line 1064
  if (peasycap->video_eof != 0) {
#line 1065
    if (easycap_debug > 7) {
#line 1065
      printk("<7>easycap::%i%s: %i=peasycap->video_eof\n", peasycap->isdongle, "easycap_video_dqbuf",
             peasycap->video_eof);
    } else {

    }
#line 1067
    if (peasycap->status == 1) {
#line 1068
      if (easycap_debug > 7) {
#line 1068
        printk("<7>easycap::%i%s: persevering ...\n", peasycap->isdongle, "easycap_video_dqbuf");
      } else {

      }
#line 1069
      peasycap->video_eof = 0;
#line 1070
      peasycap->audio_eof = 0;
#line 1071
      tmp___2 = reset(peasycap);
#line 1071
      if (tmp___2 != 0) {
#line 1072
        if (easycap_debug > 7) {
#line 1072
          printk("<7>easycap::%i%s:  ... failed  returning -EIO\n", peasycap->isdongle,
                 "easycap_video_dqbuf");
        } else {

        }
#line 1073
        peasycap->video_eof = 1;
#line 1074
        peasycap->audio_eof = 1;
#line 1075
        easycap_video_kill_urbs(peasycap);
#line 1076
        return (-5);
      } else {

      }
#line 1078
      peasycap->status = 0;
#line 1079
      if (easycap_debug > 7) {
#line 1079
        printk("<7>easycap::%i%s:  ... OK  returning -EAGAIN\n", peasycap->isdongle,
               "easycap_video_dqbuf");
      } else {

      }
#line 1080
      return (-11);
    } else {

    }
#line 1083
    peasycap->video_eof = 1;
#line 1084
    peasycap->audio_eof = 1;
#line 1085
    easycap_video_kill_urbs(peasycap);
#line 1086
    if (easycap_debug > 7) {
#line 1086
      printk("<7>easycap::%i%s: returning -EIO\n", peasycap->isdongle, "easycap_video_dqbuf");
    } else {

    }
#line 1087
    return (-5);
  } else {

  }
#line 1089
  miss = miss + 1;
  ldv_33120: ;
#line 1040
  if ((peasycap->field_read == peasycap->field_fill || ((unsigned int )peasycap->field_buffer[peasycap->field_read][0].kount & 65280U) != 0U) || ((int )peasycap->field_buffer[peasycap->field_read][0].kount & 255) != ifield) {
#line 1045
    goto ldv_33119;
  } else {

  }

#line 1091
  if (easycap_debug > 7) {
#line 1091
    printk("<7>easycap::%i%s: first awakening on wq_video after %i waits\n", peasycap->isdongle,
           "easycap_video_dqbuf", miss);
  } else {

  }
#line 1093
  rc = field2frame(peasycap);
#line 1094
  if (rc != 0) {
#line 1095
    printk("<7>easycap::%i%s: OLD_ERROR: field2frame() rc = %i\n", peasycap->isdongle,
           "easycap_video_dqbuf", rc);
  } else {

  }
#line 1101
  if (ifield != 0) {
#line 1102
    ifield = 0;
  } else {
#line 1104
    ifield = 1;
  }
#line 1105
  miss = 0;
#line 1106
  goto ldv_33129;
  ldv_33128: ;
#line 1109
  if (mode != 0) {
#line 1110
    return (-11);
  } else {

  }
#line 1112
  if (easycap_debug > 7) {
#line 1112
    printk("<7>easycap::%i%s: second wait on wq_video %i=field_read  %i=field_fill\n",
           peasycap->isdongle, "easycap_video_dqbuf", peasycap->field_read, peasycap->field_fill);
  } else {

  }
#line 1114
  __ret___0 = 0;
#line 1114
  if ((peasycap->video_idle == 0 && peasycap->video_eof == 0) && ((peasycap->field_read == peasycap->field_fill || ((unsigned int )peasycap->field_buffer[peasycap->field_read][0].kount & 65280U) != 0U) || ((int )peasycap->field_buffer[peasycap->field_read][0].kount & 255) != ifield)) {
#line 1114
    tmp___3 = get_current();
#line 1114
    __wait___0.flags = 0U;
#line 1114
    __wait___0.private = (void *)tmp___3;
#line 1114
    __wait___0.func = & autoremove_wake_function;
#line 1114
    __wait___0.task_list.next = & __wait___0.task_list;
#line 1114
    __wait___0.task_list.prev = & __wait___0.task_list;
    ldv_33126: 
#line 1114
    prepare_to_wait(& peasycap->wq_video, & __wait___0, 1);
#line 1114
    if ((peasycap->video_idle != 0 || peasycap->video_eof != 0) || ((peasycap->field_read != peasycap->field_fill && ((unsigned int )peasycap->field_buffer[peasycap->field_read][0].kount & 65280U) == 0U) && ((int )peasycap->field_buffer[peasycap->field_read][0].kount & 255) == ifield)) {
#line 1114
      goto ldv_33124;
    } else {

    }
#line 1114
    tmp___4 = get_current();
#line 1114
    tmp___5 = signal_pending(tmp___4);
#line 1114
    if (tmp___5 == 0) {
#line 1114
      schedule();
#line 1114
      goto ldv_33125;
    } else {

    }
#line 1114
    __ret___0 = -512;
#line 1114
    goto ldv_33124;
    ldv_33125: ;
#line 1114
    goto ldv_33126;
    ldv_33124: 
#line 1114
    finish_wait(& peasycap->wq_video, & __wait___0);
  } else {

  }
#line 1114
  if (__ret___0 != 0) {
#line 1119
    printk("<7>easycap::%i%s: aborted by signal\n", peasycap->isdongle, "easycap_video_dqbuf");
#line 1120
    return (-5);
  } else {

  }
#line 1122
  if (peasycap->video_idle != 0) {
#line 1123
    if (easycap_debug > 7) {
#line 1123
      printk("<7>easycap::%i%s: %i=peasycap->video_idle returning -EAGAIN\n", peasycap->isdongle,
             "easycap_video_dqbuf", peasycap->video_idle);
    } else {

    }
#line 1125
    return (-11);
  } else {

  }
#line 1127
  if (peasycap->video_eof != 0) {
#line 1128
    if (easycap_debug > 7) {
#line 1128
      printk("<7>easycap::%i%s: %i=peasycap->video_eof\n", peasycap->isdongle, "easycap_video_dqbuf",
             peasycap->video_eof);
    } else {

    }
#line 1130
    if (peasycap->status == 1) {
#line 1131
      if (easycap_debug > 7) {
#line 1131
        printk("<7>easycap::%i%s: persevering ...\n", peasycap->isdongle, "easycap_video_dqbuf");
      } else {

      }
#line 1132
      peasycap->video_eof = 0;
#line 1133
      peasycap->audio_eof = 0;
#line 1134
      tmp___6 = reset(peasycap);
#line 1134
      if (tmp___6 != 0) {
#line 1135
        if (easycap_debug > 7) {
#line 1135
          printk("<7>easycap::%i%s:  ... failed returning -EIO\n", peasycap->isdongle,
                 "easycap_video_dqbuf");
        } else {

        }
#line 1136
        peasycap->video_eof = 1;
#line 1137
        peasycap->audio_eof = 1;
#line 1138
        easycap_video_kill_urbs(peasycap);
#line 1139
        return (-5);
      } else {

      }
#line 1141
      peasycap->status = 0;
#line 1142
      if (easycap_debug > 7) {
#line 1142
        printk("<7>easycap::%i%s:  ... OK ... returning -EAGAIN\n", peasycap->isdongle,
               "easycap_video_dqbuf");
      } else {

      }
#line 1143
      return (-11);
    } else {

    }
#line 1146
    peasycap->video_eof = 1;
#line 1147
    peasycap->audio_eof = 1;
#line 1148
    easycap_video_kill_urbs(peasycap);
#line 1149
    if (easycap_debug > 7) {
#line 1149
      printk("<7>easycap::%i%s: returning -EIO\n", peasycap->isdongle, "easycap_video_dqbuf");
    } else {

    }
#line 1150
    return (-5);
  } else {

  }
#line 1152
  miss = miss + 1;
  ldv_33129: ;
#line 1106
  if ((peasycap->field_read == peasycap->field_fill || ((unsigned int )peasycap->field_buffer[peasycap->field_read][0].kount & 65280U) != 0U) || ((int )peasycap->field_buffer[peasycap->field_read][0].kount & 255) != ifield) {
#line 1110
    goto ldv_33128;
  } else {

  }

#line 1154
  if (easycap_debug > 7) {
#line 1154
    printk("<7>easycap::%i%s: second awakening on wq_video after %i waits\n", peasycap->isdongle,
           "easycap_video_dqbuf", miss);
  } else {

  }
#line 1156
  rc = field2frame(peasycap);
#line 1157
  if (rc != 0) {
#line 1158
    printk("<7>easycap::%i%s: OLD_ERROR: field2frame() rc = %i\n", peasycap->isdongle,
           "easycap_video_dqbuf", rc);
  } else {

  }
#line 1164
  if (peasycap->skip != 0) {
#line 1165
    peasycap->skipped = peasycap->skipped + 1;
#line 1166
    if (peasycap->skip != peasycap->skipped) {
#line 1167
      return (peasycap->skip - peasycap->skipped);
    } else {
#line 1169
      peasycap->skipped = 0;
    }
  } else {

  }
#line 1172
  peasycap->frame_read = peasycap->frame_fill;
#line 1173
  peasycap->queued[peasycap->frame_read] = 0;
#line 1174
  peasycap->done[peasycap->frame_read] = 4;
#line 1176
  peasycap->frame_fill = peasycap->frame_fill + 1;
#line 1177
  if (peasycap->frame_buffer_many <= peasycap->frame_fill) {
#line 1178
    peasycap->frame_fill = 0;
  } else {

  }
#line 1180
  if ((int )easycap_standard[peasycap->standard_offset].mask & 1) {
#line 1181
    peasycap->frame_buffer[peasycap->frame_read][0].kount = 2U;
  } else {
#line 1184
    peasycap->frame_buffer[peasycap->frame_read][0].kount = 3U;
  }
#line 1188
  if (easycap_debug > 7) {
#line 1188
    printk("<7>easycap::%i%s: setting:    %i=peasycap->frame_read\n", peasycap->isdongle,
           "easycap_video_dqbuf", peasycap->frame_read);
  } else {

  }
#line 1189
  if (easycap_debug > 7) {
#line 1189
    printk("<7>easycap::%i%s: bumped to:  %i=peasycap->frame_fill\n", peasycap->isdongle,
           "easycap_video_dqbuf", peasycap->frame_fill);
  } else {

  }
#line 1191
  return (0);
}
}
#line 1204 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int field2frame(struct easycap *peasycap ) 
{ 
  void *pex ;
  void *pad ;
  int kex ;
  int kad ;
  int mex ;
  int mad ;
  int rex ;
  int rad ;
  int rad2 ;
  int c2 ;
  int c3 ;
  int w2 ;
  int w3 ;
  int cz ;
  int wz ;
  int rc ;
  int bytesperpixel ;
  int multiplier ;
  int much ;
  int more ;
  int over ;
  int rump ;
  int caches ;
  int input ;
  u8 mask ;
  u8 margin ;
  bool odd ;
  bool isuy ;
  bool decimatepixel ;
  bool badinput ;

  {
#line 1215
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 1216
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "field2frame");
#line 1217
    return (-14);
  } else {

  }
#line 1220
  badinput = 0;
#line 1221
  input = (int )peasycap->field_buffer[peasycap->field_read][0].input & 7;
#line 1223
  if (easycap_debug > 7) {
#line 1223
    printk("<7>easycap::%i%s: =====  parity %i, input 0x%02X, field buffer %i --> frame buffer %i\n",
           peasycap->isdongle, "field2frame", (int )peasycap->field_buffer[peasycap->field_read][0].kount,
           (int )peasycap->field_buffer[peasycap->field_read][0].input, peasycap->field_read,
           peasycap->frame_fill);
  } else {

  }
#line 1228
  if (easycap_debug > 7) {
#line 1228
    printk("<7>easycap::%i%s: =====  %i=bytesperpixel\n", peasycap->isdongle, "field2frame",
           peasycap->bytesperpixel);
  } else {

  }
#line 1235
  if (peasycap->field_read == peasycap->field_fill) {
#line 1236
    printk("<7>easycap::%i%s: OLD_ERROR: on entry, still filling field buffer %i\n", peasycap->isdongle,
           "field2frame", peasycap->field_read);
#line 1238
    return (0);
  } else {

  }
#line 1243
  if (input >= 0 && input <= 5) {
#line 1244
    if (easycap_bars != 0 && peasycap->lost[input] > 49) {
#line 1245
      easycap_testcard(peasycap, peasycap->field_read);
    } else {

    }
  } else {

  }
#line 1250
  bytesperpixel = peasycap->bytesperpixel;
#line 1251
  decimatepixel = peasycap->decimatepixel;
#line 1253
  if ((bytesperpixel != 2 && bytesperpixel != 3) && bytesperpixel != 4) {
#line 1256
    printk("<7>easycap::%i%s: MISTAKE: %i=bytesperpixel\n", peasycap->isdongle, "field2frame",
           bytesperpixel);
#line 1257
    return (-14);
  } else {

  }
#line 1259
  if ((int )decimatepixel) {
#line 1260
    multiplier = 2;
  } else {
#line 1262
    multiplier = 1;
  }
#line 1264
  w2 = (multiplier * 2) * peasycap->width;
#line 1265
  w3 = (bytesperpixel * multiplier) * peasycap->width;
#line 1266
  wz = ((peasycap->height * multiplier) * multiplier) * peasycap->width;
#line 1269
  kex = peasycap->field_read;
#line 1269
  mex = 0;
#line 1270
  kad = peasycap->frame_fill;
#line 1270
  mad = 0;
#line 1272
  pex = peasycap->field_buffer[kex][0].pgo;
#line 1272
  rex = 4096;
#line 1273
  pad = peasycap->frame_buffer[kad][0].pgo;
#line 1273
  rad = 4096;
#line 1274
  odd = (unsigned int )peasycap->field_buffer[kex][0].kount != 0U;
#line 1276
  if ((int )odd && ! decimatepixel) {
#line 1277
    if (easycap_debug > 7) {
#line 1277
      printk("<7>easycap::%i%s: initial skipping %4i bytes p.%4i\n", peasycap->isdongle,
             "field2frame", w3 / multiplier, mad);
    } else {

    }
#line 1279
    pad = pad + (unsigned long )(w3 / multiplier);
#line 1279
    rad = rad - w3 / multiplier;
  } else {

  }
#line 1281
  isuy = 1;
#line 1282
  mask = 0U;
#line 1282
  rump = 0;
#line 1282
  caches = 0;
#line 1284
  cz = 0;
#line 1285
  goto ldv_33174;
  ldv_33173: ;
#line 1291
  if (! decimatepixel) {
#line 1292
    over = w2;
    ldv_33165: 
#line 1294
    much = over;
#line 1294
    more = 0;
#line 1295
    margin = 0U;
#line 1295
    mask = 0U;
#line 1296
    if (rex < much) {
#line 1297
      much = rex;
    } else {

    }
#line 1298
    rump = 0;
#line 1300
    if (much & 1) {
#line 1301
      printk("<7>easycap::%i%s: MISTAKE: much is odd\n", peasycap->isdongle, "field2frame");
#line 1302
      return (-14);
    } else {

    }
#line 1305
    more = (bytesperpixel * much) / 2;
#line 1308
    if (bytesperpixel > 1) {
#line 1309
      if (rad * 2 < much * bytesperpixel) {
#line 1315
        rad2 = (rad + bytesperpixel) + -1;
#line 1316
        much = (((rad2 * 2) / bytesperpixel) / 2) * 2;
#line 1317
        rump = (bytesperpixel * much) / 2 - rad;
#line 1318
        more = rad;
      } else {

      }
#line 1320
      mask = (unsigned char )rump;
#line 1321
      margin = 0U;
#line 1322
      if (much == rex) {
#line 1323
        mask = (u8 )((unsigned int )mask | 4U);
#line 1324
        if ((unsigned int )(mex + 1) <= 202U) {
#line 1325
          margin = *((u8 *)peasycap->field_buffer[kex][mex + 1].pgo);
        } else {
#line 1327
          mask = (u8 )((unsigned int )mask | 8U);
        }
      } else {

      }
    } else {
#line 1330
      printk("<7>easycap::%i%s: MISTAKE: %i=bytesperpixel\n", peasycap->isdongle,
             "field2frame", bytesperpixel);
#line 1332
      return (-14);
    }
#line 1334
    if (rump != 0) {
#line 1335
      caches = caches + 1;
    } else {

    }
#line 1336
    if ((int )badinput) {
#line 1337
      if (easycap_debug > 7) {
#line 1337
        printk("<7>easycap::%i%s: OLD_ERROR: 0x%02X=->field_buffer[%i][%i].input, 0x%02X=(0x08|->input)\n",
               peasycap->isdongle, "field2frame", (int )peasycap->field_buffer[kex][mex].input,
               kex, mex, peasycap->input | 8);
      } else {

      }
    } else {

    }
#line 1344
    rc = redaub(peasycap, pad, pex, much, more, (int )mask, (int )margin, (int )isuy);
#line 1346
    if (rc < 0) {
#line 1347
      printk("<7>easycap::%i%s: OLD_ERROR: redaub() failed\n", peasycap->isdongle, "field2frame");
#line 1348
      return (-14);
    } else {

    }
#line 1350
    if (((unsigned int )much & 3U) != 0U) {
#line 1351
      isuy = (bool )(! ((int )isuy != 0));
    } else {

    }
#line 1353
    over = over - much;
#line 1353
    cz = cz + much;
#line 1354
    pex = pex + (unsigned long )much;
#line 1354
    rex = rex - much;
#line 1355
    if (rex == 0) {
#line 1356
      mex = mex + 1;
#line 1357
      pex = peasycap->field_buffer[kex][mex].pgo;
#line 1358
      rex = 4096;
#line 1359
      if ((int )peasycap->field_buffer[kex][mex].input != (peasycap->input | 8)) {
#line 1360
        badinput = 1;
      } else {

      }
    } else {

    }
#line 1362
    pad = pad + (unsigned long )more;
#line 1363
    rad = rad - more;
#line 1364
    if (rad == 0) {
#line 1365
      mad = mad + 1;
#line 1366
      pad = peasycap->frame_buffer[kad][mad].pgo;
#line 1367
      rad = 4096;
#line 1368
      if (rump != 0) {
#line 1369
        pad = pad + (unsigned long )rump;
#line 1370
        rad = rad - rump;
      } else {

      }
    } else {

    }
#line 1373
    if (over != 0) {
#line 1375
      goto ldv_33165;
    } else {

    }

#line 1380
    if (! odd || cz != wz) {
#line 1381
      over = w3;
      ldv_33167: ;
#line 1383
      if (rad == 0) {
#line 1384
        mad = mad + 1;
#line 1385
        pad = peasycap->frame_buffer[kad][mad].pgo;
#line 1387
        rad = 4096;
      } else {

      }
#line 1389
      more = over;
#line 1390
      if (rad < more) {
#line 1391
        more = rad;
      } else {

      }
#line 1392
      over = over - more;
#line 1393
      pad = pad + (unsigned long )more;
#line 1394
      rad = rad - more;
#line 1395
      if (over != 0) {
#line 1397
        goto ldv_33167;
      } else {

      }

    } else {

    }
  } else
#line 1405
  if (! odd) {
#line 1406
    over = w2;
    ldv_33169: 
#line 1408
    much = over;
#line 1408
    more = 0;
#line 1408
    margin = 0U;
#line 1408
    mask = 0U;
#line 1409
    if (rex < much) {
#line 1410
      much = rex;
    } else {

    }
#line 1411
    rump = 0;
#line 1413
    if (much & 1) {
#line 1414
      printk("<7>easycap::%i%s: MISTAKE: much is odd\n", peasycap->isdongle, "field2frame");
#line 1415
      return (-14);
    } else {

    }
#line 1418
    more = (bytesperpixel * much) / 4;
#line 1420
    if (bytesperpixel > 1) {
#line 1421
      if (rad * 4 < much * bytesperpixel) {
#line 1428
        rad2 = (rad + bytesperpixel) + -1;
#line 1429
        much = (((rad2 * 2) / bytesperpixel) / 2) * 4;
#line 1430
        rump = (bytesperpixel * much) / 4 - rad;
#line 1431
        more = rad;
      } else {

      }
#line 1433
      mask = (unsigned char )rump;
#line 1434
      margin = 0U;
#line 1435
      if (much == rex) {
#line 1436
        mask = (u8 )((unsigned int )mask | 4U);
#line 1437
        if ((unsigned int )(mex + 1) <= 202U) {
#line 1438
          margin = *((u8 *)peasycap->field_buffer[kex][mex + 1].pgo);
        } else {
#line 1440
          mask = (u8 )((unsigned int )mask | 8U);
        }
      } else {

      }
    } else {
#line 1444
      printk("<7>easycap::%i%s: MISTAKE: %i=bytesperpixel\n", peasycap->isdongle,
             "field2frame", bytesperpixel);
#line 1446
      return (-14);
    }
#line 1449
    if (rump != 0) {
#line 1450
      caches = caches + 1;
    } else {

    }
#line 1452
    if ((int )badinput) {
#line 1453
      if (easycap_debug > 7) {
#line 1453
        printk("<7>easycap::%i%s: OLD_ERROR: 0x%02X=->field_buffer[%i][%i].input, 0x%02X=(0x08|->input)\n",
               peasycap->isdongle, "field2frame", (int )peasycap->field_buffer[kex][mex].input,
               kex, mex, peasycap->input | 8);
      } else {

      }
    } else {

    }
#line 1460
    rc = redaub(peasycap, pad, pex, much, more, (int )mask, (int )margin, (int )isuy);
#line 1462
    if (rc < 0) {
#line 1463
      printk("<7>easycap::%i%s: OLD_ERROR: redaub() failed\n", peasycap->isdongle, "field2frame");
#line 1464
      return (-14);
    } else {

    }
#line 1466
    over = over - much;
#line 1466
    cz = cz + much;
#line 1467
    pex = pex + (unsigned long )much;
#line 1467
    rex = rex - much;
#line 1468
    if (rex == 0) {
#line 1469
      mex = mex + 1;
#line 1470
      pex = peasycap->field_buffer[kex][mex].pgo;
#line 1471
      rex = 4096;
#line 1472
      if ((int )peasycap->field_buffer[kex][mex].input != (peasycap->input | 8)) {
#line 1474
        badinput = 1;
      } else {

      }
    } else {

    }
#line 1476
    pad = pad + (unsigned long )more;
#line 1477
    rad = rad - more;
#line 1478
    if (rad == 0) {
#line 1479
      mad = mad + 1;
#line 1480
      pad = peasycap->frame_buffer[kad][mad].pgo;
#line 1481
      rad = 4096;
#line 1482
      if (rump != 0) {
#line 1483
        pad = pad + (unsigned long )rump;
#line 1484
        rad = rad - rump;
      } else {

      }
    } else {

    }
#line 1487
    if (over != 0) {
#line 1489
      goto ldv_33169;
    } else {

    }

  } else {
#line 1495
    over = w2;
    ldv_33171: ;
#line 1497
    if (rex == 0) {
#line 1498
      mex = mex + 1;
#line 1499
      pex = peasycap->field_buffer[kex][mex].pgo;
#line 1500
      rex = 4096;
#line 1501
      if ((int )peasycap->field_buffer[kex][mex].input != (peasycap->input | 8)) {
#line 1503
        if (easycap_debug > 7) {
#line 1503
          printk("<7>easycap::%i%s: OLD_ERROR: 0x%02X=->field_buffer[%i][%i].input, 0x%02X=(0x08|->input)\n",
                 peasycap->isdongle, "field2frame", (int )peasycap->field_buffer[kex][mex].input,
                 kex, mex, peasycap->input | 8);
        } else {

        }
#line 1509
        badinput = 1;
      } else {

      }
    } else {

    }
#line 1512
    much = over;
#line 1513
    if (rex < much) {
#line 1514
      much = rex;
    } else {

    }
#line 1515
    over = over - much;
#line 1516
    cz = cz + much;
#line 1517
    pex = pex + (unsigned long )much;
#line 1518
    rex = rex - much;
#line 1519
    if (over != 0) {
#line 1521
      goto ldv_33171;
    } else {

    }

  }
  ldv_33174: ;
#line 1285
  if (cz < wz) {
#line 1287
    goto ldv_33173;
  } else {

  }
#line 1527
  c2 = (int )((unsigned int )((unsigned long )(mex + 1)) * 4096U - (unsigned int )rex);
#line 1528
  if (cz != c2) {
#line 1529
    printk("<7>easycap::%i%s: OLD_ERROR: discrepancy %i in bytes read\n", peasycap->isdongle,
           "field2frame", c2 - cz);
  } else {

  }
#line 1530
  c3 = (int )((unsigned int )((unsigned long )(mad + 1)) * 4096U - (unsigned int )rad);
#line 1532
  if (! decimatepixel) {
#line 1533
    if (bytesperpixel * cz != c3) {
#line 1534
      printk("<7>easycap::%i%s: OLD_ERROR: discrepancy %i in bytes written\n", peasycap->isdongle,
             "field2frame", c3 - bytesperpixel * cz);
    } else {

    }
  } else
#line 1537
  if (! odd) {
#line 1538
    if (bytesperpixel * cz != c3 * 4) {
#line 1540
      printk("<7>easycap::%i%s: OLD_ERROR: discrepancy %i in bytes written\n", peasycap->isdongle,
             "field2frame", c3 * 2 - bytesperpixel * cz);
    } else {

    }
  } else
#line 1543
  if (c3 != 0) {
#line 1544
    printk("<7>easycap::%i%s: OLD_ERROR: discrepancy %i in bytes written\n", peasycap->isdongle,
           "field2frame", c3);
  } else {

  }
#line 1548
  if (rump != 0) {
#line 1549
    printk("<7>easycap::%i%s: WORRY: undischarged cache at end of line in frame buffer\n",
           peasycap->isdongle, "field2frame");
  } else {

  }
#line 1551
  if (easycap_debug > 7) {
#line 1551
    printk("<7>easycap::%i%s: ===== field2frame(): %i bytes --> %i bytes (incl skip)\n",
           peasycap->isdongle, "field2frame", c2, c3);
  } else {

  }
#line 1552
  if (easycap_debug > 7) {
#line 1552
    printk("<7>easycap::%i%s: ===== field2frame(): %i=mad  %i=rad\n", peasycap->isdongle,
           "field2frame", mad, rad);
  } else {

  }
#line 1554
  if ((int )odd) {
#line 1555
    if (easycap_debug > 7) {
#line 1555
      printk("<7>easycap::%i%s: +++++ field2frame():  frame buffer %i is full\n",
             peasycap->isdongle, "field2frame", kad);
    } else {

    }
  } else {

  }
#line 1557
  if (peasycap->field_read == peasycap->field_fill) {
#line 1558
    printk("<7>easycap::%i%s: WARNING: on exit, filling field buffer %i\n", peasycap->isdongle,
           "field2frame", peasycap->field_read);
  } else {

  }
#line 1561
  if (caches != 0) {
#line 1562
    if (easycap_debug > 7) {
#line 1562
      printk("<7>easycap::%i%s: %i=caches\n", peasycap->isdongle, "field2frame", caches);
    } else {

    }
  } else {

  }
#line 1563
  return (0);
}
}
#line 1590 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int redaub(struct easycap *peasycap , void *pad , void *pex , int much , int more ,
                  u8 mask , u8 margin , bool isuy ) 
{ 
  s32 ay[256U] ;
  s32 bu[256U] ;
  s32 rv[256U] ;
  s32 gu[256U] ;
  s32 gv[256U] ;
  u8 *pcache ;
  u8 r ;
  u8 g ;
  u8 b ;
  u8 y ;
  u8 u ;
  u8 v ;
  u8 c ;
  u8 *p2 ;
  u8 *p3 ;
  u8 *pz ;
  u8 *pr ;
  int bytesperpixel ;
  bool byteswaporder ;
  bool decimatepixel ;
  bool last ;
  int j ;
  int rump ;
  s32 tmp ;
  u8 *tmp___0 ;
  size_t __len ;
  void *__ret ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *tmp___11 ;
  u8 *tmp___12 ;
  u8 *tmp___13 ;
  u8 *tmp___14 ;
  u8 *tmp___15 ;
  u8 *tmp___16 ;
  u8 *tmp___17 ;
  u8 *tmp___18 ;
  u8 *tmp___19 ;
  u8 *tmp___20 ;
  u8 *tmp___21 ;
  u8 *tmp___22 ;
  u8 *tmp___23 ;
  u8 *tmp___24 ;
  u8 *tmp___25 ;
  u8 *tmp___26 ;
  u8 *tmp___27 ;
  u8 *tmp___28 ;
  u8 *tmp___29 ;
  u8 *tmp___30 ;
  u8 *tmp___31 ;
  u8 *tmp___32 ;
  u8 *tmp___33 ;
  u8 *tmp___34 ;
  u8 *tmp___35 ;
  u8 *tmp___36 ;

  {
#line 1602
  if (much & 1) {
#line 1603
    printk("<7>easycap::%i%s: MISTAKE: much is odd\n", peasycap->isdongle, "redaub");
#line 1604
    return (-14);
  } else {

  }
#line 1606
  bytesperpixel = peasycap->bytesperpixel;
#line 1607
  byteswaporder = peasycap->byteswaporder;
#line 1608
  decimatepixel = peasycap->decimatepixel;
#line 1611
  if (bu[255] == 0) {
#line 1612
    j = 0;
#line 1612
    goto ldv_33212;
    ldv_33211: 
#line 1613
    tmp = (j * 453 & 65280) >> 8;
#line 1614
    bu[j + 128] = tmp;
#line 1614
    bu[127 - j] = - tmp;
#line 1615
    tmp = (j * 359 & 65280) >> 8;
#line 1616
    rv[j + 128] = tmp;
#line 1616
    rv[127 - j] = - tmp;
#line 1617
    tmp = (j * 88 & 65280) >> 8;
#line 1618
    gu[j + 128] = tmp;
#line 1618
    gu[127 - j] = - tmp;
#line 1619
    tmp = (j * 183 & 65280) >> 8;
#line 1620
    gv[j + 128] = tmp;
#line 1620
    gv[127 - j] = - tmp;
#line 1612
    j = j + 1;
    ldv_33212: ;
#line 1612
    if (j <= 111) {
#line 1614
      goto ldv_33211;
    } else {

    }
#line 1622
    j = 0;
#line 1622
    goto ldv_33215;
    ldv_33214: 
#line 1623
    bu[j] = bu[16];
#line 1623
    rv[j] = rv[16];
#line 1624
    gu[j] = gu[16];
#line 1624
    gv[j] = gv[16];
#line 1622
    j = j + 1;
    ldv_33215: ;
#line 1622
    if (j <= 15) {
#line 1624
      goto ldv_33214;
    } else {

    }
#line 1626
    j = 240;
#line 1626
    goto ldv_33218;
    ldv_33217: 
#line 1627
    bu[j] = bu[239];
#line 1627
    rv[j] = rv[239];
#line 1628
    gu[j] = gu[239];
#line 1628
    gv[j] = gv[239];
#line 1626
    j = j + 1;
    ldv_33218: ;
#line 1626
    if (j <= 255) {
#line 1628
      goto ldv_33217;
    } else {

    }
#line 1630
    j = 16;
#line 1630
    goto ldv_33221;
    ldv_33220: 
#line 1631
    ay[j] = j;
#line 1630
    j = j + 1;
    ldv_33221: ;
#line 1630
    if (j <= 235) {
#line 1632
      goto ldv_33220;
    } else {

    }
#line 1632
    j = 0;
#line 1632
    goto ldv_33224;
    ldv_33223: 
#line 1633
    ay[j] = ay[16];
#line 1632
    j = j + 1;
    ldv_33224: ;
#line 1632
    if (j <= 15) {
#line 1634
      goto ldv_33223;
    } else {

    }
#line 1634
    j = 236;
#line 1634
    goto ldv_33227;
    ldv_33226: 
#line 1635
    ay[j] = ay[235];
#line 1634
    j = j + 1;
    ldv_33227: ;
#line 1634
    if (j <= 255) {
#line 1636
      goto ldv_33226;
    } else {

    }

#line 1636
    if (easycap_debug > 7) {
#line 1636
      printk("<7>easycap::%i%s: lookup tables are prepared\n", peasycap->isdongle,
             "redaub");
    } else {

    }
  } else {

  }
#line 1638
  pcache = peasycap->pcache;
#line 1639
  if ((unsigned long )pcache == (unsigned long )((u8 *)0U)) {
#line 1640
    pcache = (u8 *)(& peasycap->cache);
  } else {

  }
#line 1646
  if ((unsigned long )pcache == (unsigned long )((u8 *)0U)) {
#line 1647
    printk("<7>easycap::%i%s: MISTAKE: pcache is NULL\n", peasycap->isdongle, "redaub");
#line 1648
    return (-14);
  } else {

  }
#line 1651
  if ((unsigned long )((u8 *)(& peasycap->cache)) != (unsigned long )pcache) {
#line 1652
    if (easycap_debug > 15) {
#line 1652
      printk("<7>easycap::%i%s: cache has %i bytes\n", peasycap->isdongle, "redaub",
             (int )((unsigned int )((long )pcache) - (unsigned int )((long )(& peasycap->cache))));
    } else {

    }
  } else {

  }
#line 1653
  p2 = (u8 *)(& peasycap->cache);
#line 1654
  p3 = (u8 *)pad + - ((unsigned long )((int )((unsigned int )((long )pcache) - (unsigned int )((long )(& peasycap->cache)))));
#line 1655
  goto ldv_33230;
  ldv_33229: 
#line 1656
  tmp___0 = p3;
#line 1656
  p3 = p3 + 1;
#line 1656
  *tmp___0 = *p2;
#line 1656
  p2 = p2 + 1;
  ldv_33230: ;
#line 1655
  if ((unsigned long )p2 < (unsigned long )pcache) {
#line 1657
    goto ldv_33229;
  } else {

  }
#line 1658
  pcache = (u8 *)(& peasycap->cache);
#line 1659
  if ((unsigned long )((void *)p3) != (unsigned long )pad) {
#line 1660
    printk("<7>easycap::%i%s: MISTAKE: pointer misalignment\n", peasycap->isdongle,
           "redaub");
#line 1661
    return (-14);
  } else {

  }
#line 1664
  rump = (int )mask & 3;
#line 1665
  u = 0U;
#line 1665
  v = 0U;
#line 1666
  p2 = (u8 *)pex;
#line 1666
  pz = p2 + (unsigned long )much;
#line 1666
  pr = p3 + (unsigned long )more;
#line 1666
  last = 0;
#line 1667
  p2 = p2 + 1;
#line 1669
  if ((int )isuy) {
#line 1670
    u = *(p2 + 0xffffffffffffffffUL);
  } else {
#line 1672
    v = *(p2 + 0xffffffffffffffffUL);
  }
#line 1674
  if (rump != 0) {
#line 1675
    if (easycap_debug > 15) {
#line 1675
      printk("<7>easycap::%i%s: %4i=much  %4i=more  %i=rump\n", peasycap->isdongle,
             "redaub", much, more, rump);
    } else {

    }
  } else {

  }
#line 1678
  switch (bytesperpixel) {
  case 2: ;
#line 1680
  if (! decimatepixel) {
#line 1681
    __len = (unsigned long )much;
#line 1681
    __ret = __builtin_memcpy(pad, (void const   *)pex, __len);
#line 1682
    if (! byteswaporder) {
#line 1684
      return (0);
    } else {
#line 1687
      p3 = (u8 *)pad;
#line 1687
      pz = p3 + (unsigned long )much;
#line 1688
      goto ldv_33237;
      ldv_33236: 
#line 1689
      c = *p3;
#line 1690
      *p3 = *(p3 + 1UL);
#line 1691
      *(p3 + 1UL) = c;
#line 1692
      p3 = p3 + 2UL;
      ldv_33237: ;
#line 1688
      if ((unsigned long )pz > (unsigned long )p3) {
#line 1690
        goto ldv_33236;
      } else {

      }

#line 1694
      return (0);
    }
  } else
#line 1697
  if (! byteswaporder) {
#line 1699
    p2 = (u8 *)pex;
#line 1699
    p3 = (u8 *)pad;
#line 1699
    pz = p2 + (unsigned long )much;
#line 1700
    goto ldv_33240;
    ldv_33239: 
#line 1701
    *p3 = *p2;
#line 1702
    *(p3 + 1UL) = *(p2 + 1UL);
#line 1703
    *(p3 + 2UL) = *(p2 + 2UL);
#line 1704
    *(p3 + 3UL) = *(p2 + 3UL);
#line 1705
    p3 = p3 + 4UL;
#line 1705
    p2 = p2 + 8UL;
    ldv_33240: ;
#line 1700
    if ((unsigned long )pz > (unsigned long )p2) {
#line 1702
      goto ldv_33239;
    } else {

    }

#line 1707
    return (0);
  } else {
#line 1710
    p2 = (u8 *)pex;
#line 1710
    p3 = (u8 *)pad;
#line 1710
    pz = p2 + (unsigned long )much;
#line 1711
    goto ldv_33243;
    ldv_33242: 
#line 1712
    *p3 = *(p2 + 1UL);
#line 1713
    *(p3 + 1UL) = *p2;
#line 1714
    *(p3 + 2UL) = *(p2 + 3UL);
#line 1715
    *(p3 + 3UL) = *(p2 + 2UL);
#line 1716
    p3 = p3 + 4UL;
#line 1716
    p2 = p2 + 8UL;
    ldv_33243: ;
#line 1711
    if ((unsigned long )pz > (unsigned long )p2) {
#line 1713
      goto ldv_33242;
    } else {

    }

#line 1718
    return (0);
  }
  case 3: ;
#line 1725
  if (! decimatepixel) {
#line 1726
    if (! byteswaporder) {
#line 1728
      goto ldv_33251;
      ldv_33250: ;
#line 1729
      if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 1730
        last = 1;
      } else {
#line 1732
        last = 0;
      }
#line 1733
      y = *p2;
#line 1734
      if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 1735
        if (((unsigned int )mask & 4U) != 0U) {
#line 1736
          if ((int )isuy) {
#line 1737
            v = margin;
          } else {
#line 1739
            u = margin;
          }
        } else {

        }
      } else
#line 1744
      if ((int )isuy) {
#line 1745
        v = *(p2 + 1UL);
      } else {
#line 1747
        u = *(p2 + 1UL);
      }
#line 1750
      tmp = ay[(int )y] + rv[(int )v];
#line 1751
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1753
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 1754
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1756
      tmp = ay[(int )y] + bu[(int )u];
#line 1757
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1760
      if ((int )last && rump != 0) {
#line 1761
        pcache = (u8 *)(& peasycap->cache);
#line 1762
        switch (bytesperpixel - rump) {
        case 1: 
#line 1764
        *p3 = r;
#line 1765
        tmp___1 = pcache;
#line 1765
        pcache = pcache + 1;
#line 1765
        *tmp___1 = g;
#line 1766
        tmp___2 = pcache;
#line 1766
        pcache = pcache + 1;
#line 1766
        *tmp___2 = b;
#line 1767
        goto ldv_33247;
        case 2: 
#line 1770
        *p3 = r;
#line 1771
        *(p3 + 1UL) = g;
#line 1772
        tmp___3 = pcache;
#line 1772
        pcache = pcache + 1;
#line 1772
        *tmp___3 = b;
#line 1773
        goto ldv_33247;
        default: 
#line 1776
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 1778
        return (-14);
        }
        ldv_33247: ;
      } else {
#line 1782
        *p3 = r;
#line 1783
        *(p3 + 1UL) = g;
#line 1784
        *(p3 + 2UL) = b;
      }
#line 1786
      p2 = p2 + 2UL;
#line 1787
      if ((int )isuy) {
#line 1788
        isuy = 0;
      } else {
#line 1790
        isuy = 1;
      }
#line 1791
      p3 = p3 + (unsigned long )bytesperpixel;
      ldv_33251: ;
#line 1728
      if ((unsigned long )pz > (unsigned long )p2) {
#line 1730
        goto ldv_33250;
      } else {

      }

#line 1793
      return (0);
    } else {
#line 1796
      goto ldv_33258;
      ldv_33257: ;
#line 1797
      if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 1798
        last = 1;
      } else {
#line 1800
        last = 0;
      }
#line 1801
      y = *p2;
#line 1802
      if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 1803
        if (((unsigned int )mask & 4U) != 0U) {
#line 1804
          if ((int )isuy) {
#line 1805
            v = margin;
          } else {
#line 1807
            u = margin;
          }
        } else {

        }
      } else
#line 1813
      if ((int )isuy) {
#line 1814
        v = *(p2 + 1UL);
      } else {
#line 1816
        u = *(p2 + 1UL);
      }
#line 1819
      tmp = ay[(int )y] + rv[(int )v];
#line 1820
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1822
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 1823
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1825
      tmp = ay[(int )y] + bu[(int )u];
#line 1826
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1829
      if ((int )last && rump != 0) {
#line 1830
        pcache = (u8 *)(& peasycap->cache);
#line 1831
        switch (bytesperpixel - rump) {
        case 1: 
#line 1833
        *p3 = b;
#line 1834
        tmp___4 = pcache;
#line 1834
        pcache = pcache + 1;
#line 1834
        *tmp___4 = g;
#line 1835
        tmp___5 = pcache;
#line 1835
        pcache = pcache + 1;
#line 1835
        *tmp___5 = r;
#line 1836
        goto ldv_33254;
        case 2: 
#line 1839
        *p3 = b;
#line 1840
        *(p3 + 1UL) = g;
#line 1841
        tmp___6 = pcache;
#line 1841
        pcache = pcache + 1;
#line 1841
        *tmp___6 = r;
#line 1842
        goto ldv_33254;
        default: 
#line 1845
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 1847
        return (-14);
        }
        ldv_33254: ;
      } else {
#line 1851
        *p3 = b;
#line 1852
        *(p3 + 1UL) = g;
#line 1853
        *(p3 + 2UL) = r;
      }
#line 1855
      p2 = p2 + 2UL;
#line 1856
      if ((int )isuy) {
#line 1857
        isuy = 0;
      } else {
#line 1859
        isuy = 1;
      }
#line 1860
      p3 = p3 + (unsigned long )bytesperpixel;
      ldv_33258: ;
#line 1796
      if ((unsigned long )pz > (unsigned long )p2) {
#line 1798
        goto ldv_33257;
      } else {

      }

    }
#line 1863
    return (0);
  } else
#line 1865
  if (! byteswaporder) {
#line 1867
    goto ldv_33265;
    ldv_33264: ;
#line 1868
    if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 1869
      last = 1;
    } else {
#line 1871
      last = 0;
    }
#line 1872
    y = *p2;
#line 1873
    if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 1874
      if (((unsigned int )mask & 4U) != 0U) {
#line 1875
        if ((int )isuy) {
#line 1876
          v = margin;
        } else {
#line 1878
          u = margin;
        }
      } else {

      }
    } else
#line 1883
    if ((int )isuy) {
#line 1884
      v = *(p2 + 1UL);
    } else {
#line 1886
      u = *(p2 + 1UL);
    }
#line 1889
    if ((int )isuy) {
#line 1890
      tmp = ay[(int )y] + rv[(int )v];
#line 1891
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1893
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 1895
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1897
      tmp = ay[(int )y] + bu[(int )u];
#line 1898
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1901
      if ((int )last && rump != 0) {
#line 1902
        pcache = (u8 *)(& peasycap->cache);
#line 1903
        switch (bytesperpixel - rump) {
        case 1: 
#line 1905
        *p3 = r;
#line 1906
        tmp___7 = pcache;
#line 1906
        pcache = pcache + 1;
#line 1906
        *tmp___7 = g;
#line 1907
        tmp___8 = pcache;
#line 1907
        pcache = pcache + 1;
#line 1907
        *tmp___8 = b;
#line 1908
        goto ldv_33261;
        case 2: 
#line 1911
        *p3 = r;
#line 1912
        *(p3 + 1UL) = g;
#line 1913
        tmp___9 = pcache;
#line 1913
        pcache = pcache + 1;
#line 1913
        *tmp___9 = b;
#line 1914
        goto ldv_33261;
        default: 
#line 1917
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 1920
        return (-14);
        }
        ldv_33261: ;
      } else {
#line 1924
        *p3 = r;
#line 1925
        *(p3 + 1UL) = g;
#line 1926
        *(p3 + 2UL) = b;
      }
#line 1928
      isuy = 0;
#line 1929
      p3 = p3 + (unsigned long )bytesperpixel;
    } else {
#line 1931
      isuy = 1;
    }
#line 1933
    p2 = p2 + 2UL;
    ldv_33265: ;
#line 1867
    if ((unsigned long )pz > (unsigned long )p2) {
#line 1869
      goto ldv_33264;
    } else {

    }

#line 1935
    return (0);
  } else {
#line 1938
    goto ldv_33272;
    ldv_33271: ;
#line 1939
    if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 1940
      last = 1;
    } else {
#line 1942
      last = 0;
    }
#line 1943
    y = *p2;
#line 1944
    if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 1945
      if (((unsigned int )mask & 4U) != 0U) {
#line 1946
        if ((int )isuy) {
#line 1947
          v = margin;
        } else {
#line 1949
          u = margin;
        }
      } else {

      }
    } else
#line 1954
    if ((int )isuy) {
#line 1955
      v = *(p2 + 1UL);
    } else {
#line 1957
      u = *(p2 + 1UL);
    }
#line 1960
    if ((int )isuy) {
#line 1962
      tmp = ay[(int )y] + rv[(int )v];
#line 1963
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1965
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 1967
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1969
      tmp = ay[(int )y] + bu[(int )u];
#line 1970
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 1973
      if ((int )last && rump != 0) {
#line 1974
        pcache = (u8 *)(& peasycap->cache);
#line 1975
        switch (bytesperpixel - rump) {
        case 1: 
#line 1977
        *p3 = b;
#line 1978
        tmp___10 = pcache;
#line 1978
        pcache = pcache + 1;
#line 1978
        *tmp___10 = g;
#line 1979
        tmp___11 = pcache;
#line 1979
        pcache = pcache + 1;
#line 1979
        *tmp___11 = r;
#line 1980
        goto ldv_33268;
        case 2: 
#line 1983
        *p3 = b;
#line 1984
        *(p3 + 1UL) = g;
#line 1985
        tmp___12 = pcache;
#line 1985
        pcache = pcache + 1;
#line 1985
        *tmp___12 = r;
#line 1986
        goto ldv_33268;
        default: 
#line 1989
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 1992
        return (-14);
        }
        ldv_33268: ;
      } else {
#line 1996
        *p3 = b;
#line 1997
        *(p3 + 1UL) = g;
#line 1998
        *(p3 + 2UL) = r;
      }
#line 2000
      isuy = 0;
#line 2001
      p3 = p3 + (unsigned long )bytesperpixel;
    } else {
#line 2004
      isuy = 1;
    }
#line 2005
    p2 = p2 + 2UL;
    ldv_33272: ;
#line 1938
    if ((unsigned long )pz > (unsigned long )p2) {
#line 1940
      goto ldv_33271;
    } else {

    }

#line 2007
    return (0);
  }
  case 4: ;
#line 2014
  if (! decimatepixel) {
#line 2015
    if (! byteswaporder) {
#line 2017
      goto ldv_33281;
      ldv_33280: ;
#line 2018
      if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 2019
        last = 1;
      } else {
#line 2021
        last = 0;
      }
#line 2022
      y = *p2;
#line 2023
      if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 2024
        if (((unsigned int )mask & 4U) != 0U) {
#line 2025
          if ((int )isuy) {
#line 2026
            v = margin;
          } else {
#line 2028
            u = margin;
          }
        } else {

        }
      } else
#line 2033
      if ((int )isuy) {
#line 2034
        v = *(p2 + 1UL);
      } else {
#line 2036
        u = *(p2 + 1UL);
      }
#line 2039
      tmp = ay[(int )y] + rv[(int )v];
#line 2040
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2042
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 2043
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2045
      tmp = ay[(int )y] + bu[(int )u];
#line 2046
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2049
      if ((int )last && rump != 0) {
#line 2050
        pcache = (u8 *)(& peasycap->cache);
#line 2051
        switch (bytesperpixel - rump) {
        case 1: 
#line 2053
        *p3 = r;
#line 2054
        tmp___13 = pcache;
#line 2054
        pcache = pcache + 1;
#line 2054
        *tmp___13 = g;
#line 2055
        tmp___14 = pcache;
#line 2055
        pcache = pcache + 1;
#line 2055
        *tmp___14 = b;
#line 2056
        tmp___15 = pcache;
#line 2056
        pcache = pcache + 1;
#line 2056
        *tmp___15 = 0U;
#line 2057
        goto ldv_33276;
        case 2: 
#line 2060
        *p3 = r;
#line 2061
        *(p3 + 1UL) = g;
#line 2062
        tmp___16 = pcache;
#line 2062
        pcache = pcache + 1;
#line 2062
        *tmp___16 = b;
#line 2063
        tmp___17 = pcache;
#line 2063
        pcache = pcache + 1;
#line 2063
        *tmp___17 = 0U;
#line 2064
        goto ldv_33276;
        case 3: 
#line 2067
        *p3 = r;
#line 2068
        *(p3 + 1UL) = g;
#line 2069
        *(p3 + 2UL) = b;
#line 2070
        tmp___18 = pcache;
#line 2070
        pcache = pcache + 1;
#line 2070
        *tmp___18 = 0U;
#line 2071
        goto ldv_33276;
        default: 
#line 2074
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 2076
        return (-14);
        }
        ldv_33276: ;
      } else {
#line 2080
        *p3 = r;
#line 2081
        *(p3 + 1UL) = g;
#line 2082
        *(p3 + 2UL) = b;
#line 2083
        *(p3 + 3UL) = 0U;
      }
#line 2085
      p2 = p2 + 2UL;
#line 2086
      if ((int )isuy) {
#line 2087
        isuy = 0;
      } else {
#line 2089
        isuy = 1;
      }
#line 2090
      p3 = p3 + (unsigned long )bytesperpixel;
      ldv_33281: ;
#line 2017
      if ((unsigned long )pz > (unsigned long )p2) {
#line 2019
        goto ldv_33280;
      } else {

      }

#line 2092
      return (0);
    } else {
#line 2097
      goto ldv_33289;
      ldv_33288: ;
#line 2098
      if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 2099
        last = 1;
      } else {
#line 2101
        last = 0;
      }
#line 2102
      y = *p2;
#line 2103
      if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 2104
        if (((unsigned int )mask & 4U) != 0U) {
#line 2105
          if ((int )isuy) {
#line 2106
            v = margin;
          } else {
#line 2108
            u = margin;
          }
        } else {

        }
      } else
#line 2113
      if ((int )isuy) {
#line 2114
        v = *(p2 + 1UL);
      } else {
#line 2116
        u = *(p2 + 1UL);
      }
#line 2119
      tmp = ay[(int )y] + rv[(int )v];
#line 2120
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2122
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 2123
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2125
      tmp = ay[(int )y] + bu[(int )u];
#line 2126
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2129
      if ((int )last && rump != 0) {
#line 2130
        pcache = (u8 *)(& peasycap->cache);
#line 2131
        switch (bytesperpixel - rump) {
        case 1: 
#line 2133
        *p3 = b;
#line 2134
        tmp___19 = pcache;
#line 2134
        pcache = pcache + 1;
#line 2134
        *tmp___19 = g;
#line 2135
        tmp___20 = pcache;
#line 2135
        pcache = pcache + 1;
#line 2135
        *tmp___20 = r;
#line 2136
        tmp___21 = pcache;
#line 2136
        pcache = pcache + 1;
#line 2136
        *tmp___21 = 0U;
#line 2137
        goto ldv_33284;
        case 2: 
#line 2140
        *p3 = b;
#line 2141
        *(p3 + 1UL) = g;
#line 2142
        tmp___22 = pcache;
#line 2142
        pcache = pcache + 1;
#line 2142
        *tmp___22 = r;
#line 2143
        tmp___23 = pcache;
#line 2143
        pcache = pcache + 1;
#line 2143
        *tmp___23 = 0U;
#line 2144
        goto ldv_33284;
        case 3: 
#line 2147
        *p3 = b;
#line 2148
        *(p3 + 1UL) = g;
#line 2149
        *(p3 + 2UL) = r;
#line 2150
        tmp___24 = pcache;
#line 2150
        pcache = pcache + 1;
#line 2150
        *tmp___24 = 0U;
#line 2151
        goto ldv_33284;
        default: 
#line 2154
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 2156
        return (-14);
        }
        ldv_33284: ;
      } else {
#line 2159
        *p3 = b;
#line 2160
        *(p3 + 1UL) = g;
#line 2161
        *(p3 + 2UL) = r;
#line 2162
        *(p3 + 3UL) = 0U;
      }
#line 2164
      p2 = p2 + 2UL;
#line 2165
      if ((int )isuy) {
#line 2166
        isuy = 0;
      } else {
#line 2168
        isuy = 1;
      }
#line 2169
      p3 = p3 + (unsigned long )bytesperpixel;
      ldv_33289: ;
#line 2097
      if ((unsigned long )pz > (unsigned long )p2) {
#line 2099
        goto ldv_33288;
      } else {

      }

    }
#line 2172
    return (0);
  } else
#line 2174
  if (! byteswaporder) {
#line 2178
    goto ldv_33297;
    ldv_33296: ;
#line 2179
    if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 2180
      last = 1;
    } else {
#line 2182
      last = 0;
    }
#line 2183
    y = *p2;
#line 2184
    if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 2185
      if (((unsigned int )mask & 4U) != 0U) {
#line 2186
        if ((int )isuy) {
#line 2187
          v = margin;
        } else {
#line 2189
          u = margin;
        }
      } else {

      }
    } else
#line 2194
    if ((int )isuy) {
#line 2195
      v = *(p2 + 1UL);
    } else {
#line 2197
      u = *(p2 + 1UL);
    }
#line 2200
    if ((int )isuy) {
#line 2202
      tmp = ay[(int )y] + rv[(int )v];
#line 2203
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2205
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 2207
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2209
      tmp = ay[(int )y] + bu[(int )u];
#line 2210
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2213
      if ((int )last && rump != 0) {
#line 2214
        pcache = (u8 *)(& peasycap->cache);
#line 2215
        switch (bytesperpixel - rump) {
        case 1: 
#line 2217
        *p3 = r;
#line 2218
        tmp___25 = pcache;
#line 2218
        pcache = pcache + 1;
#line 2218
        *tmp___25 = g;
#line 2219
        tmp___26 = pcache;
#line 2219
        pcache = pcache + 1;
#line 2219
        *tmp___26 = b;
#line 2220
        tmp___27 = pcache;
#line 2220
        pcache = pcache + 1;
#line 2220
        *tmp___27 = 0U;
#line 2221
        goto ldv_33292;
        case 2: 
#line 2224
        *p3 = r;
#line 2225
        *(p3 + 1UL) = g;
#line 2226
        tmp___28 = pcache;
#line 2226
        pcache = pcache + 1;
#line 2226
        *tmp___28 = b;
#line 2227
        tmp___29 = pcache;
#line 2227
        pcache = pcache + 1;
#line 2227
        *tmp___29 = 0U;
#line 2228
        goto ldv_33292;
        case 3: 
#line 2231
        *p3 = r;
#line 2232
        *(p3 + 1UL) = g;
#line 2233
        *(p3 + 2UL) = b;
#line 2234
        tmp___30 = pcache;
#line 2234
        pcache = pcache + 1;
#line 2234
        *tmp___30 = 0U;
#line 2235
        goto ldv_33292;
        default: 
#line 2238
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 2242
        return (-14);
        }
        ldv_33292: ;
      } else {
#line 2246
        *p3 = r;
#line 2247
        *(p3 + 1UL) = g;
#line 2248
        *(p3 + 2UL) = b;
#line 2249
        *(p3 + 3UL) = 0U;
      }
#line 2251
      isuy = 0;
#line 2252
      p3 = p3 + (unsigned long )bytesperpixel;
    } else {
#line 2254
      isuy = 1;
    }
#line 2255
    p2 = p2 + 2UL;
    ldv_33297: ;
#line 2178
    if ((unsigned long )pz > (unsigned long )p2) {
#line 2180
      goto ldv_33296;
    } else {

    }

#line 2257
    return (0);
  } else {
#line 2262
    goto ldv_33305;
    ldv_33304: ;
#line 2263
    if ((unsigned long )(p3 + (unsigned long )bytesperpixel) >= (unsigned long )pr) {
#line 2264
      last = 1;
    } else {
#line 2266
      last = 0;
    }
#line 2267
    y = *p2;
#line 2268
    if ((int )last && ((unsigned int )mask & 12U) != 0U) {
#line 2269
      if (((unsigned int )mask & 4U) != 0U) {
#line 2270
        if ((int )isuy) {
#line 2271
          v = margin;
        } else {
#line 2273
          u = margin;
        }
      } else {

      }
    } else
#line 2278
    if ((int )isuy) {
#line 2279
      v = *(p2 + 1UL);
    } else {
#line 2281
      u = *(p2 + 1UL);
    }
#line 2284
    if ((int )isuy) {
#line 2285
      tmp = ay[(int )y] + rv[(int )v];
#line 2286
      r = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2288
      tmp = (ay[(int )y] - gu[(int )u]) - gv[(int )v];
#line 2290
      g = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2292
      tmp = ay[(int )y] + bu[(int )u];
#line 2293
      b = tmp <= 255 ? (tmp >= 0 ? (u8 )tmp : 0U) : 255U;
#line 2296
      if ((int )last && rump != 0) {
#line 2297
        pcache = (u8 *)(& peasycap->cache);
#line 2298
        switch (bytesperpixel - rump) {
        case 1: 
#line 2300
        *p3 = b;
#line 2301
        tmp___31 = pcache;
#line 2301
        pcache = pcache + 1;
#line 2301
        *tmp___31 = g;
#line 2302
        tmp___32 = pcache;
#line 2302
        pcache = pcache + 1;
#line 2302
        *tmp___32 = r;
#line 2303
        tmp___33 = pcache;
#line 2303
        pcache = pcache + 1;
#line 2303
        *tmp___33 = 0U;
#line 2304
        goto ldv_33300;
        case 2: 
#line 2307
        *p3 = b;
#line 2308
        *(p3 + 1UL) = g;
#line 2309
        tmp___34 = pcache;
#line 2309
        pcache = pcache + 1;
#line 2309
        *tmp___34 = r;
#line 2310
        tmp___35 = pcache;
#line 2310
        pcache = pcache + 1;
#line 2310
        *tmp___35 = 0U;
#line 2311
        goto ldv_33300;
        case 3: 
#line 2314
        *p3 = b;
#line 2315
        *(p3 + 1UL) = g;
#line 2316
        *(p3 + 2UL) = r;
#line 2317
        tmp___36 = pcache;
#line 2317
        pcache = pcache + 1;
#line 2317
        *tmp___36 = 0U;
#line 2318
        goto ldv_33300;
        default: 
#line 2321
        printk("<7>easycap::%i%s: MISTAKE: %i=rump\n", peasycap->isdongle, "redaub",
               bytesperpixel - rump);
#line 2324
        return (-14);
        }
        ldv_33300: ;
      } else {
#line 2328
        *p3 = b;
#line 2329
        *(p3 + 1UL) = g;
#line 2330
        *(p3 + 2UL) = r;
#line 2331
        *(p3 + 3UL) = 0U;
      }
#line 2333
      isuy = 0;
#line 2334
      p3 = p3 + (unsigned long )bytesperpixel;
    } else {
#line 2336
      isuy = 1;
    }
#line 2337
    p2 = p2 + 2UL;
    ldv_33305: ;
#line 2262
    if ((unsigned long )pz > (unsigned long )p2) {
#line 2264
      goto ldv_33304;
    } else {

    }

#line 2339
    return (0);
  }
  default: 
#line 2345
  printk("<7>easycap::%i%s: MISTAKE: %i=bytesperpixel\n", peasycap->isdongle, "redaub",
         bytesperpixel);
#line 2346
  return (-14);
  }
#line 2349
  return (0);
}
}
#line 2356 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static void easycap_vma_open(struct vm_area_struct *pvma ) 
{ 
  struct easycap *peasycap ;

  {
#line 2360
  peasycap = (struct easycap *)pvma->vm_private_data;
#line 2361
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 2362
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_vma_open");
#line 2363
    return;
  } else {

  }
#line 2365
  peasycap->vma_many = peasycap->vma_many + 1;
#line 2366
  if (easycap_debug > 7) {
#line 2366
    printk("<7>easycap:: %s: %i=peasycap->vma_many\n", "easycap_vma_open", peasycap->vma_many);
  } else {

  }
#line 2367
  return;
}
}
#line 2370 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static void easycap_vma_close(struct vm_area_struct *pvma ) 
{ 
  struct easycap *peasycap ;

  {
#line 2374
  peasycap = (struct easycap *)pvma->vm_private_data;
#line 2375
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 2376
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_vma_close");
#line 2377
    return;
  } else {

  }
#line 2379
  peasycap->vma_many = peasycap->vma_many - 1;
#line 2380
  if (easycap_debug > 7) {
#line 2380
    printk("<7>easycap:: %s: %i=peasycap->vma_many\n", "easycap_vma_close", peasycap->vma_many);
  } else {

  }
#line 2381
  return;
}
}
#line 2384 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_vma_fault(struct vm_area_struct *pvma , struct vm_fault *pvmf ) 
{ 
  int k ;
  int m ;
  int retcode ;
  void *pbuf ;
  struct page *page ;
  struct easycap *peasycap ;
  unsigned long tmp ;

  {
#line 2391
  retcode = 256;
#line 2393
  if ((unsigned long )pvma == (unsigned long )((struct vm_area_struct *)0)) {
#line 2394
    printk("<7>easycap:: %s: pvma is NULL\n", "easycap_vma_fault");
#line 2395
    return (retcode);
  } else {

  }
#line 2397
  if ((unsigned long )pvmf == (unsigned long )((struct vm_fault *)0)) {
#line 2398
    printk("<7>easycap:: %s: pvmf is NULL\n", "easycap_vma_fault");
#line 2399
    return (retcode);
  } else {

  }
#line 2402
  k = (int )(pvmf->pgoff / 405UL);
#line 2403
  m = (int )(pvmf->pgoff % 405UL);
#line 2405
  if (m == 0) {
#line 2406
    if (easycap_debug > 3) {
#line 2406
      printk("<7>easycap:: %s: %4i=k, %4i=m\n", "easycap_vma_fault", k, m);
    } else {

    }
  } else
#line 2408
  if (easycap_debug > 15) {
#line 2408
    printk("<7>easycap:: %s: %4i=k, %4i=m\n", "easycap_vma_fault", k, m);
  } else {

  }
#line 2410
  if (k < 0 || k > 5) {
#line 2411
    printk("<7>easycap:: %s: OLD_ERROR: buffer index %i out of range\n", "easycap_vma_fault",
           k);
#line 2412
    return (retcode);
  } else {

  }
#line 2414
  if (m < 0 || (unsigned int )m > 404U) {
#line 2415
    printk("<7>easycap:: %s: OLD_ERROR: page number  %i out of range\n", "easycap_vma_fault",
           m);
#line 2416
    return (retcode);
  } else {

  }
#line 2418
  peasycap = (struct easycap *)pvma->vm_private_data;
#line 2419
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 2420
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_vma_fault");
#line 2421
    return (retcode);
  } else {

  }
#line 2424
  pbuf = peasycap->frame_buffer[k][m].pgo;
#line 2425
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 2426
    printk("<7>easycap::%i%s: OLD_ERROR:  pbuf is NULL\n", peasycap->isdongle, "easycap_vma_fault");
#line 2427
    return (retcode);
  } else {

  }
#line 2429
  tmp = __phys_addr((unsigned long )pbuf);
#line 2429
  page = (struct page *)-24189255811072L + (tmp >> 12);
#line 2430
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 2431
    printk("<7>easycap::%i%s: OLD_ERROR:  page is NULL\n", peasycap->isdongle, "easycap_vma_fault");
#line 2432
    return (retcode);
  } else {

  }
#line 2434
  get_page(page);
#line 2436
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 2437
    printk("<7>easycap::%i%s: OLD_ERROR:  page is NULL after get_page(page)\n", peasycap->isdongle,
           "easycap_vma_fault");
  } else {
#line 2439
    pvmf->page = page;
#line 2440
    retcode = 0;
  }
#line 2442
  return (retcode);
}
}
#line 2445 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static struct vm_operations_struct  const  easycap_vm_ops  = 
#line 2445
     {& easycap_vma_open, & easycap_vma_close, & easycap_vma_fault, 0, 0, 0, 0, 0};
#line 2451 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_mmap(struct file *file , struct vm_area_struct *pvma ) 
{ 


  {
#line 2453
  if (easycap_debug > 7) {
#line 2453
    printk("<7>easycap:: %s: \n", "easycap_mmap");
  } else {

  }
#line 2455
  pvma->vm_ops = & easycap_vm_ops;
#line 2456
  pvma->vm_flags = pvma->vm_flags | 524288UL;
#line 2457
  if ((unsigned long )file != (unsigned long )((struct file *)0)) {
#line 2458
    pvma->vm_private_data = file->private_data;
  } else {

  }
#line 2459
  easycap_vma_open(pvma);
#line 2460
  return (0);
}
}
#line 2489 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static void easycap_complete(struct urb *purb ) 
{ 
  struct easycap *peasycap ;
  struct data_buffer *pfield_buffer ;
  char errbuf[16U] ;
  int i ;
  int more ;
  int much ;
  int leap ;
  int rc ;
  int last ;
  int videofieldamount ;
  unsigned int override ;
  unsigned int bad ;
  int framestatus ;
  int framelength ;
  int frameactual ;
  int frameoffset ;
  u8 *pu ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;
  char const   *tmp___3 ;

  {
#line 2500
  if ((unsigned long )purb == (unsigned long )((struct urb *)0)) {
#line 2501
    printk("<7>easycap:: %s: OLD_ERROR: easycap_complete(): purb is NULL\n", "easycap_complete");
#line 2502
    return;
  } else {

  }
#line 2504
  peasycap = (struct easycap *)purb->context;
#line 2505
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 2506
    printk("<7>easycap:: %s: OLD_ERROR: easycap_complete(): peasycap is NULL\n", "easycap_complete");
#line 2507
    return;
  } else {

  }
#line 2509
  if (peasycap->video_eof != 0) {
#line 2510
    return;
  } else {

  }
#line 2511
  i = 0;
#line 2511
  goto ldv_33358;
  ldv_33357: ;
#line 2512
  if ((unsigned long )purb->transfer_buffer == (unsigned long )peasycap->video_isoc_buffer[i].pgo) {
#line 2513
    goto ldv_33356;
  } else {

  }
#line 2511
  i = i + 1;
  ldv_33358: ;
#line 2511
  if (i <= 15) {
#line 2513
    goto ldv_33357;
  } else {

  }
  ldv_33356: ;
#line 2514
  if (easycap_debug > 15) {
#line 2514
    printk("<7>easycap::%i%s: %2i=urb\n", peasycap->isdongle, "easycap_complete",
           i);
  } else {

  }
#line 2515
  last = peasycap->video_isoc_sequence;
#line 2516
  if ((last == 15 && i != 0) || (last != 15 && last + 1 != i)) {
#line 2518
    if (easycap_debug > 15) {
#line 2518
      printk("<7>easycap::%i%s: OLD_ERROR: out-of-order urbs %i,%i ... continuing\n",
             peasycap->isdongle, "easycap_complete", last, i);
    } else {

    }
  } else {

  }
#line 2521
  peasycap->video_isoc_sequence = i;
#line 2523
  if (peasycap->video_idle != 0) {
#line 2524
    if (easycap_debug > 15) {
#line 2524
      printk("<7>easycap::%i%s: %i=video_idle  %i=video_isoc_streaming\n", peasycap->isdongle,
             "easycap_complete", peasycap->video_idle, peasycap->video_isoc_streaming);
    } else {

    }
#line 2526
    if (peasycap->video_isoc_streaming != 0) {
#line 2527
      rc = ldv_usb_submit_urb_5(purb, 32U);
#line 2528
      if (rc != 0) {
#line 2529
        tmp = strerror(rc);
#line 2529
        printk("<7>easycap::%i%s: %s:%d ENOMEM\n", peasycap->isdongle, "easycap_complete",
               tmp, rc);
#line 2530
        if (rc != -19) {
#line 2531
          printk("<7>easycap::%i%s: OLD_ERROR: while %i=video_idle, usb_submit_urb() failed with rc:\n",
                 peasycap->isdongle, "easycap_complete", peasycap->video_idle);
        } else {

        }
      } else {

      }
    } else {

    }
#line 2537
    return;
  } else {

  }
#line 2539
  override = 0U;
#line 2541
  if (peasycap->field_fill > 3) {
#line 2542
    printk("<7>easycap::%i%s: OLD_ERROR: bad peasycap->field_fill\n", peasycap->isdongle,
           "easycap_complete");
#line 2543
    return;
  } else {

  }
#line 2545
  if (purb->status != 0) {
#line 2546
    if (purb->status == -108 || purb->status == -2) {
#line 2547
      if (easycap_debug > 7) {
#line 2547
        printk("<7>easycap::%i%s: urb status -ESHUTDOWN or -ENOENT\n", peasycap->isdongle,
               "easycap_complete");
      } else {

      }
#line 2548
      return;
    } else {

    }
#line 2551
    peasycap->field_buffer[peasycap->field_fill][0].kount = (u16 )((unsigned int )peasycap->field_buffer[peasycap->field_fill][0].kount | 32768U);
#line 2552
    tmp___0 = strerror(purb->status);
#line 2552
    printk("<7>easycap::%i%s: OLD_ERROR: bad urb status -%s: %d\n", peasycap->isdongle,
           "easycap_complete", tmp___0, purb->status);
  } else {
#line 2556
    i = 0;
#line 2556
    goto ldv_33366;
    ldv_33365: ;
#line 2557
    if (purb->iso_frame_desc[i].status != 0) {
#line 2559
      peasycap->field_buffer[peasycap->field_fill][0].kount = (u16 )((unsigned int )peasycap->field_buffer[peasycap->field_fill][0].kount | 32768U);
#line 2561
      tmp___1 = strerror(purb->iso_frame_desc[i].status);
#line 2561
      strcpy((char *)(& errbuf), tmp___1);
    } else {

    }
#line 2564
    framestatus = purb->iso_frame_desc[i].status;
#line 2565
    framelength = (int )purb->iso_frame_desc[i].length;
#line 2566
    frameactual = (int )purb->iso_frame_desc[i].actual_length;
#line 2567
    frameoffset = (int )purb->iso_frame_desc[i].offset;
#line 2569
    if (easycap_debug > 15) {
#line 2569
      printk("<7>easycap::%i%s: frame[%2i]:%4i=status %4i=actual %4i=length %5i=offset\n",
             peasycap->isdongle, "easycap_complete", i, framestatus, frameactual,
             framelength, frameoffset);
    } else {

    }
#line 2575
    if (purb->iso_frame_desc[i].status == 0) {
#line 2576
      more = (int )purb->iso_frame_desc[i].actual_length;
#line 2577
      pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )peasycap->field_fill + (unsigned long )peasycap->field_page);
#line 2579
      videofieldamount = (int )((unsigned int )((unsigned long )peasycap->field_page) * 4096U + ((unsigned int )((long )pfield_buffer->pto) - (unsigned int )((long )pfield_buffer->pgo)));
#line 2582
      if (more == 4) {
#line 2583
        peasycap->video_mt = peasycap->video_mt + 1;
      } else {

      }
#line 2584
      if (more > 4) {
#line 2585
        if (peasycap->video_mt != 0) {
#line 2586
          if (easycap_debug > 7) {
#line 2586
            printk("<7>easycap::%i%s: %4i empty video urb frames\n", peasycap->isdongle,
                   "easycap_complete", peasycap->video_mt);
          } else {

          }
#line 2588
          peasycap->video_mt = 0;
        } else {

        }
#line 2590
        if (peasycap->field_fill > 3) {
#line 2591
          printk("<7>easycap::%i%s: OLD_ERROR: bad peasycap->field_fill\n", peasycap->isdongle,
                 "easycap_complete");
#line 2592
          return;
        } else {

        }
#line 2594
        if ((unsigned int )peasycap->field_page > 202U) {
#line 2596
          printk("<7>easycap::%i%s: OLD_ERROR: bad peasycap->field_page\n", peasycap->isdongle,
                 "easycap_complete");
#line 2597
          return;
        } else {

        }
#line 2599
        pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )peasycap->field_fill + (unsigned long )peasycap->field_page);
#line 2601
        pu = (u8 *)purb->transfer_buffer + (unsigned long )purb->iso_frame_desc[i].offset;
#line 2603
        if ((int )((signed char )*pu) < 0) {
#line 2604
          leap = 8;
        } else {
#line 2606
          leap = 4;
        }
#line 2624
        if (more == 8 || override != 0U) {
#line 2625
          if (peasycap->videofieldamount < videofieldamount) {
#line 2627
            if (videofieldamount - peasycap->videofieldamount == 2) {
#line 2632
              peasycap->field_buffer[peasycap->field_fill][0].kount = (u16 )((unsigned int )peasycap->field_buffer[peasycap->field_fill][0].kount | 256U);
#line 2633
              peasycap->video_junk = peasycap->video_junk + 17;
            } else {
#line 2638
              peasycap->field_buffer[peasycap->field_fill][0].kount = (u16 )((unsigned int )peasycap->field_buffer[peasycap->field_fill][0].kount | 16384U);
            }
          } else
#line 2639
          if (peasycap->videofieldamount > videofieldamount) {
#line 2644
            peasycap->field_buffer[peasycap->field_fill][0].kount = (u16 )((unsigned int )peasycap->field_buffer[peasycap->field_fill][0].kount | 8192U);
          } else {

          }
#line 2646
          bad = (unsigned int )peasycap->field_buffer[peasycap->field_fill][0].kount & 65280U;
#line 2649
          if (bad == 0U) {
#line 2650
            peasycap->video_junk = peasycap->video_junk - 1;
#line 2651
            if (peasycap->video_junk < -16) {
#line 2653
              peasycap->video_junk = -16;
            } else {

            }
#line 2655
            tmp___2 = peasycap->field_fill;
#line 2655
            peasycap->field_fill = peasycap->field_fill + 1;
#line 2655
            peasycap->field_read = tmp___2;
#line 2658
            if (peasycap->field_fill > 3) {
#line 2661
              peasycap->field_fill = 0;
            } else {

            }
#line 2663
            peasycap->field_page = 0;
#line 2664
            pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )peasycap->field_fill + (unsigned long )peasycap->field_page);
#line 2670
            pfield_buffer->pto = pfield_buffer->pgo;
#line 2672
            if (easycap_debug > 7) {
#line 2672
              printk("<7>easycap::%i%s: bumped to: %i=peasycap->field_fill  %i=parity\n",
                     peasycap->isdongle, "easycap_complete", peasycap->field_fill,
                     (int )pfield_buffer->kount & 255);
            } else {

            }
#line 2679
            if (easycap_debug > 7) {
#line 2679
              printk("<7>easycap::%i%s: field buffer %i has %i bytes fit to be read\n",
                     peasycap->isdongle, "easycap_complete", peasycap->field_read,
                     videofieldamount);
            } else {

            }
#line 2684
            if (easycap_debug > 7) {
#line 2684
              printk("<7>easycap::%i%s: wakeup call to wq_video, %i=field_read %i=field_fill %i=parity\n",
                     peasycap->isdongle, "easycap_complete", peasycap->field_read,
                     peasycap->field_fill, (int )peasycap->field_buffer[peasycap->field_read][0].kount & 255);
            } else {

            }
#line 2695
            __wake_up(& peasycap->wq_video, 1U, 1, (void *)0);
          } else {
#line 2699
            peasycap->video_junk = peasycap->video_junk + 1;
#line 2700
            if ((bad & 16U) != 0U) {
#line 2701
              peasycap->video_junk = peasycap->video_junk + 9;
            } else {

            }
#line 2703
            if (easycap_debug > 7) {
#line 2703
              printk("<7>easycap::%i%s: field buffer %i had %i bytes, now discarded: 0x%04X\n",
                     peasycap->isdongle, "easycap_complete", peasycap->field_fill,
                     videofieldamount, (int )peasycap->field_buffer[peasycap->field_fill][0].kount & 65280);
            } else {

            }
#line 2712
            peasycap->field_fill = peasycap->field_fill + 1;
#line 2714
            if (peasycap->field_fill > 3) {
#line 2716
              peasycap->field_fill = 0;
            } else {

            }
#line 2717
            peasycap->field_page = 0;
#line 2718
            pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )peasycap->field_fill + (unsigned long )peasycap->field_page);
#line 2722
            pfield_buffer->pto = pfield_buffer->pgo;
#line 2725
            if (easycap_debug > 7) {
#line 2725
              printk("<7>easycap::%i%s: bumped to: %i=peasycap->field_fill  %i=parity\n",
                     peasycap->isdongle, "easycap_complete", peasycap->field_fill,
                     (int )pfield_buffer->kount & 255);
            } else {

            }
          }
#line 2730
          if (more == 8) {
#line 2731
            if (easycap_debug > 7) {
#line 2731
              printk("<7>easycap::%i%s: end-of-field: received parity byte 0x%02X\n",
                     peasycap->isdongle, "easycap_complete", (int )*pu);
            } else {

            }
#line 2734
            if (((unsigned int )*pu & 64U) != 0U) {
#line 2735
              pfield_buffer->kount = 0U;
            } else {
#line 2737
              pfield_buffer->kount = 1U;
            }
#line 2738
            pfield_buffer->input = (u16 )(((int )((short )peasycap->input) & 7) | 8);
#line 2740
            if (easycap_debug > 7) {
#line 2740
              printk("<7>easycap::%i%s: end-of-field: 0x%02X=kount\n", peasycap->isdongle,
                     "easycap_complete", (int )pfield_buffer->kount & 255);
            } else {

            }
          } else {

          }
        } else {

        }
#line 2749
        pu = pu + (unsigned long )leap;
#line 2750
        more = more - leap;
#line 2752
        if (peasycap->field_fill > 3) {
#line 2753
          printk("<7>easycap::%i%s: OLD_ERROR: bad peasycap->field_fill\n", peasycap->isdongle,
                 "easycap_complete");
#line 2754
          return;
        } else {

        }
#line 2756
        if ((unsigned int )peasycap->field_page > 202U) {
#line 2757
          printk("<7>easycap::%i%s: OLD_ERROR: bad peasycap->field_page\n", peasycap->isdongle,
                 "easycap_complete");
#line 2758
          return;
        } else {

        }
#line 2760
        pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )peasycap->field_fill + (unsigned long )peasycap->field_page);
#line 2762
        goto ldv_33363;
        ldv_33362: 
#line 2763
        pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )peasycap->field_fill + (unsigned long )peasycap->field_page);
#line 2766
        if ((unsigned long )((long )pfield_buffer->pto - (long )pfield_buffer->pgo) > 4096UL) {
#line 2768
          printk("<7>easycap::%i%s: OLD_ERROR: bad pfield_buffer->pto\n", peasycap->isdongle,
                 "easycap_complete");
#line 2769
          return;
        } else {

        }
#line 2771
        if ((long )pfield_buffer->pto - (long )pfield_buffer->pgo == 4096L) {
#line 2773
          peasycap->field_page = peasycap->field_page + 1;
#line 2774
          if ((unsigned int )peasycap->field_page > 202U) {
#line 2776
            if (easycap_debug > 15) {
#line 2776
              printk("<7>easycap::%i%s: wrapping peasycap->field_page\n", peasycap->isdongle,
                     "easycap_complete");
            } else {

            }
#line 2778
            peasycap->field_page = 0;
          } else {

          }
#line 2780
          pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )peasycap->field_fill + (unsigned long )peasycap->field_page);
#line 2784
          pfield_buffer->pto = pfield_buffer->pgo;
#line 2785
          pfield_buffer->input = (u16 )(((int )((short )peasycap->input) & 7) | 8);
#line 2787
          if ((int )peasycap->field_buffer[peasycap->field_fill][0].input != (int )pfield_buffer->input) {
#line 2793
            peasycap->field_buffer[peasycap->field_fill][0].kount = (u16 )((unsigned int )peasycap->field_buffer[peasycap->field_fill][0].kount | 4096U);
          } else {

          }
        } else {

        }
#line 2796
        much = (int )(((unsigned int )((long )pfield_buffer->pgo) - (unsigned int )((long )pfield_buffer->pto)) + 4096U);
#line 2800
        if (much > more) {
#line 2801
          much = more;
        } else {

        }
#line 2802
        __len = (size_t )much;
#line 2802
        __ret = __builtin_memcpy(pfield_buffer->pto, (void const   *)pu, __len);
#line 2803
        pu = pu + (unsigned long )much;
#line 2804
        pfield_buffer->pto = pfield_buffer->pto + (unsigned long )much;
#line 2805
        more = more - much;
        ldv_33363: ;
#line 2762
        if (more != 0) {
#line 2764
          goto ldv_33362;
        } else {

        }

      } else {

      }
    } else {

    }
#line 2556
    i = i + 1;
    ldv_33366: ;
#line 2556
    if (purb->number_of_packets > i) {
#line 2558
      goto ldv_33365;
    } else {

    }

  }
#line 2819
  if (peasycap->video_junk > 15) {
#line 2820
    printk("<7>easycap::%i%s: easycap driver shutting down on condition green\n",
           peasycap->isdongle, "easycap_complete");
#line 2821
    peasycap->status = 1;
#line 2822
    peasycap->video_eof = 1;
#line 2823
    peasycap->video_junk = 0;
#line 2824
    __wake_up(& peasycap->wq_video, 1U, 1, (void *)0);
#line 2829
    return;
  } else {

  }
#line 2831
  if (peasycap->video_isoc_streaming != 0) {
#line 2832
    rc = ldv_usb_submit_urb_6(purb, 32U);
#line 2833
    if (rc != 0) {
#line 2834
      tmp___3 = strerror(rc);
#line 2834
      printk("<7>easycap::%i%s: %s: %d\n", peasycap->isdongle, "easycap_complete",
             tmp___3, rc);
#line 2835
      if (rc != -19) {
#line 2836
        printk("<7>easycap::%i%s: OLD_ERROR: while %i=video_idle, usb_submit_urb() failed with rc:\n",
               peasycap->isdongle, "easycap_complete", peasycap->video_idle);
      } else {

      }
    } else {

    }
  } else {

  }
#line 2842
  return;
}
}
#line 2845 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static struct v4l2_file_operations  const  v4l2_fops  = 
#line 2845
     {& __this_module, 0, 0, & easycap_poll, 0, & easycap_unlocked_ioctl, 0, & easycap_mmap,
    & easycap_open_noinode, 0};
#line 2859 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_usb_probe(struct usb_interface *intf , struct usb_device_id  const  *id ) 
{ 
  struct usb_device *usbdev ;
  struct usb_host_interface *alt ;
  struct usb_endpoint_descriptor *ep ;
  struct usb_interface_descriptor *interface ;
  struct urb *purb ;
  struct easycap *peasycap ;
  int ndong ;
  struct data_urb *pdata_urb ;
  int i ;
  int j ;
  int k ;
  int m ;
  int rc ;
  u8 bInterfaceNumber ;
  u8 bInterfaceClass ;
  u8 bInterfaceSubClass ;
  void *pbuf ;
  int okalt[8U] ;
  int isokalt ;
  int okepn[8U] ;
  int okmps[8U] ;
  int maxpacketsize ;
  u16 mask ;
  s32 value ;
  struct easycap_format *peasycap_format ;
  int fmtidx ;
  struct inputset *inputset ;
  void *tmp ;
  int __val ;
  int __min ;
  int __max ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct v4l2_pix_format *pix ;
  int tmp___3 ;
  int tmp___4 ;
  int _min1 ;
  int _min2 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned long tmp___12 ;
  void *tmp___13 ;
  unsigned int tmp___14 ;

  {
#line 2885
  usbdev = interface_to_usbdev(intf);
#line 2888
  alt = usb_altnum_to_altsetting((struct usb_interface  const  *)intf, 0U);
#line 2889
  if ((unsigned long )alt == (unsigned long )((struct usb_host_interface *)0)) {
#line 2890
    printk("<7>easycap:: %s: OLD_ERROR: usb_host_interface not found\n", "easycap_usb_probe");
#line 2891
    return (-14);
  } else {

  }
#line 2894
  interface = & alt->desc;
#line 2895
  if ((unsigned long )interface == (unsigned long )((struct usb_interface_descriptor *)0)) {
#line 2896
    printk("<7>easycap:: %s: OLD_ERROR: intf_descriptor is NULL\n", "easycap_usb_probe");
#line 2897
    return (-14);
  } else {

  }
#line 2904
  bInterfaceNumber = interface->bInterfaceNumber;
#line 2905
  bInterfaceClass = interface->bInterfaceClass;
#line 2906
  bInterfaceSubClass = interface->bInterfaceSubClass;
#line 2908
  if (easycap_debug > 3) {
#line 2908
    printk("<7>easycap:: %s: intf[%i]: num_altsetting=%i\n", "easycap_usb_probe",
           (int )bInterfaceNumber, intf->num_altsetting);
  } else {

  }
#line 2910
  if (easycap_debug > 3) {
#line 2910
    printk("<7>easycap:: %s: intf[%i]: cur_altsetting - altsetting=%li\n", "easycap_usb_probe",
           (int )bInterfaceNumber, ((long )intf->cur_altsetting - (long )intf->altsetting) / 48L);
  } else {

  }
#line 2913
  if (easycap_debug > 3) {
#line 2913
    printk("<7>easycap:: %s: intf[%i]: bInterfaceClass=0x%02X bInterfaceSubClass=0x%02X\n",
           "easycap_usb_probe", (int )bInterfaceNumber, (int )bInterfaceClass, (int )bInterfaceSubClass);
  } else {

  }
#line 2926
  if ((unsigned int )bInterfaceNumber == 0U) {
#line 2927
    tmp = kzalloc(134768UL, 208U);
#line 2927
    peasycap = (struct easycap *)tmp;
#line 2928
    if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 2929
      printk("<7>easycap:: %s: OLD_ERROR: Could not allocate peasycap\n", "easycap_usb_probe");
#line 2930
      return (-12);
    } else {

    }
#line 2937
    peasycap->minor = -1;
#line 2938
    kref_init(& peasycap->kref);
#line 2939
    if (easycap_debug > 7) {
#line 2939
      printk("<7>easycap::%i%s: intf[%i]: after kref_init(..._video) %i=peasycap->kref.refcount.counter\n",
             peasycap->isdongle, "easycap_usb_probe", (int )bInterfaceNumber, peasycap->kref.refcount.counter);
    } else {

    }
#line 2944
    __val = easycap_gain;
#line 2944
    __min = 0;
#line 2944
    __max = 31;
#line 2944
    __val = __min > __val ? __min : __val;
#line 2944
    peasycap->gain = (signed char )(__max < __val ? __max : __val);
#line 2946
    __init_waitqueue_head(& peasycap->wq_video, "&peasycap->wq_video", & __key);
#line 2947
    __init_waitqueue_head(& peasycap->wq_audio, "&peasycap->wq_audio", & __key___0);
#line 2948
    __init_waitqueue_head(& peasycap->wq_trigger, "&peasycap->wq_trigger", & __key___1);
#line 2950
    tmp___0 = mutex_lock_interruptible_nested(& mutex_dongle, 0U);
#line 2950
    if (tmp___0 != 0) {
#line 2951
      printk("<7>easycap:: %s: OLD_ERROR: cannot down mutex_dongle\n", "easycap_usb_probe");
#line 2952
      return (-512);
    } else {

    }
#line 2955
    ndong = 0;
#line 2955
    goto ldv_33410;
    ldv_33409: ;
#line 2956
    if ((unsigned long )easycapdc60_dongle[ndong].peasycap == (unsigned long )((struct easycap *)0)) {
#line 2956
      tmp___1 = mutex_is_locked(& easycapdc60_dongle[ndong].mutex_video);
#line 2956
      if (tmp___1 == 0) {
#line 2956
        tmp___2 = mutex_is_locked(& easycapdc60_dongle[ndong].mutex_audio);
#line 2956
        if (tmp___2 == 0) {
#line 2961
          easycapdc60_dongle[ndong].peasycap = peasycap;
#line 2962
          peasycap->isdongle = ndong;
#line 2963
          if (easycap_debug > 7) {
#line 2963
            printk("<7>easycap::%i%s: intf[%i]: peasycap-->easycap_dongle[%i].peasycap\n",
                   peasycap->isdongle, "easycap_usb_probe", (int )bInterfaceNumber,
                   ndong);
          } else {

          }
#line 2966
          goto ldv_33408;
        } else {

        }
      } else {

      }
    } else {

    }
#line 2955
    ndong = ndong + 1;
    ldv_33410: ;
#line 2955
    if (ndong <= 7) {
#line 2957
      goto ldv_33409;
    } else {

    }
    ldv_33408: ;
#line 2970
    if (ndong > 7) {
#line 2971
      printk("<7>easycap::%i%s: OLD_ERROR: too many dongles\n", peasycap->isdongle, "easycap_usb_probe");
#line 2972
      mutex_unlock(& mutex_dongle);
#line 2973
      return (-12);
    } else {

    }
#line 2975
    mutex_unlock(& mutex_dongle);
#line 2977
    peasycap->allocation_video_struct = 134768;
#line 2984
    peasycap->pusb_device = usbdev;
#line 2985
    peasycap->pusb_interface = intf;
#line 2987
    peasycap->microphone = 0;
#line 2989
    peasycap->video_interface = -1;
#line 2990
    peasycap->video_altsetting_on = -1;
#line 2991
    peasycap->video_altsetting_off = -1;
#line 2992
    peasycap->video_endpointnumber = -1;
#line 2993
    peasycap->video_isoc_maxframesize = -1;
#line 2994
    peasycap->video_isoc_buffer_size = -1;
#line 2996
    peasycap->audio_interface = -1;
#line 2997
    peasycap->audio_altsetting_on = -1;
#line 2998
    peasycap->audio_altsetting_off = -1;
#line 2999
    peasycap->audio_endpointnumber = -1;
#line 3000
    peasycap->audio_isoc_maxframesize = -1;
#line 3001
    peasycap->audio_isoc_buffer_size = -1;
#line 3003
    peasycap->frame_buffer_many = 6;
#line 3010
    rc = easycap_video_fillin_formats();
#line 3011
    if (rc < 0) {
#line 3012
      printk("<7>easycap::%i%s: OLD_ERROR: fillin_formats() rc = %i\n", peasycap->isdongle,
             "easycap_usb_probe", rc);
#line 3013
      return (-14);
    } else {

    }
#line 3015
    if (easycap_debug > 3) {
#line 3015
      printk("<7>easycap::%i%s: %i formats available\n", peasycap->isdongle, "easycap_usb_probe",
             rc);
    } else {

    }
#line 3019
    inputset = (struct inputset *)(& peasycap->inputset);
#line 3021
    fmtidx = (int )peasycap->ntsc;
#line 3022
    m = 0;
#line 3023
    mask = 0U;
#line 3024
    i = 0;
#line 3024
    goto ldv_33415;
    ldv_33414: ;
#line 3025
    if ((unsigned int )fmtidx == (unsigned int )easycap_standard[i].v4l2_standard.index) {
#line 3026
      m = m + 1;
#line 3027
      k = 0;
#line 3027
      goto ldv_33412;
      ldv_33411: 
#line 3028
      (inputset + (unsigned long )k)->standard_offset = i;
#line 3027
      k = k + 1;
      ldv_33412: ;
#line 3027
      if (k <= 5) {
#line 3029
        goto ldv_33411;
      } else {

      }
#line 3030
      mask = easycap_standard[i].mask;
    } else {

    }
#line 3024
    i = i + 1;
    ldv_33415: ;
#line 3024
    if ((unsigned int )((unsigned short )easycap_standard[i].mask) != 65535U) {
#line 3026
      goto ldv_33414;
    } else {

    }

#line 3034
    if (m != 1) {
#line 3035
      printk("<7>easycap::%i%s: OLD_ERROR: inputset->standard_offset unpopulated, %i=m\n",
             peasycap->isdongle, "easycap_usb_probe", m);
#line 3037
      return (-2);
    } else {

    }
#line 3040
    peasycap_format = (struct easycap_format *)(& easycap_format);
#line 3041
    m = 0;
#line 3042
    i = 0;
#line 3042
    goto ldv_33423;
    ldv_33422: 
#line 3043
    pix = & peasycap_format->v4l2_format.fmt.pix;
#line 3045
    if (((((((int )peasycap_format->mask ^ (int )mask) & 15) == 0 && (unsigned int )pix->field == 1U) && pix->pixelformat == 1498831189U) && pix->width == 640U) && pix->height == 480U) {
#line 3049
      m = m + 1;
#line 3050
      k = 0;
#line 3050
      goto ldv_33419;
      ldv_33418: 
#line 3051
      (inputset + (unsigned long )k)->format_offset = i;
#line 3050
      k = k + 1;
      ldv_33419: ;
#line 3050
      if (k <= 5) {
#line 3052
        goto ldv_33418;
      } else {

      }

#line 3052
      goto ldv_33421;
    } else {

    }
#line 3054
    peasycap_format = peasycap_format + 1;
#line 3042
    i = i + 1;
    ldv_33423: ;
#line 3042
    if (peasycap_format->v4l2_format.fmt.pix.width != 0U) {
#line 3044
      goto ldv_33422;
    } else {

    }
    ldv_33421: ;
#line 3056
    if (m != 1) {
#line 3057
      printk("<7>easycap::%i%s: OLD_ERROR: inputset[]->format_offset unpopulated\n", peasycap->isdongle,
             "easycap_usb_probe");
#line 3058
      return (-2);
    } else {

    }
#line 3061
    m = 0;
#line 3062
    i = 0;
#line 3062
    goto ldv_33437;
    ldv_33436: 
#line 3063
    value = easycap_control[i].default_value;
#line 3064
    if (easycap_control[i].id == 9963776U) {
#line 3065
      m = m + 1;
#line 3066
      k = 0;
#line 3066
      goto ldv_33425;
      ldv_33424: 
#line 3067
      (inputset + (unsigned long )k)->brightness = value;
#line 3066
      k = k + 1;
      ldv_33425: ;
#line 3066
      if (k <= 5) {
#line 3068
        goto ldv_33424;
      } else {

      }

    } else
#line 3068
    if (easycap_control[i].id == 9963777U) {
#line 3069
      m = m + 1;
#line 3070
      k = 0;
#line 3070
      goto ldv_33428;
      ldv_33427: 
#line 3071
      (inputset + (unsigned long )k)->contrast = value;
#line 3070
      k = k + 1;
      ldv_33428: ;
#line 3070
      if (k <= 5) {
#line 3072
        goto ldv_33427;
      } else {

      }

    } else
#line 3072
    if (easycap_control[i].id == 9963778U) {
#line 3073
      m = m + 1;
#line 3074
      k = 0;
#line 3074
      goto ldv_33431;
      ldv_33430: 
#line 3075
      (inputset + (unsigned long )k)->saturation = value;
#line 3074
      k = k + 1;
      ldv_33431: ;
#line 3074
      if (k <= 5) {
#line 3076
        goto ldv_33430;
      } else {

      }

    } else
#line 3076
    if (easycap_control[i].id == 9963779U) {
#line 3077
      m = m + 1;
#line 3078
      k = 0;
#line 3078
      goto ldv_33434;
      ldv_33433: 
#line 3079
      (inputset + (unsigned long )k)->hue = value;
#line 3078
      k = k + 1;
      ldv_33434: ;
#line 3078
      if (k <= 5) {
#line 3080
        goto ldv_33433;
      } else {

      }

    } else {

    }
#line 3062
    i = i + 1;
    ldv_33437: ;
#line 3062
    if (easycap_control[i].id != 4294967295U) {
#line 3064
      goto ldv_33436;
    } else {

    }

#line 3083
    if (m != 4) {
#line 3084
      printk("<7>easycap::%i%s: OLD_ERROR: inputset[]->brightness underpopulated\n", peasycap->isdongle,
             "easycap_usb_probe");
#line 3085
      return (-2);
    } else {

    }
#line 3087
    k = 0;
#line 3087
    goto ldv_33440;
    ldv_33439: 
#line 3088
    (inputset + (unsigned long )k)->input = k;
#line 3087
    k = k + 1;
    ldv_33440: ;
#line 3087
    if (k <= 5) {
#line 3089
      goto ldv_33439;
    } else {

    }

#line 3089
    if (easycap_debug > 3) {
#line 3089
      printk("<7>easycap::%i%s: populated inputset[]\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3090
    if (easycap_debug > 3) {
#line 3090
      printk("<7>easycap::%i%s: finished initialization\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
  } else {
#line 3100
    ndong = 0;
#line 3100
    goto ldv_33444;
    ldv_33443: ;
#line 3101
    if ((unsigned long )(easycapdc60_dongle[ndong].peasycap)->pusb_device == (unsigned long )usbdev) {
#line 3103
      peasycap = easycapdc60_dongle[ndong].peasycap;
#line 3104
      if (easycap_debug > 7) {
#line 3104
        printk("<7>easycap:: %s: intf[%i]: dongle[%i].peasycap\n", "easycap_usb_probe",
               (int )bInterfaceNumber, ndong);
      } else {

      }
#line 3106
      goto ldv_33442;
    } else {

    }
#line 3100
    ndong = ndong + 1;
    ldv_33444: ;
#line 3100
    if (ndong <= 7) {
#line 3102
      goto ldv_33443;
    } else {

    }
    ldv_33442: ;
#line 3109
    if (ndong > 7) {
#line 3110
      printk("<7>easycap:: %s: OLD_ERROR: peasycap is unknown when probing interface %i\n",
             "easycap_usb_probe", (int )bInterfaceNumber);
#line 3112
      return (-19);
    } else {

    }
#line 3114
    if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 3115
      printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL when probing interface %i\n",
             "easycap_usb_probe", (int )bInterfaceNumber);
#line 3117
      return (-19);
    } else {

    }
  }
#line 3121
  if ((unsigned int )bInterfaceClass == 14U || (unsigned int )bInterfaceClass == 255U) {
#line 3123
    if (peasycap->video_interface == -1) {
#line 3124
      peasycap->video_interface = (int )bInterfaceNumber;
#line 3125
      if (easycap_debug > 3) {
#line 3125
        printk("<7>easycap::%i%s: setting peasycap->video_interface=%i\n", peasycap->isdongle,
               "easycap_usb_probe", peasycap->video_interface);
      } else {

      }
    } else
#line 3128
    if (peasycap->video_interface != (int )bInterfaceNumber) {
#line 3129
      printk("<7>easycap::%i%s: OLD_ERROR: attempting to reset peasycap->video_interface\n",
             peasycap->isdongle, "easycap_usb_probe");
#line 3131
      printk("<7>easycap::%i%s: ...... continuing with %i=peasycap->video_interface\n",
             peasycap->isdongle, "easycap_usb_probe", peasycap->video_interface);
    } else {

    }
  } else
#line 3136
  if ((unsigned int )bInterfaceClass == 1U && (unsigned int )bInterfaceSubClass == 2U) {
#line 3138
    if (peasycap->audio_interface == -1) {
#line 3139
      peasycap->audio_interface = (int )bInterfaceNumber;
#line 3140
      if (easycap_debug > 3) {
#line 3140
        printk("<7>easycap::%i%s: setting peasycap->audio_interface=%i\n", peasycap->isdongle,
               "easycap_usb_probe", peasycap->audio_interface);
      } else {

      }
    } else
#line 3143
    if (peasycap->audio_interface != (int )bInterfaceNumber) {
#line 3144
      printk("<7>easycap::%i%s: OLD_ERROR: attempting to reset peasycap->audio_interface\n",
             peasycap->isdongle, "easycap_usb_probe");
#line 3146
      printk("<7>easycap::%i%s: ...... continuing with %i=peasycap->audio_interface\n",
             peasycap->isdongle, "easycap_usb_probe", peasycap->audio_interface);
    } else {

    }
  } else {

  }
#line 3158
  isokalt = 0;
#line 3160
  i = 0;
#line 3160
  goto ldv_33455;
  ldv_33454: 
#line 3161
  alt = usb_altnum_to_altsetting((struct usb_interface  const  *)intf, (unsigned int )i);
#line 3162
  if ((unsigned long )alt == (unsigned long )((struct usb_host_interface *)0)) {
#line 3163
    printk("<7>easycap::%i%s: OLD_ERROR: alt is NULL\n", peasycap->isdongle, "easycap_usb_probe");
#line 3164
    return (-14);
  } else {

  }
#line 3166
  interface = & alt->desc;
#line 3167
  if ((unsigned long )interface == (unsigned long )((struct usb_interface_descriptor *)0)) {
#line 3168
    printk("<7>easycap::%i%s: OLD_ERROR: intf_descriptor is NULL\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3169
    return (-14);
  } else {

  }
#line 3172
  if ((unsigned int )interface->bNumEndpoints == 0U) {
#line 3173
    if (easycap_debug > 3) {
#line 3173
      printk("<7>easycap::%i%s: intf[%i]alt[%i] has no endpoints\n", peasycap->isdongle,
             "easycap_usb_probe", (int )bInterfaceNumber, i);
    } else {

    }
  } else {

  }
#line 3176
  j = 0;
#line 3176
  goto ldv_33452;
  ldv_33451: 
#line 3177
  ep = & (alt->endpoint + (unsigned long )j)->desc;
#line 3178
  if ((unsigned long )ep == (unsigned long )((struct usb_endpoint_descriptor *)0)) {
#line 3179
    printk("<7>easycap::%i%s: OLD_ERROR:  ep is NULL.\n", peasycap->isdongle, "easycap_usb_probe");
#line 3180
    printk("<7>easycap::%i%s: ...... skipping\n", peasycap->isdongle, "easycap_usb_probe");
#line 3181
    goto ldv_33445;
  } else {

  }
#line 3184
  tmp___4 = usb_endpoint_is_isoc_in((struct usb_endpoint_descriptor  const  *)ep);
#line 3184
  if (tmp___4 == 0) {
#line 3185
    if (easycap_debug > 3) {
#line 3185
      printk("<7>easycap::%i%s: intf[%i]alt[%i]end[%i] is a %d endpoint\n", peasycap->isdongle,
             "easycap_usb_probe", (int )bInterfaceNumber, i, j, (int )ep->bmAttributes);
    } else {

    }
#line 3188
    tmp___3 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)ep);
#line 3188
    if (tmp___3 != 0) {
#line 3189
      printk("<7>easycap::%i%s: OLD_ERROR: OUT endpoint unexpected\n", peasycap->isdongle,
             "easycap_usb_probe");
#line 3190
      printk("<7>easycap::%i%s: ...... continuing\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3192
    goto ldv_33445;
  } else {

  }
#line 3194
  switch ((int )bInterfaceClass) {
  case 14: ;
  case 255: ;
#line 3197
  if ((unsigned int )ep->wMaxPacketSize != 0U) {
#line 3198
    if (isokalt <= 7) {
#line 3199
      okalt[isokalt] = i;
#line 3200
      if (easycap_debug > 3) {
#line 3200
        printk("<7>easycap::%i%s: %i=okalt[%i]\n", peasycap->isdongle, "easycap_usb_probe",
               okalt[isokalt], isokalt);
      } else {

      }
#line 3204
      okepn[isokalt] = (int )ep->bEndpointAddress & 15;
#line 3208
      if (easycap_debug > 3) {
#line 3208
        printk("<7>easycap::%i%s: %i=okepn[%i]\n", peasycap->isdongle, "easycap_usb_probe",
               okepn[isokalt], isokalt);
      } else {

      }
#line 3212
      okmps[isokalt] = (int )ep->wMaxPacketSize;
#line 3215
      if (easycap_debug > 3) {
#line 3215
        printk("<7>easycap::%i%s: %i=okmps[%i]\n", peasycap->isdongle, "easycap_usb_probe",
               okmps[isokalt], isokalt);
      } else {

      }
#line 3219
      isokalt = isokalt + 1;
    } else {

    }
  } else
#line 3222
  if (peasycap->video_altsetting_off == -1) {
#line 3224
    peasycap->video_altsetting_off = i;
#line 3227
    if (easycap_debug > 3) {
#line 3227
      printk("<7>easycap::%i%s: %i=video_altsetting_off <====\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->video_altsetting_off);
    } else {

    }
  } else {
#line 3233
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->video_altsetting_off already set\n",
           peasycap->isdongle, "easycap_usb_probe");
#line 3236
    printk("<7>easycap::%i%s: ...... continuing with %i=peasycap->video_altsetting_off\n",
           peasycap->isdongle, "easycap_usb_probe", peasycap->video_altsetting_off);
  }
#line 3244
  goto ldv_33448;
  case 1: ;
#line 3247
  if ((unsigned int )bInterfaceSubClass != 2U) {
#line 3249
    goto ldv_33448;
  } else {

  }
#line 3250
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 3251
    printk("<7>easycap::%i%s: MISTAKE: peasycap is NULL\n", peasycap->isdongle, "easycap_usb_probe");
#line 3253
    return (-14);
  } else {

  }
#line 3255
  if ((unsigned int )ep->wMaxPacketSize != 0U) {
#line 3256
    if (isokalt <= 7) {
#line 3257
      okalt[isokalt] = i;
#line 3258
      if (easycap_debug > 3) {
#line 3258
        printk("<7>easycap::%i%s: %i=okalt[%i]\n", peasycap->isdongle, "easycap_usb_probe",
               okalt[isokalt], isokalt);
      } else {

      }
#line 3262
      okepn[isokalt] = (int )ep->bEndpointAddress & 15;
#line 3266
      if (easycap_debug > 3) {
#line 3266
        printk("<7>easycap::%i%s: %i=okepn[%i]\n", peasycap->isdongle, "easycap_usb_probe",
               okepn[isokalt], isokalt);
      } else {

      }
#line 3270
      okmps[isokalt] = (int )ep->wMaxPacketSize;
#line 3273
      if (easycap_debug > 3) {
#line 3273
        printk("<7>easycap::%i%s: %i=okmps[%i]\n", peasycap->isdongle, "easycap_usb_probe",
               okmps[isokalt], isokalt);
      } else {

      }
#line 3277
      isokalt = isokalt + 1;
    } else {

    }
  } else
#line 3280
  if (peasycap->audio_altsetting_off == -1) {
#line 3282
    peasycap->audio_altsetting_off = i;
#line 3285
    if (easycap_debug > 3) {
#line 3285
      printk("<7>easycap::%i%s: %i=audio_altsetting_off <====\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->audio_altsetting_off);
    } else {

    }
  } else {
#line 3291
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->audio_altsetting_off already set\n",
           peasycap->isdongle, "easycap_usb_probe");
#line 3294
    printk("<7>easycap::%i%s: ...... continuing with %i=peasycap->audio_altsetting_off\n",
           peasycap->isdongle, "easycap_usb_probe", peasycap->audio_altsetting_off);
  }
#line 3303
  goto ldv_33448;
  default: ;
#line 3306
  goto ldv_33448;
  }
  ldv_33448: ;
#line 3308
  if ((unsigned int )ep->wMaxPacketSize == 0U) {
#line 3309
    if (easycap_debug > 3) {
#line 3309
      printk("<7>easycap::%i%s: intf[%i]alt[%i]end[%i] has zero packet size\n", peasycap->isdongle,
             "easycap_usb_probe", (int )bInterfaceNumber, i, j);
    } else {

    }
  } else {

  }
  ldv_33445: 
#line 3176
  j = j + 1;
  ldv_33452: ;
#line 3176
  if ((int )interface->bNumEndpoints > j) {
#line 3178
    goto ldv_33451;
  } else {

  }
#line 3160
  i = i + 1;
  ldv_33455: ;
#line 3160
  if ((unsigned int )i < intf->num_altsetting) {
#line 3162
    goto ldv_33454;
  } else {

  }

#line 3320
  if (easycap_debug > 3) {
#line 3320
    printk("<7>easycap::%i%s: initialization begins for interface %i\n", peasycap->isdongle,
           "easycap_usb_probe", (int )interface->bInterfaceNumber);
  } else {

  }
#line 3322
  switch ((int )bInterfaceNumber) {
  case 0: ;
#line 3329
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 3330
    printk("<7>easycap::%i%s: MISTAKE: peasycap is NULL\n", peasycap->isdongle, "easycap_usb_probe");
#line 3331
    return (-14);
  } else {

  }
#line 3333
  if (isokalt == 0) {
#line 3334
    printk("<7>easycap::%i%s: OLD_ERROR:  no viable video_altsetting_on\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3335
    return (-2);
  } else {

  }
#line 3337
  peasycap->video_altsetting_on = okalt[isokalt + -1];
#line 3338
  if (easycap_debug > 3) {
#line 3338
    printk("<7>easycap::%i%s: %i=video_altsetting_on <====\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->video_altsetting_on);
  } else {

  }
#line 3345
  peasycap->video_endpointnumber = okepn[isokalt + -1];
#line 3346
  if (easycap_debug > 3) {
#line 3346
    printk("<7>easycap::%i%s: %i=video_endpointnumber\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->video_endpointnumber);
  } else {

  }
#line 3347
  maxpacketsize = okmps[isokalt + -1];
#line 3350
  _min1 = maxpacketsize;
#line 3350
  _min2 = 3072;
#line 3350
  peasycap->video_isoc_maxframesize = _min1 < _min2 ? _min1 : _min2;
#line 3351
  if (peasycap->video_isoc_maxframesize <= 0) {
#line 3352
    printk("<7>easycap::%i%s: OLD_ERROR:  bad video_isoc_maxframesize\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3353
    printk("<7>easycap::%i%s:         possibly because port is USB 1.1\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3354
    return (-2);
  } else {

  }
#line 3356
  if (easycap_debug > 3) {
#line 3356
    printk("<7>easycap::%i%s: %i=video_isoc_maxframesize\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->video_isoc_maxframesize);
  } else {

  }
#line 3359
  peasycap->video_isoc_framesperdesc = 8;
#line 3360
  if (easycap_debug > 3) {
#line 3360
    printk("<7>easycap::%i%s: %i=video_isoc_framesperdesc\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->video_isoc_framesperdesc);
  } else {

  }
#line 3362
  if (peasycap->video_isoc_framesperdesc <= 0) {
#line 3363
    printk("<7>easycap::%i%s: OLD_ERROR:  bad video_isoc_framesperdesc\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3364
    return (-2);
  } else {

  }
#line 3366
  peasycap->video_isoc_buffer_size = peasycap->video_isoc_maxframesize * peasycap->video_isoc_framesperdesc;
#line 3369
  if (easycap_debug > 3) {
#line 3369
    printk("<7>easycap::%i%s: %i=video_isoc_buffer_size\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->video_isoc_buffer_size);
  } else {

  }
#line 3371
  if ((unsigned int )peasycap->video_isoc_buffer_size > 32768U) {
#line 3373
    printk("<7>easycap::%i%s: MISTAKE: peasycap->video_isoc_buffer_size too big\n",
           peasycap->isdongle, "easycap_usb_probe");
#line 3374
    return (-14);
  } else {

  }
#line 3377
  if (peasycap->video_interface == -1) {
#line 3378
    printk("<7>easycap::%i%s: MISTAKE:  video_interface is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3379
    return (-14);
  } else {

  }
#line 3381
  if (peasycap->video_altsetting_on == -1) {
#line 3382
    printk("<7>easycap::%i%s: MISTAKE:  video_altsetting_on is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3383
    return (-14);
  } else {

  }
#line 3385
  if (peasycap->video_altsetting_off == -1) {
#line 3386
    printk("<7>easycap::%i%s: MISTAKE:  video_interface_off is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3387
    return (-14);
  } else {

  }
#line 3389
  if (peasycap->video_endpointnumber == -1) {
#line 3390
    printk("<7>easycap::%i%s: MISTAKE:  video_endpointnumber is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3391
    return (-14);
  } else {

  }
#line 3393
  if (peasycap->video_isoc_maxframesize == -1) {
#line 3394
    printk("<7>easycap::%i%s: MISTAKE:  video_isoc_maxframesize is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3395
    return (-14);
  } else {

  }
#line 3397
  if (peasycap->video_isoc_buffer_size == -1) {
#line 3398
    printk("<7>easycap::%i%s: MISTAKE:  video_isoc_buffer_size is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3399
    return (-14);
  } else {

  }
#line 3406
  INIT_LIST_HEAD(& peasycap->urb_video_head);
#line 3407
  peasycap->purb_video_head = & peasycap->urb_video_head;
#line 3409
  if (easycap_debug > 3) {
#line 3409
    printk("<7>easycap::%i%s: allocating %i frame buffers of size %li\n", peasycap->isdongle,
           "easycap_usb_probe", 6, 1658880L);
  } else {

  }
#line 3411
  if (easycap_debug > 3) {
#line 3411
    printk("<7>easycap::%i%s: .... each scattered over %li pages\n", peasycap->isdongle,
           "easycap_usb_probe", 405UL);
  } else {

  }
#line 3414
  k = 0;
#line 3414
  goto ldv_33465;
  ldv_33464: 
#line 3415
  m = 0;
#line 3415
  goto ldv_33462;
  ldv_33461: ;
#line 3416
  if ((unsigned long )peasycap->frame_buffer[k][m].pgo != (unsigned long )((void *)0)) {
#line 3417
    printk("<7>easycap::%i%s: attempting to reallocate frame  buffers\n", peasycap->isdongle,
           "easycap_usb_probe");
  } else {
#line 3420
    tmp___5 = __get_free_pages(208U, 0U);
#line 3420
    pbuf = (void *)tmp___5;
#line 3421
    if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 3422
      printk("<7>easycap::%i%s: OLD_ERROR: Could not allocate frame buffer %i page %i\n",
             peasycap->isdongle, "easycap_usb_probe", k, m);
#line 3424
      return (-12);
    } else {

    }
#line 3427
    peasycap->allocation_video_page = peasycap->allocation_video_page + 1;
#line 3428
    peasycap->frame_buffer[k][m].pgo = pbuf;
  }
#line 3430
  peasycap->frame_buffer[k][m].pto = peasycap->frame_buffer[k][m].pgo;
#line 3415
  m = m + 1;
  ldv_33462: ;
#line 3415
  if ((unsigned int )m <= 404U) {
#line 3417
    goto ldv_33461;
  } else {

  }
#line 3414
  k = k + 1;
  ldv_33465: ;
#line 3414
  if (k <= 5) {
#line 3416
    goto ldv_33464;
  } else {

  }
#line 3435
  peasycap->frame_fill = 0;
#line 3436
  peasycap->frame_read = 0;
#line 3437
  if (easycap_debug > 3) {
#line 3437
    printk("<7>easycap::%i%s: allocation of frame buffers done:  %i pages\n", peasycap->isdongle,
           "easycap_usb_probe", k * m);
  } else {

  }
#line 3440
  if (easycap_debug > 3) {
#line 3440
    printk("<7>easycap::%i%s: allocating %i field buffers of size %li\n", peasycap->isdongle,
           "easycap_usb_probe", 4, 831488L);
  } else {

  }
#line 3442
  if (easycap_debug > 3) {
#line 3442
    printk("<7>easycap::%i%s: .... each scattered over %li pages\n", peasycap->isdongle,
           "easycap_usb_probe", 203UL);
  } else {

  }
#line 3445
  k = 0;
#line 3445
  goto ldv_33471;
  ldv_33470: 
#line 3446
  m = 0;
#line 3446
  goto ldv_33468;
  ldv_33467: ;
#line 3447
  if ((unsigned long )peasycap->field_buffer[k][m].pgo != (unsigned long )((void *)0)) {
#line 3448
    printk("<7>easycap::%i%s: OLD_ERROR: attempting to reallocate field buffers\n", peasycap->isdongle,
           "easycap_usb_probe");
  } else {
#line 3451
    tmp___6 = __get_free_pages(208U, 0U);
#line 3451
    pbuf = (void *)tmp___6;
#line 3452
    if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 3453
      printk("<7>easycap::%i%s: OLD_ERROR: Could not allocate field buffer %i page %i\n",
             peasycap->isdongle, "easycap_usb_probe", k, m);
#line 3455
      return (-12);
    } else {

    }
#line 3458
    peasycap->allocation_video_page = peasycap->allocation_video_page + 1;
#line 3459
    peasycap->field_buffer[k][m].pgo = pbuf;
  }
#line 3461
  peasycap->field_buffer[k][m].pto = peasycap->field_buffer[k][m].pgo;
#line 3446
  m = m + 1;
  ldv_33468: ;
#line 3446
  if ((unsigned int )m <= 202U) {
#line 3448
    goto ldv_33467;
  } else {

  }
#line 3464
  peasycap->field_buffer[k][0].kount = 512U;
#line 3445
  k = k + 1;
  ldv_33471: ;
#line 3445
  if (k <= 3) {
#line 3447
    goto ldv_33470;
  } else {

  }
#line 3466
  peasycap->field_fill = 0;
#line 3467
  peasycap->field_page = 0;
#line 3468
  peasycap->field_read = 0;
#line 3469
  if (easycap_debug > 3) {
#line 3469
    printk("<7>easycap::%i%s: allocation of field buffers done:  %i pages\n", peasycap->isdongle,
           "easycap_usb_probe", k * m);
  } else {

  }
#line 3472
  if (easycap_debug > 3) {
#line 3472
    printk("<7>easycap::%i%s: allocating %i isoc video buffers of size %i\n", peasycap->isdongle,
           "easycap_usb_probe", 16, peasycap->video_isoc_buffer_size);
  } else {

  }
#line 3475
  if (easycap_debug > 3) {
#line 3475
    printk("<7>easycap::%i%s: .... each occupying contiguous memory pages\n", peasycap->isdongle,
           "easycap_usb_probe");
  } else {

  }
#line 3477
  k = 0;
#line 3477
  goto ldv_33474;
  ldv_33473: 
#line 3478
  tmp___7 = __get_free_pages(208U, 3U);
#line 3478
  pbuf = (void *)tmp___7;
#line 3480
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 3481
    printk("<7>easycap::%i%s: OLD_ERROR: Could not allocate isoc video buffer %i\n", peasycap->isdongle,
           "easycap_usb_probe", k);
#line 3483
    return (-12);
  } else {

  }
#line 3485
  peasycap->allocation_video_page = (int )((unsigned int )peasycap->allocation_video_page + 8U);
#line 3488
  peasycap->video_isoc_buffer[k].pgo = pbuf;
#line 3489
  peasycap->video_isoc_buffer[k].pto = pbuf + (unsigned long )peasycap->video_isoc_buffer_size;
#line 3491
  peasycap->video_isoc_buffer[k].kount = (u16 )k;
#line 3477
  k = k + 1;
  ldv_33474: ;
#line 3477
  if (k <= 15) {
#line 3479
    goto ldv_33473;
  } else {

  }

#line 3493
  if (easycap_debug > 3) {
#line 3493
    printk("<7>easycap::%i%s: allocation of isoc video buffers done: %i pages\n",
           peasycap->isdongle, "easycap_usb_probe", k * 8);
  } else {

  }
#line 3500
  if (easycap_debug > 3) {
#line 3500
    printk("<7>easycap::%i%s: allocating %i struct urb.\n", peasycap->isdongle, "easycap_usb_probe",
           16);
  } else {

  }
#line 3501
  if (easycap_debug > 3) {
#line 3501
    printk("<7>easycap::%i%s: using %i=peasycap->video_isoc_framesperdesc\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->video_isoc_framesperdesc);
  } else {

  }
#line 3503
  if (easycap_debug > 3) {
#line 3503
    printk("<7>easycap::%i%s: using %i=peasycap->video_isoc_maxframesize\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->video_isoc_maxframesize);
  } else {

  }
#line 3505
  if (easycap_debug > 3) {
#line 3505
    printk("<7>easycap::%i%s: using %i=peasycap->video_isoc_buffer_sizen", peasycap->isdongle,
           "easycap_usb_probe", peasycap->video_isoc_buffer_size);
  } else {

  }
#line 3508
  k = 0;
#line 3508
  goto ldv_33480;
  ldv_33479: 
#line 3509
  purb = ldv_usb_alloc_urb_7(peasycap->video_isoc_framesperdesc, 208U);
#line 3511
  if ((unsigned long )purb == (unsigned long )((struct urb *)0)) {
#line 3512
    printk("<7>easycap::%i%s: OLD_ERROR: usb_alloc_urb returned NULL for buffer %i\n",
           peasycap->isdongle, "easycap_usb_probe", k);
#line 3514
    return (-12);
  } else {

  }
#line 3517
  peasycap->allocation_video_urb = peasycap->allocation_video_urb + 1;
#line 3519
  tmp___8 = kzalloc(32UL, 208U);
#line 3519
  pdata_urb = (struct data_urb *)tmp___8;
#line 3520
  if ((unsigned long )pdata_urb == (unsigned long )((struct data_urb *)0)) {
#line 3521
    printk("<7>easycap::%i%s: OLD_ERROR: Could not allocate struct data_urb.\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3522
    return (-12);
  } else {

  }
#line 3525
  peasycap->allocation_video_struct = (int )((unsigned int )peasycap->allocation_video_struct + 32U);
#line 3528
  pdata_urb->purb = purb;
#line 3529
  pdata_urb->isbuf = k;
#line 3530
  pdata_urb->length = 0;
#line 3531
  list_add_tail(& pdata_urb->list_head, peasycap->purb_video_head);
#line 3538
  if (k == 0) {
#line 3539
    if (easycap_debug > 3) {
#line 3539
      printk("<7>easycap::%i%s: initializing video urbs thus:\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3540
    if (easycap_debug > 3) {
#line 3540
      printk("<7>easycap::%i%s:   purb->interval = 1;\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3541
    if (easycap_debug > 3) {
#line 3541
      printk("<7>easycap::%i%s:   purb->dev = peasycap->pusb_device;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3542
    if (easycap_debug > 3) {
#line 3542
      printk("<7>easycap::%i%s:   purb->pipe = usb_rcvisocpipe(peasycap->pusb_device,%i);\n",
             peasycap->isdongle, "easycap_usb_probe", peasycap->video_endpointnumber);
    } else {

    }
#line 3545
    if (easycap_debug > 3) {
#line 3545
      printk("<7>easycap::%i%s:   purb->transfer_flags = URB_ISO_ASAP;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3546
    if (easycap_debug > 3) {
#line 3546
      printk("<7>easycap::%i%s:   purb->transfer_buffer = peasycap->video_isoc_buffer[.].pgo;\n",
             peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3548
    if (easycap_debug > 3) {
#line 3548
      printk("<7>easycap::%i%s:   purb->transfer_buffer_length = %i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->video_isoc_buffer_size);
    } else {

    }
#line 3550
    if (easycap_debug > 3) {
#line 3550
      printk("<7>easycap::%i%s:   purb->complete = easycap_complete;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3551
    if (easycap_debug > 3) {
#line 3551
      printk("<7>easycap::%i%s:   purb->context = peasycap;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3552
    if (easycap_debug > 3) {
#line 3552
      printk("<7>easycap::%i%s:   purb->start_frame = 0;\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3553
    if (easycap_debug > 3) {
#line 3553
      printk("<7>easycap::%i%s:   purb->number_of_packets = %i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->video_isoc_framesperdesc);
    } else {

    }
#line 3555
    if (easycap_debug > 3) {
#line 3555
      printk("<7>easycap::%i%s:   for (j = 0; j < %i; j++)\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->video_isoc_framesperdesc);
    } else {

    }
#line 3557
    if (easycap_debug > 3) {
#line 3557
      printk("<7>easycap::%i%s:     {\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3558
    if (easycap_debug > 3) {
#line 3558
      printk("<7>easycap::%i%s:     purb->iso_frame_desc[j].offset = j*%i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->video_isoc_maxframesize);
    } else {

    }
#line 3560
    if (easycap_debug > 3) {
#line 3560
      printk("<7>easycap::%i%s:     purb->iso_frame_desc[j].length = %i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->video_isoc_maxframesize);
    } else {

    }
#line 3562
    if (easycap_debug > 3) {
#line 3562
      printk("<7>easycap::%i%s:     }\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
  } else {

  }
#line 3565
  purb->interval = 1;
#line 3566
  purb->dev = peasycap->pusb_device;
#line 3567
  tmp___9 = __create_pipe(peasycap->pusb_device, (unsigned int )peasycap->video_endpointnumber);
#line 3567
  purb->pipe = tmp___9 | 128U;
#line 3569
  purb->transfer_flags = 2U;
#line 3570
  purb->transfer_buffer = peasycap->video_isoc_buffer[k].pgo;
#line 3571
  purb->transfer_buffer_length = (u32 )peasycap->video_isoc_buffer_size;
#line 3573
  purb->complete = & easycap_complete;
#line 3574
  purb->context = (void *)peasycap;
#line 3575
  purb->start_frame = 0;
#line 3576
  purb->number_of_packets = peasycap->video_isoc_framesperdesc;
#line 3577
  j = 0;
#line 3577
  goto ldv_33477;
  ldv_33476: 
#line 3578
  purb->iso_frame_desc[j].offset = (unsigned int )(peasycap->video_isoc_maxframesize * j);
#line 3580
  purb->iso_frame_desc[j].length = (unsigned int )peasycap->video_isoc_maxframesize;
#line 3577
  j = j + 1;
  ldv_33477: ;
#line 3577
  if (peasycap->video_isoc_framesperdesc > j) {
#line 3579
    goto ldv_33476;
  } else {

  }
#line 3508
  k = k + 1;
  ldv_33480: ;
#line 3508
  if (k <= 15) {
#line 3510
    goto ldv_33479;
  } else {

  }

#line 3584
  if (easycap_debug > 3) {
#line 3584
    printk("<7>easycap::%i%s: allocation of %i struct urb done.\n", peasycap->isdongle,
           "easycap_usb_probe", k);
  } else {

  }
#line 3590
  ldv_usb_set_intfdata_8(intf, (void *)peasycap);
#line 3599
  peasycap->ntsc = easycap_ntsc;
#line 3600
  if (easycap_debug > 7) {
#line 3600
    printk("<7>easycap::%i%s: defaulting initially to %s\n", peasycap->isdongle, "easycap_usb_probe",
           (int )easycap_ntsc ? (char *)"NTSC" : (char *)"PAL");
  } else {

  }
#line 3602
  rc = reset(peasycap);
#line 3603
  if (rc != 0) {
#line 3604
    printk("<7>easycap::%i%s: OLD_ERROR: reset() rc = %i\n", peasycap->isdongle, "easycap_usb_probe",
           rc);
#line 3605
    return (-14);
  } else {

  }
#line 3612
  tmp___10 = v4l2_device_register(& intf->dev, & peasycap->v4l2_device);
#line 3612
  if (tmp___10 != 0) {
#line 3613
    printk("<7>easycap::%i%s: v4l2_device_register() failed\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3614
    return (-19);
  } else {

  }
#line 3616
  if (easycap_debug > 3) {
#line 3616
    printk("<7>easycap::%i%s: registered device instance: %s\n", peasycap->isdongle,
           "easycap_usb_probe", (char *)(& peasycap->v4l2_device.name));
  } else {

  }
#line 3626
  peasycap->video_device.v4l2_dev = (struct v4l2_device *)0;
#line 3630
  strcpy((char *)(& peasycap->video_device.name), "easycapdc60");
#line 3631
  peasycap->video_device.fops = & v4l2_fops;
#line 3632
  peasycap->video_device.minor = -1;
#line 3633
  peasycap->video_device.release = (void (*)(struct video_device * ))(& videodev_release);
#line 3635
  video_set_drvdata(& peasycap->video_device, (void *)peasycap);
#line 3637
  tmp___11 = video_register_device(& peasycap->video_device, 0, -1);
#line 3637
  if (tmp___11 != 0) {
#line 3639
    printk("<3>easycap: Not able to register with videodev\n");
#line 3640
    videodev_release(& peasycap->video_device);
#line 3641
    return (-19);
  } else {

  }
#line 3644
  peasycap->registered_video = peasycap->registered_video + 1;
#line 3645
  printk("<7>easycap::%i%s: registered with videodev: %i=minor\n", peasycap->isdongle,
         "easycap_usb_probe", peasycap->video_device.minor);
#line 3647
  peasycap->minor = peasycap->video_device.minor;
#line 3649
  goto ldv_33482;
  case 1: ;
#line 3658
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 3659
    printk("<7>easycap::%i%s: MISTAKE: peasycap is NULL\n", peasycap->isdongle, "easycap_usb_probe");
#line 3660
    return (-14);
  } else {

  }
#line 3667
  ldv_usb_set_intfdata_8(intf, (void *)peasycap);
#line 3668
  if (easycap_debug > 3) {
#line 3668
    printk("<7>easycap::%i%s: no initialization required for interface %i\n", peasycap->isdongle,
           "easycap_usb_probe", (int )interface->bInterfaceNumber);
  } else {

  }
#line 3670
  goto ldv_33482;
  case 2: ;
#line 3674
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 3675
    printk("<7>easycap::%i%s: MISTAKE: peasycap is NULL\n", peasycap->isdongle, "easycap_usb_probe");
#line 3676
    return (-14);
  } else {

  }
#line 3678
  if (isokalt == 0) {
#line 3679
    printk("<7>easycap::%i%s: OLD_ERROR:  no viable audio_altsetting_on\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3680
    return (-2);
  } else {

  }
#line 3682
  peasycap->audio_altsetting_on = okalt[isokalt + -1];
#line 3683
  if (easycap_debug > 3) {
#line 3683
    printk("<7>easycap::%i%s: %i=audio_altsetting_on <====\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->audio_altsetting_on);
  } else {

  }
#line 3686
  peasycap->audio_endpointnumber = okepn[isokalt + -1];
#line 3687
  if (easycap_debug > 3) {
#line 3687
    printk("<7>easycap::%i%s: %i=audio_endpointnumber\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->audio_endpointnumber);
  } else {

  }
#line 3689
  peasycap->audio_isoc_maxframesize = okmps[isokalt + -1];
#line 3690
  if (easycap_debug > 3) {
#line 3690
    printk("<7>easycap::%i%s: %i=audio_isoc_maxframesize\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->audio_isoc_maxframesize);
  } else {

  }
#line 3692
  if (peasycap->audio_isoc_maxframesize <= 0) {
#line 3693
    printk("<7>easycap::%i%s: OLD_ERROR:  bad audio_isoc_maxframesize\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3694
    return (-2);
  } else {

  }
#line 3696
  if (peasycap->audio_isoc_maxframesize == 9) {
#line 3697
    peasycap->ilk = peasycap->ilk | 2;
#line 3698
    printk("<7>easycap::%i%s: audio hardware is microphone\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3699
    peasycap->microphone = 1;
#line 3700
    peasycap->audio_pages_per_fragment = 4U;
  } else
#line 3702
  if (peasycap->audio_isoc_maxframesize == 256) {
#line 3703
    peasycap->ilk = peasycap->ilk & -3;
#line 3704
    printk("<7>easycap::%i%s: audio hardware is AC\'97\n", peasycap->isdongle, "easycap_usb_probe");
#line 3705
    peasycap->microphone = 0;
#line 3706
    peasycap->audio_pages_per_fragment = 4U;
  } else {
#line 3709
    printk("<7>easycap::%i%s: hardware is unidentified:\n", peasycap->isdongle, "easycap_usb_probe");
#line 3710
    printk("<7>easycap::%i%s: %i=audio_isoc_maxframesize\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->audio_isoc_maxframesize);
#line 3712
    return (-2);
  }
#line 3715
  peasycap->audio_bytes_per_fragment = peasycap->audio_pages_per_fragment * 4096U;
#line 3717
  peasycap->audio_buffer_page_many = peasycap->audio_pages_per_fragment * 32U;
#line 3720
  if (easycap_debug > 3) {
#line 3720
    printk("<7>easycap::%i%s: %6i=AUDIO_FRAGMENT_MANY\n", peasycap->isdongle, "easycap_usb_probe",
           32);
  } else {

  }
#line 3721
  if (easycap_debug > 3) {
#line 3721
    printk("<7>easycap::%i%s: %6i=audio_pages_per_fragment\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->audio_pages_per_fragment);
  } else {

  }
#line 3723
  if (easycap_debug > 3) {
#line 3723
    printk("<7>easycap::%i%s: %6i=audio_bytes_per_fragment\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->audio_bytes_per_fragment);
  } else {

  }
#line 3725
  if (easycap_debug > 3) {
#line 3725
    printk("<7>easycap::%i%s: %6i=audio_buffer_page_many\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->audio_buffer_page_many);
  } else {

  }
#line 3728
  peasycap->audio_isoc_framesperdesc = 32;
#line 3730
  if (easycap_debug > 3) {
#line 3730
    printk("<7>easycap::%i%s: %i=audio_isoc_framesperdesc\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->audio_isoc_framesperdesc);
  } else {

  }
#line 3732
  if (peasycap->audio_isoc_framesperdesc <= 0) {
#line 3733
    printk("<7>easycap::%i%s: OLD_ERROR:  bad audio_isoc_framesperdesc\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3734
    return (-2);
  } else {

  }
#line 3737
  peasycap->audio_isoc_buffer_size = peasycap->audio_isoc_maxframesize * peasycap->audio_isoc_framesperdesc;
#line 3740
  if (easycap_debug > 3) {
#line 3740
    printk("<7>easycap::%i%s: %i=audio_isoc_buffer_size\n", peasycap->isdongle, "easycap_usb_probe",
           peasycap->audio_isoc_buffer_size);
  } else {

  }
#line 3742
  if ((unsigned int )peasycap->audio_isoc_buffer_size > 8192U) {
#line 3743
    printk("<7>easycap::%i%s: MISTAKE:  audio_isoc_buffer_size bigger than %li=AUDIO_ISOC_BUFFER_SIZE\n",
           peasycap->isdongle, "easycap_usb_probe", 8192UL);
#line 3746
    return (-14);
  } else {

  }
#line 3748
  if (peasycap->audio_interface == -1) {
#line 3749
    printk("<7>easycap::%i%s: MISTAKE:  audio_interface is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3750
    return (-14);
  } else {

  }
#line 3752
  if (peasycap->audio_altsetting_on == -1) {
#line 3753
    printk("<7>easycap::%i%s: MISTAKE:  audio_altsetting_on is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3754
    return (-14);
  } else {

  }
#line 3756
  if (peasycap->audio_altsetting_off == -1) {
#line 3757
    printk("<7>easycap::%i%s: MISTAKE:  audio_interface_off is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3758
    return (-14);
  } else {

  }
#line 3760
  if (peasycap->audio_endpointnumber == -1) {
#line 3761
    printk("<7>easycap::%i%s: MISTAKE:  audio_endpointnumber is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3762
    return (-14);
  } else {

  }
#line 3764
  if (peasycap->audio_isoc_maxframesize == -1) {
#line 3765
    printk("<7>easycap::%i%s: MISTAKE:  audio_isoc_maxframesize is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3766
    return (-14);
  } else {

  }
#line 3768
  if (peasycap->audio_isoc_buffer_size == -1) {
#line 3769
    printk("<7>easycap::%i%s: MISTAKE:  audio_isoc_buffer_size is unset\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3770
    return (-14);
  } else {

  }
#line 3777
  INIT_LIST_HEAD(& peasycap->urb_audio_head);
#line 3778
  peasycap->purb_audio_head = & peasycap->urb_audio_head;
#line 3781
  if (easycap_debug > 3) {
#line 3781
    printk("<7>easycap::%i%s: allocating %i isoc audio buffers of size %i\n", peasycap->isdongle,
           "easycap_usb_probe", 16, peasycap->audio_isoc_buffer_size);
  } else {

  }
#line 3784
  if (easycap_debug > 3) {
#line 3784
    printk("<7>easycap::%i%s: .... each occupying contiguous memory pages\n", peasycap->isdongle,
           "easycap_usb_probe");
  } else {

  }
#line 3786
  k = 0;
#line 3786
  goto ldv_33486;
  ldv_33485: 
#line 3787
  tmp___12 = __get_free_pages(208U, 1U);
#line 3787
  pbuf = (void *)tmp___12;
#line 3789
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 3790
    printk("<7>easycap::%i%s: OLD_ERROR: Could not allocate isoc audio buffer %i\n", peasycap->isdongle,
           "easycap_usb_probe", k);
#line 3792
    return (-12);
  } else {

  }
#line 3794
  peasycap->allocation_audio_page = (int )((unsigned int )peasycap->allocation_audio_page + 2U);
#line 3797
  peasycap->audio_isoc_buffer[k].pgo = pbuf;
#line 3798
  peasycap->audio_isoc_buffer[k].pto = pbuf + (unsigned long )peasycap->audio_isoc_buffer_size;
#line 3800
  peasycap->audio_isoc_buffer[k].kount = (u16 )k;
#line 3786
  k = k + 1;
  ldv_33486: ;
#line 3786
  if (k <= 15) {
#line 3788
    goto ldv_33485;
  } else {

  }

#line 3802
  if (easycap_debug > 3) {
#line 3802
    printk("<7>easycap::%i%s: allocation of isoc audio buffers done.\n", peasycap->isdongle,
           "easycap_usb_probe");
  } else {

  }
#line 3808
  if (easycap_debug > 3) {
#line 3808
    printk("<7>easycap::%i%s: allocating %i struct urb.\n", peasycap->isdongle, "easycap_usb_probe",
           16);
  } else {

  }
#line 3809
  if (easycap_debug > 3) {
#line 3809
    printk("<7>easycap::%i%s: using %i=peasycap->audio_isoc_framesperdesc\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->audio_isoc_framesperdesc);
  } else {

  }
#line 3811
  if (easycap_debug > 3) {
#line 3811
    printk("<7>easycap::%i%s: using %i=peasycap->audio_isoc_maxframesize\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->audio_isoc_maxframesize);
  } else {

  }
#line 3813
  if (easycap_debug > 3) {
#line 3813
    printk("<7>easycap::%i%s: using %i=peasycap->audio_isoc_buffer_size\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->audio_isoc_buffer_size);
  } else {

  }
#line 3816
  k = 0;
#line 3816
  goto ldv_33492;
  ldv_33491: 
#line 3817
  purb = ldv_usb_alloc_urb_10(peasycap->audio_isoc_framesperdesc, 208U);
#line 3819
  if ((unsigned long )purb == (unsigned long )((struct urb *)0)) {
#line 3820
    printk("<7>easycap::%i%s: OLD_ERROR: usb_alloc_urb returned NULL for buffer %i\n",
           peasycap->isdongle, "easycap_usb_probe", k);
#line 3822
    return (-12);
  } else {

  }
#line 3824
  peasycap->allocation_audio_urb = peasycap->allocation_audio_urb + 1;
#line 3826
  tmp___13 = kzalloc(32UL, 208U);
#line 3826
  pdata_urb = (struct data_urb *)tmp___13;
#line 3827
  if ((unsigned long )pdata_urb == (unsigned long )((struct data_urb *)0)) {
#line 3828
    printk("<7>easycap::%i%s: OLD_ERROR: Could not allocate struct data_urb.\n", peasycap->isdongle,
           "easycap_usb_probe");
#line 3829
    return (-12);
  } else {

  }
#line 3831
  peasycap->allocation_audio_struct = (int )((unsigned int )peasycap->allocation_audio_struct + 32U);
#line 3834
  pdata_urb->purb = purb;
#line 3835
  pdata_urb->isbuf = k;
#line 3836
  pdata_urb->length = 0;
#line 3837
  list_add_tail(& pdata_urb->list_head, peasycap->purb_audio_head);
#line 3844
  if (k == 0) {
#line 3845
    if (easycap_debug > 3) {
#line 3845
      printk("<7>easycap::%i%s: initializing audio urbs thus:\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3846
    if (easycap_debug > 3) {
#line 3846
      printk("<7>easycap::%i%s:   purb->interval = 1;\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3847
    if (easycap_debug > 3) {
#line 3847
      printk("<7>easycap::%i%s:   purb->dev = peasycap->pusb_device;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3848
    if (easycap_debug > 3) {
#line 3848
      printk("<7>easycap::%i%s:   purb->pipe = usb_rcvisocpipe(peasycap->pusb_device,%i);\n",
             peasycap->isdongle, "easycap_usb_probe", peasycap->audio_endpointnumber);
    } else {

    }
#line 3851
    if (easycap_debug > 3) {
#line 3851
      printk("<7>easycap::%i%s:   purb->transfer_flags = URB_ISO_ASAP;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3852
    if (easycap_debug > 3) {
#line 3852
      printk("<7>easycap::%i%s:   purb->transfer_buffer = peasycap->audio_isoc_buffer[.].pgo;\n",
             peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3854
    if (easycap_debug > 3) {
#line 3854
      printk("<7>easycap::%i%s:   purb->transfer_buffer_length = %i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->audio_isoc_buffer_size);
    } else {

    }
#line 3856
    if (easycap_debug > 3) {
#line 3856
      printk("<7>easycap::%i%s:   purb->complete = easycap_alsa_complete;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3857
    if (easycap_debug > 3) {
#line 3857
      printk("<7>easycap::%i%s:   purb->context = peasycap;\n", peasycap->isdongle,
             "easycap_usb_probe");
    } else {

    }
#line 3858
    if (easycap_debug > 3) {
#line 3858
      printk("<7>easycap::%i%s:   purb->start_frame = 0;\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3859
    if (easycap_debug > 3) {
#line 3859
      printk("<7>easycap::%i%s:   purb->number_of_packets = %i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->audio_isoc_framesperdesc);
    } else {

    }
#line 3861
    if (easycap_debug > 3) {
#line 3861
      printk("<7>easycap::%i%s:   for (j = 0; j < %i; j++)\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->audio_isoc_framesperdesc);
    } else {

    }
#line 3863
    if (easycap_debug > 3) {
#line 3863
      printk("<7>easycap::%i%s:     {\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
#line 3864
    if (easycap_debug > 3) {
#line 3864
      printk("<7>easycap::%i%s:     purb->iso_frame_desc[j].offset = j*%i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->audio_isoc_maxframesize);
    } else {

    }
#line 3866
    if (easycap_debug > 3) {
#line 3866
      printk("<7>easycap::%i%s:     purb->iso_frame_desc[j].length = %i;\n", peasycap->isdongle,
             "easycap_usb_probe", peasycap->audio_isoc_maxframesize);
    } else {

    }
#line 3868
    if (easycap_debug > 3) {
#line 3868
      printk("<7>easycap::%i%s:     }\n", peasycap->isdongle, "easycap_usb_probe");
    } else {

    }
  } else {

  }
#line 3871
  purb->interval = 1;
#line 3872
  purb->dev = peasycap->pusb_device;
#line 3873
  tmp___14 = __create_pipe(peasycap->pusb_device, (unsigned int )peasycap->audio_endpointnumber);
#line 3873
  purb->pipe = tmp___14 | 128U;
#line 3875
  purb->transfer_flags = 2U;
#line 3876
  purb->transfer_buffer = peasycap->audio_isoc_buffer[k].pgo;
#line 3877
  purb->transfer_buffer_length = (u32 )peasycap->audio_isoc_buffer_size;
#line 3879
  purb->complete = & easycap_alsa_complete;
#line 3880
  purb->context = (void *)peasycap;
#line 3881
  purb->start_frame = 0;
#line 3882
  purb->number_of_packets = peasycap->audio_isoc_framesperdesc;
#line 3883
  j = 0;
#line 3883
  goto ldv_33489;
  ldv_33488: 
#line 3884
  purb->iso_frame_desc[j].offset = (unsigned int )(peasycap->audio_isoc_maxframesize * j);
#line 3886
  purb->iso_frame_desc[j].length = (unsigned int )peasycap->audio_isoc_maxframesize;
#line 3883
  j = j + 1;
  ldv_33489: ;
#line 3883
  if (peasycap->audio_isoc_framesperdesc > j) {
#line 3885
    goto ldv_33488;
  } else {

  }
#line 3816
  k = k + 1;
  ldv_33492: ;
#line 3816
  if (k <= 15) {
#line 3818
    goto ldv_33491;
  } else {

  }

#line 3890
  if (easycap_debug > 3) {
#line 3890
    printk("<7>easycap::%i%s: allocation of %i struct urb done.\n", peasycap->isdongle,
           "easycap_usb_probe", k);
  } else {

  }
#line 3896
  ldv_usb_set_intfdata_8(intf, (void *)peasycap);
#line 3902
  if (easycap_debug > 3) {
#line 3902
    printk("<7>easycap::%i%s: initializing ALSA card\n", peasycap->isdongle, "easycap_usb_probe");
  } else {

  }
#line 3904
  rc = easycap_alsa_probe(peasycap);
#line 3905
  if (rc != 0) {
#line 3906
    printk("<3>easycap: easycap_alsa_probe() rc = %i\n\n", rc);
#line 3907
    return (-19);
  } else {

  }
#line 3911
  if (easycap_debug > 7) {
#line 3911
    printk("<7>easycap::%i%s: kref_get() with %i=kref.refcount.counter\n", peasycap->isdongle,
           "easycap_usb_probe", peasycap->kref.refcount.counter);
  } else {

  }
#line 3913
  kref_get(& peasycap->kref);
#line 3914
  peasycap->registered_audio = peasycap->registered_audio + 1;
#line 3915
  goto ldv_33482;
  default: ;
#line 3923
  if (easycap_debug > 3) {
#line 3923
    printk("<7>easycap::%i%s: OLD_ERROR: unexpected interface %i\n", peasycap->isdongle,
           "easycap_usb_probe", (int )bInterfaceNumber);
  } else {

  }
#line 3924
  return (-22);
  }
  ldv_33482: 
#line 3926
  printk("<7>easycap::%i%s: ends successfully for interface %i\n", peasycap->isdongle,
         "easycap_usb_probe", (int )bInterfaceNumber);
#line 3927
  return (0);
}
}
#line 3938 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static void easycap_usb_disconnect(struct usb_interface *pusb_interface ) 
{ 
  struct usb_host_interface *pusb_host_interface ;
  struct usb_interface_descriptor *pusb_interface_descriptor ;
  struct easycap *peasycap ;
  int minor ;
  int kd ;
  u8 bInterfaceNumber ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3946
  if (easycap_debug > 3) {
#line 3946
    printk("<7>easycap:: %s: \n", "easycap_usb_disconnect");
  } else {

  }
#line 3948
  pusb_host_interface = pusb_interface->cur_altsetting;
#line 3949
  if ((unsigned long )pusb_host_interface == (unsigned long )((struct usb_host_interface *)0)) {
#line 3950
    if (easycap_debug > 3) {
#line 3950
      printk("<7>easycap:: %s: OLD_ERROR: pusb_host_interface is NULL\n", "easycap_usb_disconnect");
    } else {

    }
#line 3951
    return;
  } else {

  }
#line 3953
  pusb_interface_descriptor = & pusb_host_interface->desc;
#line 3954
  if ((unsigned long )pusb_interface_descriptor == (unsigned long )((struct usb_interface_descriptor *)0)) {
#line 3955
    if (easycap_debug > 3) {
#line 3955
      printk("<7>easycap:: %s: OLD_ERROR: pusb_interface_descriptor is NULL\n", "easycap_usb_disconnect");
    } else {

    }
#line 3956
    return;
  } else {

  }
#line 3958
  bInterfaceNumber = pusb_interface_descriptor->bInterfaceNumber;
#line 3959
  minor = pusb_interface->minor;
#line 3960
  if (easycap_debug > 3) {
#line 3960
    printk("<7>easycap:: %s: intf[%i]: minor=%i\n", "easycap_usb_disconnect", (int )bInterfaceNumber,
           minor);
  } else {

  }
#line 3962
  if ((unsigned int )bInterfaceNumber == 1U) {
#line 3963
    return;
  } else {

  }
#line 3965
  tmp = ldv_usb_get_intfdata_12(pusb_interface);
#line 3965
  peasycap = (struct easycap *)tmp;
#line 3966
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 3967
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_usb_disconnect");
#line 3968
    return;
  } else {

  }
#line 3975
  peasycap->video_eof = 1;
#line 3976
  peasycap->audio_eof = 1;
#line 3977
  __wake_up(& peasycap->wq_video, 1U, 1, (void *)0);
#line 3978
  __wake_up(& peasycap->wq_audio, 1U, 1, (void *)0);
#line 3980
  switch ((int )bInterfaceNumber) {
  case 0: 
#line 3982
  easycap_video_kill_urbs(peasycap);
#line 3983
  goto ldv_33506;
  case 2: 
#line 3985
  easycap_audio_kill_urbs(peasycap);
#line 3986
  goto ldv_33506;
  default: ;
#line 3988
  goto ldv_33506;
  }
  ldv_33506: 
#line 3999
  kd = easycap_isdongle(peasycap);
#line 4000
  switch ((int )bInterfaceNumber) {
  case 0: ;
#line 4002
  if (kd >= 0 && kd <= 7) {
#line 4003
    __wake_up(& peasycap->wq_video, 1U, 1, (void *)0);
#line 4004
    if (easycap_debug > 3) {
#line 4004
      printk("<7>easycap::%i%s: about to lock dongle[%i].mutex_video\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
#line 4005
    tmp___0 = mutex_lock_interruptible_nested(& easycapdc60_dongle[kd].mutex_video,
                                              0U);
#line 4005
    if (tmp___0 != 0) {
#line 4007
      printk("<7>easycap:: %s: OLD_ERROR: cannot lock dongle[%i].mutex_video\n", "easycap_usb_disconnect",
             kd);
#line 4009
      return;
    } else {

    }
#line 4011
    if (easycap_debug > 3) {
#line 4011
      printk("<7>easycap::%i%s: locked dongle[%i].mutex_video\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
  } else {
#line 4013
    printk("<7>easycap:: %s: OLD_ERROR: %i=kd is bad: cannot lock dongle\n", "easycap_usb_disconnect",
           kd);
  }
#line 4016
  if ((int )((signed char )peasycap->v4l2_device.name[0]) == 0) {
#line 4017
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->v4l2_device.name is empty\n", peasycap->isdongle,
           "easycap_usb_disconnect");
#line 4018
    if (kd >= 0 && kd <= 7) {
#line 4019
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
    } else {

    }
#line 4020
    return;
  } else {

  }
#line 4022
  v4l2_device_disconnect(& peasycap->v4l2_device);
#line 4023
  if (easycap_debug > 3) {
#line 4023
    printk("<7>easycap::%i%s: v4l2_device_disconnect() OK\n", peasycap->isdongle,
           "easycap_usb_disconnect");
  } else {

  }
#line 4024
  v4l2_device_unregister(& peasycap->v4l2_device);
#line 4025
  if (easycap_debug > 3) {
#line 4025
    printk("<7>easycap::%i%s: v4l2_device_unregister() OK\n", peasycap->isdongle,
           "easycap_usb_disconnect");
  } else {

  }
#line 4027
  video_unregister_device(& peasycap->video_device);
#line 4028
  if (easycap_debug > 3) {
#line 4028
    printk("<7>easycap::%i%s: intf[%i]: video_unregister_device() minor=%i\n", peasycap->isdongle,
           "easycap_usb_disconnect", (int )bInterfaceNumber, minor);
  } else {

  }
#line 4030
  peasycap->registered_video = peasycap->registered_video - 1;
#line 4033
  if (kd >= 0 && kd <= 7) {
#line 4034
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 4035
    if (easycap_debug > 3) {
#line 4035
      printk("<7>easycap::%i%s: unlocked dongle[%i].mutex_video\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
  } else {

  }
#line 4037
  goto ldv_33510;
  case 2: ;
#line 4040
  if (kd >= 0 && kd <= 7) {
#line 4041
    __wake_up(& peasycap->wq_audio, 1U, 1, (void *)0);
#line 4042
    if (easycap_debug > 3) {
#line 4042
      printk("<7>easycap::%i%s: about to lock dongle[%i].mutex_audio\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
#line 4043
    tmp___1 = mutex_lock_interruptible_nested(& easycapdc60_dongle[kd].mutex_audio,
                                              0U);
#line 4043
    if (tmp___1 != 0) {
#line 4045
      printk("<7>easycap:: %s: OLD_ERROR: cannot lock dongle[%i].mutex_audio\n", "easycap_usb_disconnect",
             kd);
#line 4047
      return;
    } else {

    }
#line 4049
    if (easycap_debug > 3) {
#line 4049
      printk("<7>easycap::%i%s: locked dongle[%i].mutex_audio\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
  } else {
#line 4051
    printk("<7>easycap:: %s: OLD_ERROR: %i=kd is bad: cannot lock dongle\n", "easycap_usb_disconnect",
           kd);
  }
#line 4052
  tmp___2 = snd_card_free(peasycap->psnd_card);
#line 4052
  if (tmp___2 != 0) {
#line 4053
    printk("<7>easycap:: %s: OLD_ERROR: snd_card_free() failed\n", "easycap_usb_disconnect");
  } else {
#line 4055
    peasycap->psnd_card = (struct snd_card *)0;
#line 4056
    peasycap->registered_audio = peasycap->registered_audio - 1;
  }
#line 4058
  if (kd >= 0 && kd <= 7) {
#line 4059
    mutex_unlock(& easycapdc60_dongle[kd].mutex_audio);
#line 4060
    if (easycap_debug > 3) {
#line 4060
      printk("<7>easycap::%i%s: unlocked dongle[%i].mutex_audio\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
  } else {

  }
#line 4062
  goto ldv_33510;
  default: ;
#line 4065
  goto ldv_33510;
  }
  ldv_33510: ;
#line 4073
  if (peasycap->kref.refcount.counter == 0) {
#line 4074
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->kref.refcount.counter is zero so cannot call kref_put()\n",
           peasycap->isdongle, "easycap_usb_disconnect");
#line 4076
    printk("<7>easycap::%i%s: ending unsuccessfully: may cause memory leak\n", peasycap->isdongle,
           "easycap_usb_disconnect");
#line 4077
    return;
  } else {

  }
#line 4079
  if (kd >= 0 && kd <= 7) {
#line 4080
    if (easycap_debug > 3) {
#line 4080
      printk("<7>easycap::%i%s: about to lock dongle[%i].mutex_video\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
#line 4081
    tmp___3 = mutex_lock_interruptible_nested(& easycapdc60_dongle[kd].mutex_video,
                                              0U);
#line 4081
    if (tmp___3 != 0) {
#line 4082
      printk("<7>easycap:: %s: OLD_ERROR: cannot lock dongle[%i].mutex_video\n", "easycap_usb_disconnect",
             kd);
#line 4083
      printk("<7>easycap::%i%s: ending unsuccessfully: may cause memory leak\n", peasycap->isdongle,
             "easycap_usb_disconnect");
#line 4084
      return;
    } else {

    }
#line 4086
    if (easycap_debug > 3) {
#line 4086
      printk("<7>easycap::%i%s: locked dongle[%i].mutex_video\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
#line 4087
    if (easycap_debug > 3) {
#line 4087
      printk("<7>easycap::%i%s: about to lock dongle[%i].mutex_audio\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
#line 4088
    tmp___4 = mutex_lock_interruptible_nested(& easycapdc60_dongle[kd].mutex_audio,
                                              0U);
#line 4088
    if (tmp___4 != 0) {
#line 4089
      printk("<7>easycap:: %s: OLD_ERROR: cannot lock dongle[%i].mutex_audio\n", "easycap_usb_disconnect",
             kd);
#line 4090
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 4091
      if (easycap_debug > 3) {
#line 4091
        printk("<7>easycap::%i%s: unlocked dongle[%i].mutex_video\n", peasycap->isdongle,
               "easycap_usb_disconnect", kd);
      } else {

      }
#line 4092
      printk("<7>easycap::%i%s: ending unsuccessfully: may cause memory leak\n", peasycap->isdongle,
             "easycap_usb_disconnect");
#line 4093
      return;
    } else {

    }
#line 4095
    if (easycap_debug > 3) {
#line 4095
      printk("<7>easycap::%i%s: locked dongle[%i].mutex_audio\n", peasycap->isdongle,
             "easycap_usb_disconnect", kd);
    } else {

    }
  } else {

  }
#line 4097
  if (easycap_debug > 3) {
#line 4097
    printk("<7>easycap::%i%s: intf[%i]: %i=peasycap->kref.refcount.counter\n", peasycap->isdongle,
           "easycap_usb_disconnect", (int )bInterfaceNumber, peasycap->kref.refcount.counter);
  } else {

  }
#line 4099
  ldv_kref_put_13(& peasycap->kref, & easycap_delete);
#line 4100
  if (easycap_debug > 3) {
#line 4100
    printk("<7>easycap:: %s: intf[%i]: kref_put() done.\n", "easycap_usb_disconnect",
           (int )bInterfaceNumber);
  } else {

  }
#line 4101
  if (kd >= 0 && kd <= 7) {
#line 4102
    mutex_unlock(& easycapdc60_dongle[kd].mutex_audio);
#line 4103
    if (easycap_debug > 3) {
#line 4103
      printk("<7>easycap:: %s: unlocked dongle[%i].mutex_audio\n", "easycap_usb_disconnect",
             kd);
    } else {

    }
#line 4104
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 4105
    if (easycap_debug > 3) {
#line 4105
      printk("<7>easycap:: %s: unlocked dongle[%i].mutex_video\n", "easycap_usb_disconnect",
             kd);
    } else {

    }
  } else {

  }
#line 4108
  if (easycap_debug > 3) {
#line 4108
    printk("<7>easycap::%i%s: ends\n", peasycap->isdongle, "easycap_usb_disconnect");
  } else {

  }
#line 4109
  return;
}
}
#line 4118 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static struct usb_device_id easycap_usb_device_id_table[2U]  = {      {3U, 1505U, 1032U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0UL}};
#line 4123 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
struct usb_device_id  const  __mod_usb_device_table  ;
#line 4124 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static struct usb_driver easycap_usb_driver  = 
#line 4124
     {"easycap", & easycap_usb_probe, & easycap_usb_disconnect, 0, 0, 0, 0, 0, 0, (struct usb_device_id  const  *)(& easycap_usb_device_id_table),
    {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, {{0, 0, 0, 0, (_Bool)0,
                                                                 0, 0, 0, 0, 0, 0,
                                                                 0, 0, 0}, 0}, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 4131 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static int easycap_module_init(void) 
{ 
  int k ;
  int rc ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 4135
  printk("<6>Easycap version: 0.9.01\n");
#line 4137
  if (easycap_debug > 3) {
#line 4137
    printk("<7>easycap:: %s: begins.  %i=debug %i=bars %i=gain\n", "easycap_module_init",
           easycap_debug, easycap_bars, easycap_gain);
  } else {

  }
#line 4140
  __mutex_init(& mutex_dongle, "&mutex_dongle", & __key);
#line 4141
  k = 0;
#line 4141
  goto ldv_33526;
  ldv_33525: 
#line 4142
  easycapdc60_dongle[k].peasycap = (struct easycap *)0;
#line 4143
  __mutex_init(& easycapdc60_dongle[k].mutex_video, "&easycapdc60_dongle[k].mutex_video",
               & __key___0);
#line 4144
  __mutex_init(& easycapdc60_dongle[k].mutex_audio, "&easycapdc60_dongle[k].mutex_audio",
               & __key___1);
#line 4141
  k = k + 1;
  ldv_33526: ;
#line 4141
  if (k <= 7) {
#line 4143
    goto ldv_33525;
  } else {

  }
#line 4146
  rc = ldv_usb_register_driver_14(& easycap_usb_driver, & __this_module, "easycap");
#line 4147
  if (rc != 0) {
#line 4148
    printk("<3>Easycap: usb_register failed rc=%d\n", rc);
  } else {

  }
#line 4150
  return (rc);
}
}
#line 4153 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.c"
static void easycap_module_exit(void) 
{ 


  {
#line 4155
  ldv_usb_deregister_15(& easycap_usb_driver);
#line 4156
  return;
}
}
#line 49 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_retval_4  ;
#line 50
extern void ldv_initialize(void) ;
#line 51
void ldv_check_final_state(void) ;
#line 52
extern int ldv_release_3(void) ;
#line 53 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_retval_3  ;
#line 54 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_retval_2  ;
#line 58 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
void ldv_usb_driver_2(void) 
{ 
  void *tmp ;

  {
#line 59
  tmp = ldv_init_zalloc(1288UL);
#line 59
  easycap_usb_driver_group1 = (struct usb_interface *)tmp;
#line 60
  return;
}
}
#line 63 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
void ldv_initialize_v4l2_file_operations_3(void) 
{ 
  void *tmp ;

  {
#line 64
  tmp = __VERIFIER_nondet_pointer();
#line 64
  v4l2_fops_group0 = (struct file *)tmp;
#line 65
  return;
}
}
#line 67 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
void ldv_initialize_vm_operations_struct_4(void) 
{ 
  void *tmp ;

  {
#line 68
  tmp = ldv_init_zalloc(176UL);
#line 68
  easycap_vm_ops_group0 = (struct vm_area_struct *)tmp;
#line 69
  return;
}
}
#line 76
void ldv_main_exported_1(void) ;
#line 80 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int main(void) 
{ 
  struct vm_fault *ldvarg0 ;
  void *tmp ;
  struct poll_table_struct *ldvarg8 ;
  void *tmp___0 ;
  unsigned int ldvarg7 ;
  struct vm_area_struct *ldvarg9 ;
  void *tmp___1 ;
  unsigned long ldvarg6 ;
  struct usb_device_id *ldvarg10 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 83
  tmp = ldv_init_zalloc(32UL);
#line 83
  ldvarg0 = (struct vm_fault *)tmp;
#line 84
  tmp___0 = ldv_init_zalloc(16UL);
#line 84
  ldvarg8 = (struct poll_table_struct *)tmp___0;
#line 86
  tmp___1 = ldv_init_zalloc(176UL);
#line 86
  ldvarg9 = (struct vm_area_struct *)tmp___1;
#line 88
  tmp___2 = ldv_init_zalloc(24UL);
#line 88
  ldvarg10 = (struct usb_device_id *)tmp___2;
#line 81
  ldv_initialize();
#line 85
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
#line 87
  ldv_memset((void *)(& ldvarg6), 0, 8UL);
#line 90
  ldv_state_variable_4 = 0;
#line 91
  ldv_state_variable_1 = 0;
#line 92
  ref_cnt = 0;
#line 93
  ldv_state_variable_0 = 1;
#line 94
  ldv_state_variable_3 = 0;
#line 95
  ldv_state_variable_2 = 0;
  ldv_33608: 
#line 97
  tmp___3 = __VERIFIER_nondet_int();
#line 97
  switch (tmp___3) {
  case 0: ;
#line 101
  if (ldv_state_variable_4 != 0) {
#line 102
    tmp___4 = __VERIFIER_nondet_int();
#line 102
    switch (tmp___4) {
    case 0: ;
#line 105
    if (ldv_state_variable_4 == 1) {
#line 107
      easycap_vma_fault(easycap_vm_ops_group0, ldvarg0);
#line 109
      ldv_state_variable_4 = 1;
    } else {

    }
#line 112
    if (ldv_state_variable_4 == 2) {
#line 114
      easycap_vma_fault(easycap_vm_ops_group0, ldvarg0);
#line 116
      ldv_state_variable_4 = 2;
    } else {

    }
#line 119
    goto ldv_33582;
    case 1: ;
#line 122
    if (ldv_state_variable_4 == 2) {
#line 124
      easycap_vma_close(easycap_vm_ops_group0);
#line 125
      ldv_state_variable_4 = 1;
    } else {

    }
#line 128
    goto ldv_33582;
    case 2: ;
#line 131
    if (ldv_state_variable_4 == 1) {
#line 133
      easycap_vma_open(easycap_vm_ops_group0);
#line 134
      ldv_state_variable_4 = 2;
#line 135
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 138
    goto ldv_33582;
    default: 
#line 139
    ldv_stop();
    }
    ldv_33582: ;
  } else {

  }
#line 143
  goto ldv_33586;
  case 1: ;
#line 147
  if (ldv_state_variable_1 != 0) {
#line 148
    ldv_main_exported_1();
  } else {

  }
#line 151
  goto ldv_33586;
  case 2: ;
#line 155
  if (ldv_state_variable_0 != 0) {
#line 156
    tmp___5 = __VERIFIER_nondet_int();
#line 156
    switch (tmp___5) {
    case 0: ;
#line 159
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 161
      easycap_module_exit();
#line 162
      ldv_state_variable_0 = 3;
#line 163
      goto ldv_final;
    } else {

    }
#line 166
    goto ldv_33591;
    case 1: ;
#line 169
    if (ldv_state_variable_0 == 1) {
#line 171
      ldv_retval_2 = easycap_module_init();
#line 172
      if (ldv_retval_2 != 0) {
#line 173
        ldv_state_variable_0 = 3;
#line 174
        goto ldv_final;
      } else {

      }
#line 177
      if (ldv_retval_2 == 0) {
#line 178
        ldv_state_variable_0 = 2;
#line 179
        ldv_state_variable_3 = 1;
#line 180
        ldv_initialize_v4l2_file_operations_3();
#line 181
        ldv_state_variable_1 = 1;
#line 182
        ldv_initialize_snd_pcm_ops_1();
#line 183
        ldv_state_variable_4 = 1;
#line 184
        ldv_initialize_vm_operations_struct_4();
      } else {

      }
    } else {

    }
#line 188
    goto ldv_33591;
    default: 
#line 189
    ldv_stop();
    }
    ldv_33591: ;
  } else {

  }
#line 193
  goto ldv_33586;
  case 3: ;
#line 197
  if (ldv_state_variable_3 != 0) {
#line 198
    tmp___6 = __VERIFIER_nondet_int();
#line 198
    switch (tmp___6) {
    case 0: ;
#line 201
    if (ldv_state_variable_3 == 1) {
#line 203
      easycap_mmap(v4l2_fops_group0, ldvarg9);
#line 205
      ldv_state_variable_3 = 1;
    } else {

    }
#line 208
    if (ldv_state_variable_3 == 2) {
#line 210
      easycap_mmap(v4l2_fops_group0, ldvarg9);
#line 212
      ldv_state_variable_3 = 2;
    } else {

    }
#line 215
    goto ldv_33596;
    case 1: ;
#line 218
    if (ldv_state_variable_3 == 1) {
#line 220
      easycap_poll(v4l2_fops_group0, ldvarg8);
#line 222
      ldv_state_variable_3 = 1;
    } else {

    }
#line 225
    if (ldv_state_variable_3 == 2) {
#line 227
      easycap_poll(v4l2_fops_group0, ldvarg8);
#line 229
      ldv_state_variable_3 = 2;
    } else {

    }
#line 232
    goto ldv_33596;
    case 2: ;
#line 235
    if (ldv_state_variable_3 == 1) {
#line 237
      ldv_retval_3 = easycap_open_noinode(v4l2_fops_group0);
#line 239
      if (ldv_retval_3 == 0) {
#line 240
        ldv_state_variable_3 = 2;
#line 241
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 245
    goto ldv_33596;
    case 3: ;
#line 248
    if (ldv_state_variable_3 == 1) {
#line 250
      easycap_unlocked_ioctl(v4l2_fops_group0, ldvarg7, ldvarg6);
#line 252
      ldv_state_variable_3 = 1;
    } else {

    }
#line 255
    if (ldv_state_variable_3 == 2) {
#line 257
      easycap_unlocked_ioctl(v4l2_fops_group0, ldvarg7, ldvarg6);
#line 259
      ldv_state_variable_3 = 2;
    } else {

    }
#line 262
    goto ldv_33596;
    case 4: ;
#line 265
    if (ldv_state_variable_3 == 2) {
#line 267
      ldv_release_3();
#line 269
      ldv_state_variable_3 = 1;
#line 270
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 273
    goto ldv_33596;
    default: 
#line 274
    ldv_stop();
    }
    ldv_33596: ;
  } else {

  }
#line 278
  goto ldv_33586;
  case 4: ;
#line 282
  if (ldv_state_variable_2 != 0) {
#line 283
    tmp___7 = __VERIFIER_nondet_int();
#line 283
    switch (tmp___7) {
    case 0: ;
#line 286
    if (ldv_state_variable_2 == 1) {
#line 288
      ldv_retval_4 = easycap_usb_probe(easycap_usb_driver_group1, (struct usb_device_id  const  *)ldvarg10);
#line 289
      if (ldv_retval_4 == 0) {
#line 290
        ldv_state_variable_2 = 2;
#line 291
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 295
    goto ldv_33604;
    case 1: ;
#line 298
    if (ldv_state_variable_2 == 2 && usb_counter == 0) {
#line 300
      easycap_usb_disconnect(easycap_usb_driver_group1);
#line 301
      ldv_state_variable_2 = 1;
#line 302
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 305
    goto ldv_33604;
    default: 
#line 306
    ldv_stop();
    }
    ldv_33604: ;
  } else {

  }
#line 310
  goto ldv_33586;
  default: 
#line 311
  ldv_stop();
  }
  ldv_33586: ;
#line 313
  goto ldv_33608;
  ldv_final: 
#line 315
  ldv_check_final_state();
#line 316
  return 0;
}
}
#line 319 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct usb_device *tmp ;

  {
#line 322
  tmp = ldv_interface_to_usbdev();
#line 322
  return (tmp);
}
}
#line 325 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_usb_submit_urb_2(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 328
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 328
  return (tmp);
}
}
#line 331 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
void ldv_usb_free_urb_3(struct urb *urb ) 
{ 


  {
#line 334
  ldv_free_urb(urb);
#line 335
  return;
}
}
#line 337 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
void ldv_usb_free_urb_4(struct urb *urb ) 
{ 


  {
#line 340
  ldv_free_urb(urb);
#line 341
  return;
}
}
#line 343 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_usb_submit_urb_5(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 346
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 346
  return (tmp);
}
}
#line 349 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_usb_submit_urb_6(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 352
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 352
  return (tmp);
}
}
#line 355 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct urb *ldv_usb_alloc_urb_7(int iso_packets , gfp_t mem_flags ) 
{ 
  struct urb *tmp ;

  {
#line 358
  tmp = ldv_alloc_urb();
#line 358
  return (tmp);
}
}
#line 361 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
__inline static void ldv_usb_set_intfdata_8(struct usb_interface *intf , void *data ) 
{ 


  {
#line 364
  ldv_usb_set_intfdata(data);
#line 365
  return;
}
}
#line 373 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
struct urb *ldv_usb_alloc_urb_10(int iso_packets , gfp_t mem_flags ) 
{ 
  struct urb *tmp ;

  {
#line 376
  tmp = ldv_alloc_urb();
#line 376
  return (tmp);
}
}
#line 385 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
__inline static void *ldv_usb_get_intfdata_12(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
#line 388
  tmp = ldv_usb_get_intfdata();
#line 388
  return (tmp);
}
}
#line 391 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
__inline static int ldv_kref_put_13(struct kref *kref , void (*release)(struct kref * ) ) 
{ 


  {
#line 394
  easycap_delete(kref);
#line 395
  return (0);
}
}
#line 397 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
int ldv_usb_register_driver_14(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                               char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;

  {
#line 401
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 401
  ldv_func_res = tmp;
#line 403
  ldv_state_variable_2 = 1;
#line 404
  usb_counter = 0;
#line 405
  ldv_usb_driver_2();
#line 408
  return (ldv_func_res);
}
}
#line 411 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_main.o.c.prepared"
void ldv_usb_deregister_15(struct usb_driver *arg ) 
{ 


  {
#line 414
  usb_deregister(arg);
#line 416
  ldv_state_variable_2 = 0;
#line 417
  return;
}
}
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 897 "include/linux/device.h"
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 1434 "include/linux/usb.h"
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
#line 495 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
int easycap_audio_gainset(struct usb_device *pusb_device , s8 loud ) ;
#line 496
int easycap_audio_setup(struct easycap *peasycap ) ;
#line 503
int merit_saa(struct usb_device *p ) ;
#line 504
int check_vt(struct usb_device *pusb_device ) ;
#line 506
int set_resolution(struct usb_device *p , u16 set0 , u16 set1 , u16 set2 , u16 set3 ) ;
#line 509
int write_saa(struct usb_device *p , u16 reg0 , u16 set0 ) ;
#line 65 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static struct stk1160config  const  stk1160configPAL[28U]  = 
#line 65 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
  {      {0U, 152U}, 
        {2U, 147U}, 
        {1U, 3U}, 
        {3U, 128U}, 
        {13U, 0U}, 
        {15U, 2U}, 
        {24U, 16U}, 
        {25U, 0U}, 
        {26U, 20U}, 
        {27U, 14U}, 
        {28U, 70U}, 
        {256U, 51U}, 
        {259U, 0U}, 
        {260U, 0U}, 
        {261U, 0U}, 
        {262U, 0U}, 
        {272U, 8U}, 
        {273U, 0U}, 
        {274U, 32U}, 
        {275U, 0U}, 
        {276U, 1288U}, 
        {277U, 5U}, 
        {278U, 272U}, 
        {279U, 1U}, 
        {514U, 15U}, 
        {515U, 74U}, 
        {767U, 0U}, 
        {4095U, 65535U}};
#line 107 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static struct stk1160config  const  stk1160configNTSC[28U]  = 
#line 107
  {      {0U, 152U}, 
        {2U, 147U}, 
        {1U, 3U}, 
        {3U, 128U}, 
        {13U, 0U}, 
        {15U, 2U}, 
        {24U, 16U}, 
        {25U, 0U}, 
        {26U, 20U}, 
        {27U, 14U}, 
        {28U, 70U}, 
        {256U, 51U}, 
        {259U, 0U}, 
        {260U, 0U}, 
        {261U, 0U}, 
        {262U, 0U}, 
        {272U, 8U}, 
        {273U, 0U}, 
        {274U, 3U}, 
        {275U, 0U}, 
        {276U, 1288U}, 
        {277U, 5U}, 
        {278U, 243U}, 
        {279U, 0U}, 
        {514U, 15U}, 
        {515U, 74U}, 
        {767U, 0U}, 
        {4095U, 65535U}};
#line 152 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static struct saa7113config  const  saa7113configPAL[50U]  = 
#line 152
  {      {1U, 8U}, 
        {2U, 128U}, 
        {3U, 51U}, 
        {4U, 0U}, 
        {5U, 0U}, 
        {6U, 233U}, 
        {7U, 13U}, 
        {8U, 56U}, 
        {9U, 0U}, 
        {10U, 127U}, 
        {11U, 63U}, 
        {12U, 47U}, 
        {13U, 0U}, 
        {14U, 1U}, 
        {15U, 54U}, 
        {16U, 0U}, 
        {17U, 12U}, 
        {18U, 231U}, 
        {19U, 0U}, 
        {21U, 0U}, 
        {22U, 0U}, 
        {64U, 2U}, 
        {65U, 255U}, 
        {66U, 255U}, 
        {67U, 255U}, 
        {68U, 255U}, 
        {69U, 255U}, 
        {70U, 255U}, 
        {71U, 255U}, 
        {72U, 255U}, 
        {73U, 255U}, 
        {74U, 255U}, 
        {75U, 255U}, 
        {76U, 255U}, 
        {77U, 255U}, 
        {78U, 255U}, 
        {79U, 255U}, 
        {80U, 255U}, 
        {81U, 255U}, 
        {82U, 255U}, 
        {83U, 255U}, 
        {84U, 255U}, 
        {85U, 255U}, 
        {86U, 255U}, 
        {87U, 255U}, 
        {88U, 64U}, 
        {89U, 84U}, 
        {90U, 7U}, 
        {91U, 131U}, 
        {255U, 255U}};
#line 206 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static struct saa7113config  const  saa7113configNTSC[50U]  = 
#line 206
  {      {1U, 8U}, 
        {2U, 128U}, 
        {3U, 51U}, 
        {4U, 0U}, 
        {5U, 0U}, 
        {6U, 233U}, 
        {7U, 13U}, 
        {8U, 120U}, 
        {9U, 0U}, 
        {10U, 127U}, 
        {11U, 63U}, 
        {12U, 47U}, 
        {13U, 0U}, 
        {14U, 1U}, 
        {15U, 54U}, 
        {16U, 0U}, 
        {17U, 12U}, 
        {18U, 231U}, 
        {19U, 0U}, 
        {21U, 0U}, 
        {22U, 0U}, 
        {64U, 130U}, 
        {65U, 255U}, 
        {66U, 255U}, 
        {67U, 255U}, 
        {68U, 255U}, 
        {69U, 255U}, 
        {70U, 255U}, 
        {71U, 255U}, 
        {72U, 255U}, 
        {73U, 255U}, 
        {74U, 255U}, 
        {75U, 255U}, 
        {76U, 255U}, 
        {77U, 255U}, 
        {78U, 255U}, 
        {79U, 255U}, 
        {80U, 255U}, 
        {81U, 255U}, 
        {82U, 255U}, 
        {83U, 255U}, 
        {84U, 255U}, 
        {85U, 255U}, 
        {86U, 255U}, 
        {87U, 255U}, 
        {88U, 64U}, 
        {89U, 84U}, 
        {90U, 10U}, 
        {91U, 131U}, 
        {255U, 255U}};
#line 260 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static int regget(struct usb_device *pusb_device , u16 index , void *reg , int reg_size ) 
{ 
  int rc ;
  unsigned int tmp ;

  {
#line 265
  if ((unsigned long )pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 266
    return (-19);
  } else {

  }
#line 268
  tmp = __create_pipe(pusb_device, 0U);
#line 268
  rc = usb_control_msg(pusb_device, tmp | 2147483776U, 0, 192, 0, (int )index, reg,
                       (int )((__u16 )reg_size), 50000);
#line 274
  return (rc);
}
}
#line 277 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static int regset(struct usb_device *pusb_device , u16 index , u16 value ) 
{ 
  int rc ;
  unsigned int tmp ;
  u16 igot ;

  {
#line 281
  if ((unsigned long )pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 282
    return (-19);
  } else {

  }
#line 284
  tmp = __create_pipe(pusb_device, 0U);
#line 284
  rc = usb_control_msg(pusb_device, tmp | 2147483648U, 1, 64, (int )value, (int )index,
                       (void *)0, 0, 500);
#line 289
  if (rc < 0) {
#line 290
    return (rc);
  } else {

  }
#line 292
  if ((int )easycap_readback) {
#line 293
    igot = 0U;
#line 294
    rc = regget(pusb_device, (int )index, (void *)(& igot), 2);
#line 295
    igot = (unsigned int )igot & 255U;
#line 296
    switch ((int )index) {
    case 0: ;
    case 1280: ;
    case 1282: ;
    case 1283: ;
    case 1284: ;
    case 1286: ;
    case 1287: ;
#line 304
    goto ldv_32543;
    case 516: ;
    case 517: ;
    case 848: ;
    case 849: ;
#line 310
    if ((unsigned int )igot != 0U) {
#line 311
      if (easycap_debug > 7) {
#line 311
        printk("<7>easycap:: %s: unexpected 0x%02X for STK register 0x%03X\n", "regset",
               (int )igot, (int )index);
      } else {

      }
    } else {

    }
#line 314
    goto ldv_32543;
    default: ;
#line 317
    if (((unsigned int )value & 255U) != (unsigned int )igot) {
#line 318
      if (easycap_debug > 7) {
#line 318
        printk("<7>easycap:: %s: unexpected 0x%02X != 0x%02X for STK register 0x%03X\n",
               "regset", (int )igot, (int )value, (int )index);
      } else {

      }
    } else {

    }
#line 321
    goto ldv_32543;
    }
    ldv_32543: ;
  } else {

  }
#line 325
  return (rc);
}
}
#line 332 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static int wait_i2c(struct usb_device *p ) 
{ 
  u16 get0 ;
  u8 igot ;
  int max ;
  int k ;
  int __rc ;

  {
#line 336
  max = 2;
#line 339
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 340
    return (-19);
  } else {

  }
#line 342
  k = 0;
#line 342
  goto ldv_32565;
  ldv_32564: 
#line 343
  igot = 0U;
#line 343
  __rc = regget(p, 513, (void *)(& igot), 1);
#line 343
  if (__rc < 0) {
#line 343
    if (easycap_debug > 7) {
#line 343
      printk("<7>easycap:: %s: :-(%i\n", "wait_i2c", 343);
    } else {

    }
#line 343
    return (__rc);
  } else {

  }
#line 343
  get0 = (u16 )igot;
#line 344
  switch ((int )get0) {
  case 4: ;
  case 1: ;
#line 347
  return (0);
  case 0: 
#line 349
  msleep(20U);
#line 350
  goto ldv_32562;
  default: ;
#line 352
  return ((int )get0 + -1);
  }
  ldv_32562: 
#line 342
  k = k + 1;
  ldv_32565: ;
#line 342
  if (k < max) {
#line 344
    goto ldv_32564;
  } else {

  }

#line 355
  return (-1);
}
}
#line 359 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int write_saa(struct usb_device *p , u16 reg0 , u16 set0 ) 
{ 
  int __rc ;
  int __rc___0 ;
  int __rc___1 ;
  int __rc___2 ;
  int tmp ;

  {
#line 361
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 362
    return (-19);
  } else {

  }
#line 363
  __rc = regset(p, 512, 0);
#line 363
  if (__rc < 0) {
#line 363
    if (easycap_debug > 7) {
#line 363
      printk("<7>easycap:: %s: :-(%i\n", "write_saa", 363);
    } else {

    }
#line 363
    return (__rc);
  } else {

  }
#line 364
  __rc___0 = regset(p, 516, (int )reg0);
#line 364
  if (__rc___0 < 0) {
#line 364
    if (easycap_debug > 7) {
#line 364
      printk("<7>easycap:: %s: :-(%i\n", "write_saa", 364);
    } else {

    }
#line 364
    return (__rc___0);
  } else {

  }
#line 365
  __rc___1 = regset(p, 517, (int )set0);
#line 365
  if (__rc___1 < 0) {
#line 365
    if (easycap_debug > 7) {
#line 365
      printk("<7>easycap:: %s: :-(%i\n", "write_saa", 365);
    } else {

    }
#line 365
    return (__rc___1);
  } else {

  }
#line 366
  __rc___2 = regset(p, 512, 1);
#line 366
  if (__rc___2 < 0) {
#line 366
    if (easycap_debug > 7) {
#line 366
      printk("<7>easycap:: %s: :-(%i\n", "write_saa", 366);
    } else {

    }
#line 366
    return (__rc___2);
  } else {

  }
#line 367
  tmp = wait_i2c(p);
#line 367
  return (tmp);
}
}
#line 379 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static int write_vt(struct usb_device *p , u16 reg0 , u16 set0 ) 
{ 
  u8 igot ;
  u16 got502 ;
  u16 got503 ;
  u16 set502 ;
  u16 set503 ;
  int __rc ;
  int __rc___0 ;
  int __rc___1 ;
  int __rc___2 ;
  int __rc___3 ;
  int __rc___4 ;
  int __rc___5 ;
  int __rc___6 ;

  {
#line 385
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 386
    return (-19);
  } else {

  }
#line 387
  __rc = regset(p, 1284, (int )reg0);
#line 387
  if (__rc < 0) {
#line 387
    if (easycap_debug > 7) {
#line 387
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 387);
    } else {

    }
#line 387
    return (__rc);
  } else {

  }
#line 388
  __rc___0 = regset(p, 1280, 139);
#line 388
  if (__rc___0 < 0) {
#line 388
    if (easycap_debug > 7) {
#line 388
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 388);
    } else {

    }
#line 388
    return (__rc___0);
  } else {

  }
#line 390
  igot = 0U;
#line 390
  __rc___1 = regget(p, 1282, (void *)(& igot), 1);
#line 390
  if (__rc___1 < 0) {
#line 390
    if (easycap_debug > 7) {
#line 390
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 390);
    } else {

    }
#line 390
    return (__rc___1);
  } else {

  }
#line 390
  got502 = (u16 )igot;
#line 391
  igot = 0U;
#line 391
  __rc___2 = regget(p, 1283, (void *)(& igot), 1);
#line 391
  if (__rc___2 < 0) {
#line 391
    if (easycap_debug > 7) {
#line 391
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 391);
    } else {

    }
#line 391
    return (__rc___2);
  } else {

  }
#line 391
  got503 = (u16 )igot;
#line 393
  if (easycap_debug > 15) {
#line 393
    printk("<7>easycap:: %s: write_vt(., 0x%04X, 0x%04X): was 0x%04X\n", "write_vt",
           (int )reg0, (int )set0, ((int )got503 << 8) | (int )got502);
  } else {

  }
#line 396
  set502 = (unsigned int )set0 & 255U;
#line 397
  set503 = (u16 )((int )set0 >> 8);
#line 399
  __rc___3 = regset(p, 1284, (int )reg0);
#line 399
  if (__rc___3 < 0) {
#line 399
    if (easycap_debug > 7) {
#line 399
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 399);
    } else {

    }
#line 399
    return (__rc___3);
  } else {

  }
#line 400
  __rc___4 = regset(p, 1282, (int )set502);
#line 400
  if (__rc___4 < 0) {
#line 400
    if (easycap_debug > 7) {
#line 400
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 400);
    } else {

    }
#line 400
    return (__rc___4);
  } else {

  }
#line 401
  __rc___5 = regset(p, 1283, (int )set503);
#line 401
  if (__rc___5 < 0) {
#line 401
    if (easycap_debug > 7) {
#line 401
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 401);
    } else {

    }
#line 401
    return (__rc___5);
  } else {

  }
#line 402
  __rc___6 = regset(p, 1280, 140);
#line 402
  if (__rc___6 < 0) {
#line 402
    if (easycap_debug > 7) {
#line 402
      printk("<7>easycap:: %s: :-(%i\n", "write_vt", 402);
    } else {

    }
#line 402
    return (__rc___6);
  } else {

  }
#line 404
  return (0);
}
}
#line 416 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static int read_vt(struct usb_device *p , u16 reg0 ) 
{ 
  u8 igot ;
  u16 got502 ;
  u16 got503 ;
  int __rc ;
  int __rc___0 ;
  int __rc___1 ;
  int __rc___2 ;

  {
#line 421
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 422
    return (-19);
  } else {

  }
#line 423
  __rc = regset(p, 1284, (int )reg0);
#line 423
  if (__rc < 0) {
#line 423
    if (easycap_debug > 7) {
#line 423
      printk("<7>easycap:: %s: :-(%i\n", "read_vt", 423);
    } else {

    }
#line 423
    return (__rc);
  } else {

  }
#line 424
  __rc___0 = regset(p, 1280, 139);
#line 424
  if (__rc___0 < 0) {
#line 424
    if (easycap_debug > 7) {
#line 424
      printk("<7>easycap:: %s: :-(%i\n", "read_vt", 424);
    } else {

    }
#line 424
    return (__rc___0);
  } else {

  }
#line 426
  igot = 0U;
#line 426
  __rc___1 = regget(p, 1282, (void *)(& igot), 1);
#line 426
  if (__rc___1 < 0) {
#line 426
    if (easycap_debug > 7) {
#line 426
      printk("<7>easycap:: %s: :-(%i\n", "read_vt", 426);
    } else {

    }
#line 426
    return (__rc___1);
  } else {

  }
#line 426
  got502 = (u16 )igot;
#line 427
  igot = 0U;
#line 427
  __rc___2 = regget(p, 1283, (void *)(& igot), 1);
#line 427
  if (__rc___2 < 0) {
#line 427
    if (easycap_debug > 7) {
#line 427
      printk("<7>easycap:: %s: :-(%i\n", "read_vt", 427);
    } else {

    }
#line 427
    return (__rc___2);
  } else {

  }
#line 427
  got503 = (u16 )igot;
#line 429
  if (easycap_debug > 15) {
#line 429
    printk("<7>easycap:: %s: read_vt(., 0x%04X): has 0x%04X\n", "read_vt", (int )reg0,
           ((int )got503 << 8) | (int )got502);
  } else {

  }
#line 432
  return (((int )got503 << 8) | (int )got502);
}
}
#line 440 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static int write_300(struct usb_device *p ) 
{ 
  int __rc ;
  int __rc___0 ;
  int __rc___1 ;
  int __rc___2 ;
  int __rc___3 ;
  int __rc___4 ;

  {
#line 442
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 443
    return (-19);
  } else {

  }
#line 444
  __rc = regset(p, 768, 18);
#line 444
  if (__rc < 0) {
#line 444
    if (easycap_debug > 7) {
#line 444
      printk("<7>easycap:: %s: :-(%i\n", "write_300", 444);
    } else {

    }
#line 444
    return (__rc);
  } else {

  }
#line 445
  __rc___0 = regset(p, 848, 45);
#line 445
  if (__rc___0 < 0) {
#line 445
    if (easycap_debug > 7) {
#line 445
      printk("<7>easycap:: %s: :-(%i\n", "write_300", 445);
    } else {

    }
#line 445
    return (__rc___0);
  } else {

  }
#line 446
  __rc___1 = regset(p, 849, 1);
#line 446
  if (__rc___1 < 0) {
#line 446
    if (easycap_debug > 7) {
#line 446
      printk("<7>easycap:: %s: :-(%i\n", "write_300", 446);
    } else {

    }
#line 446
    return (__rc___1);
  } else {

  }
#line 447
  __rc___2 = regset(p, 850, 0);
#line 447
  if (__rc___2 < 0) {
#line 447
    if (easycap_debug > 7) {
#line 447
      printk("<7>easycap:: %s: :-(%i\n", "write_300", 447);
    } else {

    }
#line 447
    return (__rc___2);
  } else {

  }
#line 448
  __rc___3 = regset(p, 851, 0);
#line 448
  if (__rc___3 < 0) {
#line 448
    if (easycap_debug > 7) {
#line 448
      printk("<7>easycap:: %s: :-(%i\n", "write_300", 448);
    } else {

    }
#line 448
    return (__rc___3);
  } else {

  }
#line 449
  __rc___4 = regset(p, 768, 128);
#line 449
  if (__rc___4 < 0) {
#line 449
    if (easycap_debug > 7) {
#line 449
      printk("<7>easycap:: %s: :-(%i\n", "write_300", 449);
    } else {

    }
#line 449
    return (__rc___4);
  } else {

  }
#line 450
  return (0);
}
}
#line 454 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int setup_stk(struct usb_device *p , bool ntsc ) 
{ 
  int i ;
  struct stk1160config  const  *cfg ;
  int __rc ;

  {
#line 458
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 459
    return (-19);
  } else {

  }
#line 460
  cfg = (int )ntsc ? (struct stk1160config  const  *)(& stk1160configNTSC) : (struct stk1160config  const  *)(& stk1160configPAL);
#line 461
  i = 0;
#line 461
  goto ldv_32627;
  ldv_32626: 
#line 462
  __rc = regset(p, (int )(cfg + (unsigned long )i)->reg, (int )(cfg + (unsigned long )i)->set);
#line 462
  if (__rc < 0) {
#line 462
    if (easycap_debug > 7) {
#line 462
      printk("<7>easycap:: %s: :-(%i\n", "setup_stk", 462);
    } else {

    }
#line 462
    return (__rc);
  } else {

  }
#line 461
  i = i + 1;
  ldv_32627: ;
#line 461
  if ((unsigned int )((unsigned short )(cfg + (unsigned long )i)->reg) != 4095U) {
#line 463
    goto ldv_32626;
  } else {

  }
#line 464
  write_300(p);
#line 466
  return (0);
}
}
#line 469 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int setup_saa(struct usb_device *p , bool ntsc ) 
{ 
  int i ;
  int rc ;
  struct saa7113config  const  *cfg ;

  {
#line 473
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 474
    return (-19);
  } else {

  }
#line 475
  cfg = (int )ntsc ? (struct saa7113config  const  *)(& saa7113configNTSC) : (struct saa7113config  const  *)(& saa7113configPAL);
#line 476
  i = 0;
#line 476
  goto ldv_32637;
  ldv_32636: 
#line 477
  rc = write_saa(p, (int )(cfg + (unsigned long )i)->reg, (int )(cfg + (unsigned long )i)->set);
#line 478
  if (rc != 0) {
#line 479
    dev_err((struct device  const  *)(& p->dev), "Failed to set SAA register %d",
            (int )(cfg + (unsigned long )i)->reg);
  } else {

  }
#line 476
  i = i + 1;
  ldv_32637: ;
#line 476
  if ((unsigned int )((unsigned char )(cfg + (unsigned long )i)->reg) != 255U) {
#line 478
    goto ldv_32636;
  } else {

  }

#line 482
  return (0);
}
}
#line 485 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int merit_saa(struct usb_device *p ) 
{ 
  int rc ;

  {
#line 489
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 490
    return (-19);
  } else {

  }
#line 491
  rc = read_saa(p, 31);
#line 492
  return (rc < 0 || (rc & 2) != 0);
}
}
#line 495 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int ready_saa(struct usb_device *p ) 
{ 
  int j ;
  int rc ;
  int rate ;
  int max ;
  int marktime ;

  {
#line 498
  max = 5;
#line 498
  marktime = 100;
#line 507
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 508
    return (-19);
  } else {

  }
#line 509
  j = 0;
#line 510
  goto ldv_32653;
  ldv_32652: 
#line 511
  rc = read_saa(p, 31);
#line 512
  if (rc >= 0) {
#line 513
    if ((rc & 64) == 0) {
#line 514
      goto ldv_32651;
    } else {

    }
#line 515
    if (rc & 1) {
#line 516
      goto ldv_32651;
    } else {

    }
  } else {

  }
#line 518
  msleep((unsigned int )marktime);
#line 519
  j = j + 1;
  ldv_32653: ;
#line 510
  if (max > j) {
#line 512
    goto ldv_32652;
  } else {

  }
  ldv_32651: ;
#line 522
  if (max == j) {
#line 523
    return (-1);
  } else {

  }
#line 525
  if ((rc & 32) != 0) {
#line 526
    rate = 2;
#line 527
    if (easycap_debug > 7) {
#line 527
      printk("<7>easycap:: %s: hardware detects 60 Hz\n", "ready_saa");
    } else {

    }
  } else {
#line 529
    rate = 0;
#line 530
    if (easycap_debug > 7) {
#line 530
      printk("<7>easycap:: %s: hardware detects 50 Hz\n", "ready_saa");
    } else {

    }
  }
#line 532
  if ((rc & 128) != 0) {
#line 533
    if (easycap_debug > 7) {
#line 533
      printk("<7>easycap:: %s: hardware detects interlacing\n", "ready_saa");
    } else {

    }
  } else {
#line 535
    rate = rate + 1;
#line 536
    if (easycap_debug > 7) {
#line 536
      printk("<7>easycap:: %s: hardware detects no interlacing\n", "ready_saa");
    } else {

    }
  }
#line 538
  return (0);
}
}
#line 541 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int read_saa(struct usb_device *p , u16 reg0 ) 
{ 
  u8 igot ;
  int __rc ;
  int __rc___0 ;
  int tmp ;
  int __rc___1 ;

  {
#line 545
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 546
    return (-19);
  } else {

  }
#line 547
  __rc = regset(p, 520, (int )reg0);
#line 547
  if (__rc < 0) {
#line 547
    if (easycap_debug > 7) {
#line 547
      printk("<7>easycap:: %s: :-(%i\n", "read_saa", 547);
    } else {

    }
#line 547
    return (__rc);
  } else {

  }
#line 548
  __rc___0 = regset(p, 512, 32);
#line 548
  if (__rc___0 < 0) {
#line 548
    if (easycap_debug > 7) {
#line 548
      printk("<7>easycap:: %s: :-(%i\n", "read_saa", 548);
    } else {

    }
#line 548
    return (__rc___0);
  } else {

  }
#line 549
  tmp = wait_i2c(p);
#line 549
  if (tmp != 0) {
#line 550
    return (-1);
  } else {

  }
#line 551
  igot = 0U;
#line 552
  igot = 0U;
#line 552
  __rc___1 = regget(p, 521, (void *)(& igot), 1);
#line 552
  if (__rc___1 < 0) {
#line 552
    if (easycap_debug > 7) {
#line 552
      printk("<7>easycap:: %s: :-(%i\n", "read_saa", 552);
    } else {

    }
#line 552
    return (__rc___1);
  } else {

  }
#line 553
  return ((int )igot);
}
}
#line 556 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
static int read_stk(struct usb_device *p , u32 reg0 ) 
{ 
  u8 igot ;
  int __rc ;

  {
#line 560
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 561
    return (-19);
  } else {

  }
#line 562
  igot = 0U;
#line 563
  igot = 0U;
#line 563
  __rc = regget(p, (int )((u16 )reg0), (void *)(& igot), 1);
#line 563
  if (__rc < 0) {
#line 563
    if (easycap_debug > 7) {
#line 563
      printk("<7>easycap:: %s: :-(%i\n", "read_stk", 563);
    } else {

    }
#line 563
    return (__rc);
  } else {

  }
#line 564
  return ((int )igot);
}
}
#line 566 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int select_input(struct usb_device *p , int input , int mode ) 
{ 
  int ir ;
  int tmp ;
  int __rc ;
  int __rc___0 ;
  int tmp___0 ;
  int __rc___1 ;
  int __rc___2 ;
  int tmp___1 ;
  int __rc___3 ;
  int __rc___4 ;
  int tmp___2 ;
  int __rc___5 ;
  int __rc___6 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int __rc___7 ;

  {
#line 570
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 571
    return (-19);
  } else {

  }
#line 572
  stop_100(p);
#line 573
  switch (input) {
  case 0: ;
  case 1: 
#line 576
  tmp = write_saa(p, 2, 128);
#line 576
  if (tmp != 0) {
#line 577
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x02 for input %i\n",
           "select_input", input);
  } else {

  }
#line 580
  __rc = regset(p, 0, 152);
#line 580
  if (__rc < 0) {
#line 580
    if (easycap_debug > 7) {
#line 580
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 580);
    } else {

    }
#line 580
    return (__rc);
  } else {

  }
#line 581
  __rc___0 = regset(p, 2, 120);
#line 581
  if (__rc___0 < 0) {
#line 581
    if (easycap_debug > 7) {
#line 581
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 581);
    } else {

    }
#line 581
    return (__rc___0);
  } else {

  }
#line 582
  goto ldv_32682;
  case 2: 
#line 585
  tmp___0 = write_saa(p, 2, 128);
#line 585
  if (tmp___0 != 0) {
#line 586
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x02 for input %i\n",
           "select_input", input);
  } else {

  }
#line 589
  __rc___1 = regset(p, 0, 144);
#line 589
  if (__rc___1 < 0) {
#line 589
    if (easycap_debug > 7) {
#line 589
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 589);
    } else {

    }
#line 589
    return (__rc___1);
  } else {

  }
#line 590
  __rc___2 = regset(p, 2, 120);
#line 590
  if (__rc___2 < 0) {
#line 590
    if (easycap_debug > 7) {
#line 590
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 590);
    } else {

    }
#line 590
    return (__rc___2);
  } else {

  }
#line 591
  goto ldv_32682;
  case 3: 
#line 594
  tmp___1 = write_saa(p, 2, 128);
#line 594
  if (tmp___1 != 0) {
#line 595
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x02  for input %i\n",
           "select_input", input);
  } else {

  }
#line 598
  __rc___3 = regset(p, 0, 136);
#line 598
  if (__rc___3 < 0) {
#line 598
    if (easycap_debug > 7) {
#line 598
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 598);
    } else {

    }
#line 598
    return (__rc___3);
  } else {

  }
#line 599
  __rc___4 = regset(p, 2, 120);
#line 599
  if (__rc___4 < 0) {
#line 599
    if (easycap_debug > 7) {
#line 599
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 599);
    } else {

    }
#line 599
    return (__rc___4);
  } else {

  }
#line 600
  goto ldv_32682;
  case 4: 
#line 603
  tmp___2 = write_saa(p, 2, 128);
#line 603
  if (tmp___2 != 0) {
#line 604
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x02 for input %i\n",
           "select_input", input);
  } else {

  }
#line 607
  __rc___5 = regset(p, 0, 128);
#line 607
  if (__rc___5 < 0) {
#line 607
    if (easycap_debug > 7) {
#line 607
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 607);
    } else {

    }
#line 607
    return (__rc___5);
  } else {

  }
#line 608
  __rc___6 = regset(p, 2, 120);
#line 608
  if (__rc___6 < 0) {
#line 608
    if (easycap_debug > 7) {
#line 608
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 608);
    } else {

    }
#line 608
    return (__rc___6);
  } else {

  }
#line 609
  goto ldv_32682;
  case 5: ;
#line 612
  if (mode != 9) {
#line 613
    mode = 7;
  } else {

  }
#line 614
  switch (mode) {
  case 7: 
#line 616
  tmp___3 = write_saa(p, 2, 135);
#line 616
  if (tmp___3 != 0) {
#line 617
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x02 for input %i\n",
           "select_input", input);
  } else {

  }
#line 620
  tmp___4 = write_saa(p, 5, 255);
#line 620
  if (tmp___4 != 0) {
#line 621
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x05 for input %i\n",
           "select_input", input);
  } else {

  }
#line 624
  goto ldv_32694;
  case 9: 
#line 627
  tmp___5 = write_saa(p, 2, 137);
#line 627
  if (tmp___5 != 0) {
#line 628
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x02 for input %i\n",
           "select_input", input);
  } else {

  }
#line 631
  tmp___6 = write_saa(p, 5, 0);
#line 631
  if (tmp___6 != 0) {
#line 632
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x05 for input %i\n",
           "select_input", input);
  } else {

  }
#line 635
  goto ldv_32694;
  default: 
#line 638
  printk("<7>easycap:: %s: MISTAKE:  bad mode: %i\n", "select_input", mode);
#line 639
  return (-1);
  }
  ldv_32694: 
#line 642
  tmp___7 = write_saa(p, 4, 0);
#line 642
  if (tmp___7 != 0) {
#line 643
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x04 for input %i\n",
           "select_input", input);
  } else {

  }
#line 646
  tmp___8 = write_saa(p, 9, 128);
#line 646
  if (tmp___8 != 0) {
#line 647
    printk("<7>easycap:: %s: OLD_ERROR: failed to set SAA register 0x09 for input %i\n",
           "select_input", input);
  } else {

  }
#line 650
  __rc___7 = regset(p, 2, 147);
#line 650
  if (__rc___7 < 0) {
#line 650
    if (easycap_debug > 7) {
#line 650
      printk("<7>easycap:: %s: :-(%i\n", "select_input", 650);
    } else {

    }
#line 650
    return (__rc___7);
  } else {

  }
#line 651
  goto ldv_32682;
  default: 
#line 654
  printk("<7>easycap:: %s: OLD_ERROR:  bad input: %i\n", "select_input", input);
#line 655
  return (-1);
  }
  ldv_32682: 
#line 658
  ir = read_stk(p, 0U);
#line 659
  if (easycap_debug > 7) {
#line 659
    printk("<7>easycap:: %s: STK register 0x00 has 0x%02X\n", "select_input", ir);
  } else {

  }
#line 660
  ir = read_saa(p, 2);
#line 661
  if (easycap_debug > 7) {
#line 661
    printk("<7>easycap:: %s: SAA register 0x02 has 0x%02X\n", "select_input", ir);
  } else {

  }
#line 663
  start_100(p);
#line 665
  return (0);
}
}
#line 668 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int set_resolution(struct usb_device *p , u16 set0 , u16 set1 , u16 set2 , u16 set3 ) 
{ 
  u16 u0x0111 ;
  u16 u0x0113 ;
  u16 u0x0115 ;
  u16 u0x0117 ;
  int __rc ;
  int __rc___0 ;
  int __rc___1 ;
  int __rc___2 ;
  int __rc___3 ;
  int __rc___4 ;
  int __rc___5 ;
  int __rc___6 ;

  {
#line 673
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 674
    return (-19);
  } else {

  }
#line 675
  u0x0111 = (u16 )((int )set0 >> 8);
#line 676
  u0x0113 = (u16 )((int )set1 >> 8);
#line 677
  u0x0115 = (u16 )((int )set2 >> 8);
#line 678
  u0x0117 = (u16 )((int )set3 >> 8);
#line 680
  __rc = regset(p, 272, (int )set0 & 255);
#line 680
  if (__rc < 0) {
#line 680
    if (easycap_debug > 7) {
#line 680
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 680);
    } else {

    }
#line 680
    return (__rc);
  } else {

  }
#line 681
  __rc___0 = regset(p, 273, (int )u0x0111);
#line 681
  if (__rc___0 < 0) {
#line 681
    if (easycap_debug > 7) {
#line 681
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 681);
    } else {

    }
#line 681
    return (__rc___0);
  } else {

  }
#line 682
  __rc___1 = regset(p, 274, (int )set1 & 255);
#line 682
  if (__rc___1 < 0) {
#line 682
    if (easycap_debug > 7) {
#line 682
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 682);
    } else {

    }
#line 682
    return (__rc___1);
  } else {

  }
#line 683
  __rc___2 = regset(p, 275, (int )u0x0113);
#line 683
  if (__rc___2 < 0) {
#line 683
    if (easycap_debug > 7) {
#line 683
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 683);
    } else {

    }
#line 683
    return (__rc___2);
  } else {

  }
#line 684
  __rc___3 = regset(p, 276, (int )set2 & 255);
#line 684
  if (__rc___3 < 0) {
#line 684
    if (easycap_debug > 7) {
#line 684
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 684);
    } else {

    }
#line 684
    return (__rc___3);
  } else {

  }
#line 685
  __rc___4 = regset(p, 277, (int )u0x0115);
#line 685
  if (__rc___4 < 0) {
#line 685
    if (easycap_debug > 7) {
#line 685
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 685);
    } else {

    }
#line 685
    return (__rc___4);
  } else {

  }
#line 686
  __rc___5 = regset(p, 278, (int )set3 & 255);
#line 686
  if (__rc___5 < 0) {
#line 686
    if (easycap_debug > 7) {
#line 686
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 686);
    } else {

    }
#line 686
    return (__rc___5);
  } else {

  }
#line 687
  __rc___6 = regset(p, 279, (int )u0x0117);
#line 687
  if (__rc___6 < 0) {
#line 687
    if (easycap_debug > 7) {
#line 687
      printk("<7>easycap:: %s: :-(%i\n", "set_resolution", 687);
    } else {

    }
#line 687
    return (__rc___6);
  } else {

  }
#line 689
  return (0);
}
}
#line 692 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int start_100(struct usb_device *p ) 
{ 
  u16 get116 ;
  u16 get117 ;
  u16 get0 ;
  u8 igot116 ;
  u8 igot117 ;
  u8 igot ;
  int __rc ;
  int __rc___0 ;
  int __rc___1 ;
  int __rc___2 ;
  int __rc___3 ;
  int __rc___4 ;
  int __rc___5 ;
  int __rc___6 ;

  {
#line 697
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 698
    return (-19);
  } else {

  }
#line 699
  igot116 = 0U;
#line 699
  __rc = regget(p, 278, (void *)(& igot116), 1);
#line 699
  if (__rc < 0) {
#line 699
    if (easycap_debug > 7) {
#line 699
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 699);
    } else {

    }
#line 699
    return (__rc);
  } else {

  }
#line 700
  get116 = (u16 )igot116;
#line 701
  igot117 = 0U;
#line 701
  __rc___0 = regget(p, 279, (void *)(& igot117), 1);
#line 701
  if (__rc___0 < 0) {
#line 701
    if (easycap_debug > 7) {
#line 701
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 701);
    } else {

    }
#line 701
    return (__rc___0);
  } else {

  }
#line 702
  get117 = (u16 )igot117;
#line 703
  __rc___1 = regset(p, 278, 0);
#line 703
  if (__rc___1 < 0) {
#line 703
    if (easycap_debug > 7) {
#line 703
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 703);
    } else {

    }
#line 703
    return (__rc___1);
  } else {

  }
#line 704
  __rc___2 = regset(p, 279, 0);
#line 704
  if (__rc___2 < 0) {
#line 704
    if (easycap_debug > 7) {
#line 704
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 704);
    } else {

    }
#line 704
    return (__rc___2);
  } else {

  }
#line 706
  igot = 0U;
#line 706
  __rc___3 = regget(p, 256, (void *)(& igot), 1);
#line 706
  if (__rc___3 < 0) {
#line 706
    if (easycap_debug > 7) {
#line 706
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 706);
    } else {

    }
#line 706
    return (__rc___3);
  } else {

  }
#line 707
  get0 = (u16 )igot;
#line 708
  __rc___4 = regset(p, 256, (int )((unsigned int )get0 | 128U));
#line 708
  if (__rc___4 < 0) {
#line 708
    if (easycap_debug > 7) {
#line 708
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 708);
    } else {

    }
#line 708
    return (__rc___4);
  } else {

  }
#line 710
  __rc___5 = regset(p, 278, (int )get116);
#line 710
  if (__rc___5 < 0) {
#line 710
    if (easycap_debug > 7) {
#line 710
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 710);
    } else {

    }
#line 710
    return (__rc___5);
  } else {

  }
#line 711
  __rc___6 = regset(p, 279, (int )get117);
#line 711
  if (__rc___6 < 0) {
#line 711
    if (easycap_debug > 7) {
#line 711
      printk("<7>easycap:: %s: :-(%i\n", "start_100", 711);
    } else {

    }
#line 711
    return (__rc___6);
  } else {

  }
#line 713
  return (0);
}
}
#line 716 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int stop_100(struct usb_device *p ) 
{ 
  u16 get0 ;
  u8 igot ;
  int __rc ;
  int __rc___0 ;

  {
#line 721
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 722
    return (-19);
  } else {

  }
#line 723
  igot = 0U;
#line 723
  __rc = regget(p, 256, (void *)(& igot), 1);
#line 723
  if (__rc < 0) {
#line 723
    if (easycap_debug > 7) {
#line 723
      printk("<7>easycap:: %s: :-(%i\n", "stop_100", 723);
    } else {

    }
#line 723
    return (__rc);
  } else {

  }
#line 724
  get0 = (u16 )igot;
#line 725
  __rc___0 = regset(p, 256, (int )get0 & 127);
#line 725
  if (__rc___0 < 0) {
#line 725
    if (easycap_debug > 7) {
#line 725
      printk("<7>easycap:: %s: :-(%i\n", "stop_100", 725);
    } else {

    }
#line 725
    return (__rc___0);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int easycap_wakeup_device(struct usb_device *pusb_device ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 733
  if ((unsigned long )pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 734
    return (-19);
  } else {

  }
#line 736
  tmp = __create_pipe(pusb_device, 0U);
#line 736
  tmp___0 = usb_control_msg(pusb_device, tmp | 2147483648U, 3, 0, 1, 0, (void *)0,
                            0, 50000);
#line 736
  return (tmp___0);
}
}
#line 743 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int easycap_audio_setup(struct easycap *peasycap ) 
{ 
  struct usb_device *pusb_device ;
  u8 buffer[1U] ;
  int rc ;
  int id1 ;
  int id2 ;
  u8 request ;
  u8 requesttype ;
  u16 value_unmute ;
  u16 index ;
  u16 length ;
  unsigned int tmp ;
  int __rc ;
  int __rc___0 ;
  int __rc___1 ;
  int __rc___2 ;
  int tmp___0 ;

  {
#line 756
  request = 1U;
#line 757
  requesttype = 33U;
#line 760
  value_unmute = 512U;
#line 761
  index = 769U;
#line 762
  length = 1U;
#line 764
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 765
    return (-14);
  } else {

  }
#line 767
  pusb_device = peasycap->pusb_device;
#line 768
  if ((unsigned long )pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 769
    return (-19);
  } else {

  }
#line 771
  if (easycap_debug > 7) {
#line 771
    printk("<7>easycap::%i%s: %02X %02X %02X %02X %02X %02X %02X %02X\n", peasycap->isdongle,
           "easycap_audio_setup", (int )requesttype, (int )request, (int )value_unmute & 255,
           (int )value_unmute >> 8, (int )index & 255, (int )index >> 8, (int )length & 255,
           (int )length >> 8);
  } else {

  }
#line 780
  buffer[0] = 1U;
#line 782
  tmp = __create_pipe(pusb_device, 0U);
#line 782
  rc = usb_control_msg(pusb_device, tmp | 2147483648U, (int )request, (int )requesttype,
                       (int )value_unmute, (int )index, (void *)(& buffer), (int )length,
                       50000);
#line 786
  if (easycap_debug > 7) {
#line 786
    printk("<7>easycap:: %s: 0x%02X=buffer\n", "easycap_audio_setup", (int )buffer[0]);
  } else {

  }
#line 787
  if ((int )length != rc) {
#line 788
    switch (rc) {
    case -32: 
#line 790
    printk("<7>easycap:: %s: usb_control_msg returned -EPIPE\n", "easycap_audio_setup");
#line 791
    goto ldv_32763;
    default: 
#line 793
    printk("<7>easycap:: %s: OLD_ERROR: usb_control_msg returned %i\n", "easycap_audio_setup",
           rc);
#line 794
    goto ldv_32763;
    }
    ldv_32763: ;
  } else {

  }
#line 812
  __rc = regset(pusb_device, 1280, 148);
#line 812
  if (__rc < 0) {
#line 812
    if (easycap_debug > 7) {
#line 812
      printk("<7>easycap:: %s: :-(%i\n", "easycap_audio_setup", 812);
    } else {

    }
#line 812
    return (__rc);
  } else {

  }
#line 813
  __rc___0 = regset(pusb_device, 1280, 140);
#line 813
  if (__rc___0 < 0) {
#line 813
    if (easycap_debug > 7) {
#line 813
      printk("<7>easycap:: %s: :-(%i\n", "easycap_audio_setup", 813);
    } else {

    }
#line 813
    return (__rc___0);
  } else {

  }
#line 814
  __rc___1 = regset(pusb_device, 1286, 1);
#line 814
  if (__rc___1 < 0) {
#line 814
    if (easycap_debug > 7) {
#line 814
      printk("<7>easycap:: %s: :-(%i\n", "easycap_audio_setup", 814);
    } else {

    }
#line 814
    return (__rc___1);
  } else {

  }
#line 815
  __rc___2 = regset(pusb_device, 1287, 0);
#line 815
  if (__rc___2 < 0) {
#line 815
    if (easycap_debug > 7) {
#line 815
      printk("<7>easycap:: %s: :-(%i\n", "easycap_audio_setup", 815);
    } else {

    }
#line 815
    return (__rc___2);
  } else {

  }
#line 816
  id1 = read_vt(pusb_device, 124);
#line 817
  id2 = read_vt(pusb_device, 126);
#line 818
  printk("<7>easycap::%i%s: 0x%04X:0x%04X is audio vendor id\n", peasycap->isdongle,
         "easycap_audio_setup", id1, id2);
#line 824
  tmp___0 = easycap_audio_gainset(pusb_device, (int )peasycap->gain);
#line 824
  if (tmp___0 != 0) {
#line 825
    printk("<7>easycap:: %s: OLD_ERROR: audio_gainset() failed\n", "easycap_audio_setup");
  } else {

  }
#line 826
  check_vt(pusb_device);
#line 827
  return (0);
}
}
#line 830 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int check_vt(struct usb_device *pusb_device ) 
{ 
  int igot ;

  {
#line 834
  if ((unsigned long )pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 835
    return (-19);
  } else {

  }
#line 836
  igot = read_vt(pusb_device, 2);
#line 837
  if (igot < 0) {
#line 838
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x02\n", "check_vt");
  } else {

  }
#line 839
  if ((igot & 32768) != 0) {
#line 840
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 2);
  } else {

  }
#line 842
  igot = read_vt(pusb_device, 14);
#line 843
  if (igot < 0) {
#line 844
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x0E\n", "check_vt");
  } else {

  }
#line 845
  if ((igot & 32768) != 0) {
#line 846
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 14);
  } else {

  }
#line 848
  igot = read_vt(pusb_device, 16);
#line 849
  if (igot < 0) {
#line 850
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x10\n", "check_vt");
  } else {

  }
#line 851
  if ((igot & 32768) != 0) {
#line 852
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 16);
  } else {

  }
#line 854
  igot = read_vt(pusb_device, 18);
#line 855
  if (igot < 0) {
#line 856
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x12\n", "check_vt");
  } else {

  }
#line 857
  if ((igot & 32768) != 0) {
#line 858
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 18);
  } else {

  }
#line 860
  igot = read_vt(pusb_device, 20);
#line 861
  if (igot < 0) {
#line 862
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x14\n", "check_vt");
  } else {

  }
#line 863
  if ((igot & 32768) != 0) {
#line 864
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 20);
  } else {

  }
#line 866
  igot = read_vt(pusb_device, 22);
#line 867
  if (igot < 0) {
#line 868
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x16\n", "check_vt");
  } else {

  }
#line 869
  if ((igot & 32768) != 0) {
#line 870
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 22);
  } else {

  }
#line 872
  igot = read_vt(pusb_device, 24);
#line 873
  if (igot < 0) {
#line 874
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x18\n", "check_vt");
  } else {

  }
#line 875
  if ((igot & 32768) != 0) {
#line 876
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 24);
  } else {

  }
#line 878
  igot = read_vt(pusb_device, 28);
#line 879
  if (igot < 0) {
#line 880
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x1C\n", "check_vt");
  } else {

  }
#line 881
  if ((igot & 32768) != 0) {
#line 882
    printk("<7>easycap:: %s: register 0x%02X muted\n", "check_vt", 28);
  } else {

  }
#line 884
  return (0);
}
}
#line 901 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_low.c"
int easycap_audio_gainset(struct usb_device *pusb_device , s8 loud ) 
{ 
  int igot ;
  u8 tmp ;
  u16 mute ;

  {
#line 907
  if ((unsigned long )pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 908
    return (-19);
  } else {

  }
#line 909
  if ((int )loud < 0) {
#line 910
    loud = 0;
  } else {

  }
#line 911
  if ((int )loud > 31) {
#line 912
    loud = 31;
  } else {

  }
#line 914
  write_vt(pusb_device, 2, 32768);
#line 916
  igot = read_vt(pusb_device, 14);
#line 917
  if (igot < 0) {
#line 918
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x0E\n", "easycap_audio_gainset");
#line 919
    mute = 0U;
  } else {
#line 921
    mute = (unsigned int )((u16 )igot) & 32768U;
  }
#line 922
  mute = 0U;
#line 924
  if ((int )loud <= 15) {
#line 925
    tmp = (u8 )(((int )((signed char )((int )(15U - (unsigned int )((unsigned char )loud)) << 1)) & 30) | 1);
  } else {
#line 927
    tmp = 0U;
  }
#line 929
  if (easycap_debug > 7) {
#line 929
    printk("<7>easycap:: %s: 0x%04X=(mute|tmp) for VT1612A register 0x0E\n", "easycap_audio_gainset",
           (int )mute | (int )tmp);
  } else {

  }
#line 930
  write_vt(pusb_device, 14, (int )((u16 )tmp) | (int )mute);
#line 932
  igot = read_vt(pusb_device, 16);
#line 933
  if (igot < 0) {
#line 934
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x10\n", "easycap_audio_gainset");
#line 935
    mute = 0U;
  } else {
#line 937
    mute = (unsigned int )((u16 )igot) & 32768U;
  }
#line 938
  mute = 0U;
#line 940
  if (easycap_debug > 7) {
#line 940
    printk("<7>easycap:: %s: 0x%04X=(mute|tmp|(tmp<<8)) for VT1612A register 0x10,...0x18\n",
           "easycap_audio_gainset", ((int )mute | (int )tmp) | ((int )tmp << 8));
  } else {

  }
#line 942
  write_vt(pusb_device, 16, (int )((u16 )((int )((short )((int )((unsigned short )tmp) | (int )mute)) | (int )((short )((int )tmp << 8)))));
#line 943
  write_vt(pusb_device, 18, (int )((u16 )((int )((short )((int )((unsigned short )tmp) | (int )mute)) | (int )((short )((int )tmp << 8)))));
#line 944
  write_vt(pusb_device, 20, (int )((u16 )((int )((short )((int )((unsigned short )tmp) | (int )mute)) | (int )((short )((int )tmp << 8)))));
#line 945
  write_vt(pusb_device, 22, (int )((u16 )((int )((short )((int )((unsigned short )tmp) | (int )mute)) | (int )((short )((int )tmp << 8)))));
#line 946
  write_vt(pusb_device, 24, (int )((u16 )((int )((short )((int )((unsigned short )tmp) | (int )mute)) | (int )((short )((int )tmp << 8)))));
#line 948
  igot = read_vt(pusb_device, 28);
#line 949
  if (igot < 0) {
#line 950
    printk("<7>easycap:: %s: OLD_ERROR: failed to read VT1612A register 0x1C\n", "easycap_audio_gainset");
#line 951
    mute = 0U;
  } else {
#line 953
    mute = (unsigned int )((u16 )igot) & 32768U;
  }
#line 954
  mute = 0U;
#line 956
  if ((int )loud > 15) {
#line 957
    tmp = (unsigned int )((u8 )((unsigned int )((unsigned char )loud) - 16U)) & 15U;
  } else {
#line 959
    tmp = 0U;
  }
#line 961
  if (easycap_debug > 7) {
#line 961
    printk("<7>easycap:: %s: 0x%04X=(mute|tmp|(tmp<<8)) for VT1612A register 0x1C\n",
           "easycap_audio_gainset", ((int )mute | (int )tmp) | ((int )tmp << 8));
  } else {

  }
#line 963
  write_vt(pusb_device, 28, (int )((u16 )((int )((short )((int )((unsigned short )tmp) | (int )mute)) | (int )((short )((int )tmp << 8)))));
#line 964
  write_vt(pusb_device, 26, 1028);
#line 965
  write_vt(pusb_device, 2, 0);
#line 966
  return (0);
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 65 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 178 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 205
extern int kstrtoll(char const   * , unsigned int  , long long * ) ;
#line 219 "include/linux/kernel.h"
__inline static int kstrtol(char const   *s , unsigned int base , long *res ) 
{ 
  int tmp ;

  {
#line 227
  tmp = kstrtoll(s, base, (long long *)res);
#line 227
  return (tmp);
}
}
#line 307
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 16 "include/linux/string.h"
extern void *memdup_user(void const   * , size_t  ) ;
#line 34 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 61
extern size_t strlen(char const   * ) ;
#line 30 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 27 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 


  {
#line 29
  return ((long )ptr);
}
}
#line 32 "include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 34
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 34
  return (tmp);
}
}
#line 149 "include/linux/time.h"
extern void do_gettimeofday(struct timeval * ) ;
#line 40 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 42
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 46 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 50
  tmp = __builtin_object_size((void const   *)to, 0);
#line 50
  sz = (int )tmp;
#line 52
  might_fault();
#line 53
  tmp___1 = ldv__builtin_expect(sz == -1, 1L);
#line 53
  if (tmp___1 != 0L) {
#line 54
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 53
    tmp___2 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 53
    if (tmp___2 != 0L) {
#line 54
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 57
      __ret_warn_on = 1;
#line 57
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 57
      if (tmp___0 != 0L) {
#line 57
        warn_slowpath_fmt("/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/uaccess_64.h",
                          57, "Buffer overflow detected!\n");
      } else {

      }
#line 57
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 59
  return (n);
}
}
#line 63 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ 
  unsigned long tmp ;

  {
#line 65
  might_fault();
#line 67
  tmp = _copy_to_user(dst, src, size);
#line 67
  return ((int )tmp);
}
}
#line 655 "include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ 
  int actual ;

  {
#line 658
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, (char *)(& dev->devpath));
#line 660
  return ((int )size > actual ? actual : -1);
}
}
#line 876 "include/sound/pcm.h"
extern void snd_pcm_period_elapsed(struct snd_pcm_substream * ) ;
#line 42 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
int adjust_standard(struct easycap *peasycap , v4l2_std_id std_id ) 
{ 
  struct easycap_standard  const  *peasycap_standard ;
  u16 reg ;
  u16 set ;
  int ir ;
  int rc ;
  int need ;
  int k ;
  unsigned int itwas ;
  unsigned int isnow ;
  bool resubmit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 50
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 51
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_standard");
#line 52
    return (-14);
  } else {

  }
#line 54
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 55
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_standard");
#line 56
    return (-14);
  } else {

  }
#line 58
  peasycap_standard = (struct easycap_standard  const  *)(& easycap_standard);
#line 59
  goto ldv_32529;
  ldv_32528: ;
#line 60
  if ((unsigned long long )peasycap_standard->v4l2_standard.id == std_id) {
#line 61
    goto ldv_32527;
  } else {

  }
#line 62
  peasycap_standard = peasycap_standard + 1;
  ldv_32529: ;
#line 59
  if ((unsigned int )((unsigned short )peasycap_standard->mask) != 65535U) {
#line 61
    goto ldv_32528;
  } else {

  }
  ldv_32527: ;
#line 64
  if ((unsigned int )((unsigned short )peasycap_standard->mask) == 65535U) {
#line 65
    peasycap_standard = (struct easycap_standard  const  *)(& easycap_standard);
#line 66
    goto ldv_32532;
    ldv_32531: ;
#line 67
    if (((unsigned long long )peasycap_standard->v4l2_standard.id & std_id) != 0ULL) {
#line 68
      goto ldv_32530;
    } else {

    }
#line 69
    peasycap_standard = peasycap_standard + 1;
    ldv_32532: ;
#line 66
    if ((unsigned int )((unsigned short )peasycap_standard->mask) != 65535U) {
#line 68
      goto ldv_32531;
    } else {

    }
    ldv_32530: ;
  } else {

  }
#line 72
  if ((unsigned int )((unsigned short )peasycap_standard->mask) == 65535U) {
#line 73
    printk("<7>easycap::%i%s: OLD_ERROR: 0x%08X=std_id: standard not found\n", peasycap->isdongle,
           "adjust_standard", (unsigned int )std_id);
#line 75
    return (-22);
  } else {

  }
#line 77
  printk("<7>easycap::%i%s: selected standard: %s\n", peasycap->isdongle, "adjust_standard",
         (__u8 const   *)(& peasycap_standard->v4l2_standard.name));
#line 79
  if ((long )peasycap->standard_offset == ((long )peasycap_standard - (long )(& easycap_standard)) / 80L) {
#line 80
    printk("<7>easycap::%i%s: requested standard already in effect\n", peasycap->isdongle,
           "adjust_standard");
#line 81
    return (0);
  } else {

  }
#line 83
  peasycap->standard_offset = (int )(((long )peasycap_standard - (long )(& easycap_standard)) / 80L);
#line 84
  k = 0;
#line 84
  goto ldv_32534;
  ldv_32533: ;
#line 85
  if (peasycap->inputset[k].standard_offset_ok == 0) {
#line 86
    peasycap->inputset[k].standard_offset = peasycap->standard_offset;
  } else {

  }
#line 84
  k = k + 1;
  ldv_32534: ;
#line 84
  if (k <= 5) {
#line 86
    goto ldv_32533;
  } else {

  }

#line 90
  if (peasycap->input >= 0 && peasycap->input <= 5) {
#line 91
    peasycap->inputset[peasycap->input].standard_offset = peasycap->standard_offset;
#line 93
    peasycap->inputset[peasycap->input].standard_offset_ok = 1;
  } else
#line 95
  if (easycap_debug > 7) {
#line 95
    printk("<7>easycap::%i%s: %i=peasycap->input\n", peasycap->isdongle, "adjust_standard",
           peasycap->input);
  } else {

  }
#line 97
  peasycap->fps = (int )((unsigned int )peasycap_standard->v4l2_standard.frameperiod.denominator / (unsigned int )peasycap_standard->v4l2_standard.frameperiod.numerator);
#line 99
  switch (peasycap->fps) {
  case 6: ;
  case 30: 
#line 102
  peasycap->ntsc = 1;
#line 103
  goto ldv_32538;
  case 5: ;
  case 25: 
#line 107
  peasycap->ntsc = 0;
#line 108
  goto ldv_32538;
  default: 
#line 111
  printk("<7>easycap::%i%s: MISTAKE: %i=frames-per-second\n", peasycap->isdongle,
         "adjust_standard", peasycap->fps);
#line 112
  return (-2);
  }
  ldv_32538: ;
#line 115
  if (easycap_debug > 7) {
#line 115
    printk("<7>easycap::%i%s: %i frames-per-second\n", peasycap->isdongle, "adjust_standard",
           peasycap->fps);
  } else {

  }
#line 116
  if ((int )((short )peasycap_standard->mask) < 0) {
#line 117
    peasycap->skip = 5;
#line 118
    peasycap->usec = 1000000 / (peasycap->fps * 10);
#line 119
    peasycap->tolerate = (25 / (peasycap->fps * 5)) * 1000;
  } else {
#line 121
    peasycap->skip = 0;
#line 122
    peasycap->usec = 1000000 / (peasycap->fps * 2);
#line 123
    peasycap->tolerate = (25 / peasycap->fps) * 1000;
  }
#line 125
  if (peasycap->video_isoc_streaming != 0) {
#line 126
    resubmit = 1;
#line 127
    easycap_video_kill_urbs(peasycap);
  } else {
#line 129
    resubmit = 0;
  }
#line 135
  need = 0;
#line 136
  itwas = 0U;
#line 137
  reg = 0U;
#line 138
  set = 0U;
#line 139
  switch ((int )peasycap_standard->mask & 15) {
  case 5: 
#line 141
  reg = 10U;
#line 142
  set = 149U;
#line 143
  ir = read_saa(peasycap->pusb_device, (int )reg);
#line 144
  if (ir < 0) {
#line 145
    printk("<7>easycap::%i%s: OLD_ERROR: cannot read SAA register 0x%02X\n", peasycap->isdongle,
           "adjust_standard", (int )reg);
  } else {
#line 147
    itwas = (unsigned int )ir;
  }
#line 148
  rc = write_saa(peasycap->pusb_device, (int )reg, (int )set);
#line 149
  if (rc != 0) {
#line 150
    printk("<7>easycap::%i%s: OLD_ERROR: failed to set SAA register 0x%02X to 0x%02X for JP standard\n",
           peasycap->isdongle, "adjust_standard", (int )reg, (int )set);
  } else {
#line 153
    tmp = read_saa(peasycap->pusb_device, (int )reg);
#line 153
    isnow = (unsigned int )tmp;
#line 154
    if (ir < 0) {
#line 155
      if (easycap_debug > 7) {
#line 155
        printk("<7>easycap::%i%s: SAA register 0x%02X changed to 0x%02X\n", peasycap->isdongle,
               "adjust_standard", (int )reg, isnow);
      } else {

      }
    } else
#line 158
    if (easycap_debug > 7) {
#line 158
      printk("<7>easycap::%i%s: SAA register 0x%02X changed from 0x%02X to 0x%02X\n",
             peasycap->isdongle, "adjust_standard", (int )reg, itwas, isnow);
    } else {

    }
  }
#line 162
  reg = 11U;
#line 163
  set = 72U;
#line 164
  ir = read_saa(peasycap->pusb_device, (int )reg);
#line 165
  if (ir < 0) {
#line 166
    printk("<7>easycap::%i%s: OLD_ERROR: cannot read SAA register 0x%02X\n", peasycap->isdongle,
           "adjust_standard", (int )reg);
  } else {
#line 168
    itwas = (unsigned int )ir;
  }
#line 169
  rc = write_saa(peasycap->pusb_device, (int )reg, (int )set);
#line 170
  if (rc != 0) {
#line 171
    printk("<7>easycap::%i%s: OLD_ERROR: failed to set SAA register 0x%02X to 0x%02X for JP standard\n",
           peasycap->isdongle, "adjust_standard", (int )reg, (int )set);
  } else {
#line 174
    tmp___0 = read_saa(peasycap->pusb_device, (int )reg);
#line 174
    isnow = (unsigned int )tmp___0;
#line 175
    if (ir < 0) {
#line 176
      if (easycap_debug > 7) {
#line 176
        printk("<7>easycap::%i%s: SAA register 0x%02X changed to 0x%02X\n", peasycap->isdongle,
               "adjust_standard", (int )reg, isnow);
      } else {

      }
    } else
#line 179
    if (easycap_debug > 7) {
#line 179
      printk("<7>easycap::%i%s: SAA register 0x%02X changed from 0x%02X to 0x%02X\n",
             peasycap->isdongle, "adjust_standard", (int )reg, itwas, isnow);
    } else {

    }
  }
  case 1: ;
  case 0: 
#line 190
  reg = 14U;
#line 191
  set = 1U;
#line 192
  need = 1;
#line 193
  goto ldv_32545;
  case 8: ;
  case 7: 
#line 197
  reg = 14U;
#line 198
  set = 17U;
#line 199
  need = 1;
#line 200
  goto ldv_32545;
  case 3: ;
  case 2: 
#line 204
  reg = 14U;
#line 205
  set = 33U;
#line 206
  need = 1;
#line 207
  goto ldv_32545;
  case 6: ;
  case 9: 
#line 211
  reg = 14U;
#line 212
  set = 49U;
#line 213
  need = 1;
#line 214
  goto ldv_32545;
  case 4: 
#line 217
  reg = 14U;
#line 218
  set = 81U;
#line 219
  need = 1;
#line 220
  goto ldv_32545;
  default: ;
#line 223
  goto ldv_32545;
  }
  ldv_32545: ;
#line 226
  if (need != 0) {
#line 227
    ir = read_saa(peasycap->pusb_device, (int )reg);
#line 228
    if (ir < 0) {
#line 229
      printk("<7>easycap::%i%s: OLD_ERROR: failed to read SAA register 0x%02X\n", peasycap->isdongle,
             "adjust_standard", (int )reg);
    } else {
#line 231
      itwas = (unsigned int )ir;
    }
#line 232
    rc = write_saa(peasycap->pusb_device, (int )reg, (int )set);
#line 233
    tmp___2 = write_saa(peasycap->pusb_device, (int )reg, (int )set);
#line 233
    if (tmp___2 != 0) {
#line 234
      printk("<7>easycap::%i%s: OLD_ERROR: failed to set SAA register 0x%02X to 0x%02X for table 42\n",
             peasycap->isdongle, "adjust_standard", (int )reg, (int )set);
    } else {
#line 237
      tmp___1 = read_saa(peasycap->pusb_device, (int )reg);
#line 237
      isnow = (unsigned int )tmp___1;
#line 238
      if (ir < 0) {
#line 239
        if (easycap_debug > 7) {
#line 239
          printk("<7>easycap::%i%s: SAA register 0x%02X changed to 0x%02X\n", peasycap->isdongle,
                 "adjust_standard", (int )reg, isnow);
        } else {

        }
      } else
#line 242
      if (easycap_debug > 7) {
#line 242
        printk("<7>easycap::%i%s: SAA register 0x%02X changed from 0x%02X to 0x%02X\n",
               peasycap->isdongle, "adjust_standard", (int )reg, itwas, isnow);
      } else {

      }
    }
  } else {

  }
#line 251
  reg = 8U;
#line 252
  ir = read_saa(peasycap->pusb_device, (int )reg);
#line 253
  if (ir < 0) {
#line 254
    printk("<7>easycap::%i%s: OLD_ERROR: failed to read SAA register 0x%02X so cannot reset\n",
           peasycap->isdongle, "adjust_standard", (int )reg);
  } else {
#line 257
    itwas = (unsigned int )ir;
#line 258
    if ((int )peasycap_standard->mask & 1) {
#line 259
      set = (unsigned int )((u16 )itwas) | 64U;
    } else {
#line 261
      set = (unsigned int )((u16 )itwas) & 65471U;
    }
#line 262
    rc = write_saa(peasycap->pusb_device, (int )reg, (int )set);
#line 263
    if (rc != 0) {
#line 264
      printk("<7>easycap::%i%s: OLD_ERROR: failed to set SAA register 0x%02X to 0x%02X\n",
             peasycap->isdongle, "adjust_standard", (int )reg, (int )set);
    } else {
#line 267
      tmp___3 = read_saa(peasycap->pusb_device, (int )reg);
#line 267
      isnow = (unsigned int )tmp___3;
#line 268
      if (ir < 0) {
#line 269
        if (easycap_debug > 7) {
#line 269
          printk("<7>easycap::%i%s: SAA register 0x%02X changed to 0x%02X\n", peasycap->isdongle,
                 "adjust_standard", (int )reg, isnow);
        } else {

        }
      } else
#line 272
      if (easycap_debug > 7) {
#line 272
        printk("<7>easycap::%i%s: SAA register 0x%02X changed from 0x%02X to 0x%02X\n",
               peasycap->isdongle, "adjust_standard", (int )reg, itwas, isnow);
      } else {

      }
    }
  }
#line 281
  reg = 64U;
#line 282
  ir = read_saa(peasycap->pusb_device, (int )reg);
#line 283
  if (ir < 0) {
#line 284
    printk("<7>easycap::%i%s: OLD_ERROR: failed to read SAA register 0x%02X so cannot reset\n",
           peasycap->isdongle, "adjust_standard", (int )reg);
  } else {
#line 287
    itwas = (unsigned int )ir;
#line 288
    if ((int )peasycap_standard->mask & 1) {
#line 289
      set = (unsigned int )((u16 )itwas) | 128U;
    } else {
#line 291
      set = (unsigned int )((u16 )itwas) & 65407U;
    }
#line 292
    rc = write_saa(peasycap->pusb_device, (int )reg, (int )set);
#line 293
    if (rc != 0) {
#line 294
      printk("<7>easycap::%i%s: OLD_ERROR: failed to set SAA register 0x%02X to 0x%02X\n",
             peasycap->isdongle, "adjust_standard", (int )reg, (int )set);
    } else {
#line 297
      tmp___4 = read_saa(peasycap->pusb_device, (int )reg);
#line 297
      isnow = (unsigned int )tmp___4;
#line 298
      if (ir < 0) {
#line 299
        if (easycap_debug > 7) {
#line 299
          printk("<7>easycap::%i%s: SAA register 0x%02X changed to 0x%02X\n", peasycap->isdongle,
                 "adjust_standard", (int )reg, isnow);
        } else {

        }
      } else
#line 302
      if (easycap_debug > 7) {
#line 302
        printk("<7>easycap::%i%s: SAA register 0x%02X changed from 0x%02X to 0x%02X\n",
               peasycap->isdongle, "adjust_standard", (int )reg, itwas, isnow);
      } else {

      }
    }
  }
#line 311
  reg = 90U;
#line 312
  ir = read_saa(peasycap->pusb_device, (int )reg);
#line 313
  if (ir < 0) {
#line 314
    printk("<7>easycap::%i%s: OLD_ERROR: failed to read SAA register 0x%02X but continuing\n",
           peasycap->isdongle, "adjust_standard", (int )reg);
  } else {

  }
#line 315
  itwas = (unsigned int )ir;
#line 316
  if ((int )peasycap_standard->mask & 1) {
#line 317
    set = 10U;
  } else {
#line 319
    set = 7U;
  }
#line 320
  tmp___6 = write_saa(peasycap->pusb_device, (int )reg, (int )set);
#line 320
  if (tmp___6 != 0) {
#line 321
    printk("<7>easycap::%i%s: OLD_ERROR: failed to set SAA register 0x%02X to 0x%02X\n",
           peasycap->isdongle, "adjust_standard", (int )reg, (int )set);
  } else {
#line 324
    tmp___5 = read_saa(peasycap->pusb_device, (int )reg);
#line 324
    isnow = (unsigned int )tmp___5;
#line 325
    if (ir < 0) {
#line 326
      if (easycap_debug > 7) {
#line 326
        printk("<7>easycap::%i%s: SAA register 0x%02X changed to 0x%02X\n", peasycap->isdongle,
               "adjust_standard", (int )reg, isnow);
      } else {

      }
    } else
#line 329
    if (easycap_debug > 7) {
#line 329
      printk("<7>easycap::%i%s: SAA register 0x%02X changed from 0x%02X to 0x%02X\n",
             peasycap->isdongle, "adjust_standard", (int )reg, itwas, isnow);
    } else {

    }
  }
#line 332
  if ((int )resubmit) {
#line 333
    easycap_video_submit_urbs(peasycap);
  } else {

  }
#line 334
  return (0);
}
}
#line 361 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
int adjust_format(struct easycap *peasycap , u32 width , u32 height , u32 pixelformat ,
                  int field , bool try ) 
{ 
  struct easycap_format *peasycap_format ;
  struct easycap_format *peasycap_best_format ;
  u16 mask ;
  struct usb_device *p ;
  int miss ;
  int multiplier ;
  int best ;
  int k ;
  char bf[5U] ;
  char fo[32U] ;
  char *pc ;
  u32 uc ;
  bool resubmit ;
  size_t __len ;
  void *__ret ;
  long ret ;
  int __x___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 372
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 373
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_format");
#line 374
    return (-14);
  } else {

  }
#line 376
  if (peasycap->standard_offset < 0) {
#line 377
    if (easycap_debug > 7) {
#line 377
      printk("<7>easycap::%i%s: %i=peasycap->standard_offset\n", peasycap->isdongle,
             "adjust_format", peasycap->standard_offset);
    } else {

    }
#line 378
    return (-16);
  } else {

  }
#line 380
  p = peasycap->pusb_device;
#line 381
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 382
    printk("<7>easycap::%i%s: OLD_ERROR: peaycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_format");
#line 383
    return (-14);
  } else {

  }
#line 385
  pc = (char *)(& bf);
#line 386
  uc = pixelformat;
#line 387
  __len = 4UL;
#line 387
  if (__len > 63UL) {
#line 387
    __ret = memcpy((void *)pc, (void const   *)(& uc), __len);
  } else {
#line 387
    __ret = __builtin_memcpy((void *)pc, (void const   *)(& uc), __len);
  }
#line 388
  bf[4] = 0;
#line 389
  mask = (unsigned int )((u16 )easycap_standard[peasycap->standard_offset].mask) & 255U;
#line 390
  printk("<7>easycap::%i%s: sought:    %ix%i,%s(0x%08X),%i=field,0x%02X=std mask\n",
         peasycap->isdongle, "adjust_format", width, height, pc, pixelformat, field,
         (int )mask);
#line 392
  switch (field) {
  case 0: 
#line 394
  strcpy((char *)(& fo), "V4L2_FIELD_ANY ");
#line 395
  goto ldv_32580;
  case 1: 
#line 398
  strcpy((char *)(& fo), "V4L2_FIELD_NONE");
#line 399
  goto ldv_32580;
  case 2: 
#line 402
  strcpy((char *)(& fo), "V4L2_FIELD_TOP");
#line 403
  goto ldv_32580;
  case 3: 
#line 406
  strcpy((char *)(& fo), "V4L2_FIELD_BOTTOM");
#line 407
  goto ldv_32580;
  case 4: 
#line 410
  strcpy((char *)(& fo), "V4L2_FIELD_INTERLACED");
#line 411
  goto ldv_32580;
  case 5: 
#line 414
  strcpy((char *)(& fo), "V4L2_FIELD_SEQ_TB");
#line 415
  goto ldv_32580;
  case 6: 
#line 418
  strcpy((char *)(& fo), "V4L2_FIELD_SEQ_BT");
#line 419
  goto ldv_32580;
  case 7: 
#line 422
  strcpy((char *)(& fo), "V4L2_FIELD_ALTERNATE");
#line 423
  goto ldv_32580;
  case 8: 
#line 426
  strcpy((char *)(& fo), "V4L2_FIELD_INTERLACED_TB");
#line 427
  goto ldv_32580;
  case 9: 
#line 430
  strcpy((char *)(& fo), "V4L2_FIELD_INTERLACED_BT");
#line 431
  goto ldv_32580;
  default: 
#line 434
  strcpy((char *)(& fo), "V4L2_FIELD_... UNKNOWN  ");
#line 435
  goto ldv_32580;
  }
  ldv_32580: 
#line 438
  printk("<7>easycap::%i%s: sought:    %s\n", peasycap->isdongle, "adjust_format",
         (char *)(& fo));
#line 439
  if (field == 0) {
#line 440
    field = 1;
#line 441
    printk("<7>easycap::%i%s: prefer:    V4L2_FIELD_NONE=field, was V4L2_FIELD_ANY\n",
           peasycap->isdongle, "adjust_format");
  } else {

  }
#line 443
  peasycap_best_format = (struct easycap_format *)0;
#line 444
  peasycap_format = (struct easycap_format *)(& easycap_format);
#line 445
  goto ldv_32593;
  ldv_32592: ;
#line 446
  if (easycap_debug > 15) {
#line 446
    printk("<7>easycap::%i%s: .> %i %i 0x%08X %ix%i\n", peasycap->isdongle, "adjust_format",
           (int )peasycap_format->mask & 1, (unsigned int )peasycap_format->v4l2_format.fmt.pix.field,
           peasycap_format->v4l2_format.fmt.pix.pixelformat, peasycap_format->v4l2_format.fmt.pix.width,
           peasycap_format->v4l2_format.fmt.pix.height);
  } else {

  }
#line 453
  if (((((((int )peasycap_format->mask ^ (int )mask) & 31) == 0 && (unsigned int )peasycap_format->v4l2_format.fmt.pix.field == (unsigned int )field) && peasycap_format->v4l2_format.fmt.pix.pixelformat == pixelformat) && peasycap_format->v4l2_format.fmt.pix.width == width) && peasycap_format->v4l2_format.fmt.pix.height == height) {
#line 459
    peasycap_best_format = peasycap_format;
#line 460
    goto ldv_32591;
  } else {

  }
#line 462
  peasycap_format = peasycap_format + 1;
  ldv_32593: ;
#line 445
  if (peasycap_format->v4l2_format.fmt.pix.width != 0U) {
#line 447
    goto ldv_32592;
  } else {

  }
  ldv_32591: ;
#line 464
  if (peasycap_format->v4l2_format.fmt.pix.width == 0U) {
#line 465
    printk("<7>easycap::%i%s: cannot do: %ix%i with standard mask 0x%02X\n", peasycap->isdongle,
           "adjust_format", width, height, (int )mask);
#line 467
    peasycap_format = (struct easycap_format *)(& easycap_format);
#line 468
    best = -1;
#line 469
    goto ldv_32600;
    ldv_32599: ;
#line 470
    if (((((int )peasycap_format->mask ^ (int )mask) & 31) == 0 && (unsigned int )peasycap_format->v4l2_format.fmt.pix.field == (unsigned int )field) && peasycap_format->v4l2_format.fmt.pix.pixelformat == pixelformat) {
#line 474
      __x___0 = (int )(peasycap_format->v4l2_format.fmt.pix.width - width);
#line 474
      ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
#line 474
      miss = (int )ret;
#line 475
      if (best > miss || best < 0) {
#line 476
        best = miss;
#line 477
        peasycap_best_format = peasycap_format;
#line 478
        if (miss == 0) {
#line 479
          goto ldv_32598;
        } else {

        }
      } else {

      }
    } else {

    }
#line 482
    peasycap_format = peasycap_format + 1;
    ldv_32600: ;
#line 469
    if (peasycap_format->v4l2_format.fmt.pix.width != 0U) {
#line 471
      goto ldv_32599;
    } else {

    }
    ldv_32598: ;
#line 484
    if (best == -1) {
#line 485
      printk("<7>easycap::%i%s: cannot do %ix... with standard mask 0x%02X\n", peasycap->isdongle,
             "adjust_format", width, (int )mask);
#line 487
      printk("<7>easycap::%i%s: cannot do ...x%i with standard mask 0x%02X\n", peasycap->isdongle,
             "adjust_format", height, (int )mask);
#line 489
      printk("<7>easycap::%i%s:            %ix%i unmatched\n", peasycap->isdongle,
             "adjust_format", width, height);
#line 490
      return (peasycap->format_offset);
    } else {

    }
  } else {

  }
#line 493
  if ((unsigned long )peasycap_best_format == (unsigned long )((struct easycap_format *)0)) {
#line 494
    printk("<7>easycap::%i%s: MISTAKE: peasycap_best_format is NULL", peasycap->isdongle,
           "adjust_format");
#line 495
    return (-22);
  } else {

  }
#line 497
  peasycap_format = peasycap_best_format;
#line 500
  if ((int )try) {
#line 501
    return ((int )(((long )peasycap_best_format - (long )(& easycap_format)) / 344L));
  } else {

  }
#line 504
  if ((int )try) {
#line 505
    printk("<7>easycap::%i%s: MISTAKE: true==try where is should be false\n", peasycap->isdongle,
           "adjust_format");
#line 506
    return (-22);
  } else {

  }
#line 508
  printk("<7>easycap::%i%s: actioning: %ix%i %s\n", peasycap->isdongle, "adjust_format",
         peasycap_format->v4l2_format.fmt.pix.width, peasycap_format->v4l2_format.fmt.pix.height,
         (char *)(& peasycap_format->name));
#line 512
  peasycap->height = (int )peasycap_format->v4l2_format.fmt.pix.height;
#line 513
  peasycap->width = (int )peasycap_format->v4l2_format.fmt.pix.width;
#line 514
  peasycap->pixelformat = peasycap_format->v4l2_format.fmt.pix.pixelformat;
#line 515
  peasycap->format_offset = (int )(((long )peasycap_format - (long )(& easycap_format)) / 344L);
#line 518
  k = 0;
#line 518
  goto ldv_32602;
  ldv_32601: ;
#line 519
  if (peasycap->inputset[k].format_offset_ok == 0) {
#line 520
    peasycap->inputset[k].format_offset = peasycap->format_offset;
  } else {

  }
#line 518
  k = k + 1;
  ldv_32602: ;
#line 518
  if (k <= 5) {
#line 520
    goto ldv_32601;
  } else {

  }

#line 524
  if (peasycap->input >= 0 && peasycap->input <= 5) {
#line 525
    peasycap->inputset[peasycap->input].format_offset = peasycap->format_offset;
#line 527
    peasycap->inputset[peasycap->input].format_offset_ok = 1;
  } else
#line 529
  if (easycap_debug > 7) {
#line 529
    printk("<7>easycap::%i%s: %i=peasycap->input\n", peasycap->isdongle, "adjust_format",
           peasycap->input);
  } else {

  }
#line 533
  peasycap->bytesperpixel = (int )(((unsigned int )peasycap_format->mask & 224U) >> 5);
#line 534
  if (((unsigned int )peasycap_format->mask & 256U) != 0U) {
#line 535
    peasycap->byteswaporder = 1;
  } else {
#line 537
    peasycap->byteswaporder = 0;
  }
#line 538
  if (((unsigned int )peasycap_format->mask & 512U) != 0U) {
#line 539
    peasycap->skip = 5;
  } else {
#line 541
    peasycap->skip = 0;
  }
#line 542
  if (((unsigned int )peasycap_format->mask & 2048U) != 0U) {
#line 543
    peasycap->decimatepixel = 1;
  } else {
#line 545
    peasycap->decimatepixel = 0;
  }
#line 546
  if (((unsigned int )peasycap_format->mask & 4096U) != 0U) {
#line 547
    peasycap->offerfields = 1;
  } else {
#line 549
    peasycap->offerfields = 0;
  }
#line 550
  if ((int )peasycap->decimatepixel) {
#line 551
    multiplier = 2;
  } else {
#line 553
    multiplier = 1;
  }
#line 554
  peasycap->videofieldamount = ((peasycap->width * multiplier) * multiplier) * peasycap->height;
#line 556
  peasycap->frame_buffer_used = (peasycap->bytesperpixel * peasycap->width) * peasycap->height;
#line 558
  if (peasycap->video_isoc_streaming != 0) {
#line 559
    resubmit = 1;
#line 560
    easycap_video_kill_urbs(peasycap);
  } else {
#line 562
    resubmit = 0;
  }
#line 568
  if (((unsigned int )peasycap_format->mask & 1U) == 0U) {
#line 569
    if ((peasycap_format->v4l2_format.fmt.pix.width == 720U && peasycap_format->v4l2_format.fmt.pix.height == 576U) || (peasycap_format->v4l2_format.fmt.pix.width == 360U && peasycap_format->v4l2_format.fmt.pix.height == 288U)) {
#line 573
      tmp = set_resolution(p, 0, 1, 1440, 289);
#line 573
      if (tmp != 0) {
#line 574
        printk("<7>easycap::%i%s: OLD_ERROR: set_resolution() failed\n", peasycap->isdongle,
               "adjust_format");
#line 575
        return (-22);
      } else {

      }
    } else
#line 577
    if (peasycap_format->v4l2_format.fmt.pix.width == 704U && peasycap_format->v4l2_format.fmt.pix.height == 576U) {
#line 579
      tmp___0 = set_resolution(p, 4, 1, 1412, 289);
#line 579
      if (tmp___0 != 0) {
#line 580
        printk("<7>easycap::%i%s: OLD_ERROR: set_resolution() failed\n", peasycap->isdongle,
               "adjust_format");
#line 581
        return (-22);
      } else {

      }
    } else
#line 583
    if ((peasycap_format->v4l2_format.fmt.pix.width == 640U && peasycap_format->v4l2_format.fmt.pix.height == 480U) || (peasycap_format->v4l2_format.fmt.pix.width == 320U && peasycap_format->v4l2_format.fmt.pix.height == 240U)) {
#line 587
      tmp___1 = set_resolution(p, 20, 32, 1300, 272);
#line 587
      if (tmp___1 != 0) {
#line 588
        printk("<7>easycap::%i%s: OLD_ERROR: set_resolution() failed\n", peasycap->isdongle,
               "adjust_format");
#line 589
        return (-22);
      } else {

      }
    } else {
#line 592
      printk("<7>easycap::%i%s: MISTAKE: bad format, cannot set resolution\n", peasycap->isdongle,
             "adjust_format");
#line 593
      return (-22);
    }
  } else
#line 601
  if ((peasycap_format->v4l2_format.fmt.pix.width == 720U && peasycap_format->v4l2_format.fmt.pix.height == 480U) || (peasycap_format->v4l2_format.fmt.pix.width == 360U && peasycap_format->v4l2_format.fmt.pix.height == 240U)) {
#line 605
    tmp___2 = set_resolution(p, 0, 3, 1440, 243);
#line 605
    if (tmp___2 != 0) {
#line 606
      printk("<7>easycap::%i%s: OLD_ERROR: set_resolution() failed\n", peasycap->isdongle,
             "adjust_format");
#line 607
      return (-22);
    } else {

    }
  } else
#line 609
  if ((peasycap_format->v4l2_format.fmt.pix.width == 640U && peasycap_format->v4l2_format.fmt.pix.height == 480U) || (peasycap_format->v4l2_format.fmt.pix.width == 320U && peasycap_format->v4l2_format.fmt.pix.height == 240U)) {
#line 613
    tmp___3 = set_resolution(p, 20, 3, 1300, 243);
#line 613
    if (tmp___3 != 0) {
#line 614
      printk("<7>easycap::%i%s: OLD_ERROR: set_resolution() failed\n", peasycap->isdongle,
             "adjust_format");
#line 615
      return (-22);
    } else {

    }
  } else {
#line 618
    printk("<7>easycap::%i%s: MISTAKE: bad format, cannot set resolution\n", peasycap->isdongle,
           "adjust_format");
#line 619
    return (-22);
  }
#line 623
  if ((int )resubmit) {
#line 624
    easycap_video_submit_urbs(peasycap);
  } else {

  }
#line 626
  return ((int )(((long )peasycap_best_format - (long )(& easycap_format)) / 344L));
}
}
#line 629 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
int adjust_brightness(struct easycap *peasycap , int value ) 
{ 
  unsigned int mood ;
  int i1 ;
  int k ;
  int tmp ;

  {
#line 634
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 635
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_brightness");
#line 636
    return (-14);
  } else {

  }
#line 638
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 639
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_brightness");
#line 640
    return (-14);
  } else {

  }
#line 642
  i1 = 0;
#line 643
  goto ldv_32616;
  ldv_32615: ;
#line 644
  if (easycap_control[i1].id == 9963776U) {
#line 645
    if (easycap_control[i1].minimum > value || easycap_control[i1].maximum < value) {
#line 647
      value = easycap_control[i1].default_value;
    } else {

    }
#line 649
    if (easycap_control[i1].minimum <= peasycap->brightness && easycap_control[i1].maximum >= peasycap->brightness) {
#line 651
      if (peasycap->brightness == value) {
#line 652
        printk("<7>easycap::%i%s: unchanged brightness at  0x%02X\n", peasycap->isdongle,
               "adjust_brightness", value);
#line 654
        return (0);
      } else {

      }
    } else {

    }
#line 657
    peasycap->brightness = value;
#line 658
    k = 0;
#line 658
    goto ldv_32613;
    ldv_32612: ;
#line 659
    if (peasycap->inputset[k].brightness_ok == 0) {
#line 660
      peasycap->inputset[k].brightness = peasycap->brightness;
    } else {

    }
#line 658
    k = k + 1;
    ldv_32613: ;
#line 658
    if (k <= 5) {
#line 660
      goto ldv_32612;
    } else {

    }

#line 663
    if (peasycap->input >= 0 && peasycap->input <= 5) {
#line 664
      peasycap->inputset[peasycap->input].brightness = peasycap->brightness;
#line 666
      peasycap->inputset[peasycap->input].brightness_ok = 1;
    } else
#line 668
    if (easycap_debug > 7) {
#line 668
      printk("<7>easycap::%i%s: %i=peasycap->input\n", peasycap->isdongle, "adjust_brightness",
             peasycap->input);
    } else {

    }
#line 670
    mood = (unsigned int )peasycap->brightness & 255U;
#line 671
    tmp = write_saa(peasycap->pusb_device, 10, (int )((u16 )mood));
#line 671
    if (tmp != 0) {
#line 672
      printk("<7>easycap::%i%s: WARNING: failed to adjust brightness to 0x%02X\n",
             peasycap->isdongle, "adjust_brightness", mood);
#line 674
      return (-2);
    } else {

    }
#line 676
    printk("<7>easycap::%i%s: adjusting brightness to  0x%02X\n", peasycap->isdongle,
           "adjust_brightness", mood);
#line 677
    return (0);
  } else {

  }
#line 679
  i1 = i1 + 1;
  ldv_32616: ;
#line 643
  if (easycap_control[i1].id != 4294967295U) {
#line 645
    goto ldv_32615;
  } else {

  }
#line 681
  printk("<7>easycap::%i%s: WARNING: failed to adjust brightness: control not found\n",
         peasycap->isdongle, "adjust_brightness");
#line 682
  return (-2);
}
}
#line 685 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
int adjust_contrast(struct easycap *peasycap , int value ) 
{ 
  unsigned int mood ;
  int i1 ;
  int k ;
  int tmp ;

  {
#line 690
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 691
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_contrast");
#line 692
    return (-14);
  } else {

  }
#line 694
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 695
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_contrast");
#line 696
    return (-14);
  } else {

  }
#line 698
  i1 = 0;
#line 699
  goto ldv_32630;
  ldv_32629: ;
#line 700
  if (easycap_control[i1].id == 9963777U) {
#line 701
    if (easycap_control[i1].minimum > value || easycap_control[i1].maximum < value) {
#line 703
      value = easycap_control[i1].default_value;
    } else {

    }
#line 706
    if (easycap_control[i1].minimum <= peasycap->contrast && easycap_control[i1].maximum >= peasycap->contrast) {
#line 708
      if (peasycap->contrast == value) {
#line 709
        printk("<7>easycap::%i%s: unchanged contrast at  0x%02X\n", peasycap->isdongle,
               "adjust_contrast", value);
#line 710
        return (0);
      } else {

      }
    } else {

    }
#line 713
    peasycap->contrast = value;
#line 714
    k = 0;
#line 714
    goto ldv_32627;
    ldv_32626: ;
#line 715
    if (peasycap->inputset[k].contrast_ok == 0) {
#line 716
      peasycap->inputset[k].contrast = peasycap->contrast;
    } else {

    }
#line 714
    k = k + 1;
    ldv_32627: ;
#line 714
    if (k <= 5) {
#line 716
      goto ldv_32626;
    } else {

    }

#line 719
    if (peasycap->input >= 0 && peasycap->input <= 5) {
#line 720
      peasycap->inputset[peasycap->input].contrast = peasycap->contrast;
#line 722
      peasycap->inputset[peasycap->input].contrast_ok = 1;
    } else
#line 724
    if (easycap_debug > 7) {
#line 724
      printk("<7>easycap::%i%s: %i=peasycap->input\n", peasycap->isdongle, "adjust_contrast",
             peasycap->input);
    } else {

    }
#line 726
    mood = (unsigned int )(peasycap->contrast + -128) & 255U;
#line 727
    tmp = write_saa(peasycap->pusb_device, 11, (int )((u16 )mood));
#line 727
    if (tmp != 0) {
#line 728
      printk("<7>easycap::%i%s: WARNING: failed to adjust contrast to 0x%02X\n", peasycap->isdongle,
             "adjust_contrast", mood);
#line 730
      return (-2);
    } else {

    }
#line 732
    printk("<7>easycap::%i%s: adjusting contrast to  0x%02X\n", peasycap->isdongle,
           "adjust_contrast", mood);
#line 733
    return (0);
  } else {

  }
#line 735
  i1 = i1 + 1;
  ldv_32630: ;
#line 699
  if (easycap_control[i1].id != 4294967295U) {
#line 701
    goto ldv_32629;
  } else {

  }
#line 737
  printk("<7>easycap::%i%s: WARNING: failed to adjust contrast: control not found\n",
         peasycap->isdongle, "adjust_contrast");
#line 738
  return (-2);
}
}
#line 741 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
int adjust_saturation(struct easycap *peasycap , int value ) 
{ 
  unsigned int mood ;
  int i1 ;
  int k ;
  int tmp ;

  {
#line 746
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 747
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_saturation");
#line 748
    return (-14);
  } else {

  }
#line 750
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 751
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_saturation");
#line 752
    return (-14);
  } else {

  }
#line 754
  i1 = 0;
#line 755
  goto ldv_32644;
  ldv_32643: ;
#line 756
  if (easycap_control[i1].id == 9963778U) {
#line 757
    if (easycap_control[i1].minimum > value || easycap_control[i1].maximum < value) {
#line 759
      value = easycap_control[i1].default_value;
    } else {

    }
#line 762
    if (easycap_control[i1].minimum <= peasycap->saturation && easycap_control[i1].maximum >= peasycap->saturation) {
#line 764
      if (peasycap->saturation == value) {
#line 765
        printk("<7>easycap::%i%s: unchanged saturation at  0x%02X\n", peasycap->isdongle,
               "adjust_saturation", value);
#line 767
        return (0);
      } else {

      }
    } else {

    }
#line 770
    peasycap->saturation = value;
#line 771
    k = 0;
#line 771
    goto ldv_32641;
    ldv_32640: ;
#line 772
    if (peasycap->inputset[k].saturation_ok == 0) {
#line 773
      peasycap->inputset[k].saturation = peasycap->saturation;
    } else {

    }
#line 771
    k = k + 1;
    ldv_32641: ;
#line 771
    if (k <= 5) {
#line 773
      goto ldv_32640;
    } else {

    }

#line 776
    if (peasycap->input >= 0 && peasycap->input <= 5) {
#line 777
      peasycap->inputset[peasycap->input].saturation = peasycap->saturation;
#line 779
      peasycap->inputset[peasycap->input].saturation_ok = 1;
    } else
#line 781
    if (easycap_debug > 7) {
#line 781
      printk("<7>easycap::%i%s: %i=peasycap->input\n", peasycap->isdongle, "adjust_saturation",
             peasycap->input);
    } else {

    }
#line 782
    mood = (unsigned int )(peasycap->saturation + -128) & 255U;
#line 783
    tmp = write_saa(peasycap->pusb_device, 12, (int )((u16 )mood));
#line 783
    if (tmp != 0) {
#line 784
      printk("<7>easycap::%i%s: WARNING: failed to adjust saturation to 0x%02X\n",
             peasycap->isdongle, "adjust_saturation", mood);
#line 786
      return (-2);
    } else {

    }
#line 788
    printk("<7>easycap::%i%s: adjusting saturation to  0x%02X\n", peasycap->isdongle,
           "adjust_saturation", mood);
#line 789
    return (0);
  } else {

  }
#line 792
  i1 = i1 + 1;
  ldv_32644: ;
#line 755
  if (easycap_control[i1].id != 4294967295U) {
#line 757
    goto ldv_32643;
  } else {

  }
#line 794
  printk("<7>easycap::%i%s: WARNING: failed to adjust saturation: control not found\n",
         peasycap->isdongle, "adjust_saturation");
#line 795
  return (-2);
}
}
#line 798 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
int adjust_hue(struct easycap *peasycap , int value ) 
{ 
  unsigned int mood ;
  int i1 ;
  int i2 ;
  int k ;
  int tmp ;

  {
#line 803
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 804
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_hue");
#line 805
    return (-14);
  } else {

  }
#line 807
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 808
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_hue");
#line 809
    return (-14);
  } else {

  }
#line 811
  i1 = 0;
#line 812
  goto ldv_32659;
  ldv_32658: ;
#line 813
  if (easycap_control[i1].id == 9963779U) {
#line 814
    if (easycap_control[i1].minimum > value || easycap_control[i1].maximum < value) {
#line 816
      value = easycap_control[i1].default_value;
    } else {

    }
#line 818
    if (easycap_control[i1].minimum <= peasycap->hue && easycap_control[i1].maximum >= peasycap->hue) {
#line 820
      if (peasycap->hue == value) {
#line 821
        printk("<7>easycap::%i%s: unchanged hue at  0x%02X\n", peasycap->isdongle,
               "adjust_hue", value);
#line 822
        return (0);
      } else {

      }
    } else {

    }
#line 825
    peasycap->hue = value;
#line 826
    k = 0;
#line 826
    goto ldv_32656;
    ldv_32655: ;
#line 827
    if (peasycap->inputset[k].hue_ok == 0) {
#line 828
      peasycap->inputset[k].hue = peasycap->hue;
    } else {

    }
#line 826
    k = k + 1;
    ldv_32656: ;
#line 826
    if (k <= 5) {
#line 828
      goto ldv_32655;
    } else {

    }

#line 830
    if (peasycap->input >= 0 && peasycap->input <= 5) {
#line 831
      peasycap->inputset[peasycap->input].hue = peasycap->hue;
#line 832
      peasycap->inputset[peasycap->input].hue_ok = 1;
    } else
#line 834
    if (easycap_debug > 7) {
#line 834
      printk("<7>easycap::%i%s: %i=peasycap->input\n", peasycap->isdongle, "adjust_hue",
             peasycap->input);
    } else {

    }
#line 835
    i2 = peasycap->hue + -128;
#line 836
    mood = (unsigned int )i2 & 255U;
#line 837
    tmp = write_saa(peasycap->pusb_device, 13, (int )((u16 )mood));
#line 837
    if (tmp != 0) {
#line 838
      printk("<7>easycap::%i%s: WARNING: failed to adjust hue to 0x%02X\n", peasycap->isdongle,
             "adjust_hue", mood);
#line 839
      return (-2);
    } else {

    }
#line 841
    printk("<7>easycap::%i%s: adjusting hue to  0x%02X\n", peasycap->isdongle, "adjust_hue",
           mood);
#line 842
    return (0);
  } else {

  }
#line 845
  i1 = i1 + 1;
  ldv_32659: ;
#line 812
  if (easycap_control[i1].id != 4294967295U) {
#line 814
    goto ldv_32658;
  } else {

  }
#line 847
  printk("<7>easycap::%i%s: WARNING: failed to adjust hue: control not found\n", peasycap->isdongle,
         "adjust_hue");
#line 848
  return (-2);
}
}
#line 851 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
static int adjust_volume(struct easycap *peasycap , int value ) 
{ 
  s8 mood ;
  int i1 ;
  int tmp ;

  {
#line 856
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 857
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_volume");
#line 858
    return (-14);
  } else {

  }
#line 860
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 861
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_volume");
#line 862
    return (-14);
  } else {

  }
#line 864
  i1 = 0;
#line 865
  goto ldv_32669;
  ldv_32668: ;
#line 866
  if (easycap_control[i1].id == 9963781U) {
#line 867
    if (easycap_control[i1].minimum > value || easycap_control[i1].maximum < value) {
#line 869
      value = easycap_control[i1].default_value;
    } else {

    }
#line 871
    if (easycap_control[i1].minimum <= peasycap->volume && easycap_control[i1].maximum >= peasycap->volume) {
#line 873
      if (peasycap->volume == value) {
#line 874
        printk("<7>easycap::%i%s: unchanged volume at  0x%02X\n", peasycap->isdongle,
               "adjust_volume", value);
#line 875
        return (0);
      } else {

      }
    } else {

    }
#line 878
    peasycap->volume = value;
#line 879
    mood = peasycap->volume > 15 ? (peasycap->volume <= 31 ? (s8 )peasycap->volume : 31) : 16;
#line 882
    tmp = easycap_audio_gainset(peasycap->pusb_device, (int )mood);
#line 882
    if (tmp == 0) {
#line 883
      printk("<7>easycap::%i%s: WARNING: failed to adjust volume to 0x%2X\n", peasycap->isdongle,
             "adjust_volume", (int )mood);
#line 885
      return (-2);
    } else {

    }
#line 887
    printk("<7>easycap::%i%s: adjusting volume to 0x%02X\n", peasycap->isdongle, "adjust_volume",
           (int )mood);
#line 888
    return (0);
  } else {

  }
#line 890
  i1 = i1 + 1;
  ldv_32669: ;
#line 865
  if (easycap_control[i1].id != 4294967295U) {
#line 867
    goto ldv_32668;
  } else {

  }
#line 892
  printk("<7>easycap::%i%s: WARNING: failed to adjust volume: control not found\n",
         peasycap->isdongle, "adjust_volume");
#line 893
  return (-2);
}
}
#line 907 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
static int adjust_mute(struct easycap *peasycap , int value ) 
{ 
  int i1 ;

  {
#line 911
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 912
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "adjust_mute");
#line 913
    return (-14);
  } else {

  }
#line 915
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 916
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "adjust_mute");
#line 917
    return (-14);
  } else {

  }
#line 919
  i1 = 0;
#line 920
  goto ldv_32681;
  ldv_32680: ;
#line 921
  if (easycap_control[i1].id == 9963785U) {
#line 922
    peasycap->mute = value;
#line 923
    switch (peasycap->mute) {
    case 1: 
#line 925
    peasycap->audio_idle = 1;
#line 926
    printk("<7>easycap::%i%s: adjusting mute: %i=peasycap->audio_idle\n", peasycap->isdongle,
           "adjust_mute", peasycap->audio_idle);
#line 928
    return (0);
    default: 
#line 931
    peasycap->audio_idle = 0;
#line 932
    printk("<7>easycap::%i%s: adjusting mute: %i=peasycap->audio_idle\n", peasycap->isdongle,
           "adjust_mute", peasycap->audio_idle);
#line 934
    return (0);
    }
#line 937
    goto ldv_32679;
  } else {

  }
#line 939
  i1 = i1 + 1;
  ldv_32681: ;
#line 920
  if (easycap_control[i1].id != 4294967295U) {
#line 922
    goto ldv_32680;
  } else {

  }
  ldv_32679: 
#line 941
  printk("<7>easycap::%i%s: WARNING: failed to adjust mute: control not found\n",
         peasycap->isdongle, "adjust_mute");
#line 942
  return (-2);
}
}
#line 945 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_ioctl.c"
long easycap_unlocked_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ 
  struct easycap *peasycap ;
  struct usb_device *p ;
  int kd ;
  int tmp ;
  int tmp___0 ;
  struct v4l2_capability v4l2_capability ;
  char version[16U] ;
  char *p1 ;
  char *p2 ;
  int i ;
  int rc ;
  int k[3U] ;
  long lng ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct v4l2_input v4l2_input ;
  u32 index ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  u32 index___0 ;
  int tmp___7 ;
  u32 index___1 ;
  int rc___0 ;
  unsigned long tmp___8 ;
  struct v4l2_audioout v4l2_audioout ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  int i1 ;
  struct v4l2_queryctrl v4l2_queryctrl ;
  unsigned long tmp___11 ;
  size_t __len ;
  void *__ret ;
  int tmp___12 ;
  struct v4l2_control *pv4l2_control ;
  void *tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  struct v4l2_control v4l2_control ;
  unsigned long tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int mute ;
  int tmp___23 ;
  u32 index___2 ;
  struct v4l2_fmtdesc v4l2_fmtdesc ;
  unsigned long tmp___24 ;
  int tmp___25 ;
  u32 index___3 ;
  struct v4l2_frmsizeenum v4l2_frmsizeenum ;
  unsigned long tmp___26 ;
  int tmp___27 ;
  u32 index___4 ;
  int denominator ;
  struct v4l2_frmivalenum v4l2_frmivalenum ;
  unsigned long tmp___28 ;
  int tmp___29 ;
  struct v4l2_format *pv4l2_format ;
  struct v4l2_pix_format *pv4l2_pix_format ;
  void *tmp___30 ;
  void *tmp___31 ;
  unsigned long tmp___32 ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___33 ;
  struct v4l2_format v4l2_format ;
  struct v4l2_pix_format v4l2_pix_format ;
  bool try ;
  int best_format ;
  unsigned long tmp___34 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___35 ;
  struct v4l2_cropcap v4l2_cropcap ;
  unsigned long tmp___36 ;
  int tmp___37 ;
  int last0 ;
  int last1 ;
  int last2 ;
  int last3 ;
  struct v4l2_standard v4l2_standard ;
  u32 index___5 ;
  struct easycap_standard  const  *peasycap_standard ;
  unsigned long tmp___38 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___39 ;
  v4l2_std_id std_id ;
  struct easycap_standard  const  *peasycap_standard___0 ;
  unsigned long tmp___40 ;
  int tmp___41 ;
  v4l2_std_id std_id___0 ;
  int rc___1 ;
  unsigned long tmp___42 ;
  int nbuffers ;
  struct v4l2_requestbuffers v4l2_requestbuffers ;
  unsigned long tmp___43 ;
  int tmp___44 ;
  u32 index___6 ;
  struct v4l2_buffer v4l2_buffer ;
  unsigned long tmp___45 ;
  int tmp___46 ;
  struct v4l2_buffer v4l2_buffer___0 ;
  unsigned long tmp___47 ;
  int tmp___48 ;
  struct timeval timeval ;
  struct timeval timeval2 ;
  int i___0 ;
  int j ;
  struct v4l2_buffer v4l2_buffer___1 ;
  int rcdq ;
  u16 input ;
  unsigned long tmp___49 ;
  u32 tmp___50 ;
  int tmp___51 ;
  int i___1 ;
  struct v4l2_streamparm *pv4l2_streamparm ;
  void *tmp___52 ;
  long tmp___53 ;
  long tmp___54 ;
  int tmp___55 ;

  {
#line 952
  if ((unsigned long )file == (unsigned long )((struct file *)0)) {
#line 953
    printk("<7>easycap:: %s: OLD_ERROR:  file is NULL\n", "easycap_unlocked_ioctl");
#line 954
    return (-512L);
  } else {

  }
#line 956
  peasycap = (struct easycap *)file->private_data;
#line 957
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 958
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_unlocked_ioctl");
#line 959
    return (-1L);
  } else {

  }
#line 961
  p = peasycap->pusb_device;
#line 962
  if ((unsigned long )p == (unsigned long )((struct usb_device *)0)) {
#line 963
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
#line 964
    return (-14L);
  } else {

  }
#line 966
  kd = easycap_isdongle(peasycap);
#line 967
  if (kd >= 0 && kd <= 7) {
#line 968
    tmp = mutex_lock_interruptible_nested(& easycapdc60_dongle[kd].mutex_video, 0U);
#line 968
    if (tmp != 0) {
#line 969
      printk("<7>easycap:: %s: OLD_ERROR: cannot lock easycapdc60_dongle[%i].mutex_video\n",
             "easycap_unlocked_ioctl", kd);
#line 971
      return (-512L);
    } else {

    }
#line 973
    if (easycap_debug > 3) {
#line 973
      printk("<7>easycap::%i%s: locked easycapdc60_dongle[%i].mutex_video\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", kd);
    } else {

    }
#line 981
    tmp___0 = easycap_isdongle(peasycap);
#line 981
    if (tmp___0 != kd) {
#line 982
      return (-512L);
    } else {

    }
#line 983
    if ((unsigned long )file == (unsigned long )((struct file *)0)) {
#line 984
      printk("<7>easycap:: %s: OLD_ERROR:  file is NULL\n", "easycap_unlocked_ioctl");
#line 985
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 986
      return (-512L);
    } else {

    }
#line 988
    peasycap = (struct easycap *)file->private_data;
#line 989
    if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 990
      printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_unlocked_ioctl");
#line 991
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 992
      return (-512L);
    } else {

    }
#line 994
    if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 995
      printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
             "easycap_unlocked_ioctl");
#line 996
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 997
      return (-512L);
    } else {

    }
  } else {
#line 1006
    return (-512L);
  }
#line 1009
  switch (cmd) {
  case 2154321408U: ;
#line 1016
  if (easycap_debug > 7) {
#line 1016
    printk("<7>easycap::%i%s: VIDIOC_QUERYCAP\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1018
  tmp___1 = strlen("0.9.01");
#line 1018
  if (tmp___1 > 15UL) {
#line 1019
    printk("<7>easycap::%i%s: OLD_ERROR: bad driver version string\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
#line 1020
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1021
    return (-22L);
  } else {

  }
#line 1023
  strcpy((char *)(& version), "0.9.01");
#line 1024
  i = 0;
#line 1024
  goto ldv_32701;
  ldv_32700: 
#line 1025
  k[i] = 0;
#line 1024
  i = i + 1;
  ldv_32701: ;
#line 1024
  if (i <= 2) {
#line 1026
    goto ldv_32700;
  } else {

  }
#line 1026
  p2 = (char *)(& version);
#line 1027
  i = 0;
#line 1028
  goto ldv_32707;
  ldv_32706: 
#line 1029
  p1 = p2;
#line 1030
  goto ldv_32704;
  ldv_32703: 
#line 1031
  p2 = p2 + 1;
  ldv_32704: ;
#line 1030
  if ((int )((signed char )*p2) != 0 && (int )((signed char )*p2) != 46) {
#line 1032
    goto ldv_32703;
  } else {

  }

#line 1032
  if ((int )((signed char )*p2) != 0) {
#line 1033
    tmp___2 = p2;
#line 1033
    p2 = p2 + 1;
#line 1033
    *tmp___2 = 0;
  } else {

  }
#line 1034
  if (i <= 2) {
#line 1035
    rc = kstrtol((char const   *)p1, 10U, & lng);
#line 1036
    if (rc != 0) {
#line 1037
      printk("<7>easycap::%i%s: OLD_ERROR: %i=strict_strtol(%s,.,,)\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", rc, p1);
#line 1039
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1040
      return (-22L);
    } else {

    }
#line 1042
    k[i] = (int )lng;
  } else {

  }
#line 1044
  i = i + 1;
  ldv_32707: ;
#line 1028
  if ((int )((signed char )*p2) != 0) {
#line 1030
    goto ldv_32706;
  } else {

  }
#line 1047
  memset((void *)(& v4l2_capability), 0, 104UL);
#line 1048
  strlcpy((char *)(& v4l2_capability.driver), "easycap", 16UL);
#line 1051
  v4l2_capability.capabilities = 84017153U;
#line 1056
  v4l2_capability.version = (__u32 )(((k[0] << 16) + (k[1] << 8)) + k[2]);
#line 1057
  if (easycap_debug > 7) {
#line 1057
    printk("<7>easycap::%i%s: v4l2_capability.version=(%i,%i,%i)\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", k[0], k[1], k[2]);
  } else {

  }
#line 1059
  strlcpy((char *)(& v4l2_capability.card), "EasyCAP DC60", 32UL);
#line 1062
  tmp___3 = usb_make_path(peasycap->pusb_device, (char *)(& v4l2_capability.bus_info),
                          32UL);
#line 1062
  if (tmp___3 < 0) {
#line 1066
    strlcpy((char *)(& v4l2_capability.bus_info), "EasyCAP bus_info", 32UL);
#line 1068
    if (easycap_debug > 7) {
#line 1068
      printk("<7>easycap::%i%s: %s=v4l2_capability.bus_info\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", (__u8 *)(& v4l2_capability.bus_info));
    } else {

    }
  } else {

  }
#line 1071
  tmp___4 = copy_to_user((void *)arg, (void const   *)(& v4l2_capability), 104U);
#line 1071
  if (tmp___4 != 0) {
#line 1073
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1074
    return (-14L);
  } else {

  }
#line 1076
  goto ldv_32709;
  case 3226490394U: ;
#line 1083
  if (easycap_debug > 7) {
#line 1083
    printk("<7>easycap::%i%s: VIDIOC_ENUMINPUT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1085
  tmp___5 = copy_from_user((void *)(& v4l2_input), (void const   *)arg, 80UL);
#line 1085
  if (tmp___5 != 0UL) {
#line 1087
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1088
    return (-14L);
  } else {

  }
#line 1091
  index = v4l2_input.index;
#line 1092
  memset((void *)(& v4l2_input), 0, 80UL);
#line 1094
  switch (index) {
  case 0U: 
#line 1096
  v4l2_input.index = index;
#line 1097
  strcpy((char *)(& v4l2_input.name), "CVBS0");
#line 1098
  v4l2_input.type = 2U;
#line 1099
  v4l2_input.audioset = 1U;
#line 1100
  v4l2_input.tuner = 0U;
#line 1101
  v4l2_input.std = 16756991ULL;
#line 1104
  v4l2_input.status = 0U;
#line 1105
  if (easycap_debug > 7) {
#line 1105
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index, (__u8 *)(& v4l2_input.name));
  } else {

  }
#line 1106
  goto ldv_32714;
  case 1U: 
#line 1109
  v4l2_input.index = index;
#line 1110
  strcpy((char *)(& v4l2_input.name), "CVBS1");
#line 1111
  v4l2_input.type = 2U;
#line 1112
  v4l2_input.audioset = 1U;
#line 1113
  v4l2_input.tuner = 0U;
#line 1114
  v4l2_input.std = 16756991ULL;
#line 1116
  v4l2_input.status = 0U;
#line 1117
  if (easycap_debug > 7) {
#line 1117
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index, (__u8 *)(& v4l2_input.name));
  } else {

  }
#line 1118
  goto ldv_32714;
  case 2U: 
#line 1121
  v4l2_input.index = index;
#line 1122
  strcpy((char *)(& v4l2_input.name), "CVBS2");
#line 1123
  v4l2_input.type = 2U;
#line 1124
  v4l2_input.audioset = 1U;
#line 1125
  v4l2_input.tuner = 0U;
#line 1126
  v4l2_input.std = 16756991ULL;
#line 1128
  v4l2_input.status = 0U;
#line 1129
  if (easycap_debug > 7) {
#line 1129
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index, (__u8 *)(& v4l2_input.name));
  } else {

  }
#line 1130
  goto ldv_32714;
  case 3U: 
#line 1133
  v4l2_input.index = index;
#line 1134
  strcpy((char *)(& v4l2_input.name), "CVBS3");
#line 1135
  v4l2_input.type = 2U;
#line 1136
  v4l2_input.audioset = 1U;
#line 1137
  v4l2_input.tuner = 0U;
#line 1138
  v4l2_input.std = 16756991ULL;
#line 1140
  v4l2_input.status = 0U;
#line 1141
  if (easycap_debug > 7) {
#line 1141
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index, (__u8 *)(& v4l2_input.name));
  } else {

  }
#line 1142
  goto ldv_32714;
  case 4U: 
#line 1145
  v4l2_input.index = index;
#line 1146
  strcpy((char *)(& v4l2_input.name), "CVBS4");
#line 1147
  v4l2_input.type = 2U;
#line 1148
  v4l2_input.audioset = 1U;
#line 1149
  v4l2_input.tuner = 0U;
#line 1150
  v4l2_input.std = 16756991ULL;
#line 1152
  v4l2_input.status = 0U;
#line 1153
  if (easycap_debug > 7) {
#line 1153
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index, (__u8 *)(& v4l2_input.name));
  } else {

  }
#line 1154
  goto ldv_32714;
  case 5U: 
#line 1157
  v4l2_input.index = index;
#line 1158
  strcpy((char *)(& v4l2_input.name), "S-VIDEO");
#line 1159
  v4l2_input.type = 2U;
#line 1160
  v4l2_input.audioset = 1U;
#line 1161
  v4l2_input.tuner = 0U;
#line 1162
  v4l2_input.std = 16756991ULL;
#line 1164
  v4l2_input.status = 0U;
#line 1165
  if (easycap_debug > 7) {
#line 1165
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index, (__u8 *)(& v4l2_input.name));
  } else {

  }
#line 1166
  goto ldv_32714;
  default: ;
#line 1169
  if (easycap_debug > 7) {
#line 1169
    printk("<7>easycap::%i%s: %i=index: exhausts inputs\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index);
  } else {

  }
#line 1170
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1171
  return (-22L);
  }
  ldv_32714: 
#line 1175
  tmp___6 = copy_to_user((void *)arg, (void const   *)(& v4l2_input), 80U);
#line 1175
  if (tmp___6 != 0) {
#line 1177
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1178
    return (-14L);
  } else {

  }
#line 1180
  goto ldv_32709;
  case 2147767846U: ;
#line 1186
  if (easycap_debug > 7) {
#line 1186
    printk("<7>easycap::%i%s: VIDIOC_G_INPUT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1187
  index___0 = (unsigned int )peasycap->input;
#line 1188
  if (easycap_debug > 7) {
#line 1188
    printk("<7>easycap::%i%s: user is told: %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___0);
  } else {

  }
#line 1189
  tmp___7 = copy_to_user((void *)arg, (void const   *)(& index___0), 4U);
#line 1189
  if (tmp___7 != 0) {
#line 1190
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1191
    return (-14L);
  } else {

  }
#line 1193
  goto ldv_32709;
  case 3221509671U: ;
#line 1201
  if (easycap_debug > 7) {
#line 1201
    printk("<7>easycap::%i%s: VIDIOC_S_INPUT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1203
  tmp___8 = copy_from_user((void *)(& index___1), (void const   *)arg, 4UL);
#line 1203
  if (tmp___8 != 0UL) {
#line 1204
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1205
    return (-14L);
  } else {

  }
#line 1208
  if (easycap_debug > 7) {
#line 1208
    printk("<7>easycap::%i%s: user requests input %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___1);
  } else {

  }
#line 1210
  if ((int )index___1 == peasycap->input) {
#line 1211
    printk("<7>easycap::%i%s: requested input already in effect\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
#line 1212
    goto ldv_32709;
  } else {

  }
#line 1215
  if (index___1 > 5U) {
#line 1216
    if (easycap_debug > 7) {
#line 1216
      printk("<7>easycap::%i%s: OLD_ERROR:  bad requested input: %i\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", index___1);
    } else {

    }
#line 1217
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1218
    return (-22L);
  } else {

  }
#line 1221
  rc___0 = easycap_newinput(peasycap, (int )index___1);
#line 1222
  if (rc___0 == 0) {
#line 1223
    if (easycap_debug > 7) {
#line 1223
      printk("<7>easycap::%i%s: newinput(.,%i) OK\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             (int )index___1);
    } else {

    }
  } else {
#line 1225
    printk("<7>easycap::%i%s: OLD_ERROR: newinput(.,%i) returned %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", (int )index___1, rc___0);
#line 1226
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1227
    return (-14L);
  }
#line 1229
  goto ldv_32709;
  case 3224655425U: ;
#line 1233
  if (easycap_debug > 7) {
#line 1233
    printk("<7>easycap::%i%s: VIDIOC_ENUMAUDIO\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1234
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1235
  return (-22L);
  case 3224655426U: ;
#line 1241
  if (easycap_debug > 7) {
#line 1241
    printk("<7>easycap::%i%s: VIDIOC_ENUMAUDOUT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1243
  tmp___9 = copy_from_user((void *)(& v4l2_audioout), (void const   *)arg, 52UL);
#line 1243
  if (tmp___9 != 0UL) {
#line 1245
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1246
    return (-14L);
  } else {

  }
#line 1249
  if (v4l2_audioout.index != 0U) {
#line 1250
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1251
    return (-22L);
  } else {

  }
#line 1253
  memset((void *)(& v4l2_audioout), 0, 52UL);
#line 1254
  v4l2_audioout.index = 0U;
#line 1255
  strcpy((char *)(& v4l2_audioout.name), "Soundtrack");
#line 1257
  tmp___10 = copy_to_user((void *)arg, (void const   *)(& v4l2_audioout), 52U);
#line 1257
  if (tmp___10 != 0) {
#line 1259
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1260
    return (-14L);
  } else {

  }
#line 1262
  goto ldv_32709;
  case 3225703972U: ;
#line 1269
  if (easycap_debug > 7) {
#line 1269
    printk("<7>easycap::%i%s: VIDIOC_QUERYCTRL\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1271
  tmp___11 = copy_from_user((void *)(& v4l2_queryctrl), (void const   *)arg, 68UL);
#line 1271
  if (tmp___11 != 0UL) {
#line 1273
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1274
    return (-14L);
  } else {

  }
#line 1277
  i1 = 0;
#line 1278
  goto ldv_32737;
  ldv_32736: ;
#line 1279
  if (easycap_control[i1].id == v4l2_queryctrl.id) {
#line 1280
    if (easycap_debug > 7) {
#line 1280
      printk("<7>easycap::%i%s: VIDIOC_QUERYCTRL  %s=easycap_control[%i].name\n",
             peasycap->isdongle, "easycap_unlocked_ioctl", (__u8 *)(& easycap_control[i1].name),
             i1);
    } else {

    }
#line 1282
    __len = 68UL;
#line 1282
    if (__len > 63UL) {
#line 1282
      __ret = memcpy((void *)(& v4l2_queryctrl), (void const   *)(& easycap_control) + (unsigned long )i1,
                       __len);
    } else {
#line 1282
      __ret = __builtin_memcpy((void *)(& v4l2_queryctrl), (void const   *)(& easycap_control) + (unsigned long )i1,
                               __len);
    }
#line 1284
    goto ldv_32735;
  } else {

  }
#line 1286
  i1 = i1 + 1;
  ldv_32737: ;
#line 1278
  if (easycap_control[i1].id != 4294967295U) {
#line 1280
    goto ldv_32736;
  } else {

  }
  ldv_32735: ;
#line 1288
  if (easycap_control[i1].id == 4294967295U) {
#line 1289
    if (easycap_debug > 7) {
#line 1289
      printk("<7>easycap::%i%s: %i=index: exhausts controls\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", i1);
    } else {

    }
#line 1290
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1291
    return (-22L);
  } else {

  }
#line 1293
  tmp___12 = copy_to_user((void *)arg, (void const   *)(& v4l2_queryctrl), 68U);
#line 1293
  if (tmp___12 != 0) {
#line 1295
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1296
    return (-14L);
  } else {

  }
#line 1298
  goto ldv_32709;
  case 3224131109U: ;
#line 1302
  if (easycap_debug > 7) {
#line 1302
    printk("<7>easycap::%i%s: VIDIOC_QUERYMENU unsupported\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
  } else {

  }
#line 1303
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1304
  return (-22L);
  case 3221771803U: ;
#line 1310
  if (easycap_debug > 7) {
#line 1310
    printk("<7>easycap::%i%s: VIDIOC_G_CTRL\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1311
  tmp___13 = memdup_user((void const   *)arg, 8UL);
#line 1311
  pv4l2_control = (struct v4l2_control *)tmp___13;
#line 1313
  tmp___15 = IS_ERR((void const   *)pv4l2_control);
#line 1313
  if (tmp___15 != 0L) {
#line 1314
    printk("<7>easycap::%i%s: OLD_ERROR: copy from user failed\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
#line 1315
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1316
    tmp___14 = PTR_ERR((void const   *)pv4l2_control);
#line 1316
    return (tmp___14);
  } else {

  }
#line 1319
  switch (pv4l2_control->id) {
  case 9963776U: 
#line 1321
  pv4l2_control->value = peasycap->brightness;
#line 1322
  if (easycap_debug > 7) {
#line 1322
    printk("<7>easycap::%i%s: user enquires brightness: %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", pv4l2_control->value);
  } else {

  }
#line 1323
  goto ldv_32742;
  case 9963777U: 
#line 1326
  pv4l2_control->value = peasycap->contrast;
#line 1327
  if (easycap_debug > 7) {
#line 1327
    printk("<7>easycap::%i%s: user enquires contrast: %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           pv4l2_control->value);
  } else {

  }
#line 1328
  goto ldv_32742;
  case 9963778U: 
#line 1331
  pv4l2_control->value = peasycap->saturation;
#line 1332
  if (easycap_debug > 7) {
#line 1332
    printk("<7>easycap::%i%s: user enquires saturation: %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", pv4l2_control->value);
  } else {

  }
#line 1333
  goto ldv_32742;
  case 9963779U: 
#line 1336
  pv4l2_control->value = peasycap->hue;
#line 1337
  if (easycap_debug > 7) {
#line 1337
    printk("<7>easycap::%i%s: user enquires hue: %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           pv4l2_control->value);
  } else {

  }
#line 1338
  goto ldv_32742;
  case 9963781U: 
#line 1341
  pv4l2_control->value = peasycap->volume;
#line 1342
  if (easycap_debug > 7) {
#line 1342
    printk("<7>easycap::%i%s: user enquires volume: %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           pv4l2_control->value);
  } else {

  }
#line 1343
  goto ldv_32742;
  case 9963785U: ;
#line 1346
  if (peasycap->mute == 1) {
#line 1347
    pv4l2_control->value = 1;
  } else {
#line 1349
    pv4l2_control->value = 0;
  }
#line 1350
  if (easycap_debug > 7) {
#line 1350
    printk("<7>easycap::%i%s: user enquires mute: %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           pv4l2_control->value);
  } else {

  }
#line 1351
  goto ldv_32742;
  default: 
#line 1354
  printk("<7>easycap::%i%s: OLD_ERROR: unknown V4L2 control: 0x%08X=id\n", peasycap->isdongle,
         "easycap_unlocked_ioctl", pv4l2_control->id);
#line 1356
  kfree((void const   *)pv4l2_control);
#line 1357
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1358
  return (-22L);
  }
  ldv_32742: 
#line 1361
  tmp___16 = copy_to_user((void *)arg, (void const   *)pv4l2_control, 8U);
#line 1361
  if (tmp___16 != 0) {
#line 1363
    kfree((void const   *)pv4l2_control);
#line 1364
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1365
    return (-14L);
  } else {

  }
#line 1367
  kfree((void const   *)pv4l2_control);
#line 1368
  goto ldv_32709;
  case 3221771804U: ;
#line 1374
  if (easycap_debug > 7) {
#line 1374
    printk("<7>easycap::%i%s: VIDIOC_S_CTRL\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1376
  tmp___17 = copy_from_user((void *)(& v4l2_control), (void const   *)arg, 8UL);
#line 1376
  if (tmp___17 != 0UL) {
#line 1378
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1379
    return (-14L);
  } else {

  }
#line 1382
  switch (v4l2_control.id) {
  case 9963776U: ;
#line 1384
  if (easycap_debug > 7) {
#line 1384
    printk("<7>easycap::%i%s: user requests brightness %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", v4l2_control.value);
  } else {

  }
#line 1385
  tmp___18 = adjust_brightness(peasycap, v4l2_control.value);
#line 1387
  goto ldv_32752;
  case 9963777U: ;
#line 1390
  if (easycap_debug > 7) {
#line 1390
    printk("<7>easycap::%i%s: user requests contrast %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_control.value);
  } else {

  }
#line 1391
  tmp___19 = adjust_contrast(peasycap, v4l2_control.value);
#line 1393
  goto ldv_32752;
  case 9963778U: ;
#line 1396
  if (easycap_debug > 7) {
#line 1396
    printk("<7>easycap::%i%s: user requests saturation %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", v4l2_control.value);
  } else {

  }
#line 1397
  tmp___20 = adjust_saturation(peasycap, v4l2_control.value);
#line 1399
  goto ldv_32752;
  case 9963779U: ;
#line 1402
  if (easycap_debug > 7) {
#line 1402
    printk("<7>easycap::%i%s: user requests hue %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_control.value);
  } else {

  }
#line 1403
  tmp___21 = adjust_hue(peasycap, v4l2_control.value);
#line 1405
  goto ldv_32752;
  case 9963781U: ;
#line 1408
  if (easycap_debug > 7) {
#line 1408
    printk("<7>easycap::%i%s: user requests volume %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_control.value);
  } else {

  }
#line 1409
  tmp___22 = adjust_volume(peasycap, v4l2_control.value);
#line 1411
  goto ldv_32752;
  case 9963785U: ;
#line 1416
  if (easycap_debug > 7) {
#line 1416
    printk("<7>easycap::%i%s: user requests mute %i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_control.value);
  } else {

  }
#line 1417
  if (v4l2_control.value != 0) {
#line 1418
    mute = 1;
  } else {
#line 1420
    mute = 0;
  }
#line 1422
  tmp___23 = adjust_mute(peasycap, mute);
#line 1422
  if (tmp___23 != 0) {
#line 1423
    printk("<7>easycap::%i%s: WARNING: failed to adjust mute to %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", mute);
  } else {

  }
#line 1424
  goto ldv_32752;
  default: 
#line 1427
  printk("<7>easycap::%i%s: OLD_ERROR: unknown V4L2 control: 0x%08X=id\n", peasycap->isdongle,
         "easycap_unlocked_ioctl", v4l2_control.id);
#line 1429
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1430
  return (-22L);
  }
  ldv_32752: ;
#line 1433
  goto ldv_32709;
  case 3223344712U: ;
#line 1437
  if (easycap_debug > 7) {
#line 1437
    printk("<7>easycap::%i%s: VIDIOC_S_EXT_CTRLS unsupported\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
  } else {

  }
#line 1438
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1439
  return (-22L);
  case 3225441794U: ;
#line 1446
  if (easycap_debug > 7) {
#line 1446
    printk("<7>easycap::%i%s: VIDIOC_ENUM_FMT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1448
  tmp___24 = copy_from_user((void *)(& v4l2_fmtdesc), (void const   *)arg, 64UL);
#line 1448
  if (tmp___24 != 0UL) {
#line 1450
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1451
    return (-14L);
  } else {

  }
#line 1454
  index___2 = v4l2_fmtdesc.index;
#line 1455
  memset((void *)(& v4l2_fmtdesc), 0, 64UL);
#line 1457
  v4l2_fmtdesc.index = index___2;
#line 1458
  v4l2_fmtdesc.type = 1;
#line 1460
  switch (index___2) {
  case 0U: 
#line 1462
  v4l2_fmtdesc.flags = 0U;
#line 1463
  strcpy((char *)(& v4l2_fmtdesc.description), "uyvy");
#line 1464
  v4l2_fmtdesc.pixelformat = 1498831189U;
#line 1465
  if (easycap_debug > 7) {
#line 1465
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___2, (__u8 *)(& v4l2_fmtdesc.description));
  } else {

  }
#line 1466
  goto ldv_32765;
  case 1U: 
#line 1469
  v4l2_fmtdesc.flags = 0U;
#line 1470
  strcpy((char *)(& v4l2_fmtdesc.description), "yuy2");
#line 1471
  v4l2_fmtdesc.pixelformat = 1448695129U;
#line 1472
  if (easycap_debug > 7) {
#line 1472
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___2, (__u8 *)(& v4l2_fmtdesc.description));
  } else {

  }
#line 1473
  goto ldv_32765;
  case 2U: 
#line 1476
  v4l2_fmtdesc.flags = 0U;
#line 1477
  strcpy((char *)(& v4l2_fmtdesc.description), "rgb24");
#line 1478
  v4l2_fmtdesc.pixelformat = 859981650U;
#line 1479
  if (easycap_debug > 7) {
#line 1479
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___2, (__u8 *)(& v4l2_fmtdesc.description));
  } else {

  }
#line 1480
  goto ldv_32765;
  case 3U: 
#line 1483
  v4l2_fmtdesc.flags = 0U;
#line 1484
  strcpy((char *)(& v4l2_fmtdesc.description), "rgb32");
#line 1485
  v4l2_fmtdesc.pixelformat = 876758866U;
#line 1486
  if (easycap_debug > 7) {
#line 1486
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___2, (__u8 *)(& v4l2_fmtdesc.description));
  } else {

  }
#line 1487
  goto ldv_32765;
  case 4U: 
#line 1490
  v4l2_fmtdesc.flags = 0U;
#line 1491
  strcpy((char *)(& v4l2_fmtdesc.description), "bgr24");
#line 1492
  v4l2_fmtdesc.pixelformat = 861030210U;
#line 1493
  if (easycap_debug > 7) {
#line 1493
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___2, (__u8 *)(& v4l2_fmtdesc.description));
  } else {

  }
#line 1494
  goto ldv_32765;
  case 5U: 
#line 1497
  v4l2_fmtdesc.flags = 0U;
#line 1498
  strcpy((char *)(& v4l2_fmtdesc.description), "bgr32");
#line 1499
  v4l2_fmtdesc.pixelformat = 877807426U;
#line 1500
  if (easycap_debug > 7) {
#line 1500
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___2, (__u8 *)(& v4l2_fmtdesc.description));
  } else {

  }
#line 1501
  goto ldv_32765;
  default: ;
#line 1504
  if (easycap_debug > 7) {
#line 1504
    printk("<7>easycap::%i%s: %i=index: exhausts formats\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___2);
  } else {

  }
#line 1505
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1506
  return (-22L);
  }
  ldv_32765: 
#line 1509
  tmp___25 = copy_to_user((void *)arg, (void const   *)(& v4l2_fmtdesc), 64U);
#line 1509
  if (tmp___25 != 0) {
#line 1511
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1512
    return (-14L);
  } else {

  }
#line 1514
  goto ldv_32709;
  case 3224131146U: ;
#line 1526
  if (easycap_debug > 7) {
#line 1526
    printk("<7>easycap::%i%s: VIDIOC_ENUM_FRAMESIZES\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1528
  tmp___26 = copy_from_user((void *)(& v4l2_frmsizeenum), (void const   *)arg, 44UL);
#line 1528
  if (tmp___26 != 0UL) {
#line 1530
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1531
    return (-14L);
  } else {

  }
#line 1534
  index___3 = v4l2_frmsizeenum.index;
#line 1536
  v4l2_frmsizeenum.type = 1U;
#line 1538
  if ((int )peasycap->ntsc) {
#line 1539
    switch (index___3) {
    case 0U: 
#line 1541
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 640U;
#line 1542
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 480U;
#line 1543
    if (easycap_debug > 7) {
#line 1543
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1548
    goto ldv_32776;
    case 1U: 
#line 1551
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 320U;
#line 1552
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 240U;
#line 1553
    if (easycap_debug > 7) {
#line 1553
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1558
    goto ldv_32776;
    case 2U: 
#line 1561
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 720U;
#line 1562
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 480U;
#line 1563
    if (easycap_debug > 7) {
#line 1563
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1568
    goto ldv_32776;
    case 3U: 
#line 1571
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 360U;
#line 1572
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 240U;
#line 1573
    if (easycap_debug > 7) {
#line 1573
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1578
    goto ldv_32776;
    default: ;
#line 1581
    if (easycap_debug > 7) {
#line 1581
      printk("<7>easycap::%i%s: %i=index: exhausts framesizes\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", index___3);
    } else {

    }
#line 1582
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1583
    return (-22L);
    }
    ldv_32776: ;
  } else {
#line 1587
    switch (index___3) {
    case 0U: 
#line 1589
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 640U;
#line 1590
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 480U;
#line 1591
    if (easycap_debug > 7) {
#line 1591
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1596
    goto ldv_32782;
    case 1U: 
#line 1599
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 320U;
#line 1600
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 240U;
#line 1601
    if (easycap_debug > 7) {
#line 1601
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1606
    goto ldv_32782;
    case 2U: 
#line 1609
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 704U;
#line 1610
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 576U;
#line 1611
    if (easycap_debug > 7) {
#line 1611
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1616
    goto ldv_32782;
    case 3U: 
#line 1619
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 720U;
#line 1620
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 576U;
#line 1621
    if (easycap_debug > 7) {
#line 1621
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1626
    goto ldv_32782;
    case 4U: 
#line 1629
    v4l2_frmsizeenum.__annonCompField48.discrete.width = 360U;
#line 1630
    v4l2_frmsizeenum.__annonCompField48.discrete.height = 288U;
#line 1631
    if (easycap_debug > 7) {
#line 1631
      printk("<7>easycap::%i%s: %i=index: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
             index___3, (int )v4l2_frmsizeenum.__annonCompField48.discrete.width,
             (int )v4l2_frmsizeenum.__annonCompField48.discrete.height);
    } else {

    }
#line 1636
    goto ldv_32782;
    default: ;
#line 1639
    if (easycap_debug > 7) {
#line 1639
      printk("<7>easycap::%i%s: %i=index: exhausts framesizes\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", index___3);
    } else {

    }
#line 1640
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1641
    return (-22L);
    }
    ldv_32782: ;
  }
#line 1645
  tmp___27 = copy_to_user((void *)arg, (void const   *)(& v4l2_frmsizeenum), 44U);
#line 1645
  if (tmp___27 != 0) {
#line 1647
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1648
    return (-14L);
  } else {

  }
#line 1650
  goto ldv_32709;
  case 3224655435U: ;
#line 1663
  if (easycap_debug > 7) {
#line 1663
    printk("<7>easycap::%i%s: VIDIOC_ENUM_FRAMEINTERVALS\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1665
  if (peasycap->fps != 0) {
#line 1666
    denominator = peasycap->fps;
  } else
#line 1668
  if ((int )peasycap->ntsc) {
#line 1669
    denominator = 30;
  } else {
#line 1671
    denominator = 25;
  }
#line 1674
  tmp___28 = copy_from_user((void *)(& v4l2_frmivalenum), (void const   *)arg, 52UL);
#line 1674
  if (tmp___28 != 0UL) {
#line 1676
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1677
    return (-14L);
  } else {

  }
#line 1680
  index___4 = v4l2_frmivalenum.index;
#line 1682
  v4l2_frmivalenum.type = 1U;
#line 1684
  switch (index___4) {
  case 0U: 
#line 1686
  v4l2_frmivalenum.__annonCompField49.discrete.numerator = 1U;
#line 1687
  v4l2_frmivalenum.__annonCompField49.discrete.denominator = (__u32 )denominator;
#line 1688
  if (easycap_debug > 7) {
#line 1688
    printk("<7>easycap::%i%s: %i=index: %i/%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___4, (int )v4l2_frmivalenum.__annonCompField49.discrete.numerator,
           (int )v4l2_frmivalenum.__annonCompField49.discrete.denominator);
  } else {

  }
#line 1691
  goto ldv_32793;
  case 1U: 
#line 1694
  v4l2_frmivalenum.__annonCompField49.discrete.numerator = 1U;
#line 1695
  v4l2_frmivalenum.__annonCompField49.discrete.denominator = (__u32 )(denominator / 5);
#line 1696
  if (easycap_debug > 7) {
#line 1696
    printk("<7>easycap::%i%s: %i=index: %i/%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___4, (int )v4l2_frmivalenum.__annonCompField49.discrete.numerator,
           (int )v4l2_frmivalenum.__annonCompField49.discrete.denominator);
  } else {

  }
#line 1699
  goto ldv_32793;
  default: ;
#line 1702
  if (easycap_debug > 7) {
#line 1702
    printk("<7>easycap::%i%s: %i=index: exhausts frameintervals\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", index___4);
  } else {

  }
#line 1703
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1704
  return (-22L);
  }
  ldv_32793: 
#line 1707
  tmp___29 = copy_to_user((void *)arg, (void const   *)(& v4l2_frmivalenum), 52U);
#line 1707
  if (tmp___29 != 0) {
#line 1709
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1710
    return (-14L);
  } else {

  }
#line 1712
  goto ldv_32709;
  case 3234878980U: ;
#line 1719
  if (easycap_debug > 7) {
#line 1719
    printk("<7>easycap::%i%s: VIDIOC_G_FMT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1720
  tmp___30 = kzalloc(208UL, 208U);
#line 1720
  pv4l2_format = (struct v4l2_format *)tmp___30;
#line 1721
  if ((unsigned long )pv4l2_format == (unsigned long )((struct v4l2_format *)0)) {
#line 1722
    printk("<7>easycap::%i%s: OLD_ERROR: out of memory\n", peasycap->isdongle, "easycap_unlocked_ioctl");
#line 1723
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1724
    return (-12L);
  } else {

  }
#line 1726
  tmp___31 = kzalloc(32UL, 208U);
#line 1726
  pv4l2_pix_format = (struct v4l2_pix_format *)tmp___31;
#line 1727
  if ((unsigned long )pv4l2_pix_format == (unsigned long )((struct v4l2_pix_format *)0)) {
#line 1728
    printk("<7>easycap::%i%s: OLD_ERROR: out of memory\n", peasycap->isdongle, "easycap_unlocked_ioctl");
#line 1729
    kfree((void const   *)pv4l2_format);
#line 1730
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1731
    return (-12L);
  } else {

  }
#line 1733
  tmp___32 = copy_from_user((void *)pv4l2_format, (void const   *)arg, 208UL);
#line 1733
  if (tmp___32 != 0UL) {
#line 1735
    kfree((void const   *)pv4l2_format);
#line 1736
    kfree((void const   *)pv4l2_pix_format);
#line 1737
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1738
    return (-14L);
  } else {

  }
#line 1741
  if ((unsigned int )pv4l2_format->type != 1U) {
#line 1742
    kfree((void const   *)pv4l2_format);
#line 1743
    kfree((void const   *)pv4l2_pix_format);
#line 1744
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1745
    return (-22L);
  } else {

  }
#line 1748
  memset((void *)pv4l2_pix_format, 0, 32UL);
#line 1749
  pv4l2_format->type = 1;
#line 1750
  __len___0 = 32UL;
#line 1750
  if (__len___0 > 63UL) {
#line 1750
    __ret___0 = memcpy((void *)(& pv4l2_format->fmt.pix), (void const   *)(& easycap_format[peasycap->format_offset].v4l2_format.fmt.pix),
                         __len___0);
  } else {
#line 1750
    __ret___0 = __builtin_memcpy((void *)(& pv4l2_format->fmt.pix), (void const   *)(& easycap_format[peasycap->format_offset].v4l2_format.fmt.pix),
                                 __len___0);
  }
#line 1753
  if (easycap_debug > 7) {
#line 1753
    printk("<7>easycap::%i%s: user is told: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (char *)(& easycap_format[peasycap->format_offset].name));
  } else {

  }
#line 1756
  tmp___33 = copy_to_user((void *)arg, (void const   *)pv4l2_format, 208U);
#line 1756
  if (tmp___33 != 0) {
#line 1758
    kfree((void const   *)pv4l2_format);
#line 1759
    kfree((void const   *)pv4l2_pix_format);
#line 1760
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1761
    return (-14L);
  } else {

  }
#line 1763
  kfree((void const   *)pv4l2_format);
#line 1764
  kfree((void const   *)pv4l2_pix_format);
#line 1765
  goto ldv_32709;
  case 3234879040U: ;
  case 3234878981U: ;
#line 1775
  if (cmd == 3234879040U) {
#line 1776
    if (easycap_debug > 7) {
#line 1776
      printk("<7>easycap::%i%s: VIDIOC_TRY_FMT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
    } else {

    }
#line 1777
    try = 1;
  } else {
#line 1779
    if (easycap_debug > 7) {
#line 1779
      printk("<7>easycap::%i%s: VIDIOC_S_FMT\n", peasycap->isdongle, "easycap_unlocked_ioctl");
    } else {

    }
#line 1780
    try = 0;
  }
#line 1783
  tmp___34 = copy_from_user((void *)(& v4l2_format), (void const   *)arg, 208UL);
#line 1783
  if (tmp___34 != 0UL) {
#line 1785
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1786
    return (-14L);
  } else {

  }
#line 1789
  best_format = adjust_format(peasycap, v4l2_format.fmt.pix.width, v4l2_format.fmt.pix.height,
                              v4l2_format.fmt.pix.pixelformat, (int )v4l2_format.fmt.pix.field,
                              (int )try);
#line 1795
  if (best_format < 0) {
#line 1796
    if (best_format == -16) {
#line 1797
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1798
      return (-16L);
    } else {

    }
#line 1800
    if (easycap_debug > 7) {
#line 1800
      printk("<7>easycap::%i%s: WARNING: adjust_format() returned %i\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", best_format);
    } else {

    }
#line 1801
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1802
    return (-2L);
  } else {

  }
#line 1805
  memset((void *)(& v4l2_pix_format), 0, 32UL);
#line 1806
  v4l2_format.type = 1;
#line 1808
  __len___1 = 32UL;
#line 1808
  if (__len___1 > 63UL) {
#line 1808
    __ret___1 = memcpy((void *)(& v4l2_format.fmt.pix), (void const   *)(& easycap_format[best_format].v4l2_format.fmt.pix),
                         __len___1);
  } else {
#line 1808
    __ret___1 = __builtin_memcpy((void *)(& v4l2_format.fmt.pix), (void const   *)(& easycap_format[best_format].v4l2_format.fmt.pix),
                                 __len___1);
  }
#line 1811
  if (easycap_debug > 7) {
#line 1811
    printk("<7>easycap::%i%s: user is told: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (char *)(& easycap_format[best_format].name));
  } else {

  }
#line 1813
  tmp___35 = copy_to_user((void *)arg, (void const   *)(& v4l2_format), 208U);
#line 1813
  if (tmp___35 != 0) {
#line 1815
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1816
    return (-14L);
  } else {

  }
#line 1818
  goto ldv_32709;
  case 3224131130U: ;
#line 1824
  if (easycap_debug > 7) {
#line 1824
    printk("<7>easycap::%i%s: VIDIOC_CROPCAP\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1826
  tmp___36 = copy_from_user((void *)(& v4l2_cropcap), (void const   *)arg, 44UL);
#line 1826
  if (tmp___36 != 0UL) {
#line 1828
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1829
    return (-14L);
  } else {

  }
#line 1832
  if ((unsigned int )v4l2_cropcap.type != 1U) {
#line 1833
    if (easycap_debug > 7) {
#line 1833
      printk("<7>easycap::%i%s: v4l2_cropcap.type != V4L2_BUF_TYPE_VIDEO_CAPTURE\n",
             peasycap->isdongle, "easycap_unlocked_ioctl");
    } else {

    }
  } else {

  }
#line 1835
  memset((void *)(& v4l2_cropcap), 0, 44UL);
#line 1836
  v4l2_cropcap.type = 1;
#line 1837
  v4l2_cropcap.bounds.left = 0;
#line 1838
  v4l2_cropcap.bounds.top = 0;
#line 1839
  v4l2_cropcap.bounds.width = peasycap->width;
#line 1840
  v4l2_cropcap.bounds.height = peasycap->height;
#line 1841
  v4l2_cropcap.defrect.left = 0;
#line 1842
  v4l2_cropcap.defrect.top = 0;
#line 1843
  v4l2_cropcap.defrect.width = peasycap->width;
#line 1844
  v4l2_cropcap.defrect.height = peasycap->height;
#line 1845
  v4l2_cropcap.pixelaspect.numerator = 1U;
#line 1846
  v4l2_cropcap.pixelaspect.denominator = 1U;
#line 1848
  if (easycap_debug > 7) {
#line 1848
    printk("<7>easycap::%i%s: user is told: %ix%i\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           peasycap->width, peasycap->height);
  } else {

  }
#line 1850
  tmp___37 = copy_to_user((void *)arg, (void const   *)(& v4l2_cropcap), 44U);
#line 1850
  if (tmp___37 != 0) {
#line 1852
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1853
    return (-14L);
  } else {

  }
#line 1855
  goto ldv_32709;
  case 3222558267U: ;
  case 1075074620U: ;
#line 1860
  if (easycap_debug > 7) {
#line 1860
    printk("<7>easycap::%i%s: VIDIOC_G_CROP|VIDIOC_S_CROP  unsupported\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
  } else {

  }
#line 1861
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1862
  return (-22L);
  case 2148030015U: ;
#line 1866
  if (easycap_debug > 7) {
#line 1866
    printk("<7>easycap::%i%s: VIDIOC_QUERYSTD: EasyCAP is incapable of detecting standard\n",
           peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1868
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1869
  return (-22L);
  case 3225966105U: 
#line 1881
  last0 = -1;
#line 1881
  last1 = -1;
#line 1881
  last2 = -1;
#line 1881
  last3 = -1;
#line 1886
  if (easycap_debug > 7) {
#line 1886
    printk("<7>easycap::%i%s: VIDIOC_ENUMSTD\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1888
  tmp___38 = copy_from_user((void *)(& v4l2_standard), (void const   *)arg, 72UL);
#line 1888
  if (tmp___38 != 0UL) {
#line 1890
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1891
    return (-14L);
  } else {

  }
#line 1893
  index___5 = v4l2_standard.index;
#line 1895
  last3 = last2;
#line 1896
  last2 = last1;
#line 1897
  last1 = last0;
#line 1898
  last0 = (int )index___5;
#line 1899
  if ((((u32 )last3 == index___5 && (u32 )last2 == index___5) && (u32 )last1 == index___5) && (u32 )last0 == index___5) {
#line 1901
    index___5 = index___5 + 1U;
#line 1902
    last3 = last2;
#line 1903
    last2 = last1;
#line 1904
    last1 = last0;
#line 1905
    last0 = (int )index___5;
  } else {

  }
#line 1908
  memset((void *)(& v4l2_standard), 0, 72UL);
#line 1910
  peasycap_standard = (struct easycap_standard  const  *)(& easycap_standard);
#line 1911
  goto ldv_32826;
  ldv_32825: ;
#line 1912
  if ((u32 )(((long )peasycap_standard - (long )(& easycap_standard)) / 80L) == index___5) {
#line 1913
    goto ldv_32824;
  } else {

  }
#line 1914
  peasycap_standard = peasycap_standard + 1;
  ldv_32826: ;
#line 1911
  if ((unsigned int )((unsigned short )peasycap_standard->mask) != 65535U) {
#line 1913
    goto ldv_32825;
  } else {

  }
  ldv_32824: ;
#line 1916
  if ((unsigned int )((unsigned short )peasycap_standard->mask) == 65535U) {
#line 1917
    if (easycap_debug > 7) {
#line 1917
      printk("<7>easycap::%i%s: %i=index: exhausts standards\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", index___5);
    } else {

    }
#line 1918
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1919
    return (-22L);
  } else {

  }
#line 1921
  if (easycap_debug > 7) {
#line 1921
    printk("<7>easycap::%i%s: %i=index: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           index___5, (__u8 const   *)(& peasycap_standard->v4l2_standard.name));
  } else {

  }
#line 1923
  __len___2 = 72UL;
#line 1923
  if (__len___2 > 63UL) {
#line 1923
    __ret___2 = memcpy((void *)(& v4l2_standard), (void const   *)(& peasycap_standard->v4l2_standard),
                         __len___2);
  } else {
#line 1923
    __ret___2 = __builtin_memcpy((void *)(& v4l2_standard), (void const   *)(& peasycap_standard->v4l2_standard),
                                 __len___2);
  }
#line 1926
  v4l2_standard.index = index___5;
#line 1928
  tmp___39 = copy_to_user((void *)arg, (void const   *)(& v4l2_standard), 72U);
#line 1928
  if (tmp___39 != 0) {
#line 1930
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1931
    return (-14L);
  } else {

  }
#line 1933
  goto ldv_32709;
  case 2148029975U: ;
#line 1940
  if (easycap_debug > 7) {
#line 1940
    printk("<7>easycap::%i%s: VIDIOC_G_STD\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1942
  if (peasycap->standard_offset < 0) {
#line 1943
    if (easycap_debug > 7) {
#line 1943
      printk("<7>easycap::%i%s: %i=peasycap->standard_offset\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", peasycap->standard_offset);
    } else {

    }
#line 1945
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1946
    return (-16L);
  } else {

  }
#line 1949
  tmp___40 = copy_from_user((void *)(& std_id), (void const   *)arg, 8UL);
#line 1949
  if (tmp___40 != 0UL) {
#line 1951
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1952
    return (-14L);
  } else {

  }
#line 1955
  peasycap_standard___0 = (struct easycap_standard  const  *)(& easycap_standard) + (unsigned long )peasycap->standard_offset;
#line 1956
  std_id = peasycap_standard___0->v4l2_standard.id;
#line 1958
  if (easycap_debug > 7) {
#line 1958
    printk("<7>easycap::%i%s: user is told: %s\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (__u8 const   *)(& peasycap_standard___0->v4l2_standard.name));
  } else {

  }
#line 1961
  tmp___41 = copy_to_user((void *)arg, (void const   *)(& std_id), 8U);
#line 1961
  if (tmp___41 != 0) {
#line 1963
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1964
    return (-14L);
  } else {

  }
#line 1966
  goto ldv_32709;
  case 1074288152U: ;
#line 1973
  if (easycap_debug > 7) {
#line 1973
    printk("<7>easycap::%i%s: VIDIOC_S_STD\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 1975
  tmp___42 = copy_from_user((void *)(& std_id___0), (void const   *)arg, 8UL);
#line 1975
  if (tmp___42 != 0UL) {
#line 1977
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1978
    return (-14L);
  } else {

  }
#line 1981
  if (easycap_debug > 7) {
#line 1981
    printk("<7>easycap::%i%s: User requests standard: 0x%08X%08X\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", (int )(std_id___0 >> 32), (int )std_id___0);
  } else {

  }
#line 1985
  rc___1 = adjust_standard(peasycap, std_id___0);
#line 1986
  if (rc___1 < 0) {
#line 1987
    if (easycap_debug > 7) {
#line 1987
      printk("<7>easycap::%i%s: WARNING: adjust_standard() returned %i\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", rc___1);
    } else {

    }
#line 1988
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 1989
    return (-2L);
  } else {

  }
#line 1991
  goto ldv_32709;
  case 3222558216U: ;
#line 1998
  if (easycap_debug > 7) {
#line 1998
    printk("<7>easycap::%i%s: VIDIOC_REQBUFS\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2000
  tmp___43 = copy_from_user((void *)(& v4l2_requestbuffers), (void const   *)arg,
                            20UL);
#line 2000
  if (tmp___43 != 0UL) {
#line 2003
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2004
    return (-14L);
  } else {

  }
#line 2007
  if ((unsigned int )v4l2_requestbuffers.type != 1U) {
#line 2008
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2009
    return (-22L);
  } else {

  }
#line 2011
  if ((unsigned int )v4l2_requestbuffers.memory != 1U) {
#line 2012
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2013
    return (-22L);
  } else {

  }
#line 2015
  nbuffers = (int )v4l2_requestbuffers.count;
#line 2016
  if (easycap_debug > 7) {
#line 2016
    printk("<7>easycap::%i%s:                    User requests %i buffers ...\n",
           peasycap->isdongle, "easycap_unlocked_ioctl", nbuffers);
  } else {

  }
#line 2017
  if (nbuffers <= 1) {
#line 2018
    nbuffers = 2;
  } else {

  }
#line 2019
  if (nbuffers > 6) {
#line 2020
    nbuffers = 6;
  } else {

  }
#line 2021
  if (v4l2_requestbuffers.count == (__u32 )nbuffers) {
#line 2022
    if (easycap_debug > 7) {
#line 2022
      printk("<7>easycap::%i%s:                    ... agree to  %i buffers\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", nbuffers);
    } else {

    }
  } else {
#line 2025
    if (easycap_debug > 7) {
#line 2025
      printk("<7>easycap::%i%s:                   ... insist on  %i buffers\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", nbuffers);
    } else {

    }
#line 2027
    v4l2_requestbuffers.count = (__u32 )nbuffers;
  }
#line 2029
  peasycap->frame_buffer_many = nbuffers;
#line 2031
  tmp___44 = copy_to_user((void *)arg, (void const   *)(& v4l2_requestbuffers), 20U);
#line 2031
  if (tmp___44 != 0) {
#line 2033
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2034
    return (-14L);
  } else {

  }
#line 2036
  goto ldv_32709;
  case 3227014665U: ;
#line 2043
  if (easycap_debug > 7) {
#line 2043
    printk("<7>easycap::%i%s: VIDIOC_QUERYBUF\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2045
  if (peasycap->video_eof != 0) {
#line 2046
    if (easycap_debug > 7) {
#line 2046
      printk("<7>easycap::%i%s: returning -EIO because  %i=video_eof\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", peasycap->video_eof);
    } else {

    }
#line 2048
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2049
    return (-5L);
  } else {

  }
#line 2052
  tmp___45 = copy_from_user((void *)(& v4l2_buffer), (void const   *)arg, 88UL);
#line 2052
  if (tmp___45 != 0UL) {
#line 2054
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2055
    return (-14L);
  } else {

  }
#line 2058
  if ((unsigned int )v4l2_buffer.type != 1U) {
#line 2059
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2060
    return (-22L);
  } else {

  }
#line 2062
  index___6 = v4l2_buffer.index;
#line 2063
  if ((u32 )peasycap->frame_buffer_many <= index___6) {
#line 2064
    return (-22L);
  } else {

  }
#line 2065
  memset((void *)(& v4l2_buffer), 0, 88UL);
#line 2066
  v4l2_buffer.index = index___6;
#line 2067
  v4l2_buffer.type = 1;
#line 2068
  v4l2_buffer.bytesused = (__u32 )peasycap->frame_buffer_used;
#line 2069
  v4l2_buffer.flags = (__u32 )((peasycap->done[index___6] | 1) | peasycap->queued[index___6]);
#line 2072
  v4l2_buffer.field = 1;
#line 2073
  v4l2_buffer.memory = 1;
#line 2074
  v4l2_buffer.m.offset = index___6 * 1658880U;
#line 2075
  v4l2_buffer.length = 1658880U;
#line 2077
  if (easycap_debug > 15) {
#line 2077
    printk("<7>easycap::%i%s:   %10i=index\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer.index);
  } else {

  }
#line 2078
  if (easycap_debug > 15) {
#line 2078
    printk("<7>easycap::%i%s:   0x%08X=type\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (unsigned int )v4l2_buffer.type);
  } else {

  }
#line 2079
  if (easycap_debug > 15) {
#line 2079
    printk("<7>easycap::%i%s:   %10i=bytesused\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer.bytesused);
  } else {

  }
#line 2080
  if (easycap_debug > 15) {
#line 2080
    printk("<7>easycap::%i%s:   0x%08X=flags\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer.flags);
  } else {

  }
#line 2081
  if (easycap_debug > 15) {
#line 2081
    printk("<7>easycap::%i%s:   %10i=field\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (unsigned int )v4l2_buffer.field);
  } else {

  }
#line 2082
  if (easycap_debug > 15) {
#line 2082
    printk("<7>easycap::%i%s:   %10li=timestamp.tv_usec\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer.timestamp.tv_usec);
  } else {

  }
#line 2084
  if (easycap_debug > 15) {
#line 2084
    printk("<7>easycap::%i%s:   %10i=sequence\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer.sequence);
  } else {

  }
#line 2085
  if (easycap_debug > 15) {
#line 2085
    printk("<7>easycap::%i%s:   0x%08X=memory\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (unsigned int )v4l2_buffer.memory);
  } else {

  }
#line 2086
  if (easycap_debug > 15) {
#line 2086
    printk("<7>easycap::%i%s:   %10i=m.offset\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer.m.offset);
  } else {

  }
#line 2087
  if (easycap_debug > 15) {
#line 2087
    printk("<7>easycap::%i%s:   %10i=length\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer.length);
  } else {

  }
#line 2089
  tmp___46 = copy_to_user((void *)arg, (void const   *)(& v4l2_buffer), 88U);
#line 2089
  if (tmp___46 != 0) {
#line 2091
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2092
    return (-14L);
  } else {

  }
#line 2094
  goto ldv_32709;
  case 3227014671U: ;
#line 2100
  if (easycap_debug > 7) {
#line 2100
    printk("<7>easycap::%i%s: VIDIOC_QBUF\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2102
  tmp___47 = copy_from_user((void *)(& v4l2_buffer___0), (void const   *)arg, 88UL);
#line 2102
  if (tmp___47 != 0UL) {
#line 2104
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2105
    return (-14L);
  } else {

  }
#line 2108
  if ((unsigned int )v4l2_buffer___0.type != 1U) {
#line 2109
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2110
    return (-22L);
  } else {

  }
#line 2112
  if ((unsigned int )v4l2_buffer___0.memory != 1U) {
#line 2113
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2114
    return (-22L);
  } else {

  }
#line 2116
  if (v4l2_buffer___0.index >= (__u32 )peasycap->frame_buffer_many) {
#line 2118
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2119
    return (-22L);
  } else {

  }
#line 2121
  v4l2_buffer___0.flags = 3U;
#line 2123
  peasycap->done[v4l2_buffer___0.index] = 0;
#line 2124
  peasycap->queued[v4l2_buffer___0.index] = 2;
#line 2126
  tmp___48 = copy_to_user((void *)arg, (void const   *)(& v4l2_buffer___0), 88U);
#line 2126
  if (tmp___48 != 0) {
#line 2128
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2129
    return (-14L);
  } else {

  }
#line 2132
  if (easycap_debug > 7) {
#line 2132
    printk("<7>easycap::%i%s: .....   user queueing frame buffer %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", (int )v4l2_buffer___0.index);
  } else {

  }
#line 2135
  peasycap->frame_lock = 0;
#line 2137
  goto ldv_32709;
  case 3227014673U: ;
#line 2148
  if (easycap_debug > 7) {
#line 2148
    printk("<7>easycap::%i%s: VIDIOC_DQBUF\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2150
  if (peasycap->video_idle != 0 || peasycap->video_eof != 0) {
#line 2151
    if (easycap_debug > 7) {
#line 2151
      printk("<7>easycap::%i%s: returning -EIO because  %i=video_idle  %i=video_eof\n",
             peasycap->isdongle, "easycap_unlocked_ioctl", peasycap->video_idle, peasycap->video_eof);
    } else {

    }
#line 2154
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2155
    return (-5L);
  } else {

  }
#line 2158
  tmp___49 = copy_from_user((void *)(& v4l2_buffer___1), (void const   *)arg, 88UL);
#line 2158
  if (tmp___49 != 0UL) {
#line 2160
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2161
    return (-14L);
  } else {

  }
#line 2164
  if ((unsigned int )v4l2_buffer___1.type != 1U) {
#line 2165
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2166
    return (-22L);
  } else {

  }
#line 2169
  if ((int )peasycap->offerfields) {
#line 2176
    if ((unsigned int )v4l2_buffer___1.field == 2U) {
#line 2177
      if (easycap_debug > 7) {
#line 2177
        printk("<7>easycap::%i%s: user wants V4L2_FIELD_TOP\n", peasycap->isdongle,
               "easycap_unlocked_ioctl");
      } else {

      }
    } else
#line 2178
    if ((unsigned int )v4l2_buffer___1.field == 3U) {
#line 2179
      if (easycap_debug > 7) {
#line 2179
        printk("<7>easycap::%i%s: user wants V4L2_FIELD_BOTTOM\n", peasycap->isdongle,
               "easycap_unlocked_ioctl");
      } else {

      }
    } else
#line 2180
    if ((unsigned int )v4l2_buffer___1.field == 0U) {
#line 2181
      if (easycap_debug > 7) {
#line 2181
        printk("<7>easycap::%i%s: user wants V4L2_FIELD_ANY\n", peasycap->isdongle,
               "easycap_unlocked_ioctl");
      } else {

      }
    } else
#line 2183
    if (easycap_debug > 7) {
#line 2183
      printk("<7>easycap::%i%s: user wants V4L2_FIELD_...UNKNOWN: %i\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", (unsigned int )v4l2_buffer___1.field);
    } else {

    }
  } else {

  }
#line 2187
  if (peasycap->video_isoc_streaming == 0) {
#line 2188
    if (easycap_debug > 15) {
#line 2188
      printk("<7>easycap::%i%s: returning -EIO because video urbs not streaming\n",
             peasycap->isdongle, "easycap_unlocked_ioctl");
    } else {

    }
#line 2189
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2190
    return (-5L);
  } else {

  }
#line 2202
  if (peasycap->polled == 0) {
    ldv_32852: 
#line 2204
    rcdq = easycap_video_dqbuf(peasycap, 0);
#line 2205
    if (rcdq == -5) {
#line 2206
      if (easycap_debug > 7) {
#line 2206
        printk("<7>easycap::%i%s: returning -EIO because dqbuf() returned -EIO\n",
               peasycap->isdongle, "easycap_unlocked_ioctl");
      } else {

      }
#line 2208
      mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2209
      return (-5L);
    } else {

    }
#line 2211
    if (rcdq != 0) {
#line 2213
      goto ldv_32852;
    } else {

    }

  } else
#line 2213
  if (peasycap->video_eof != 0) {
#line 2214
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2215
    return (-5L);
  } else {

  }
#line 2218
  if (peasycap->done[peasycap->frame_read] != 4) {
#line 2219
    if (easycap_debug > 7) {
#line 2219
      printk("<7>easycap::%i%s: V4L2_BUF_FLAG_DONE != 0x%08X\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", peasycap->done[peasycap->frame_read]);
    } else {

    }
  } else {

  }
#line 2222
  peasycap->polled = 0;
#line 2224
  if (peasycap->isequence % 10U == 0U) {
#line 2225
    i___0 = 0;
#line 2225
    goto ldv_32855;
    ldv_32854: 
#line 2226
    peasycap->merit[i___0] = peasycap->merit[i___0 + 1];
#line 2225
    i___0 = i___0 + 1;
    ldv_32855: ;
#line 2225
    if (i___0 <= 178) {
#line 2227
      goto ldv_32854;
    } else {

    }
#line 2227
    peasycap->merit[179] = merit_saa(peasycap->pusb_device);
#line 2228
    j = 0;
#line 2229
    i___0 = 0;
#line 2229
    goto ldv_32858;
    ldv_32857: 
#line 2230
    j = peasycap->merit[i___0] + j;
#line 2229
    i___0 = i___0 + 1;
    ldv_32858: ;
#line 2229
    if (i___0 <= 179) {
#line 2231
      goto ldv_32857;
    } else {

    }

#line 2231
    if (j > 90) {
#line 2232
      printk("<7>easycap::%i%s: easycap driver shutting down on condition blue\n",
             peasycap->isdongle, "easycap_unlocked_ioctl");
#line 2234
      peasycap->video_eof = 1;
#line 2235
      peasycap->audio_eof = 1;
    } else {

    }
  } else {

  }
#line 2239
  v4l2_buffer___1.index = (__u32 )peasycap->frame_read;
#line 2240
  v4l2_buffer___1.type = 1;
#line 2241
  v4l2_buffer___1.bytesused = (__u32 )peasycap->frame_buffer_used;
#line 2242
  v4l2_buffer___1.flags = 5U;
#line 2243
  if ((int )peasycap->offerfields) {
#line 2244
    v4l2_buffer___1.field = 3;
  } else {
#line 2246
    v4l2_buffer___1.field = 1;
  }
#line 2247
  do_gettimeofday(& timeval);
#line 2248
  timeval2 = timeval;
#line 2250
  v4l2_buffer___1.timestamp = timeval2;
#line 2251
  tmp___50 = peasycap->isequence;
#line 2251
  peasycap->isequence = peasycap->isequence + 1U;
#line 2251
  v4l2_buffer___1.sequence = tmp___50;
#line 2252
  v4l2_buffer___1.memory = 1;
#line 2253
  v4l2_buffer___1.m.offset = v4l2_buffer___1.index * 1658880U;
#line 2254
  v4l2_buffer___1.length = 1658880U;
#line 2256
  if (easycap_debug > 15) {
#line 2256
    printk("<7>easycap::%i%s:   %10i=index\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.index);
  } else {

  }
#line 2257
  if (easycap_debug > 15) {
#line 2257
    printk("<7>easycap::%i%s:   0x%08X=type\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (unsigned int )v4l2_buffer___1.type);
  } else {

  }
#line 2258
  if (easycap_debug > 15) {
#line 2258
    printk("<7>easycap::%i%s:   %10i=bytesused\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.bytesused);
  } else {

  }
#line 2259
  if (easycap_debug > 15) {
#line 2259
    printk("<7>easycap::%i%s:   0x%08X=flags\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.flags);
  } else {

  }
#line 2260
  if (easycap_debug > 15) {
#line 2260
    printk("<7>easycap::%i%s:   %10i=field\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (unsigned int )v4l2_buffer___1.field);
  } else {

  }
#line 2261
  if (easycap_debug > 15) {
#line 2261
    printk("<7>easycap::%i%s:   %10li=timestamp.tv_sec\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.timestamp.tv_sec);
  } else {

  }
#line 2263
  if (easycap_debug > 15) {
#line 2263
    printk("<7>easycap::%i%s:   %10li=timestamp.tv_usec\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.timestamp.tv_usec);
  } else {

  }
#line 2265
  if (easycap_debug > 15) {
#line 2265
    printk("<7>easycap::%i%s:   %10i=sequence\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.sequence);
  } else {

  }
#line 2266
  if (easycap_debug > 15) {
#line 2266
    printk("<7>easycap::%i%s:   0x%08X=memory\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           (unsigned int )v4l2_buffer___1.memory);
  } else {

  }
#line 2267
  if (easycap_debug > 15) {
#line 2267
    printk("<7>easycap::%i%s:   %10i=m.offset\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.m.offset);
  } else {

  }
#line 2268
  if (easycap_debug > 15) {
#line 2268
    printk("<7>easycap::%i%s:   %10i=length\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           v4l2_buffer___1.length);
  } else {

  }
#line 2270
  tmp___51 = copy_to_user((void *)arg, (void const   *)(& v4l2_buffer___1), 88U);
#line 2270
  if (tmp___51 != 0) {
#line 2272
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2273
    return (-14L);
  } else {

  }
#line 2276
  input = peasycap->frame_buffer[peasycap->frame_read][0].input;
#line 2277
  if (((unsigned int )input & 8U) != 0U) {
#line 2278
    if (easycap_debug > 7) {
#line 2278
      printk("<7>easycap::%i%s: user is offered frame buffer %i, input %i\n", peasycap->isdongle,
             "easycap_unlocked_ioctl", peasycap->frame_read, (int )input & 7);
    } else {

    }
  } else
#line 2281
  if (easycap_debug > 7) {
#line 2281
    printk("<7>easycap::%i%s: user is offered frame buffer %i\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", peasycap->frame_read);
  } else {

  }
#line 2284
  peasycap->frame_lock = 1;
#line 2285
  if (easycap_debug > 7) {
#line 2285
    printk("<7>easycap::%i%s: %i=peasycap->frame_fill\n", peasycap->isdongle, "easycap_unlocked_ioctl",
           peasycap->frame_fill);
  } else {

  }
#line 2286
  if (peasycap->frame_read == peasycap->frame_fill) {
#line 2287
    if (peasycap->frame_lock != 0) {
#line 2288
      if (easycap_debug > 7) {
#line 2288
        printk("<7>easycap::%i%s: WORRY:  filling frame buffer while offered to user\n",
               peasycap->isdongle, "easycap_unlocked_ioctl");
      } else {

      }
    } else {

    }
  } else {

  }
#line 2292
  goto ldv_32709;
  case 1074026002U: ;
#line 2298
  if (easycap_debug > 7) {
#line 2298
    printk("<7>easycap::%i%s: VIDIOC_STREAMON\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2300
  peasycap->isequence = 0U;
#line 2301
  i___1 = 0;
#line 2301
  goto ldv_32863;
  ldv_32862: 
#line 2302
  peasycap->merit[i___1] = 0;
#line 2301
  i___1 = i___1 + 1;
  ldv_32863: ;
#line 2301
  if (i___1 <= 179) {
#line 2303
    goto ldv_32862;
  } else {

  }

#line 2303
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 2304
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
#line 2305
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2306
    return (-14L);
  } else {

  }
#line 2308
  easycap_video_submit_urbs(peasycap);
#line 2309
  peasycap->video_idle = 0;
#line 2310
  peasycap->audio_idle = 0;
#line 2311
  peasycap->video_eof = 0;
#line 2312
  peasycap->audio_eof = 0;
#line 2313
  goto ldv_32709;
  case 1074026003U: ;
#line 2317
  if (easycap_debug > 7) {
#line 2317
    printk("<7>easycap::%i%s: VIDIOC_STREAMOFF\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2319
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 2320
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
#line 2321
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2322
    return (-14L);
  } else {

  }
#line 2325
  peasycap->video_idle = 1;
#line 2326
  peasycap->audio_idle = 1;
#line 2333
  if (easycap_debug > 7) {
#line 2333
    printk("<7>easycap::%i%s: calling wake_up on wq_video and wq_audio\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
  } else {

  }
#line 2334
  __wake_up(& peasycap->wq_video, 1U, 1, (void *)0);
#line 2335
  if ((unsigned long )peasycap->psubstream != (unsigned long )((struct snd_pcm_substream *)0)) {
#line 2336
    snd_pcm_period_elapsed(peasycap->psubstream);
  } else {

  }
#line 2337
  goto ldv_32709;
  case 3234616853U: ;
#line 2343
  if (easycap_debug > 7) {
#line 2343
    printk("<7>easycap::%i%s: VIDIOC_G_PARM\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2344
  tmp___52 = memdup_user((void const   *)arg, 204UL);
#line 2344
  pv4l2_streamparm = (struct v4l2_streamparm *)tmp___52;
#line 2346
  tmp___54 = IS_ERR((void const   *)pv4l2_streamparm);
#line 2346
  if (tmp___54 != 0L) {
#line 2347
    printk("<7>easycap::%i%s: OLD_ERROR: copy from user failed\n", peasycap->isdongle,
           "easycap_unlocked_ioctl");
#line 2348
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2349
    tmp___53 = PTR_ERR((void const   *)pv4l2_streamparm);
#line 2349
    return (tmp___53);
  } else {

  }
#line 2352
  if ((unsigned int )pv4l2_streamparm->type != 1U) {
#line 2353
    kfree((void const   *)pv4l2_streamparm);
#line 2354
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2355
    return (-22L);
  } else {

  }
#line 2357
  pv4l2_streamparm->parm.capture.capability = 0U;
#line 2358
  pv4l2_streamparm->parm.capture.capturemode = 0U;
#line 2359
  pv4l2_streamparm->parm.capture.timeperframe.numerator = 1U;
#line 2361
  if (peasycap->fps != 0) {
#line 2362
    pv4l2_streamparm->parm.capture.timeperframe.denominator = (__u32 )peasycap->fps;
  } else
#line 2365
  if ((int )peasycap->ntsc) {
#line 2366
    pv4l2_streamparm->parm.capture.timeperframe.denominator = 30U;
  } else {
#line 2369
    pv4l2_streamparm->parm.capture.timeperframe.denominator = 25U;
  }
#line 2374
  pv4l2_streamparm->parm.capture.readbuffers = (__u32 )peasycap->frame_buffer_many;
#line 2376
  pv4l2_streamparm->parm.capture.extendedmode = 0U;
#line 2377
  tmp___55 = copy_to_user((void *)arg, (void const   *)pv4l2_streamparm, 204U);
#line 2377
  if (tmp___55 != 0) {
#line 2380
    kfree((void const   *)pv4l2_streamparm);
#line 2381
    mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2382
    return (-14L);
  } else {

  }
#line 2384
  kfree((void const   *)pv4l2_streamparm);
#line 2385
  goto ldv_32709;
  case 3234616854U: ;
#line 2389
  if (easycap_debug > 7) {
#line 2389
    printk("<7>easycap::%i%s: VIDIOC_S_PARM unsupported\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2390
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2391
  return (-22L);
  case 2150913569U: ;
#line 2395
  if (easycap_debug > 7) {
#line 2395
    printk("<7>easycap::%i%s: VIDIOC_G_AUDIO unsupported\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2396
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2397
  return (-22L);
  case 1077171746U: ;
#line 2401
  if (easycap_debug > 7) {
#line 2401
    printk("<7>easycap::%i%s: VIDIOC_S_AUDIO unsupported\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2402
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2403
  return (-22L);
  case 1079268894U: ;
#line 2407
  if (easycap_debug > 7) {
#line 2407
    printk("<7>easycap::%i%s: VIDIOC_S_TUNER unsupported\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2408
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2409
  return (-22L);
  case 2150651402U: ;
  case 1076909579U: ;
  case 1074025998U: ;
#line 2415
  if (easycap_debug > 7) {
#line 2415
    printk("<7>easycap::%i%s: VIDIOC_G_FBUF|VIDIOC_S_FBUF|VIDIOC_OVERLAY unsupported\n",
           peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2416
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2417
  return (-22L);
  case 3226752541U: ;
#line 2421
  if (easycap_debug > 7) {
#line 2421
    printk("<7>easycap::%i%s: VIDIOC_G_TUNER unsupported\n", peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2422
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2423
  return (-22L);
  case 3224131128U: ;
  case 1076647481U: ;
#line 2427
  if (easycap_debug > 7) {
#line 2427
    printk("<7>easycap::%i%s: VIDIOC_G_FREQUENCY|VIDIOC_S_FREQUENCY unsupported\n",
           peasycap->isdongle, "easycap_unlocked_ioctl");
  } else {

  }
#line 2428
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2429
  return (-22L);
  default: ;
#line 2433
  if (easycap_debug > 7) {
#line 2433
    printk("<7>easycap::%i%s: OLD_ERROR: unrecognized V4L2 IOCTL command: 0x%08X\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", cmd);
  } else {

  }
#line 2434
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2435
  return (-515L);
  }
  ldv_32709: 
#line 2438
  mutex_unlock(& easycapdc60_dongle[kd].mutex_video);
#line 2439
  if (easycap_debug > 3) {
#line 2439
    printk("<7>easycap::%i%s: unlocked easycapdc60_dongle[%i].mutex_video\n", peasycap->isdongle,
           "easycap_unlocked_ioctl", kd);
  } else {

  }
#line 2440
  return (0L);
}
}
#line 63 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/arch/x86/include/asm/string_64.h"
extern char *strcat(char * , char const   * ) ;
#line 563 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/inst/current/envs/linux-stable-8817633-1/linux-stable-8817633-1/drivers/staging/media/easycap/easycap.h"
struct easycap_format easycap_format[3361U]  ;
#line 41 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_settings.c"
struct easycap_standard  const  easycap_standard[21U]  = 
#line 41 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_settings.c"
  {      {0U, {0U, 541ULL, {'P', 'A', 'L', '_', 'B', 'G', 'H', 'I', 'N', '\000'}, {1U,
                                                                               25U},
           625U, {0U, 0U, 0U, 0U}}}, 
        {8U, {8U, 0ULL, {'N', 'T', 'S', 'C', '_', 'N', '_', '4', '4', '3', '\000'}, {1U,
                                                                                  25U},
           480U, {0U, 0U, 0U, 0U}}}, 
        {2U, {2U, 1024ULL, {'P', 'A', 'L', '_', 'N', 'c', '\000'}, {1U, 25U}, 625U, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U}}}, 
        {6U,
      {6U, 0ULL, {'N', 'T', 'S', 'C', '_', 'N', '\000'}, {1U, 25U}, 525U, {0U, 0U,
                                                                           0U, 0U}}}, 
        {4U,
      {4U, 16711680ULL, {'S', 'E', 'C', 'A', 'M', '\000'}, {1U, 25U}, 625U, {0U, 0U,
                                                                             0U, 0U}}}, 
        {1U,
      {1U, 4096ULL, {'N', 'T', 'S', 'C', '_', 'M', '\000'}, {1U, 30U}, 525U, {0U,
                                                                              0U,
                                                                              0U,
                                                                              0U}}}, 
        {5U,
      {5U, 8192ULL, {'N', 'T', 'S', 'C', '_', 'M', '_', 'J', 'P', '\000'}, {1U, 30U},
       525U, {0U, 0U, 0U, 0U}}}, 
        {7U, {7U, 2048ULL, {'P', 'A', 'L', '_', '6', '0', '\000'}, {1U, 30U}, 525U, {0U,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U}}}, 
        {3U,
      {3U, 16384ULL, {'N', 'T', 'S', 'C', '_', '4', '4', '3', '\000'}, {1U, 30U},
       525U, {0U, 0U, 0U, 0U}}}, 
        {9U, {9U, 256ULL, {'P', 'A', 'L', '_', 'M', '\000'}, {1U, 30U}, 525U, {0U, 0U,
                                                                            0U, 0U}}}, 
        {32778U,
      {10U, 4294967837ULL, {'P', 'A', 'L', '_', 'B', 'G', 'H', 'I', 'N', '_', 'S',
                            'L', 'O', 'W', '\000'}, {1U, 5U}, 625U, {0U, 0U, 0U, 0U}}}, 
        {32786U,
      {18U, 73014444032ULL, {'N', 'T', 'S', 'C', '_', 'N', '_', '4', '4', '3', '_',
                             'S', 'L', 'O', 'W', '\000'}, {1U, 5U}, 480U, {0U, 0U,
                                                                           0U, 0U}}}, 
        {32780U,
      {12U, 4294968320ULL, {'P', 'A', 'L', '_', 'N', 'c', '_', 'S', 'L', 'O', 'W',
                            '\000'}, {1U, 5U}, 625U, {0U, 0U, 0U, 0U}}}, 
        {32784U, {16U, 141733920768ULL, {'N', 'T', 'S', 'C', '_', 'N', '_', 'S', 'L',
                                      'O', 'W', '\000'}, {1U, 5U}, 525U, {0U, 0U,
                                                                          0U, 0U}}}, 
        {32782U,
      {14U, 4311678976ULL, {'S', 'E', 'C', 'A', 'M', '_', 'S', 'L', 'O', 'W', '\000'},
       {1U, 5U}, 625U, {0U, 0U, 0U, 0U}}}, 
        {32779U, {11U, 4294971392ULL, {'N', 'T', 'S', 'C', '_', 'M', '_', 'S', 'L', 'O',
                                    'W', '\000'}, {1U, 6U}, 525U, {0U, 0U, 0U, 0U}}}, 
        {32783U,
      {15U, 4294975488ULL, {'N', 'T', 'S', 'C', '_', 'M', '_', 'J', 'P', '_', 'S',
                            'L', 'O', 'W', '\000'}, {1U, 6U}, 525U, {0U, 0U, 0U, 0U}}}, 
        {32785U,
      {17U, 4294969344ULL, {'P', 'A', 'L', '_', '6', '0', '_', 'S', 'L', 'O', 'W',
                            '\000'}, {1U, 6U}, 525U, {0U, 0U, 0U, 0U}}}, 
        {32781U, {13U, 4294983680ULL, {'N', 'T', 'S', 'C', '_', '4', '4', '3', '_', 'S',
                                    'L', 'O', 'W', '\000'}, {1U, 6U}, 525U, {0U, 0U,
                                                                             0U, 0U}}}, 
        {32787U,
      {19U, 4294967552ULL, {'P', 'A', 'L', '_', 'M', '_', 'S', 'L', 'O', 'W', '\000'},
       {1U, 6U}, 525U, {0U, 0U, 0U, 0U}}}, 
        {65535U, {0U, 0ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
               {0U, 0U}, 0U, {0U, 0U, 0U, 0U}}}};
#line 316 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_settings.c"
int easycap_video_fillin_formats(void) 
{ 
  char const   *name1 ;
  char const   *name2 ;
  char const   *name3 ;
  char const   *name4 ;
  struct v4l2_format *fmt ;
  int i ;
  int j ;
  int k ;
  int m ;
  int n ;
  u32 width ;
  u32 height ;
  u32 pixelformat ;
  u32 bytesperline ;
  u32 sizeimage ;
  u16 mask1 ;
  u16 mask2 ;
  u16 mask3 ;
  u16 mask4 ;
  enum v4l2_field field ;
  enum v4l2_colorspace colorspace ;

  {
#line 326
  i = 0;
#line 326
  n = 0;
#line 326
  goto ldv_32592;
  ldv_32591: 
#line 327
  mask1 = 0U;
#line 328
  switch (i) {
  case 0: 
#line 330
  mask1 = 0U;
#line 331
  name1 = "PAL_BGHIN";
#line 332
  colorspace = 6;
#line 333
  goto ldv_32539;
  case 4: 
#line 336
  mask1 = 4U;
#line 337
  name1 = "SECAM";
#line 338
  colorspace = 6;
#line 339
  goto ldv_32539;
  case 2: 
#line 342
  mask1 = 2U;
#line 343
  name1 = "PAL_Nc";
#line 344
  colorspace = 6;
#line 345
  goto ldv_32539;
  case 7: 
#line 348
  mask1 = 7U;
#line 349
  name1 = "PAL_60";
#line 350
  colorspace = 6;
#line 351
  goto ldv_32539;
  case 9: 
#line 354
  mask1 = 9U;
#line 355
  name1 = "PAL_M";
#line 356
  colorspace = 6;
#line 357
  goto ldv_32539;
  case 1: 
#line 360
  mask1 = 1U;
#line 361
  name1 = "NTSC_M";
#line 362
  colorspace = 5;
#line 363
  goto ldv_32539;
  case 3: 
#line 366
  mask1 = 3U;
#line 367
  name1 = "NTSC_443";
#line 368
  colorspace = 5;
#line 369
  goto ldv_32539;
  case 5: 
#line 372
  mask1 = 5U;
#line 373
  name1 = "NTSC_M_JP";
#line 374
  colorspace = 5;
#line 375
  goto ldv_32539;
  case 6: 
#line 378
  mask1 = 1U;
#line 379
  name1 = "NTSC_N";
#line 380
  colorspace = 5;
#line 381
  goto ldv_32539;
  case 8: 
#line 384
  mask1 = 8U;
#line 385
  name1 = "NTSC_N_443";
#line 386
  colorspace = 5;
#line 387
  goto ldv_32539;
  case 10: 
#line 390
  mask1 = 10U;
#line 391
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 392
  name1 = "PAL_BGHIN_SLOW";
#line 393
  colorspace = 6;
#line 394
  goto ldv_32539;
  case 14: 
#line 397
  mask1 = 14U;
#line 398
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 399
  name1 = "SECAM_SLOW";
#line 400
  colorspace = 6;
#line 401
  goto ldv_32539;
  case 12: 
#line 404
  mask1 = 12U;
#line 405
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 406
  name1 = "PAL_Nc_SLOW";
#line 407
  colorspace = 6;
#line 408
  goto ldv_32539;
  case 17: 
#line 411
  mask1 = 17U;
#line 412
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 413
  name1 = "PAL_60_SLOW";
#line 414
  colorspace = 6;
#line 415
  goto ldv_32539;
  case 19: 
#line 418
  mask1 = 19U;
#line 419
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 420
  name1 = "PAL_M_SLOW";
#line 421
  colorspace = 6;
#line 422
  goto ldv_32539;
  case 11: 
#line 425
  mask1 = 11U;
#line 426
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 427
  name1 = "NTSC_M_SLOW";
#line 428
  colorspace = 5;
#line 429
  goto ldv_32539;
  case 13: 
#line 432
  mask1 = 13U;
#line 433
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 434
  name1 = "NTSC_443_SLOW";
#line 435
  colorspace = 5;
#line 436
  goto ldv_32539;
  case 15: 
#line 439
  mask1 = 15U;
#line 440
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 441
  name1 = "NTSC_M_JP_SLOW";
#line 442
  colorspace = 5;
#line 443
  goto ldv_32539;
  case 16: 
#line 446
  mask1 = 16U;
#line 447
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 448
  name1 = "NTSC_N_SLOW";
#line 449
  colorspace = 5;
#line 450
  goto ldv_32539;
  case 18: 
#line 453
  mask1 = 18U;
#line 454
  mask1 = (u16 )((unsigned int )mask1 | 512U);
#line 455
  name1 = "NTSC_N_443_SLOW";
#line 456
  colorspace = 5;
#line 457
  goto ldv_32539;
  default: ;
#line 460
  return (-1);
  }
  ldv_32539: 
#line 463
  j = 0;
#line 463
  goto ldv_32589;
  ldv_32588: 
#line 464
  mask2 = 0U;
#line 465
  switch (j) {
  case 0: ;
#line 467
  if ((int )mask1 & 1) {
#line 468
    goto ldv_32561;
  } else {

  }
#line 469
  name2 = "_AT_720x576";
#line 470
  width = 720U;
#line 471
  height = 576U;
#line 472
  goto ldv_32562;
  case 1: ;
#line 475
  if ((int )mask1 & 1) {
#line 476
    goto ldv_32561;
  } else {

  }
#line 477
  name2 = "_AT_704x576";
#line 478
  width = 704U;
#line 479
  height = 576U;
#line 480
  goto ldv_32562;
  case 2: 
#line 483
  name2 = "_AT_640x480";
#line 484
  width = 640U;
#line 485
  height = 480U;
#line 486
  goto ldv_32562;
  case 3: ;
#line 489
  if (((unsigned int )mask1 & 1U) == 0U) {
#line 490
    goto ldv_32561;
  } else {

  }
#line 491
  name2 = "_AT_720x480";
#line 492
  width = 720U;
#line 493
  height = 480U;
#line 494
  goto ldv_32562;
  case 4: ;
#line 497
  if ((int )mask1 & 1) {
#line 498
    goto ldv_32561;
  } else {

  }
#line 499
  name2 = "_AT_360x288";
#line 500
  width = 360U;
#line 501
  height = 288U;
#line 502
  mask2 = 2048U;
#line 503
  goto ldv_32562;
  case 5: 
#line 506
  name2 = "_AT_320x240";
#line 507
  width = 320U;
#line 508
  height = 240U;
#line 509
  mask2 = 2048U;
#line 510
  goto ldv_32562;
  case 6: ;
#line 513
  if (((unsigned int )mask1 & 1U) == 0U) {
#line 514
    goto ldv_32561;
  } else {

  }
#line 515
  name2 = "_AT_360x240";
#line 516
  width = 360U;
#line 517
  height = 240U;
#line 518
  mask2 = 2048U;
#line 519
  goto ldv_32562;
  default: ;
#line 522
  return (-2);
  }
  ldv_32562: 
#line 525
  k = 0;
#line 525
  goto ldv_32586;
  ldv_32585: 
#line 526
  mask3 = 0U;
#line 527
  switch (k) {
  case 0: 
#line 529
  name3 = "FMT_UYVY";
#line 530
  pixelformat = 1498831189U;
#line 531
  mask3 = (u16 )((unsigned int )mask3 | 64U);
#line 532
  goto ldv_32571;
  case 1: 
#line 535
  name3 = "FMT_YUY2";
#line 536
  pixelformat = 1448695129U;
#line 537
  mask3 = (u16 )((unsigned int )mask3 | 64U);
#line 538
  mask3 = (u16 )((unsigned int )mask3 | 256U);
#line 539
  goto ldv_32571;
  case 2: 
#line 542
  name3 = "FMT_RGB24";
#line 543
  pixelformat = 859981650U;
#line 544
  mask3 = (u16 )((unsigned int )mask3 | 96U);
#line 545
  goto ldv_32571;
  case 3: 
#line 548
  name3 = "FMT_RGB32";
#line 549
  pixelformat = 876758866U;
#line 550
  mask3 = (u16 )((unsigned int )mask3 | 128U);
#line 551
  goto ldv_32571;
  case 4: 
#line 554
  name3 = "FMT_BGR24";
#line 555
  pixelformat = 861030210U;
#line 556
  mask3 = (u16 )((unsigned int )mask3 | 96U);
#line 557
  mask3 = (u16 )((unsigned int )mask3 | 256U);
#line 558
  goto ldv_32571;
  case 5: 
#line 561
  name3 = "FMT_BGR32";
#line 562
  pixelformat = 877807426U;
#line 563
  mask3 = (u16 )((unsigned int )mask3 | 128U);
#line 564
  mask3 = (u16 )((unsigned int )mask3 | 256U);
#line 565
  goto ldv_32571;
  default: ;
#line 568
  return (-3);
  }
  ldv_32571: 
#line 570
  bytesperline = (u32 )(((int )mask3 & 224) >> 5) * width;
#line 571
  sizeimage = bytesperline * height;
#line 573
  m = 0;
#line 573
  goto ldv_32583;
  ldv_32582: 
#line 574
  mask4 = 0U;
#line 575
  switch (m) {
  case 0: 
#line 577
  name4 = "-n";
#line 578
  field = 1;
#line 579
  goto ldv_32579;
  case 1: 
#line 582
  name4 = "-i";
#line 583
  mask4 = (u16 )((unsigned int )mask4 | 4096U);
#line 584
  field = 4;
#line 585
  goto ldv_32579;
  default: ;
#line 588
  return (-4);
  }
  ldv_32579: ;
#line 590
  if (n > 3359) {
#line 591
    return (-5);
  } else {

  }
#line 593
  strcpy((char *)(& easycap_format[n].name), name1);
#line 594
  strcat((char *)(& easycap_format[n].name), name2);
#line 595
  strcat((char *)(& easycap_format[n].name), "_");
#line 596
  strcat((char *)(& easycap_format[n].name), name3);
#line 597
  strcat((char *)(& easycap_format[n].name), name4);
#line 598
  easycap_format[n].mask = (u16 )((((int )mask1 | (int )mask2) | (int )mask3) | (int )mask4);
#line 600
  fmt = & easycap_format[n].v4l2_format;
#line 602
  fmt->type = 1;
#line 603
  fmt->fmt.pix.width = width;
#line 604
  fmt->fmt.pix.height = height;
#line 605
  fmt->fmt.pix.pixelformat = pixelformat;
#line 606
  fmt->fmt.pix.field = field;
#line 607
  fmt->fmt.pix.bytesperline = bytesperline;
#line 608
  fmt->fmt.pix.sizeimage = sizeimage;
#line 609
  fmt->fmt.pix.colorspace = colorspace;
#line 610
  fmt->fmt.pix.priv = 0U;
#line 611
  n = n + 1;
#line 573
  m = m + 1;
  ldv_32583: ;
#line 573
  if (m <= 1) {
#line 575
    goto ldv_32582;
  } else {

  }
#line 525
  k = k + 1;
  ldv_32586: ;
#line 525
  if (k <= 5) {
#line 527
    goto ldv_32585;
  } else {

  }

  ldv_32561: 
#line 463
  j = j + 1;
  ldv_32589: ;
#line 463
  if (j <= 6) {
#line 465
    goto ldv_32588;
  } else {

  }
#line 326
  i = i + 1;
  ldv_32592: ;
#line 326
  if (i <= 19) {
#line 328
    goto ldv_32591;
  } else {

  }

#line 616
  if (n > 3360) {
#line 617
    return (-6);
  } else {

  }
#line 618
  easycap_format[n].mask = 65535U;
#line 619
  return (n);
}
}
#line 622 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_settings.c"
struct v4l2_queryctrl easycap_control[7U]  = {      {9963776U, 1, {'B', 'r', 'i', 'g', 'h', 't', 'n', 'e', 's', 's', '\000'}, 0,
      255, 1, 127, 0U, {0U, 0U}}, 
        {9963777U, 1, {'C', 'o', 'n', 't', 'r', 'a', 's', 't', '\000'}, 0, 255, 1, 191,
      0U, {0U, 0U}}, 
        {9963778U, 1, {'S', 'a', 't', 'u', 'r', 'a', 't', 'i', 'o', 'n', '\000'}, 0,
      255, 1, 175, 0U, {0U, 0U}}, 
        {9963779U, 1, {'H', 'u', 'e', '\000'}, 0, 255, 1, 128, 0U, {0U, 0U}}, 
        {9963781U, 1, {'V', 'o', 'l', 'u', 'm', 'e', '\000'}, 0, 31, 1, 16, 0U, {0U,
                                                                              0U}}, 
        {9963785U,
      2, {'M', 'u', 't', 'e', '\000'}, 0, 0, 0, 1, 0U, {0U, 0U}}, 
        {4294967295U, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      0, 0, 0, 0, 0U, {0U, 0U}}};
#line 33 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_testcard.c"
void easycap_testcard(struct easycap *peasycap , int field ) 
{ 
  int total ;
  int y ;
  int u ;
  int v ;
  int r ;
  int g ;
  int b ;
  unsigned char uyvy[4U] ;
  int i1 ;
  int line ;
  int k ;
  int m ;
  int n ;
  int more ;
  int much ;
  int barwidth ;
  int barheight ;
  unsigned char bfbar[180U] ;
  unsigned char *p1 ;
  unsigned char *p2 ;
  struct data_buffer *pfield_buffer ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  size_t __len ;
  void *__ret ;

  {
#line 42
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 43
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_testcard");
#line 44
    return;
  } else {

  }
#line 46
  if (easycap_debug > 7) {
#line 46
    printk("<7>easycap::%i%s: %i=field\n", peasycap->isdongle, "easycap_testcard",
           field);
  } else {

  }
#line 47
  switch (peasycap->width) {
  case 720: ;
  case 360: 
#line 50
  barwidth = 180;
#line 51
  goto ldv_32540;
  case 704: ;
  case 352: 
#line 55
  barwidth = 176;
#line 56
  goto ldv_32540;
  case 640: ;
  case 320: 
#line 60
  barwidth = 160;
#line 61
  goto ldv_32540;
  default: 
#line 64
  printk("<7>easycap::%i%s: OLD_ERROR:  cannot set barwidth\n", peasycap->isdongle, "easycap_testcard");
#line 65
  return;
  }
  ldv_32540: ;
#line 68
  if (barwidth > 1440) {
#line 69
    printk("<7>easycap::%i%s: OLD_ERROR: barwidth is too large\n", peasycap->isdongle,
           "easycap_testcard");
#line 70
    return;
  } else {

  }
#line 72
  switch (peasycap->height) {
  case 576: ;
  case 288: 
#line 75
  barheight = 576;
#line 76
  goto ldv_32548;
  case 480: ;
  case 240: 
#line 80
  barheight = 480;
#line 81
  goto ldv_32548;
  default: 
#line 84
  printk("<7>easycap::%i%s: OLD_ERROR: cannot set barheight\n", peasycap->isdongle, "easycap_testcard");
#line 85
  return;
  }
  ldv_32548: 
#line 88
  total = 0;
#line 89
  k = field;
#line 90
  m = 0;
#line 91
  n = 0;
#line 93
  line = 0;
#line 93
  goto ldv_32565;
  ldv_32564: 
#line 94
  i1 = 0;
#line 94
  goto ldv_32562;
  ldv_32561: 
#line 95
  r = (i1 * 256) / 8;
#line 96
  g = (i1 * 256) / 8;
#line 97
  b = (i1 * 256) / 8;
#line 99
  y = ((r * 299) / 1000 + (g * 587) / 1000) + (b * 114) / 1000;
#line 100
  u = ((r * -147) / 1000 - (g * 289) / 1000) + (b * 436) / 1000;
#line 101
  u = u + 128;
#line 102
  v = ((r * 615) / 1000 - (g * 515) / 1000) - (b * 100) / 1000;
#line 103
  v = v + 128;
#line 105
  uyvy[0] = (unsigned char )u;
#line 106
  uyvy[1] = (unsigned char )y;
#line 107
  uyvy[2] = (unsigned char )v;
#line 108
  uyvy[3] = (unsigned char )y;
#line 110
  p1 = (unsigned char *)(& bfbar);
#line 111
  goto ldv_32553;
  ldv_32552: 
#line 112
  tmp = p1;
#line 112
  p1 = p1 + 1;
#line 112
  *tmp = uyvy[0];
#line 113
  tmp___0 = p1;
#line 113
  p1 = p1 + 1;
#line 113
  *tmp___0 = uyvy[1];
#line 114
  tmp___1 = p1;
#line 114
  p1 = p1 + 1;
#line 114
  *tmp___1 = uyvy[2];
#line 115
  tmp___2 = p1;
#line 115
  p1 = p1 + 1;
#line 115
  *tmp___2 = uyvy[3];
#line 116
  total = total + 4;
  ldv_32553: ;
#line 111
  if ((unsigned long )((unsigned char *)(& bfbar) + (unsigned long )barwidth) > (unsigned long )p1) {
#line 113
    goto ldv_32552;
  } else {

  }
#line 119
  p1 = (unsigned char *)(& bfbar);
#line 120
  more = barwidth;
#line 122
  goto ldv_32559;
  ldv_32558: ;
#line 123
  if ((unsigned int )m > 202U) {
#line 124
    printk("<7>easycap::%i%s: OLD_ERROR:  bad m reached\n", peasycap->isdongle, "easycap_testcard");
#line 125
    return;
  } else {

  }
#line 127
  if ((unsigned int )n > 4096U) {
#line 128
    printk("<7>easycap::%i%s: OLD_ERROR:  bad n reached\n", peasycap->isdongle, "easycap_testcard");
#line 129
    return;
  } else {

  }
#line 132
  if (more < 0) {
#line 133
    printk("<7>easycap::%i%s: OLD_ERROR:  internal fault\n", peasycap->isdongle, "easycap_testcard");
#line 134
    return;
  } else {

  }
#line 137
  much = (int )(4096U - (unsigned int )n);
#line 138
  if (much > more) {
#line 139
    much = more;
  } else {

  }
#line 140
  pfield_buffer = (struct data_buffer *)(& peasycap->field_buffer) + ((unsigned long )k + (unsigned long )m);
#line 141
  p2 = (unsigned char *)pfield_buffer->pgo + (unsigned long )n;
#line 142
  __len = (size_t )much;
#line 142
  __ret = __builtin_memcpy((void *)p2, (void const   *)p1, __len);
#line 144
  p1 = p1 + (unsigned long )much;
#line 145
  n = n + much;
#line 146
  more = more - much;
#line 147
  if (n == 4096) {
#line 148
    m = m + 1;
#line 149
    n = 0;
  } else {

  }
  ldv_32559: ;
#line 122
  if (more != 0) {
#line 124
    goto ldv_32558;
  } else {

  }
#line 94
  i1 = i1 + 1;
  ldv_32562: ;
#line 94
  if (i1 <= 7) {
#line 96
    goto ldv_32561;
  } else {

  }
#line 93
  line = line + 1;
  ldv_32565: ;
#line 93
  if (barheight / 2 > line) {
#line 95
    goto ldv_32564;
  } else {

  }

#line 154
  return;
}
}
#line 304 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 54 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 66
extern void vfree(void const   * ) ;
#line 1371 "include/linux/usb.h"
int ldv_usb_submit_urb_23(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 1375
int ldv_usb_submit_urb_24(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 292 "include/linux/mm.h"
extern struct page *vmalloc_to_page(void const   * ) ;
#line 285 "include/sound/core.h"
extern int snd_card_create(int  , char const   * , struct module * , int  , struct snd_card ** ) ;
#line 293
extern int snd_card_register(struct snd_card * ) ;
#line 475 "include/sound/pcm.h"
extern int snd_pcm_new(struct snd_card * , char const   * , int  , int  , int  , struct snd_pcm ** ) ;
#line 758 "include/sound/pcm.h"
__inline static struct snd_interval  const  *hw_param_interval_c(struct snd_pcm_hw_params  const  *params ,
                                                                 snd_pcm_hw_param_t var ) 
{ 


  {
#line 761
  return ((struct snd_interval  const  *)(& params->intervals) + ((unsigned long )var + 0xfffffffffffffff8UL));
}
}
#line 863
extern void snd_pcm_set_ops(struct snd_pcm * , int  , struct snd_pcm_ops * ) ;
#line 866
extern int snd_pcm_lib_ioctl(struct snd_pcm_substream * , unsigned int  , void * ) ;
#line 38 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static struct snd_pcm_hardware  const  alsa_hardware  = 
#line 38 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
     {65795U, 4ULL, 160U, 32000U, 48000U, 2U, 2U, 524288UL, 16384UL, 32768UL, 32U, 64U,
    0UL};
#line 64 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_audio_submit_urbs(struct easycap *peasycap ) 
{ 
  struct data_urb *pdata_urb ;
  struct urb *purb ;
  struct list_head *plist_head ;
  int j ;
  int isbad ;
  int nospc ;
  int m ;
  int rc ;
  int isbuf ;
  struct list_head  const  *__mptr ;
  unsigned int tmp ;
  char const   *tmp___0 ;

  {
#line 72
  if ((unsigned long )peasycap->purb_audio_head == (unsigned long )((struct list_head *)0)) {
#line 73
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->urb_audio_head uninitialized\n", peasycap->isdongle,
           "easycap_audio_submit_urbs");
#line 74
    return (-14);
  } else {

  }
#line 76
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 77
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_audio_submit_urbs");
#line 78
    return (-14);
  } else {

  }
#line 81
  if (peasycap->audio_isoc_streaming != 0) {
#line 82
    if (easycap_debug > 3) {
#line 82
      printk("<7>easycap::%i%s: already streaming audio urbs\n", peasycap->isdongle,
             "easycap_audio_submit_urbs");
    } else {

    }
#line 83
    return (0);
  } else {

  }
#line 86
  if (easycap_debug > 3) {
#line 86
    printk("<7>easycap::%i%s: initial submission of all audio urbs\n", peasycap->isdongle,
           "easycap_audio_submit_urbs");
  } else {

  }
#line 87
  rc = usb_set_interface(peasycap->pusb_device, peasycap->audio_interface, peasycap->audio_altsetting_on);
#line 90
  if (easycap_debug > 7) {
#line 90
    printk("<7>easycap::%i%s: usb_set_interface(.,%i,%i) returned %i\n", peasycap->isdongle,
           "easycap_audio_submit_urbs", peasycap->audio_interface, peasycap->audio_altsetting_on,
           rc);
  } else {

  }
#line 94
  isbad = 0;
#line 95
  nospc = 0;
#line 96
  m = 0;
#line 97
  plist_head = (peasycap->purb_audio_head)->next;
#line 97
  goto ldv_32544;
  ldv_32543: 
#line 98
  __mptr = (struct list_head  const  *)plist_head;
#line 98
  pdata_urb = (struct data_urb *)__mptr;
#line 99
  if ((unsigned long )pdata_urb != (unsigned long )((struct data_urb *)0) && (unsigned long )pdata_urb->purb != (unsigned long )((struct urb *)0)) {
#line 100
    purb = pdata_urb->purb;
#line 101
    isbuf = pdata_urb->isbuf;
#line 103
    purb->interval = 1;
#line 104
    purb->dev = peasycap->pusb_device;
#line 105
    tmp = __create_pipe(peasycap->pusb_device, (unsigned int )peasycap->audio_endpointnumber);
#line 105
    purb->pipe = tmp | 128U;
#line 107
    purb->transfer_flags = 2U;
#line 108
    purb->transfer_buffer = peasycap->audio_isoc_buffer[isbuf].pgo;
#line 109
    purb->transfer_buffer_length = (u32 )peasycap->audio_isoc_buffer_size;
#line 110
    purb->complete = & easycap_alsa_complete;
#line 111
    purb->context = (void *)peasycap;
#line 112
    purb->start_frame = 0;
#line 113
    purb->number_of_packets = peasycap->audio_isoc_framesperdesc;
#line 114
    j = 0;
#line 114
    goto ldv_32541;
    ldv_32540: 
#line 115
    purb->iso_frame_desc[j].offset = (unsigned int )(peasycap->audio_isoc_maxframesize * j);
#line 116
    purb->iso_frame_desc[j].length = (unsigned int )peasycap->audio_isoc_maxframesize;
#line 114
    j = j + 1;
    ldv_32541: ;
#line 114
    if (peasycap->audio_isoc_framesperdesc > j) {
#line 116
      goto ldv_32540;
    } else {

    }
#line 119
    rc = ldv_usb_submit_urb_23(purb, 208U);
#line 120
    if (rc != 0) {
#line 121
      isbad = isbad + 1;
#line 122
      tmp___0 = strerror(rc);
#line 122
      printk("<7>easycap::%i%s: OLD_ERROR: usb_submit_urb() failed for urb with rc: -%s: %d\n",
             peasycap->isdongle, "easycap_audio_submit_urbs", tmp___0, rc);
    } else {
#line 126
      m = m + 1;
    }
  } else {
#line 129
    isbad = isbad + 1;
  }
#line 97
  plist_head = plist_head->next;
  ldv_32544: ;
#line 97
  if ((unsigned long )peasycap->purb_audio_head != (unsigned long )plist_head) {
#line 99
    goto ldv_32543;
  } else {

  }

#line 132
  if (nospc != 0) {
#line 133
    printk("<7>easycap::%i%s: -ENOSPC=usb_submit_urb() for %i urbs\n", peasycap->isdongle,
           "easycap_audio_submit_urbs", nospc);
#line 134
    printk("<7>easycap::%i%s: .....  possibly inadequate USB bandwidth\n", peasycap->isdongle,
           "easycap_audio_submit_urbs");
#line 135
    peasycap->audio_eof = 1;
  } else {

  }
#line 138
  if (isbad != 0) {
#line 139
    easycap_audio_kill_urbs(peasycap);
  } else {
#line 141
    peasycap->audio_isoc_streaming = m;
  }
#line 143
  return (0);
}
}
#line 150 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_sound_setup(struct easycap *peasycap ) 
{ 
  int rc ;

  {
#line 154
  if (easycap_debug > 3) {
#line 154
    printk("<7>easycap::%i%s: starting initialization\n", peasycap->isdongle, "easycap_sound_setup");
  } else {

  }
#line 156
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 157
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL.\n", "easycap_sound_setup");
#line 158
    return (-14);
  } else {

  }
#line 160
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 161
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device is NULL\n", peasycap->isdongle,
           "easycap_sound_setup");
#line 162
    return (-19);
  } else {

  }
#line 164
  if (easycap_debug > 15) {
#line 164
    printk("<7>easycap::%i%s: 0x%08lX=peasycap->pusb_device\n", peasycap->isdongle,
           "easycap_sound_setup", (long )peasycap->pusb_device);
  } else {

  }
#line 166
  rc = easycap_audio_setup(peasycap);
#line 167
  if (easycap_debug > 7) {
#line 167
    printk("<7>easycap::%i%s: audio_setup() returned %i\n", peasycap->isdongle, "easycap_sound_setup",
           rc);
  } else {

  }
#line 169
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 170
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device has become NULL\n", peasycap->isdongle,
           "easycap_sound_setup");
#line 171
    return (-19);
  } else {

  }
#line 174
  if ((unsigned long )peasycap->pusb_device == (unsigned long )((struct usb_device *)0)) {
#line 175
    printk("<7>easycap::%i%s: OLD_ERROR: peasycap->pusb_device has become NULL\n", peasycap->isdongle,
           "easycap_sound_setup");
#line 176
    return (-19);
  } else {

  }
#line 178
  rc = usb_set_interface(peasycap->pusb_device, peasycap->audio_interface, peasycap->audio_altsetting_on);
#line 180
  if (easycap_debug > 7) {
#line 180
    printk("<7>easycap::%i%s: usb_set_interface(.,%i,%i) returned %i\n", peasycap->isdongle,
           "easycap_sound_setup", peasycap->audio_interface, peasycap->audio_altsetting_on,
           rc);
  } else {

  }
#line 183
  rc = easycap_wakeup_device(peasycap->pusb_device);
#line 184
  if (easycap_debug > 7) {
#line 184
    printk("<7>easycap::%i%s: wakeup_device() returned %i\n", peasycap->isdongle,
           "easycap_sound_setup", rc);
  } else {

  }
#line 186
  peasycap->audio_eof = 0;
#line 187
  peasycap->audio_idle = 0;
#line 189
  easycap_audio_submit_urbs(peasycap);
#line 191
  if (easycap_debug > 3) {
#line 191
    printk("<7>easycap::%i%s: finished initialization\n", peasycap->isdongle, "easycap_sound_setup");
  } else {

  }
#line 192
  return (0);
}
}
#line 202 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
void easycap_alsa_complete(struct urb *purb ) 
{ 
  struct easycap *peasycap ;
  struct snd_pcm_substream *pss ;
  struct snd_pcm_runtime *prt ;
  int dma_bytes ;
  int fragment_bytes ;
  int isfragment ;
  u8 *p1 ;
  u8 *p2 ;
  s16 tmp ;
  int i ;
  int j ;
  int more ;
  int much ;
  int rc ;
  int k ;
  s16 oldaudio ;
  s16 newaudio ;
  s16 delta ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t __len ;
  void *__ret ;
  char const   *tmp___2 ;

  {
#line 217
  if (easycap_debug > 15) {
#line 217
    printk("<7>easycap:: %s: \n", "easycap_alsa_complete");
  } else {

  }
#line 219
  if ((unsigned long )purb == (unsigned long )((struct urb *)0)) {
#line 220
    printk("<7>easycap:: %s: OLD_ERROR: purb is NULL\n", "easycap_alsa_complete");
#line 221
    return;
  } else {

  }
#line 223
  peasycap = (struct easycap *)purb->context;
#line 224
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 225
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_alsa_complete");
#line 226
    return;
  } else {

  }
#line 228
  much = 0;
#line 229
  if (peasycap->audio_idle != 0) {
#line 230
    if (easycap_debug > 15) {
#line 230
      printk("<7>easycap::%i%s: %i=audio_idle  %i=audio_isoc_streaming\n", peasycap->isdongle,
             "easycap_alsa_complete", peasycap->audio_idle, peasycap->audio_isoc_streaming);
    } else {

    }
#line 232
    if (peasycap->audio_isoc_streaming != 0) {
#line 233
      goto resubmit;
    } else {

    }
  } else {

  }
#line 236
  pss = peasycap->psubstream;
#line 237
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 238
    goto resubmit;
  } else {

  }
#line 239
  prt = pss->runtime;
#line 240
  if ((unsigned long )prt == (unsigned long )((struct snd_pcm_runtime *)0)) {
#line 241
    goto resubmit;
  } else {

  }
#line 242
  dma_bytes = (int )prt->dma_bytes;
#line 243
  if (dma_bytes == 0) {
#line 244
    goto resubmit;
  } else {

  }
#line 245
  fragment_bytes = (int )prt->period_size * 4;
#line 246
  if (fragment_bytes == 0) {
#line 247
    goto resubmit;
  } else {

  }
#line 249
  if (purb->status != 0) {
#line 250
    if (purb->status == -108 || purb->status == -2) {
#line 251
      if (easycap_debug > 15) {
#line 251
        printk("<7>easycap::%i%s: urb status -ESHUTDOWN or -ENOENT\n", peasycap->isdongle,
               "easycap_alsa_complete");
      } else {

      }
#line 252
      return;
    } else {

    }
#line 254
    tmp___0 = strerror(purb->status);
#line 254
    printk("<7>easycap::%i%s: OLD_ERROR: non-zero urb status: -%s: %d\n", peasycap->isdongle,
           "easycap_alsa_complete", tmp___0, purb->status);
#line 256
    goto resubmit;
  } else {

  }
#line 265
  oldaudio = peasycap->oldaudio;
#line 268
  i = 0;
#line 268
  goto ldv_32588;
  ldv_32587: ;
#line 269
  if (purb->iso_frame_desc[i].status < 0) {
#line 270
    tmp___1 = strerror(purb->iso_frame_desc[i].status);
#line 270
    printk("<7>easycap::%i%s: -%s: %d\n", peasycap->isdongle, "easycap_alsa_complete",
           tmp___1, purb->iso_frame_desc[i].status);
  } else {

  }
#line 274
  if (purb->iso_frame_desc[i].status != 0) {
#line 275
    if (easycap_debug > 11) {
#line 275
      printk("<7>easycap::%i%s: discarding audio samples because %i=purb->iso_frame_desc[i].status\n",
             peasycap->isdongle, "easycap_alsa_complete", purb->iso_frame_desc[i].status);
    } else {

    }
#line 278
    goto ldv_32574;
  } else {

  }
#line 280
  more = (int )purb->iso_frame_desc[i].actual_length;
#line 281
  if (more == 0) {
#line 282
    peasycap->audio_mt = peasycap->audio_mt + 1;
#line 283
    goto ldv_32574;
  } else {

  }
#line 285
  if (more < 0) {
#line 286
    printk("<7>easycap::%i%s: MISTAKE: more is negative\n", peasycap->isdongle, "easycap_alsa_complete");
#line 287
    return;
  } else {

  }
#line 290
  if (peasycap->audio_mt != 0) {
#line 291
    if (easycap_debug > 11) {
#line 291
      printk("<7>easycap::%i%s: %4i empty audio urb frames\n", peasycap->isdongle,
             "easycap_alsa_complete", peasycap->audio_mt);
    } else {

    }
#line 293
    peasycap->audio_mt = 0;
  } else {

  }
#line 296
  p1 = (u8 *)purb->transfer_buffer + (unsigned long )purb->iso_frame_desc[i].offset;
#line 305
  goto ldv_32585;
  ldv_32584: 
#line 306
  much = dma_bytes - peasycap->dma_fill;
#line 307
  if (much < 0) {
#line 308
    printk("<7>easycap::%i%s: MISTAKE: much is negative\n", peasycap->isdongle, "easycap_alsa_complete");
#line 309
    return;
  } else {

  }
#line 311
  if (much == 0) {
#line 312
    peasycap->dma_fill = 0;
#line 313
    peasycap->dma_next = fragment_bytes;
#line 314
    if (easycap_debug > 7) {
#line 314
      printk("<7>easycap::%i%s: wrapped dma buffer\n", peasycap->isdongle, "easycap_alsa_complete");
    } else {

    }
  } else {

  }
#line 316
  if (! peasycap->microphone) {
#line 317
    if (much > more) {
#line 318
      much = more;
    } else {

    }
#line 319
    __len = (size_t )much;
#line 319
    __ret = __builtin_memcpy((void *)prt->dma_area + (unsigned long )peasycap->dma_fill,
                             (void const   *)p1, __len);
#line 321
    p1 = p1 + (unsigned long )much;
#line 322
    more = more - much;
  } else {
#line 325
    if (((unsigned int )much & 15U) != 0U) {
#line 326
      if (easycap_debug > 7) {
#line 326
        printk("<7>easycap::%i%s: MISTAKE? much is not divisible by 16\n", peasycap->isdongle,
               "easycap_alsa_complete");
      } else {

      }
    } else {

    }
#line 328
    if (more * 16 < much) {
#line 329
      much = more * 16;
    } else {

    }
#line 330
    p2 = prt->dma_area + (unsigned long )peasycap->dma_fill;
#line 332
    j = 0;
#line 332
    goto ldv_32582;
    ldv_32581: 
#line 333
    newaudio = (s16 )((unsigned int )((unsigned short )*p1) + 65408U);
#line 334
    newaudio = (s16 )((unsigned int )((unsigned short )newaudio) * 128U);
#line 336
    delta = (s16 )(((int )newaudio - (int )oldaudio) / 4);
#line 337
    tmp = (s16 )((int )((unsigned short )oldaudio) + (int )((unsigned short )delta));
#line 339
    k = 0;
#line 339
    goto ldv_32579;
    ldv_32578: 
#line 340
    *p2 = (u8 )tmp;
#line 341
    *(p2 + 1UL) = (u8 )(((int )tmp & 65280) >> 8);
#line 342
    p2 = p2 + 2UL;
#line 343
    *p2 = (u8 )tmp;
#line 344
    *(p2 + 1UL) = (u8 )(((int )tmp & 65280) >> 8);
#line 345
    p2 = p2 + 2UL;
#line 346
    tmp = (s16 )((int )((unsigned short )tmp) + (int )((unsigned short )delta));
#line 339
    k = k + 1;
    ldv_32579: ;
#line 339
    if (k <= 3) {
#line 341
      goto ldv_32578;
    } else {

    }
#line 348
    p1 = p1 + 1;
#line 349
    more = more - 1;
#line 350
    oldaudio = tmp;
#line 332
    j = j + 1;
    ldv_32582: ;
#line 332
    if (much / 16 > j) {
#line 334
      goto ldv_32581;
    } else {

    }

  }
#line 368
  peasycap->dma_fill = peasycap->dma_fill + much;
#line 369
  if (peasycap->dma_fill >= peasycap->dma_next) {
#line 370
    isfragment = peasycap->dma_fill / fragment_bytes;
#line 371
    if (isfragment < 0) {
#line 372
      printk("<7>easycap::%i%s: MISTAKE: isfragment is negative\n", peasycap->isdongle,
             "easycap_alsa_complete");
#line 373
      return;
    } else {

    }
#line 375
    peasycap->dma_read = (isfragment + -1) * fragment_bytes;
#line 376
    peasycap->dma_next = (isfragment + 1) * fragment_bytes;
#line 377
    if (peasycap->dma_next > dma_bytes) {
#line 378
      peasycap->dma_next = fragment_bytes;
    } else {

    }
#line 380
    if (peasycap->dma_read >= 0) {
#line 381
      if (easycap_debug > 7) {
#line 381
        printk("<7>easycap::%i%s: snd_pcm_period_elapsed(), %i=isfragment\n", peasycap->isdongle,
               "easycap_alsa_complete", isfragment);
      } else {

      }
#line 383
      snd_pcm_period_elapsed(pss);
    } else {

    }
  } else {

  }
  ldv_32585: ;
#line 305
  if (more != 0) {
#line 307
    goto ldv_32584;
  } else {

  }
#line 389
  peasycap->oldaudio = oldaudio;
  ldv_32574: 
#line 268
  i = i + 1;
  ldv_32588: ;
#line 268
  if (purb->number_of_packets > i) {
#line 270
    goto ldv_32587;
  } else {

  }

  resubmit: ;
#line 399
  if (peasycap->audio_isoc_streaming == 0) {
#line 400
    return;
  } else {

  }
#line 402
  rc = ldv_usb_submit_urb_24(purb, 32U);
#line 403
  if (rc != 0) {
#line 404
    if (rc != -19 && rc != -2) {
#line 405
      tmp___2 = strerror(rc);
#line 405
      printk("<7>easycap::%i%s: OLD_ERROR: while %i=audio_idle, usb_submit_urb failed with rc: -%s :%d\n",
             peasycap->isdongle, "easycap_alsa_complete", peasycap->audio_idle, tmp___2,
             rc);
    } else {

    }
#line 409
    if (peasycap->audio_isoc_streaming > 0) {
#line 410
      peasycap->audio_isoc_streaming = peasycap->audio_isoc_streaming - 1;
    } else {

    }
  } else {

  }
#line 412
  return;
}
}
#line 415 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_open(struct snd_pcm_substream *pss ) 
{ 
  struct snd_pcm *psnd_pcm ;
  struct snd_card *psnd_card ;
  struct easycap *peasycap ;
  int tmp ;

  {
#line 421
  if (easycap_debug > 3) {
#line 421
    printk("<7>easycap:: %s: \n", "easycap_alsa_open");
  } else {

  }
#line 422
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 423
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_open");
#line 424
    return (-14);
  } else {

  }
#line 426
  psnd_pcm = pss->pcm;
#line 427
  if ((unsigned long )psnd_pcm == (unsigned long )((struct snd_pcm *)0)) {
#line 428
    printk("<7>easycap:: %s: OLD_ERROR:  psnd_pcm is NULL\n", "easycap_alsa_open");
#line 429
    return (-14);
  } else {

  }
#line 431
  psnd_card = psnd_pcm->card;
#line 432
  if ((unsigned long )psnd_card == (unsigned long )((struct snd_card *)0)) {
#line 433
    printk("<7>easycap:: %s: OLD_ERROR:  psnd_card is NULL\n", "easycap_alsa_open");
#line 434
    return (-14);
  } else {

  }
#line 437
  peasycap = (struct easycap *)psnd_card->private_data;
#line 438
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 439
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_alsa_open");
#line 440
    return (-14);
  } else {

  }
#line 442
  if ((unsigned long )peasycap->psnd_card != (unsigned long )psnd_card) {
#line 443
    printk("<7>easycap::%i%s: OLD_ERROR: bad peasycap->psnd_card\n", peasycap->isdongle,
           "easycap_alsa_open");
#line 444
    return (-14);
  } else {

  }
#line 446
  if ((unsigned long )peasycap->psubstream != (unsigned long )((struct snd_pcm_substream *)0)) {
#line 447
    printk("<7>easycap::%i%s: OLD_ERROR: bad peasycap->psubstream\n", peasycap->isdongle,
           "easycap_alsa_open");
#line 448
    return (-14);
  } else {

  }
#line 450
  pss->private_data = (void *)peasycap;
#line 451
  peasycap->psubstream = pss;
#line 452
  (pss->runtime)->hw = peasycap->alsa_hardware;
#line 453
  (pss->runtime)->private_data = (void *)peasycap;
#line 454
  pss->private_data = (void *)peasycap;
#line 456
  tmp = easycap_sound_setup(peasycap);
#line 456
  if (tmp != 0) {
#line 457
    if (easycap_debug > 3) {
#line 457
      printk("<7>easycap::%i%s: ending unsuccessfully\n", peasycap->isdongle, "easycap_alsa_open");
    } else {

    }
#line 458
    return (-14);
  } else {

  }
#line 460
  if (easycap_debug > 3) {
#line 460
    printk("<7>easycap::%i%s: ending successfully\n", peasycap->isdongle, "easycap_alsa_open");
  } else {

  }
#line 461
  return (0);
}
}
#line 464 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_close(struct snd_pcm_substream *pss ) 
{ 
  struct easycap *peasycap ;

  {
#line 468
  if (easycap_debug > 3) {
#line 468
    printk("<7>easycap:: %s: \n", "easycap_alsa_close");
  } else {

  }
#line 469
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 470
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_close");
#line 471
    return (-14);
  } else {

  }
#line 473
  peasycap = (struct easycap *)pss->private_data;
#line 474
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 475
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_alsa_close");
#line 476
    return (-14);
  } else {

  }
#line 478
  pss->private_data = (void *)0;
#line 479
  peasycap->psubstream = (struct snd_pcm_substream *)0;
#line 480
  if (easycap_debug > 3) {
#line 480
    printk("<7>easycap:: %s: ending successfully\n", "easycap_alsa_close");
  } else {

  }
#line 481
  return (0);
}
}
#line 484 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_vmalloc(struct snd_pcm_substream *pss , size_t sz ) 
{ 
  struct snd_pcm_runtime *prt ;
  void *tmp ;

  {
#line 487
  if (easycap_debug > 3) {
#line 487
    printk("<7>easycap:: %s: \n", "easycap_alsa_vmalloc");
  } else {

  }
#line 489
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 490
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_vmalloc");
#line 491
    return (-14);
  } else {

  }
#line 493
  prt = pss->runtime;
#line 494
  if ((unsigned long )prt == (unsigned long )((struct snd_pcm_runtime *)0)) {
#line 495
    printk("<7>easycap:: %s: OLD_ERROR: substream.runtime is NULL\n", "easycap_alsa_vmalloc");
#line 496
    return (-14);
  } else {

  }
#line 498
  if ((unsigned long )prt->dma_area != (unsigned long )((unsigned char *)0U)) {
#line 499
    if (prt->dma_bytes > sz) {
#line 500
      return (0);
    } else {

    }
#line 501
    vfree((void const   *)prt->dma_area);
  } else {

  }
#line 503
  tmp = vmalloc(sz);
#line 503
  prt->dma_area = (unsigned char *)tmp;
#line 504
  if ((unsigned long )prt->dma_area == (unsigned long )((unsigned char *)0U)) {
#line 505
    return (-12);
  } else {

  }
#line 506
  prt->dma_bytes = sz;
#line 507
  return (0);
}
}
#line 510 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_hw_params(struct snd_pcm_substream *pss , struct snd_pcm_hw_params *phw ) 
{ 
  int rc ;
  struct snd_interval  const  *tmp ;
  struct snd_interval  const  *tmp___0 ;

  {
#line 515
  if (easycap_debug > 3) {
#line 515
    tmp = hw_param_interval_c((struct snd_pcm_hw_params  const  *)phw, 18);
#line 515
    printk("<7>easycap:: %s: %i\n", "easycap_alsa_hw_params", tmp->min);
  } else {

  }
#line 516
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 517
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_hw_params");
#line 518
    return (-14);
  } else {

  }
#line 520
  tmp___0 = hw_param_interval_c((struct snd_pcm_hw_params  const  *)phw, 18);
#line 520
  rc = easycap_alsa_vmalloc(pss, (size_t )tmp___0->min);
#line 521
  if (rc != 0) {
#line 522
    return (rc);
  } else {

  }
#line 523
  return (0);
}
}
#line 526 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_hw_free(struct snd_pcm_substream *pss ) 
{ 
  struct snd_pcm_runtime *prt ;

  {
#line 529
  if (easycap_debug > 3) {
#line 529
    printk("<7>easycap:: %s: \n", "easycap_alsa_hw_free");
  } else {

  }
#line 531
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 532
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_hw_free");
#line 533
    return (-14);
  } else {

  }
#line 535
  prt = pss->runtime;
#line 536
  if ((unsigned long )prt == (unsigned long )((struct snd_pcm_runtime *)0)) {
#line 537
    printk("<7>easycap:: %s: OLD_ERROR: substream.runtime is NULL\n", "easycap_alsa_hw_free");
#line 538
    return (-14);
  } else {

  }
#line 540
  if ((unsigned long )prt->dma_area != (unsigned long )((unsigned char *)0U)) {
#line 541
    if (easycap_debug > 7) {
#line 541
      printk("<7>easycap:: %s: prt->dma_area = %p\n", "easycap_alsa_hw_free", prt->dma_area);
    } else {

    }
#line 542
    vfree((void const   *)prt->dma_area);
#line 543
    prt->dma_area = (unsigned char *)0U;
  } else
#line 545
  if (easycap_debug > 7) {
#line 545
    printk("<7>easycap:: %s: dma_area already freed\n", "easycap_alsa_hw_free");
  } else {

  }
#line 546
  return (0);
}
}
#line 549 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_prepare(struct snd_pcm_substream *pss ) 
{ 
  struct easycap *peasycap ;
  struct snd_pcm_runtime *prt ;

  {
#line 554
  if (easycap_debug > 3) {
#line 554
    printk("<7>easycap:: %s: \n", "easycap_alsa_prepare");
  } else {

  }
#line 555
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 556
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_prepare");
#line 557
    return (-14);
  } else {

  }
#line 559
  prt = pss->runtime;
#line 560
  peasycap = (struct easycap *)pss->private_data;
#line 561
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 562
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_alsa_prepare");
#line 563
    return (-14);
  } else {

  }
#line 566
  if (easycap_debug > 15) {
#line 566
    printk("<7>easycap::%i%s: ALSA decides %8i Hz=rate\n", peasycap->isdongle, "easycap_alsa_prepare",
           (pss->runtime)->rate);
  } else {

  }
#line 567
  if (easycap_debug > 15) {
#line 567
    printk("<7>easycap::%i%s: ALSA decides %8ld =period_size\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->period_size);
  } else {

  }
#line 568
  if (easycap_debug > 15) {
#line 568
    printk("<7>easycap::%i%s: ALSA decides %8i =periods\n", peasycap->isdongle, "easycap_alsa_prepare",
           (pss->runtime)->periods);
  } else {

  }
#line 569
  if (easycap_debug > 15) {
#line 569
    printk("<7>easycap::%i%s: ALSA decides %8ld =buffer_size\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->buffer_size);
  } else {

  }
#line 570
  if (easycap_debug > 15) {
#line 570
    printk("<7>easycap::%i%s: ALSA decides %8zd =dma_bytes\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->dma_bytes);
  } else {

  }
#line 571
  if (easycap_debug > 15) {
#line 571
    printk("<7>easycap::%i%s: ALSA decides %8ld =boundary\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->boundary);
  } else {

  }
#line 572
  if (easycap_debug > 15) {
#line 572
    printk("<7>easycap::%i%s: ALSA decides %8i =period_step\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->period_step);
  } else {

  }
#line 573
  if (easycap_debug > 15) {
#line 573
    printk("<7>easycap::%i%s: ALSA decides %8i =sample_bits\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->sample_bits);
  } else {

  }
#line 574
  if (easycap_debug > 15) {
#line 574
    printk("<7>easycap::%i%s: ALSA decides %8i =frame_bits\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->frame_bits);
  } else {

  }
#line 575
  if (easycap_debug > 15) {
#line 575
    printk("<7>easycap::%i%s: ALSA decides %8ld =min_align\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->min_align);
  } else {

  }
#line 576
  if (easycap_debug > 11) {
#line 576
    printk("<7>easycap::%i%s: ALSA decides %8ld =hw_ptr_base\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->hw_ptr_base);
  } else {

  }
#line 577
  if (easycap_debug > 11) {
#line 577
    printk("<7>easycap::%i%s: ALSA decides %8ld =hw_ptr_interrupt\n", peasycap->isdongle,
           "easycap_alsa_prepare", (pss->runtime)->hw_ptr_interrupt);
  } else {

  }
#line 580
  if (prt->dma_bytes != (size_t )(((int )prt->period_size * 4) * (int )prt->periods)) {
#line 581
    printk("<7>easycap:: %s: MISTAKE:  unexpected ALSA parameters\n", "easycap_alsa_prepare");
#line 582
    return (-2);
  } else {

  }
#line 584
  return (0);
}
}
#line 587 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_ack(struct snd_pcm_substream *pss ) 
{ 


  {
#line 589
  return (0);
}
}
#line 592 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static int easycap_alsa_trigger(struct snd_pcm_substream *pss , int cmd ) 
{ 
  struct easycap *peasycap ;

  {
#line 596
  if (easycap_debug > 3) {
#line 596
    printk("<7>easycap:: %s: %i=cmd cf %i=START %i=STOP\n", "easycap_alsa_trigger",
           cmd, 1, 0);
  } else {

  }
#line 598
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 599
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_trigger");
#line 600
    return (-14);
  } else {

  }
#line 602
  peasycap = (struct easycap *)pss->private_data;
#line 603
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 604
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_alsa_trigger");
#line 605
    return (-14);
  } else {

  }
#line 607
  switch (cmd) {
  case 1: 
#line 609
  peasycap->audio_idle = 0;
#line 610
  goto ldv_32635;
  case 0: 
#line 613
  peasycap->audio_idle = 1;
#line 614
  goto ldv_32635;
  default: ;
#line 617
  return (-22);
  }
  ldv_32635: ;
#line 619
  return (0);
}
}
#line 622 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static snd_pcm_uframes_t easycap_alsa_pointer(struct snd_pcm_substream *pss ) 
{ 
  struct easycap *peasycap ;
  snd_pcm_uframes_t offset ;

  {
#line 627
  if (easycap_debug > 15) {
#line 627
    printk("<7>easycap:: %s: \n", "easycap_alsa_pointer");
  } else {

  }
#line 628
  if ((unsigned long )pss == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 629
    printk("<7>easycap:: %s: OLD_ERROR:  pss is NULL\n", "easycap_alsa_pointer");
#line 630
    return (0xfffffffffffffff2UL);
  } else {

  }
#line 632
  peasycap = (struct easycap *)pss->private_data;
#line 633
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 634
    printk("<7>easycap:: %s: OLD_ERROR:  peasycap is NULL\n", "easycap_alsa_pointer");
#line 635
    return (0xfffffffffffffff2UL);
  } else {

  }
#line 637
  if (peasycap->audio_eof != 0 || peasycap->audio_idle != 0) {
#line 638
    if (easycap_debug > 7) {
#line 638
      printk("<7>easycap::%i%s: returning -EIO because  %i=audio_idle  %i=audio_eof\n",
             peasycap->isdongle, "easycap_alsa_pointer", peasycap->audio_idle, peasycap->audio_eof);
    } else {

    }
#line 641
    return (0xfffffffffffffffbUL);
  } else {

  }
#line 644
  if (peasycap->dma_read < 0) {
#line 645
    if (easycap_debug > 7) {
#line 645
      printk("<7>easycap::%i%s: returning -EBUSY\n", peasycap->isdongle, "easycap_alsa_pointer");
    } else {

    }
#line 646
    return (0xfffffffffffffff0UL);
  } else {

  }
#line 648
  offset = (unsigned long )peasycap->dma_read / 4UL;
#line 649
  if (easycap_debug > 7) {
#line 649
    printk("<7>easycap::%i%s: ALSA decides %8i   =hw_ptr_base\n", peasycap->isdongle,
           "easycap_alsa_pointer", (int )(pss->runtime)->hw_ptr_base);
  } else {

  }
#line 650
  if (easycap_debug > 7) {
#line 650
    printk("<7>easycap::%i%s: ALSA decides %8i   =hw_ptr_interrupt\n", peasycap->isdongle,
           "easycap_alsa_pointer", (int )(pss->runtime)->hw_ptr_interrupt);
  } else {

  }
#line 652
  if (easycap_debug > 7) {
#line 652
    printk("<7>easycap::%i%s: %7i=offset %7i=dma_read %7i=dma_next\n", peasycap->isdongle,
           "easycap_alsa_pointer", (int )offset, peasycap->dma_read, peasycap->dma_next);
  } else {

  }
#line 654
  return (offset);
}
}
#line 658 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static struct page *easycap_alsa_page(struct snd_pcm_substream *pss , unsigned long offset ) 
{ 
  struct page *tmp ;

  {
#line 660
  tmp = vmalloc_to_page((void const   *)((pss->runtime)->dma_area + offset));
#line 660
  return (tmp);
}
}
#line 664 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
static struct snd_pcm_ops easycap_alsa_pcm_ops  = 
#line 664
     {& easycap_alsa_open, & easycap_alsa_close, & snd_pcm_lib_ioctl, & easycap_alsa_hw_params,
    & easycap_alsa_hw_free, & easycap_alsa_prepare, & easycap_alsa_trigger, & easycap_alsa_pointer,
    0, 0, & easycap_alsa_page, 0, & easycap_alsa_ack};
#line 684 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.c"
int easycap_alsa_probe(struct easycap *peasycap ) 
{ 
  int rc ;
  struct snd_card *psnd_card ;
  struct snd_pcm *psnd_pcm ;
  int tmp ;

  {
#line 690
  if ((unsigned long )peasycap == (unsigned long )((struct easycap *)0)) {
#line 691
    printk("<7>easycap:: %s: OLD_ERROR: peasycap is NULL\n", "easycap_alsa_probe");
#line 692
    return (-19);
  } else {

  }
#line 694
  if (peasycap->minor < 0) {
#line 695
    printk("<7>easycap:: %s: OLD_ERROR: no minor\n", "easycap_alsa_probe");
#line 696
    return (-19);
  } else {

  }
#line 699
  peasycap->alsa_hardware = alsa_hardware;
#line 700
  if ((int )peasycap->microphone) {
#line 701
    peasycap->alsa_hardware.rates = 32U;
#line 702
    peasycap->alsa_hardware.rate_min = 32000U;
#line 703
    peasycap->alsa_hardware.rate_max = 32000U;
  } else {
#line 705
    peasycap->alsa_hardware.rates = 128U;
#line 706
    peasycap->alsa_hardware.rate_min = 48000U;
#line 707
    peasycap->alsa_hardware.rate_max = 48000U;
  }
#line 710
  tmp = snd_card_create(-1, "easycap_alsa", & __this_module, 0, & psnd_card);
#line 710
  if (tmp != 0) {
#line 712
    printk("<7>easycap:: %s: OLD_ERROR: Cannot do ALSA snd_card_create()\n", "easycap_alsa_probe");
#line 713
    return (-14);
  } else {

  }
#line 716
  sprintf((char *)(& psnd_card->id), "EasyALSA%i", peasycap->minor);
#line 717
  strcpy((char *)(& psnd_card->driver), "easycapdc60");
#line 718
  strcpy((char *)(& psnd_card->shortname), "easycap_alsa");
#line 719
  sprintf((char *)(& psnd_card->longname), "%s", (char *)(& psnd_card->shortname));
#line 721
  psnd_card->dev = & (peasycap->pusb_device)->dev;
#line 722
  psnd_card->private_data = (void *)peasycap;
#line 723
  peasycap->psnd_card = psnd_card;
#line 725
  rc = snd_pcm_new(psnd_card, "easycap_pcm", 0, 0, 1, & psnd_pcm);
#line 726
  if (rc != 0) {
#line 727
    printk("<7>easycap::%i%s: OLD_ERROR: Cannot do ALSA snd_pcm_new()\n", peasycap->isdongle,
           "easycap_alsa_probe");
#line 728
    snd_card_free(psnd_card);
#line 729
    return (-14);
  } else {

  }
#line 732
  snd_pcm_set_ops(psnd_pcm, 1, & easycap_alsa_pcm_ops);
#line 734
  psnd_pcm->info_flags = 0U;
#line 735
  strcpy((char *)(& psnd_pcm->name), (char const   *)(& psnd_card->id));
#line 736
  psnd_pcm->private_data = (void *)peasycap;
#line 737
  peasycap->psnd_pcm = psnd_pcm;
#line 738
  peasycap->psubstream = (struct snd_pcm_substream *)0;
#line 740
  rc = snd_card_register(psnd_card);
#line 741
  if (rc != 0) {
#line 742
    printk("<7>easycap::%i%s: OLD_ERROR: Cannot do ALSA snd_card_register()\n", peasycap->isdongle,
           "easycap_alsa_probe");
#line 743
    snd_card_free(psnd_card);
#line 744
    return (-14);
  } else {

  }
#line 747
  printk("<7>easycap::%i%s: registered %s\n", peasycap->isdongle, "easycap_alsa_probe",
         (char *)(& psnd_card->id));
#line 748
  return (0);
}
}
#line 48 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.o.c.prepared"
int ldv_retval_0  ;
#line 49 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.o.c.prepared"
int ldv_retval_1  ;
#line 52 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.o.c.prepared"
void ldv_initialize_snd_pcm_ops_1(void) 
{ 
  void *tmp ;

  {
#line 53
  tmp = ldv_init_zalloc(488UL);
#line 53
  easycap_alsa_pcm_ops_group0 = (struct snd_pcm_substream *)tmp;
#line 54
  return;
}
}
#line 56 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.o.c.prepared"
void ldv_main_exported_1(void) 
{ 
  struct snd_pcm_hw_params *ldvarg2 ;
  void *tmp ;
  unsigned int ldvarg5 ;
  unsigned long ldvarg3 ;
  void *ldvarg4 ;
  void *tmp___0 ;
  int ldvarg1 ;
  int tmp___1 ;

  {
#line 57
  tmp = ldv_init_zalloc(608UL);
#line 57
  ldvarg2 = (struct snd_pcm_hw_params *)tmp;
#line 60
  tmp___0 = ldv_init_zalloc(1UL);
#line 60
  ldvarg4 = tmp___0;
#line 58
  ldv_memset((void *)(& ldvarg5), 0, 4UL);
#line 59
  ldv_memset((void *)(& ldvarg3), 0, 8UL);
#line 61
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 63
  tmp___1 = __VERIFIER_nondet_int();
#line 63
  switch (tmp___1) {
  case 0: ;
#line 66
  if (ldv_state_variable_1 == 1) {
#line 68
    easycap_alsa_prepare(easycap_alsa_pcm_ops_group0);
#line 70
    ldv_state_variable_1 = 1;
  } else {

  }
#line 73
  if (ldv_state_variable_1 == 2) {
#line 75
    easycap_alsa_prepare(easycap_alsa_pcm_ops_group0);
#line 77
    ldv_state_variable_1 = 2;
  } else {

  }
#line 80
  goto ldv_32670;
  case 1: ;
#line 83
  if (ldv_state_variable_1 == 1) {
#line 85
    easycap_alsa_ack(easycap_alsa_pcm_ops_group0);
#line 87
    ldv_state_variable_1 = 1;
  } else {

  }
#line 90
  if (ldv_state_variable_1 == 2) {
#line 92
    easycap_alsa_ack(easycap_alsa_pcm_ops_group0);
#line 94
    ldv_state_variable_1 = 2;
  } else {

  }
#line 97
  goto ldv_32670;
  case 2: ;
#line 100
  if (ldv_state_variable_1 == 1) {
#line 102
    easycap_alsa_hw_free(easycap_alsa_pcm_ops_group0);
#line 104
    ldv_state_variable_1 = 1;
  } else {

  }
#line 107
  if (ldv_state_variable_1 == 2) {
#line 109
    easycap_alsa_hw_free(easycap_alsa_pcm_ops_group0);
#line 111
    ldv_state_variable_1 = 2;
  } else {

  }
#line 114
  goto ldv_32670;
  case 3: ;
#line 117
  if (ldv_state_variable_1 == 1) {
#line 119
    easycap_alsa_pointer(easycap_alsa_pcm_ops_group0);
#line 121
    ldv_state_variable_1 = 1;
  } else {

  }
#line 124
  if (ldv_state_variable_1 == 2) {
#line 126
    easycap_alsa_pointer(easycap_alsa_pcm_ops_group0);
#line 128
    ldv_state_variable_1 = 2;
  } else {

  }
#line 131
  goto ldv_32670;
  case 4: ;
#line 134
  if (ldv_state_variable_1 == 2) {
#line 136
    ldv_retval_1 = easycap_alsa_close(easycap_alsa_pcm_ops_group0);
#line 138
    if (ldv_retval_1 == 0) {
#line 139
      ldv_state_variable_1 = 1;
#line 140
      ref_cnt = ref_cnt - 1;
    } else {

    }
  } else {

  }
#line 144
  goto ldv_32670;
  case 5: ;
#line 147
  if (ldv_state_variable_1 == 1) {
#line 149
    ldv_retval_0 = easycap_alsa_open(easycap_alsa_pcm_ops_group0);
#line 151
    if (ldv_retval_0 == 0) {
#line 152
      ldv_state_variable_1 = 2;
#line 153
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 157
  goto ldv_32670;
  case 6: ;
#line 160
  if (ldv_state_variable_1 == 1) {
#line 162
    snd_pcm_lib_ioctl(easycap_alsa_pcm_ops_group0, ldvarg5, ldvarg4);
#line 164
    ldv_state_variable_1 = 1;
  } else {

  }
#line 167
  if (ldv_state_variable_1 == 2) {
#line 169
    snd_pcm_lib_ioctl(easycap_alsa_pcm_ops_group0, ldvarg5, ldvarg4);
#line 171
    ldv_state_variable_1 = 2;
  } else {

  }
#line 174
  goto ldv_32670;
  case 7: ;
#line 177
  if (ldv_state_variable_1 == 1) {
#line 179
    easycap_alsa_page(easycap_alsa_pcm_ops_group0, ldvarg3);
#line 181
    ldv_state_variable_1 = 1;
  } else {

  }
#line 184
  if (ldv_state_variable_1 == 2) {
#line 186
    easycap_alsa_page(easycap_alsa_pcm_ops_group0, ldvarg3);
#line 188
    ldv_state_variable_1 = 2;
  } else {

  }
#line 191
  goto ldv_32670;
  case 8: ;
#line 194
  if (ldv_state_variable_1 == 1) {
#line 196
    easycap_alsa_hw_params(easycap_alsa_pcm_ops_group0, ldvarg2);
#line 198
    ldv_state_variable_1 = 1;
  } else {

  }
#line 201
  if (ldv_state_variable_1 == 2) {
#line 203
    easycap_alsa_hw_params(easycap_alsa_pcm_ops_group0, ldvarg2);
#line 205
    ldv_state_variable_1 = 2;
  } else {

  }
#line 208
  goto ldv_32670;
  case 9: ;
#line 211
  if (ldv_state_variable_1 == 1) {
#line 213
    easycap_alsa_trigger(easycap_alsa_pcm_ops_group0, ldvarg1);
#line 215
    ldv_state_variable_1 = 1;
  } else {

  }
#line 218
  if (ldv_state_variable_1 == 2) {
#line 220
    easycap_alsa_trigger(easycap_alsa_pcm_ops_group0, ldvarg1);
#line 222
    ldv_state_variable_1 = 2;
  } else {

  }
#line 225
  goto ldv_32670;
  default: 
#line 226
  ldv_stop();
  }
  ldv_32670: ;
#line 230
  return;
}
}
#line 237 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.o.c.prepared"
int ldv_usb_submit_urb_23(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 240
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 240
  return (tmp);
}
}
#line 243 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/dscv/ri/144_2a/drivers/staging/media/easycap/easycap_sound.o.c.prepared"
int ldv_usb_submit_urb_24(struct urb *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 246
  tmp = ldv_submit_urb(ldv_func_arg1);
#line 246
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-svcomp162/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 8 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int INTERF_STATE  =    0;
#line 10 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int SERIAL_STATE  =    0;
#line 13 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void *usb_intfdata  =    (void *)0;
#line 16 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct urb *usb_urb  =    (struct urb *)0;
#line 19 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct usb_device *usb_dev  =    (struct usb_device *)0;
#line 22 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int dev_counter  =    0;
#line 25 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int completeFnIntCounter  =    0;
#line 28 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int completeFnBulkCounter  =    0;
#line 31 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void (*completeFnInt)(struct urb * )  ;
#line 34 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void (*completeFnBulk)(struct urb * )  ;
#line 37 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void *ldv_usb_get_intfdata(void) 
{ 


  {
#line 39
  return (usb_intfdata);
}
}
#line 43 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_usb_set_intfdata(void *data ) 
{ 


  {
#line 46
  usb_intfdata = data;
#line 47
  return;
}
}
#line 50 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_usb_put_intf(void) 
{ 


  {
#line 53
  usb_intfdata = (void *)0;
#line 54
  return;
}
}
#line 57 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct urb *ldv_alloc_urb(void) 
{ 
  struct urb *value ;
  void *tmp ;
  int tmp___0 ;

  {
#line 60
  tmp = ldv_undef_ptr();
#line 60
  value = (struct urb *)tmp;
#line 61
  tmp___0 = ldv_undef_int();
#line 61
  if (tmp___0 != 0) {
#line 63
    if ((unsigned long )value != (unsigned long )((struct urb *)0)) {
#line 66
      usb_urb = value;
    } else {

    }
  } else {

  }
#line 69
  return (usb_urb);
}
}
#line 73 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_free_urb(struct urb *urb ) 
{ 


  {
#line 75
  if ((unsigned long )usb_urb == (unsigned long )urb && (unsigned long )usb_urb != (unsigned long )((struct urb *)0)) {
#line 78
    usb_urb = (struct urb *)0;
  } else {

  }
#line 79
  return;
}
}
#line 82 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_fill_int_urb(struct urb *urb , void (*complete_fn)(struct urb * ) ) 
{ 


  {
#line 84
  if ((unsigned long )usb_urb == (unsigned long )urb) {
#line 89
    completeFnInt = complete_fn;
#line 91
    completeFnIntCounter = completeFnIntCounter + 1;
  } else {

  }
#line 93
  return;
}
}
#line 97 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_fill_bulk_urb(struct urb *urb , void (*complete_fn)(struct urb * ) ) 
{ 


  {
#line 99
  if ((unsigned long )usb_urb == (unsigned long )urb) {
#line 104
    completeFnBulk = complete_fn;
#line 106
    completeFnBulkCounter = completeFnBulkCounter + 1;
  } else {

  }
#line 108
  return;
}
}
#line 112 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int ldv_submit_urb(struct urb *urb ) 
{ 
  int res ;
  int tmp ;

  {
#line 115
  tmp = ldv_undef_int();
#line 115
  res = tmp;
#line 117
  if (res > 0) {
#line 117
    ldv_stop();
  } else {

  }
#line 118
  if (res == 0) {
#line 120
    if ((unsigned long )usb_urb == (unsigned long )urb) {
#line 122
      if (completeFnIntCounter != 0) {
#line 125
        (*completeFnInt)(usb_urb);
#line 127
        completeFnIntCounter = 0;
      } else {

      }
#line 129
      if (completeFnBulkCounter != 0) {
#line 132
        (*completeFnBulk)(usb_urb);
#line 134
        completeFnBulkCounter = 0;
      } else {

      }
    } else {

    }
  } else {

  }
#line 138
  return (res);
}
}
#line 142 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct usb_device *ldv_interface_to_usbdev(void) 
{ 
  void *result ;
  void *tmp ;

  {
#line 145
  tmp = ldv_undef_ptr();
#line 145
  result = tmp;
#line 147
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 147
    ldv_stop();
  } else {

  }
#line 148
  return ((struct usb_device *)result);
}
}
#line 152 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
struct usb_device *ldv_get_dev(struct usb_device *data ) 
{ 
  int tmp ;

  {
#line 154
  if ((unsigned long )usb_dev == (unsigned long )((struct usb_device *)0)) {
#line 156
    tmp = ldv_undef_int();
#line 156
    if (tmp != 0) {
#line 159
      dev_counter = dev_counter + 1;
#line 161
      usb_dev = data;
    } else {

    }
  } else
#line 166
  if ((unsigned long )usb_dev == (unsigned long )data) {
#line 169
    dev_counter = dev_counter + 1;
  } else {

  }
#line 173
  return (usb_dev);
}
}
#line 177 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_put_dev(struct usb_device *data ) 
{ 


  {
#line 179
  if ((unsigned long )usb_dev == (unsigned long )data && (unsigned long )data != (unsigned long )((struct usb_device *)0)) {
#line 182
    dev_counter = dev_counter + -1;
#line 183
    if (dev_counter == 0) {
#line 186
      usb_dev = (struct usb_device *)0;
    } else {

    }
  } else {

  }
#line 188
  return;
}
}
#line 192 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int ldv_get_interface(struct usb_interface *intf ) 
{ 
  int res ;
  int tmp ;

  {
#line 195
  tmp = ldv_undef_int();
#line 195
  res = tmp;
#line 197
  if (res > 0) {
#line 197
    ldv_stop();
  } else {

  }
#line 198
  if (res == 0) {
#line 201
    INTERF_STATE = INTERF_STATE + 1;
  } else {

  }
#line 203
  return (res);
}
}
#line 207 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_put_interface(void) 
{ 


  {
#line 210
  if (INTERF_STATE <= 0) {
#line 210
    ldv_error();
  } else {

  }
#line 212
  INTERF_STATE = INTERF_STATE + -1;
#line 213
  return;
}
}
#line 216 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
int ldv_serial_register(void) 
{ 
  int res ;
  int tmp ;

  {
#line 219
  tmp = ldv_undef_int();
#line 219
  res = tmp;
#line 221
  if (res > 0) {
#line 221
    ldv_stop();
  } else {

  }
#line 222
  if (res == 0) {
#line 225
    SERIAL_STATE = SERIAL_STATE + 1;
  } else {

  }
#line 227
  return (res);
}
}
#line 231 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_serial_deregister(void) 
{ 


  {
#line 234
  if (SERIAL_STATE <= 0) {
#line 234
    ldv_error();
  } else {

  }
#line 236
  SERIAL_STATE = SERIAL_STATE + -1;
#line 237
  return;
}
}
#line 240 "/home/ldvuser/andrianov/commit-tester-work/task-233--linux-stable--dir/work/current--X--drivers/staging/media/easycap/easycap.ko--X--defaultlinux-stable-8817633-1--X--144_2a--X--cpachecker/linux-stable-8817633-1/csd_deg_dscv/16/dscv_tempdir/rule-instrumentor/144_2a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 243
  if ((unsigned long )usb_urb != (unsigned long )((struct urb *)0)) {
#line 243
    ldv_error();
  } else {

  }
#line 245
  if ((unsigned long )usb_dev != (unsigned long )((struct usb_device *)0)) {
#line 245
    ldv_error();
  } else {

  }
#line 247
  if (dev_counter != 0) {
#line 247
    ldv_error();
  } else {

  }
#line 249
  if (INTERF_STATE != 0) {
#line 249
    ldv_error();
  } else {

  }
#line 251
  if (SERIAL_STATE != 0) {
#line 251
    ldv_error();
  } else {

  }
#line 255
  return;
}
}
