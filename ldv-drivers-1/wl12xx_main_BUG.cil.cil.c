/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 19 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 42 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 45 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 11 "include/asm-generic/types.h"
typedef unsigned short umode_t;
#line 14 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/types.h"
typedef u64 dma_addr_t;
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_nlink_t;
#line 13 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_off_t;
#line 18 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_size_t;
#line 19 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_ssize_t;
#line 21 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_time_t;
#line 25 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_clockid_t;
#line 30 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_uid32_t;
#line 31 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_gid32_t;
#line 38 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef long long __kernel_loff_t;
#line 18 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 21 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 23 "include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 24 "include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
#line 25 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 31 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 34 "include/linux/types.h"
typedef _Bool bool;
#line 36 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 37 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 50 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 59 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 64 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 74 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 88 "include/linux/types.h"
typedef unsigned char u_char;
#line 135 "include/linux/types.h"
typedef u64 sector_t;
#line 136 "include/linux/types.h"
typedef u64 blkcnt_t;
#line 168 "include/linux/types.h"
typedef __u16 __le16;
#line 169 "include/linux/types.h"
typedef __u16 __be16;
#line 171 "include/linux/types.h"
typedef __u32 __be32;
#line 176 "include/linux/types.h"
typedef __u32 __wsum;
#line 179 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 180 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 190 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
#line 190 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 7 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
struct task_struct;
#line 7
struct task_struct;
#line 7
struct task_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 42 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long bx ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long bp ;
   unsigned long ax ;
   unsigned long ds ;
   unsigned long es ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 138 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 135 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/ptrace.h"
struct task_struct;
#line 191 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/vm86.h"
struct task_struct;
#line 60 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/alternative.h"
struct module;
#line 60
struct module;
#line 60
struct module;
#line 10 "include/asm-generic/bug.h"
struct bug_entry {
   unsigned long bug_addr ;
   unsigned short flags ;
};
#line 116 "include/linux/kernel.h"
struct completion;
#line 116
struct completion;
#line 116
struct completion;
#line 117
struct pt_regs;
#line 211
struct pid;
#line 211
struct pid;
#line 211
struct pid;
#line 8 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/current.h"
struct task_struct;
#line 10 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable-3level_types.h"
typedef u64 pgdval_t;
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable-3level_types.h"
typedef u64 pgprotval_t;
#line 187 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 187 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 189 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_16 {
   pgdval_t pgd ;
};
#line 189 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_16 pgd_t;
#line 277
struct page;
#line 277
struct page;
#line 290
struct file;
#line 290
struct file;
#line 290
struct file;
#line 307
struct seq_file;
#line 307
struct seq_file;
#line 307
struct seq_file;
#line 45 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/paravirt_types.h"
struct page;
#line 49
struct mm_struct;
#line 51
struct task_struct;
#line 52
struct cpumask;
#line 52
struct cpumask;
#line 52
struct cpumask;
#line 321
struct raw_spinlock;
#line 321
struct raw_spinlock;
#line 321
struct raw_spinlock;
#line 13 "include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((32U + 8U * sizeof(long )) - 1U) / (8U * sizeof(long ))] ;
};
#line 13 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 20 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/system.h"
struct task_struct;
#line 18 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/page.h"
struct page;
#line 10 "include/linux/personality.h"
struct exec_domain;
#line 10
struct exec_domain;
#line 10
struct exec_domain;
#line 11
struct pt_regs;
#line 91
struct map_segment;
#line 91
struct map_segment;
#line 91 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 151 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 151
struct seq_operations;
#line 423
struct kmem_cache;
#line 423
struct kmem_cache;
#line 625 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_33 {
   unsigned long seg ;
};
#line 625 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_33 mm_segment_t;
#line 19 "include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 540
struct hlist_node;
#line 540
struct hlist_node;
#line 540 "include/linux/list.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 544 "include/linux/list.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 12 "include/linux/thread_info.h"
struct timespec;
#line 12
struct timespec;
#line 12
struct timespec;
#line 18 "include/linux/thread_info.h"
struct __anonstruct____missing_field_name_35 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
#line 18 "include/linux/thread_info.h"
struct __anonstruct_futex_36 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 18 "include/linux/thread_info.h"
struct __anonstruct_nanosleep_37 {
   clockid_t index ;
   struct timespec *rmtp ;
   u64 expires ;
};
#line 18
struct pollfd;
#line 18
struct pollfd;
#line 18 "include/linux/thread_info.h"
struct __anonstruct_poll_38 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 18 "include/linux/thread_info.h"
union __anonunion____missing_field_name_34 {
   struct __anonstruct____missing_field_name_35 __annonCompField16 ;
   struct __anonstruct_futex_36 futex ;
   struct __anonstruct_nanosleep_37 nanosleep ;
   struct __anonstruct_poll_38 poll ;
};
#line 18 "include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_34 __annonCompField17 ;
};
#line 20 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/thread_info.h"
struct task_struct;
#line 21
struct exec_domain;
#line 141 "include/asm-generic/atomic-long.h"
typedef atomic_t atomic_long_t;
#line 26 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
   int uaccess_err ;
};
#line 8 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
struct raw_spinlock {
   unsigned int slock ;
};
#line 8 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 14 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_raw_rwlock_t_40 {
   unsigned int lock ;
};
#line 14 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
typedef struct __anonstruct_raw_rwlock_t_40 raw_rwlock_t;
#line 12 "include/linux/lockdep.h"
struct task_struct;
#line 366 "include/linux/lockdep.h"
struct lock_class_key {

};
#line 20 "include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_41 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 20 "include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_41 spinlock_t;
#line 36 "include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_42 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 36 "include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_42 rwlock_t;
#line 32 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_43 {
   unsigned int sequence ;
   spinlock_t lock ;
};
#line 32 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_43 seqlock_t;
#line 121 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 14 "include/linux/time.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 62 "include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 50 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 54 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 56
struct task_struct;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_44 {
   unsigned long bits[(((unsigned int )(1 << 4) + 8U * sizeof(long )) - 1U) / (8U * sizeof(long ))] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_44 nodemask_t;
#line 60 "include/linux/pageblock-flags.h"
struct page;
#line 48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
};
#line 17 "include/linux/rwsem.h"
struct rw_semaphore;
#line 17
struct rw_semaphore;
#line 17
struct rw_semaphore;
#line 67 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/rwsem.h"
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
#line 8 "include/linux/memory_hotplug.h"
struct page;
#line 757 "include/linux/mmzone.h"
struct ctl_table;
#line 757
struct ctl_table;
#line 757
struct ctl_table;
#line 167 "include/linux/ioport.h"
struct device;
#line 167
struct device;
#line 167
struct device;
#line 110 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/mpspec.h"
struct device;
#line 46 "include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 10 "include/linux/timer.h"
struct tvec_base;
#line 10
struct tvec_base;
#line 10
struct tvec_base;
#line 12 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
};
#line 16 "include/linux/workqueue.h"
struct work_struct;
#line 16
struct work_struct;
#line 16
struct work_struct;
#line 25 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
#line 41 "include/linux/pm.h"
struct device;
#line 43 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 43 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 196 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
   int (*runtime_suspend)(struct device *dev ) ;
   int (*runtime_resume)(struct device *dev ) ;
   int (*runtime_idle)(struct device *dev ) ;
};
#line 351
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
#line 384
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 403
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_RESUME = 3
} ;
#line 410 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   spinlock_t lock ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int ignore_children : 1 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
};
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_111 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_111 mm_context_t;
#line 10 "include/linux/gfp.h"
struct vm_area_struct;
#line 10
struct vm_area_struct;
#line 10
struct vm_area_struct;
#line 46 "include/linux/kmod.h"
struct file;
#line 103
struct file;
#line 284 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/elf.h"
struct task_struct;
#line 10 "include/linux/elf.h"
struct file;
#line 20 "include/linux/elf.h"
typedef __u32 Elf32_Addr;
#line 21 "include/linux/elf.h"
typedef __u16 Elf32_Half;
#line 24 "include/linux/elf.h"
typedef __u32 Elf32_Word;
#line 172 "include/linux/elf.h"
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
#line 172 "include/linux/elf.h"
typedef struct elf32_sym Elf32_Sym;
#line 20 "include/linux/sysfs.h"
struct kobject;
#line 20
struct kobject;
#line 20
struct kobject;
#line 21
struct module;
#line 28 "include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63
struct vm_area_struct;
#line 77 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 82
struct sysfs_dirent;
#line 82
struct sysfs_dirent;
#line 82
struct sysfs_dirent;
#line 20 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 59 "include/linux/kobject.h"
struct kset;
#line 59
struct kset;
#line 59
struct kobj_type;
#line 59
struct kobj_type;
#line 59 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
#line 113 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 120 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 154 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
#line 32 "include/linux/moduleparam.h"
struct kernel_param;
#line 32
struct kernel_param;
#line 32
struct kernel_param;
#line 42
struct kparam_string;
#line 42
struct kparam_string;
#line 42
struct kparam_array;
#line 42
struct kparam_array;
#line 42 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_121 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 42 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   u16 perm ;
   u16 flags ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_121 __annonCompField18 ;
};
#line 56 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
#line 234
struct module;
#line 25 "include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 49 "include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
#line 20 "include/linux/tracepoint.h"
struct module;
#line 21
struct tracepoint;
#line 21
struct tracepoint;
#line 21
struct tracepoint;
#line 23 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   int state ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
#line 37 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 64 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 71 "include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   unsigned long min_partial ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 4] ;
   struct kmem_cache_cpu *cpu_slab[32] ;
};
#line 8 "include/asm-generic/module.h"
struct mod_arch_specific {

};
#line 11 "include/trace/events/module.h"
struct module;
#line 35 "include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 47
struct module;
#line 49 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 59
struct module_param_attrs;
#line 59
struct module_param_attrs;
#line 59 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 72
struct exception_table_entry;
#line 72
struct exception_table_entry;
#line 72
struct exception_table_entry;
#line 227
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 234
struct module_sect_attrs;
#line 234
struct module_sect_attrs;
#line 234
struct module_notes_attrs;
#line 234
struct module_notes_attrs;
#line 234
struct ftrace_event_call;
#line 234
struct ftrace_event_call;
#line 234 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   Elf32_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   char const   **trace_bprintk_fmt_start ;
   unsigned int num_trace_bprintk_fmt ;
   struct ftrace_event_call *trace_events ;
   unsigned int num_trace_events ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
};
#line 665
struct device_driver;
#line 665
struct device_driver;
#line 665
struct device_driver;
#line 667
struct module;
#line 10 "include/linux/irqreturn.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 83 "include/linux/irq.h"
struct proc_dir_entry;
#line 83
struct proc_dir_entry;
#line 83
struct proc_dir_entry;
#line 16 "include/linux/profile.h"
struct proc_dir_entry;
#line 17
struct pt_regs;
#line 65
struct task_struct;
#line 66
struct mm_struct;
#line 88
struct pt_regs;
#line 133 "include/linux/hardirq.h"
struct task_struct;
#line 100 "include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 110 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 149 "include/linux/interrupt.h"
struct device;
#line 612
struct seq_file;
#line 11 "include/linux/firmware.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
};
#line 16
struct device;
#line 19 "include/linux/klist.h"
struct klist_node;
#line 19
struct klist_node;
#line 19
struct klist_node;
#line 39 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 16 "include/linux/semaphore.h"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 4 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *acpi_handle ;
   void *iommu ;
};
#line 29 "include/linux/device.h"
struct device;
#line 30
struct device_private;
#line 30
struct device_private;
#line 30
struct device_private;
#line 31
struct device_driver;
#line 32
struct driver_private;
#line 32
struct driver_private;
#line 32
struct driver_private;
#line 33
struct class;
#line 33
struct class;
#line 33
struct class;
#line 34
struct class_private;
#line 34
struct class_private;
#line 34
struct class_private;
#line 35
struct bus_type;
#line 35
struct bus_type;
#line 35
struct bus_type;
#line 36
struct bus_type_private;
#line 36
struct bus_type_private;
#line 36
struct bus_type_private;
#line 38 "include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
#line 51
struct device_attribute;
#line 51
struct device_attribute;
#line 51
struct driver_attribute;
#line 51
struct driver_attribute;
#line 51 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct bus_type_private *p ;
};
#line 122 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 157 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
#line 189
struct class_attribute;
#line 189
struct class_attribute;
#line 189 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , mode_t *mode ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct class_private *p ;
};
#line 211
struct device_type;
#line 211
struct device_type;
#line 252 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
#line 299 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , mode_t *mode ) ;
   void (*release)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 310 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 370 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 379
struct dma_coherent_mem;
#line 379
struct dma_coherent_mem;
#line 379 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device *dev ) ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 407 "include/linux/mod_devicetable.h"
struct spi_device_id {
   char name[32] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 68 "include/linux/spi/spi.h"
struct spi_master;
#line 68
struct spi_master;
#line 68 "include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 mode ;
   u8 bits_per_word ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32] ;
};
#line 143
struct spi_message;
#line 143
struct spi_message;
#line 143
struct spi_message;
#line 174 "include/linux/spi/spi.h"
struct spi_driver {
   struct spi_device_id  const  *id_table ;
   int (*probe)(struct spi_device *spi ) ;
   int (*remove)(struct spi_device *spi ) ;
   void (*shutdown)(struct spi_device *spi ) ;
   int (*suspend)(struct spi_device *spi , pm_message_t mesg ) ;
   int (*resume)(struct spi_device *spi ) ;
   struct device_driver driver ;
};
#line 234 "include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u16 flags ;
   int (*setup)(struct spi_device *spi ) ;
   int (*transfer)(struct spi_device *spi , struct spi_message *mesg ) ;
   void (*cleanup)(struct spi_device *spi ) ;
};
#line 465 "include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void *context ) ;
   void *context ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 14 "include/linux/prio_tree.h"
struct prio_tree_node;
#line 14
struct prio_tree_node;
#line 14 "include/linux/prio_tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 20 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 28 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 23 "include/linux/mm_types.h"
struct address_space;
#line 23
struct address_space;
#line 23
struct address_space;
#line 28 "include/linux/mm_types.h"
typedef atomic_long_t mm_counter_t;
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_130 {
   u16 inuse ;
   u16 objects ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_129 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_130 __annonCompField19 ;
};
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_132 {
   unsigned long private ;
   struct address_space *mapping ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_131 {
   struct __anonstruct____missing_field_name_132 __annonCompField21 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_133 {
   unsigned long index ;
   void *freelist ;
};
#line 40 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_129 __annonCompField20 ;
   union __anonunion____missing_field_name_131 __annonCompField22 ;
   union __anonunion____missing_field_name_133 __annonCompField23 ;
   struct list_head lru ;
};
#line 134 "include/linux/mm_types.h"
struct __anonstruct_vm_set_135 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 134 "include/linux/mm_types.h"
union __anonunion_shared_134 {
   struct __anonstruct_vm_set_135 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 134
struct anon_vma;
#line 134
struct anon_vma;
#line 134
struct vm_operations_struct;
#line 134
struct vm_operations_struct;
#line 134
struct mempolicy;
#line 134
struct mempolicy;
#line 134 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_134 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
   struct mempolicy *vm_policy ;
};
#line 191 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 196 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 202
struct linux_binfmt;
#line 202
struct linux_binfmt;
#line 202
struct mmu_notifier_mm;
#line 202
struct mmu_notifier_mm;
#line 202 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[42] ;
   struct linux_binfmt *binfmt ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
};
#line 11 "include/linux/socket.h"
struct sockaddr;
#line 11
struct sockaddr;
#line 16 "include/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 29 "include/linux/socket.h"
struct seq_file;
#line 34 "include/linux/socket.h"
typedef unsigned short sa_family_t;
#line 40 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 62 "include/linux/net.h"
struct poll_table_struct;
#line 62
struct poll_table_struct;
#line 62
struct poll_table_struct;
#line 63
struct pipe_inode_info;
#line 63
struct pipe_inode_info;
#line 63
struct pipe_inode_info;
#line 64
struct inode;
#line 64
struct inode;
#line 64
struct inode;
#line 65
struct net;
#line 65
struct net;
#line 65
struct net;
#line 129
struct fasync_struct;
#line 129
struct fasync_struct;
#line 129
struct sock;
#line 129
struct sock;
#line 148
struct vm_area_struct;
#line 149
struct page;
#line 150
struct kiocb;
#line 150
struct kiocb;
#line 150
struct kiocb;
#line 151
struct sockaddr;
#line 153
struct module;
#line 207
struct iovec;
#line 32 "include/linux/sysctl.h"
struct completion;
#line 947
struct ctl_table;
#line 948
struct nsproxy;
#line 948
struct nsproxy;
#line 948
struct nsproxy;
#line 949
struct ctl_table_root;
#line 949
struct ctl_table_root;
#line 949
struct ctl_table_root;
#line 951 "include/linux/sysctl.h"
struct ctl_table_set {
   struct list_head list ;
   struct ctl_table_set *parent ;
   int (*is_seen)(struct ctl_table_set * ) ;
};
#line 961
struct ctl_table_header;
#line 961
struct ctl_table_header;
#line 961
struct ctl_table_header;
#line 976 "include/linux/sysctl.h"
typedef int ctl_handler(struct ctl_table *table , void *oldval , size_t *oldlenp ,
                        void *newval , size_t newlen );
#line 980 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *ctl , int write , void *buffer , size_t *lenp ,
                         loff_t *ppos );
#line 1052 "include/linux/sysctl.h"
struct ctl_table {
   int ctl_name ;
   char const   *procname ;
   void *data ;
   int maxlen ;
   mode_t mode ;
   struct ctl_table *child ;
   struct ctl_table *parent ;
   proc_handler *proc_handler ;
   ctl_handler *strategy ;
   void *extra1 ;
   void *extra2 ;
};
#line 1067 "include/linux/sysctl.h"
struct ctl_table_root {
   struct list_head root_list ;
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *root , struct nsproxy *namespaces ) ;
   int (*permissions)(struct ctl_table_root *root , struct nsproxy *namespaces , struct ctl_table *table ) ;
};
#line 1078 "include/linux/sysctl.h"
struct ctl_table_header {
   struct ctl_table *ctl_table ;
   struct list_head ctl_entry ;
   int used ;
   int count ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_table *attached_by ;
   struct ctl_table *attached_to ;
   struct ctl_table_header *parent ;
};
#line 95 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 109 "include/net/checksum.h"
struct sk_buff;
#line 109
struct sk_buff;
#line 109
struct sk_buff;
#line 12 "include/linux/bug.h"
struct pt_regs;
#line 6 "include/asm-generic/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 8 "include/linux/debug_locks.h"
struct task_struct;
#line 48
struct task_struct;
#line 16 "include/linux/mm.h"
struct mempolicy;
#line 17
struct anon_vma;
#line 18
struct file_ra_state;
#line 18
struct file_ra_state;
#line 18
struct file_ra_state;
#line 20
struct writeback_control;
#line 20
struct writeback_control;
#line 20
struct writeback_control;
#line 26 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_32.h"
struct mm_struct;
#line 27
struct vm_area_struct;
#line 554 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable.h"
struct vm_area_struct;
#line 167 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 184 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
};
#line 226
struct inode;
#line 199 "include/linux/page-flags.h"
struct page;
#line 8 "include/linux/vmalloc.h"
struct vm_area_struct;
#line 25 "include/linux/dma-debug.h"
struct device;
#line 26
struct scatterlist;
#line 27
struct bus_type;
#line 6 "include/linux/swiotlb.h"
struct device;
#line 8
struct scatterlist;
#line 33 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 94 "include/linux/skbuff.h"
struct net_device;
#line 94
struct net_device;
#line 94
struct net_device;
#line 95
struct scatterlist;
#line 96
struct pipe_inode_info;
#line 99 "include/linux/skbuff.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 105 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned int mask ;
   unsigned long data[32U / sizeof(unsigned long )] ;
};
#line 114 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 123
struct sk_buff;
#line 255 "include/linux/skbuff.h"
typedef unsigned char *sk_buff_data_t;
#line 313
struct sec_path;
#line 313
struct sec_path;
#line 313 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_198 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 313 "include/linux/skbuff.h"
union __anonunion____missing_field_name_197 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_198 __annonCompField25 ;
};
#line 313 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   struct sock *sk ;
   ktime_t tstamp ;
   struct net_device *dev ;
   unsigned long _skb_dst ;
   struct sec_path *sp ;
   char cb[48] ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion____missing_field_name_197 __annonCompField26 ;
   __u32 priority ;
   int flags1_begin[0] ;
   __u8 local_df : 1 ;
   __u8 cloned : 1 ;
   __u8 ip_summed : 2 ;
   __u8 nohdr : 1 ;
   __u8 nfctinfo : 3 ;
   __u8 pkt_type : 3 ;
   __u8 fclone : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 peeked : 1 ;
   __u8 nf_trace : 1 ;
   __be16 protocol : 16 ;
   int flags1_end[0] ;
   void (*destructor)(struct sk_buff *skb ) ;
   struct nf_conntrack *nfct ;
   struct sk_buff *nfct_reasm ;
   struct nf_bridge_info *nf_bridge ;
   int iif ;
   __u16 tc_index ;
   __u16 tc_verd ;
   int flags2_begin[0] ;
   __u16 queue_mapping : 16 ;
   __u8 ndisc_nodetype : 2 ;
   int flags2_end[0] ;
   dma_cookie_t dma_cookie ;
   __u32 secmark ;
   __u32 mark ;
   __u16 vlan_tci ;
   sk_buff_data_t transport_header ;
   sk_buff_data_t network_header ;
   sk_buff_data_t mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 425
struct dst_entry;
#line 425
struct dst_entry;
#line 37 "include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_199 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 37 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_199 sync_serial_settings;
#line 43 "include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_200 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 43 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_200 te1_settings;
#line 50 "include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_201 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 50 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_201 raw_hdlc_proto;
#line 55 "include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_202 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 55 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_202 fr_proto;
#line 65 "include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_203 {
   unsigned int dlci ;
};
#line 65 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_203 fr_proto_pvc;
#line 69 "include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_204 {
   unsigned int dlci ;
   char master[16] ;
};
#line 69 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_204 fr_proto_pvc_info;
#line 74 "include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_205 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 74 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_205 cisco_proto;
#line 128 "include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 139 "include/linux/if.h"
union __anonunion_ifs_ifsu_208 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 139 "include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_208 ifs_ifsu ;
};
#line 164 "include/linux/if.h"
union __anonunion_ifr_ifrn_209 {
   char ifrn_name[16] ;
};
#line 164 "include/linux/if.h"
union __anonunion_ifr_ifru_210 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 164 "include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_209 ifr_ifrn ;
   union __anonunion_ifr_ifru_210 ifr_ifru ;
};
#line 19 "include/linux/ethtool.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 reserved2 ;
   __u32 lp_advertising ;
   __u32 reserved[2] ;
};
#line 54 "include/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32] ;
   char version[32] ;
   char fw_version[32] ;
   char bus_info[32] ;
   char reserved1[32] ;
   char reserved2[12] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 72 "include/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6] ;
};
#line 86 "include/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0] ;
};
#line 94 "include/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0] ;
};
#line 103 "include/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 199 "include/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 221 "include/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 260 "include/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0] ;
};
#line 269 "include/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0] ;
};
#line 299 "include/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 307 "include/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 314 "include/linux/ethtool.h"
struct ethtool_rawip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __u8 hdata[64] ;
};
#line 320 "include/linux/ethtool.h"
struct ethtool_ether_spec {
   __be16 ether_type ;
   __u8 frame_size ;
   __u8 eframe[16] ;
};
#line 329 "include/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 338 "include/linux/ethtool.h"
union __anonunion_h_u_212 {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_rawip4_spec raw_ip4_spec ;
   struct ethtool_ether_spec ether_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   __u8 hdata[64] ;
};
#line 338 "include/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union __anonunion_h_u_212 h_u ;
   union __anonunion_h_u_212 m_u ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 355 "include/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0] ;
};
#line 371 "include/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128] ;
};
#line 379
struct net_device;
#line 456 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   u32 (*get_rx_csum)(struct net_device * ) ;
   int (*set_rx_csum)(struct net_device * , u32  ) ;
   u32 (*get_tx_csum)(struct net_device * ) ;
   int (*set_tx_csum)(struct net_device * , u32  ) ;
   u32 (*get_sg)(struct net_device * ) ;
   int (*set_sg)(struct net_device * , u32  ) ;
   u32 (*get_tso)(struct net_device * ) ;
   int (*set_tso)(struct net_device * , u32  ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32 stringset , u8 * ) ;
   int (*phys_id)(struct net_device * , u32  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_ufo)(struct net_device * ) ;
   int (*set_ufo)(struct net_device * , u32  ) ;
   u32 (*get_flags)(struct net_device * ) ;
   int (*set_flags)(struct net_device * , u32  ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*self_test_count)(struct net_device * ) ;
   int (*get_stats_count)(struct net_device * ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , void * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
};
#line 4 "include/net/netns/core.h"
struct ctl_table_header;
#line 5
struct prot_inuse;
#line 5
struct prot_inuse;
#line 5
struct prot_inuse;
#line 7 "include/net/netns/core.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 72 "include/net/snmp.h"
struct ipstats_mib {
   unsigned long mibs[31] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 80 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 85 "include/net/snmp.h"
struct icmpmsg_mib {
   unsigned long mibs[512] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 91 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[4] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 96 "include/net/snmp.h"
struct icmpv6msg_mib {
   unsigned long mibs[512] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 103 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[15] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 109 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[7] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 115 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[75] ;
};
#line 121 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[26] ;
};
#line 6 "include/net/netns/mib.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics[2] ;
   struct ipstats_mib *ip_statistics[2] ;
   struct linux_mib *net_statistics[2] ;
   struct udp_mib *udp_statistics[2] ;
   struct udp_mib *udplite_statistics[2] ;
   struct icmp_mib *icmp_statistics[2] ;
   struct icmpmsg_mib *icmpmsg_statistics[2] ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6[2] ;
   struct udp_mib *udplite_stats_in6[2] ;
   struct ipstats_mib *ipv6_statistics[2] ;
   struct icmpv6_mib *icmpv6_statistics[2] ;
   struct icmpv6msg_mib *icmpv6msg_statistics[2] ;
   struct linux_xfrm_mib *xfrm_statistics[2] ;
};
#line 7 "include/net/netns/unix.h"
struct ctl_table_header;
#line 8 "include/net/netns/unix.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 10 "include/net/netns/packet.h"
struct netns_packet {
   rwlock_t sklist_lock ;
   struct hlist_head sklist ;
};
#line 4 "include/net/inet_frag.h"
struct netns_frags {
   int nqueues ;
   atomic_t mem ;
   struct list_head lru_list ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 10 "include/net/netns/ipv4.h"
struct ctl_table_header;
#line 11
struct ipv4_devconf;
#line 11
struct ipv4_devconf;
#line 11
struct ipv4_devconf;
#line 12
struct fib_rules_ops;
#line 12
struct fib_rules_ops;
#line 12
struct fib_rules_ops;
#line 13
struct hlist_head;
#line 14
struct sock;
#line 16
struct xt_table;
#line 16
struct xt_table;
#line 16
struct mfc_cache;
#line 16
struct mfc_cache;
#line 16
struct vif_device;
#line 16
struct vif_device;
#line 16 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *tcp_sock ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
   int nat_vmalloced ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   int sysctl_rt_cache_rebuild_count ;
   int current_rt_cache_rebuild_count ;
   struct timer_list rt_secret_timer ;
   atomic_t rt_genid ;
   struct sock *mroute_sk ;
   struct mfc_cache **mfc_cache_array ;
   struct vif_device *vif_table ;
   int maxvif ;
   atomic_t cache_resolve_queue_len ;
   int mroute_do_assert ;
   int mroute_do_pim ;
   int mroute_reg_vif_num ;
};
#line 5 "include/net/dst_ops.h"
struct dst_entry;
#line 7
struct net_device;
#line 8
struct sk_buff;
#line 10 "include/net/dst_ops.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *ops ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32 cookie ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device *dev , int how ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry *dst , u32 mtu ) ;
   int (*local_out)(struct sk_buff *skb ) ;
   atomic_t entries ;
   struct kmem_cache *kmem_cachep ;
};
#line 11 "include/net/netns/ipv6.h"
struct ctl_table_header;
#line 13 "include/net/netns/ipv6.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *table ;
   struct ctl_table_header *frags_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int icmpv6_time ;
};
#line 30
struct ipv6_devconf;
#line 30
struct ipv6_devconf;
#line 30
struct rt6_info;
#line 30
struct rt6_info;
#line 30
struct rt6_statistics;
#line 30
struct rt6_statistics;
#line 30
struct fib6_table;
#line 30
struct fib6_table;
#line 30
struct mfc6_cache;
#line 30
struct mfc6_cache;
#line 30
struct mif_device;
#line 30
struct mif_device;
#line 30 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mroute6_sk ;
   struct mfc6_cache **mfc6_cache_array ;
   struct mif_device *vif6_table ;
   int maxvif ;
   atomic_t cache_resolve_queue_len ;
   int mroute_do_assert ;
   int mroute_do_pim ;
   int mroute_reg_vif_num ;
};
#line 4 "include/net/netns/dccp.h"
struct sock;
#line 6 "include/net/netns/dccp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 88 "include/linux/netfilter.h"
struct sk_buff;
#line 87 "include/net/flow.h"
struct net;
#line 88
struct sock;
#line 11 "include/linux/dcache.h"
struct nameidata;
#line 11
struct nameidata;
#line 11
struct nameidata;
#line 12
struct path;
#line 12
struct path;
#line 12
struct path;
#line 13
struct vfsmount;
#line 13
struct vfsmount;
#line 13
struct vfsmount;
#line 33 "include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
#line 89 "include/linux/dcache.h"
union __anonunion_d_u_231 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 89
struct dentry_operations;
#line 89
struct dentry_operations;
#line 89
struct super_block;
#line 89
struct super_block;
#line 89 "include/linux/dcache.h"
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_231 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[40] ;
};
#line 134 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
#line 4 "include/linux/path.h"
struct dentry;
#line 5
struct vfsmount;
#line 7 "include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 61 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 61
struct radix_tree_node;
#line 61 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 6 "include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 50
struct pid_namespace;
#line 50
struct pid_namespace;
#line 50 "include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 57 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
#line 100
struct pid_namespace;
#line 18 "include/linux/capability.h"
struct task_struct;
#line 568
struct dentry;
#line 16 "include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
#line 384 "include/linux/fs.h"
struct export_operations;
#line 384
struct export_operations;
#line 384
struct export_operations;
#line 386
struct iovec;
#line 387
struct nameidata;
#line 388
struct kiocb;
#line 389
struct pipe_inode_info;
#line 390
struct poll_table_struct;
#line 391
struct kstatfs;
#line 391
struct kstatfs;
#line 391
struct kstatfs;
#line 392
struct vm_area_struct;
#line 393
struct vfsmount;
#line 394
struct cred;
#line 394
struct cred;
#line 394
struct cred;
#line 446 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 106 "include/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
#line 127 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 50 "include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 137 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 137 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 143 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 17 "include/linux/dqblk_qtree.h"
struct dquot;
#line 17
struct dquot;
#line 17
struct dquot;
#line 182 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 183 "include/linux/quota.h"
typedef long long qsize_t;
#line 197 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 212
struct quota_format_type;
#line 212
struct quota_format_type;
#line 212
struct quota_format_type;
#line 214 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 227
struct super_block;
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 284 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
#line 295 "include/linux/quota.h"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   int (*reserve_space)(struct inode * , qsize_t  , int  ) ;
   int (*claim_space)(struct inode * , qsize_t  ) ;
   void (*release_rsv)(struct inode * , qsize_t  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 322 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
#line 336 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
#line 509 "include/linux/fs.h"
struct page;
#line 510
struct address_space;
#line 511
struct writeback_control;
#line 554 "include/linux/fs.h"
union __anonunion_arg_238 {
   char *buf ;
   void *data ;
};
#line 554 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_237 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_238 arg ;
   int error ;
};
#line 554 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_237 read_descriptor_t;
#line 567 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 617
struct backing_dev_info;
#line 617
struct backing_dev_info;
#line 617
struct backing_dev_info;
#line 618 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 642
struct hd_struct;
#line 642
struct hd_struct;
#line 642
struct gendisk;
#line 642
struct gendisk;
#line 642 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 716
struct posix_acl;
#line 716
struct posix_acl;
#line 716
struct posix_acl;
#line 719
struct inode_operations;
#line 719
struct inode_operations;
#line 719
struct file_operations;
#line 719
struct file_operations;
#line 719
struct file_lock;
#line 719
struct file_lock;
#line 719
struct cdev;
#line 719
struct cdev;
#line 719 "include/linux/fs.h"
union __anonunion____missing_field_name_239 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 719 "include/linux/fs.h"
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   blkcnt_t i_blocks ;
   unsigned int i_blkbits ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_239 __annonCompField27 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_mark_entries ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   void *i_private ;
};
#line 874 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 885 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 908 "include/linux/fs.h"
union __anonunion_f_u_240 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 908 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_240 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
};
#line 1027
struct files_struct;
#line 1027
struct files_struct;
#line 1027 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1029 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1034 "include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
#line 8 "include/linux/nfs_fs_i.h"
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 13 "include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 20 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1056 "include/linux/fs.h"
struct __anonstruct_afs_242 {
   struct list_head link ;
   int state ;
};
#line 1056 "include/linux/fs.h"
union __anonunion_fl_u_241 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_242 afs ;
};
#line 1056 "include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_241 fl_u ;
};
#line 1281 "include/linux/fs.h"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
#line 1316
struct file_system_type;
#line 1316
struct file_system_type;
#line 1316
struct super_operations;
#line 1316
struct super_operations;
#line 1316
struct xattr_handler;
#line 1316
struct xattr_handler;
#line 1316
struct mtd_info;
#line 1316
struct mtd_info;
#line 1316 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
};
#line 1435 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1482 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
#line 1511 "include/linux/fs.h"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*check_acl)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
#line 1541
struct seq_file;
#line 1555 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
#line 1738 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
#line 2477
struct ctl_table;
#line 10 "include/linux/proc_fs.h"
struct net;
#line 11
struct completion;
#line 12
struct mm_struct;
#line 46 "include/linux/proc_fs.h"
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
#line 48 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file *file , char const   *buffer , unsigned long count ,
                         void *data );
#line 51 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
#line 117
struct pid_namespace;
#line 261
struct ctl_table_header;
#line 262
struct ctl_table;
#line 7 "include/net/netns/x_tables.h"
struct ebt_table;
#line 7
struct ebt_table;
#line 7
struct ebt_table;
#line 9 "include/net/netns/x_tables.h"
struct netns_xt {
   struct list_head tables[13] ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 17 "include/linux/list_nulls.h"
struct hlist_nulls_node;
#line 17
struct hlist_nulls_node;
#line 17 "include/linux/list_nulls.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 21 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 8 "include/net/netns/conntrack.h"
struct ctl_table_header;
#line 11
struct ip_conntrack_stat;
#line 11
struct ip_conntrack_stat;
#line 11 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   unsigned int htable_size ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct ip_conntrack_stat *stat ;
   int sysctl_events ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_acct ;
   int sysctl_checksum ;
   unsigned int sysctl_log_invalid ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   int hash_vmalloc ;
   int expect_vmalloc ;
   char *slabname ;
};
#line 9 "include/net/netns/xfrm.h"
struct ctl_table_header;
#line 11 "include/net/netns/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 16 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   wait_queue_head_t km_waitq ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6] ;
   struct xfrm_policy_hash policy_bydst[6] ;
   unsigned int policy_count[6] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
};
#line 24 "include/net/net_namespace.h"
struct proc_dir_entry;
#line 25
struct net_device;
#line 26
struct sock;
#line 27
struct ctl_table_header;
#line 28
struct net_generic;
#line 28
struct net_generic;
#line 28
struct net_generic;
#line 29
struct sock;
#line 31 "include/net/net_namespace.h"
struct net {
   atomic_t count ;
   struct list_head list ;
   struct work_struct work ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct net_device *loopback_dev ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   struct list_head rules_ops ;
   spinlock_t rules_mod_lock ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_dccp dccp ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_xfrm xfrm ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
};
#line 10 "include/linux/seq_file.h"
struct seq_operations;
#line 11
struct file;
#line 12
struct path;
#line 13
struct inode;
#line 14
struct dentry;
#line 16 "include/linux/seq_file.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   void *private ;
};
#line 29 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *m , loff_t *pos ) ;
   void (*stop)(struct seq_file *m , void *v ) ;
   void *(*next)(struct seq_file *m , void *v , loff_t *pos ) ;
   int (*show)(struct seq_file *m , void *v ) ;
};
#line 6 "include/linux/seq_file_net.h"
struct net;
#line 266 "include/net/net_namespace.h"
struct ctl_table;
#line 267
struct ctl_table_header;
#line 27 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   u8 (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   u8 (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
};
#line 53 "include/linux/netdevice.h"
struct vlan_group;
#line 53
struct vlan_group;
#line 53
struct vlan_group;
#line 54
struct netpoll_info;
#line 54
struct netpoll_info;
#line 54
struct netpoll_info;
#line 56
struct wireless_dev;
#line 56
struct wireless_dev;
#line 56
struct wireless_dev;
#line 83
enum netdev_tx {
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 1,
    NETDEV_TX_LOCKED = -1
} ;
#line 88 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 128 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 178
struct neighbour;
#line 178
struct neighbour;
#line 178
struct neighbour;
#line 179
struct neigh_parms;
#line 179
struct neigh_parms;
#line 179
struct neigh_parms;
#line 180
struct sk_buff;
#line 192 "include/linux/netdevice.h"
struct dev_addr_list {
   struct dev_addr_list *next ;
   u8 da_addr[32] ;
   u8 da_addrlen ;
   u8 da_synced ;
   int da_users ;
   int da_gusers ;
};
#line 225 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 230 "include/linux/netdevice.h"
struct hh_cache {
   struct hh_cache *hh_next ;
   atomic_t hh_refcnt ;
   __be16 hh_type  __attribute__((__aligned__((1) <<  (4) ))) ;
   u16 hh_len ;
   int (*hh_output)(struct sk_buff *skb ) ;
   seqlock_t hh_lock ;
   unsigned long hh_data[128U / sizeof(long )] ;
};
#line 276 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *skb , struct net_device *dev , unsigned short type ,
                 void const   *daddr , void const   *saddr , unsigned int len ) ;
   int (*parse)(struct sk_buff  const  *skb , unsigned char *haddr ) ;
   int (*rebuild)(struct sk_buff *skb ) ;
   int (*cache)(struct neighbour  const  *neigh , struct hh_cache *hh ) ;
   void (*cache_update)(struct hh_cache *hh , struct net_device  const  *dev , unsigned char const   *haddr ) ;
};
#line 466
struct Qdisc;
#line 466
struct Qdisc;
#line 466 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   unsigned long state ;
   struct Qdisc *qdisc_sleeping ;
   spinlock_t _xmit_lock  __attribute__((__aligned__((1) <<  (4) ))) ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long tx_bytes ;
   unsigned long tx_packets ;
   unsigned long tx_dropped ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 582 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *dev ) ;
   void (*ndo_uninit)(struct net_device *dev ) ;
   int (*ndo_open)(struct net_device *dev ) ;
   int (*ndo_stop)(struct net_device *dev ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb , struct net_device *dev ) ;
   u16 (*ndo_select_queue)(struct net_device *dev , struct sk_buff *skb ) ;
   void (*ndo_change_rx_flags)(struct net_device *dev , int flags ) ;
   void (*ndo_set_rx_mode)(struct net_device *dev ) ;
   void (*ndo_set_multicast_list)(struct net_device *dev ) ;
   int (*ndo_set_mac_address)(struct net_device *dev , void *addr ) ;
   int (*ndo_validate_addr)(struct net_device *dev ) ;
   int (*ndo_do_ioctl)(struct net_device *dev , struct ifreq *ifr , int cmd ) ;
   int (*ndo_set_config)(struct net_device *dev , struct ifmap *map ) ;
   int (*ndo_change_mtu)(struct net_device *dev , int new_mtu ) ;
   int (*ndo_neigh_setup)(struct net_device *dev , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device *dev ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *dev ) ;
   void (*ndo_vlan_rx_register)(struct net_device *dev , struct vlan_group *grp ) ;
   void (*ndo_vlan_rx_add_vid)(struct net_device *dev , unsigned short vid ) ;
   void (*ndo_vlan_rx_kill_vid)(struct net_device *dev , unsigned short vid ) ;
   void (*ndo_poll_controller)(struct net_device *dev ) ;
   int (*ndo_fcoe_enable)(struct net_device *dev ) ;
   int (*ndo_fcoe_disable)(struct net_device *dev ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *dev , u16 xid , struct scatterlist *sgl ,
                             unsigned int sgc ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *dev , u16 xid ) ;
};
#line 651
struct iw_handler_def;
#line 651
struct iw_handler_def;
#line 651
struct iw_public_data;
#line 651
struct iw_public_data;
#line 651
enum __anonenum_reg_state_254 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
} ;
#line 651
struct net_bridge_port;
#line 651
struct net_bridge_port;
#line 651
struct macvlan_port;
#line 651
struct macvlan_port;
#line 651
struct garp_port;
#line 651
struct garp_port;
#line 651
struct rtnl_link_ops;
#line 651
struct rtnl_link_ops;
#line 651 "include/linux/netdevice.h"
struct net_device {
   char name[16] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   unsigned int irq ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   unsigned long features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned short gflags ;
   unsigned short priv_flags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   struct net_device *master ;
   unsigned char perm_addr[32] ;
   unsigned char addr_len ;
   unsigned short dev_id ;
   struct netdev_hw_addr_list uc ;
   int uc_promisc ;
   spinlock_t addr_list_lock ;
   struct dev_addr_list *mc_list ;
   int mc_count ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   void *dsa_ptr ;
   void *atalk_ptr ;
   void *ip_ptr ;
   void *dn_ptr ;
   void *ip6_ptr ;
   void *ec_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_hw_addr_list dev_addrs ;
   unsigned char broadcast[32] ;
   struct netdev_queue rx_queue ;
   struct netdev_queue *_tx  __attribute__((__aligned__((1) <<  (4) ))) ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   atomic_t refcnt  __attribute__((__aligned__((1) <<  (4) ))) ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct net_device *link_watch_next ;
   enum __anonenum_reg_state_254 reg_state ;
   void (*destructor)(struct net_device *dev ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   void *ml_priv ;
   struct net_bridge_port *br_port ;
   struct macvlan_port *macvlan_port ;
   struct garp_port *garp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[3] ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned long vlan_features ;
   unsigned int gso_max_size ;
   struct dcbnl_rtnl_ops *dcbnl_ops ;
   unsigned int fcoe_ddp_xid ;
};
#line 27 "include/linux/spi/wl12xx.h"
struct wl12xx_platform_data {
   void (*set_power)(bool enable ) ;
};
#line 671 "include/linux/wireless.h"
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
#line 683 "include/linux/wireless.h"
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
#line 711 "include/linux/wireless.h"
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
#line 722 "include/linux/wireless.h"
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
#line 738 "include/linux/wireless.h"
struct iw_discarded {
   __u32 nwid ;
   __u32 code ;
   __u32 fragment ;
   __u32 retries ;
   __u32 misc ;
};
#line 751 "include/linux/wireless.h"
struct iw_missed {
   __u32 beacon ;
};
#line 897 "include/linux/wireless.h"
struct iw_statistics {
   __u16 status ;
   struct iw_quality qual ;
   struct iw_discarded discard ;
   struct iw_missed miss ;
};
#line 919 "include/linux/wireless.h"
union iwreq_data {
   char name[16] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
#line 1083 "include/linux/wireless.h"
struct iw_priv_args {
   __u32 cmd ;
   __u16 set_args ;
   __u16 get_args ;
   char name[16] ;
};
#line 739 "include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3] ;
} __attribute__((__packed__)) ;
#line 22 "include/linux/debugfs.h"
struct file_operations;
#line 30 "include/linux/netlink.h"
struct net;
#line 779 "include/linux/nl80211.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    __NL80211_IFTYPE_AFTER_LAST = 8,
    NL80211_IFTYPE_MAX = 7
} ;
#line 1029
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
#line 1258
enum nl80211_channel_type {
    NL80211_CHAN_NO_HT = 0,
    NL80211_CHAN_HT20 = 1,
    NL80211_CHAN_HT40MINUS = 2,
    NL80211_CHAN_HT40PLUS = 3
} ;
#line 1322
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    __NL80211_AUTHTYPE_NUM = 4,
    NL80211_AUTHTYPE_MAX = 3,
    NL80211_AUTHTYPE_AUTOMATIC = 4
} ;
#line 21 "include/net/regulatory.h"
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
#line 51 "include/net/regulatory.h"
struct regulatory_request {
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   char alpha2[2] ;
   bool intersect ;
   u32 country_ie_checksum ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
#line 61 "include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
#line 67 "include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
#line 72 "include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
};
#line 78 "include/net/regulatory.h"
struct ieee80211_regdomain {
   u32 n_reg_rules ;
   char alpha2[2] ;
   struct ieee80211_reg_rule reg_rules[] ;
};
#line 303 "include/net/iw_handler.h"
struct iw_request_info {
   __u16 cmd ;
   __u16 flags ;
};
#line 309
struct net_device;
#line 315 "include/net/iw_handler.h"
typedef int (*iw_handler)(struct net_device *dev , struct iw_request_info *info ,
                          union iwreq_data *wrqu , char *extra );
#line 324 "include/net/iw_handler.h"
struct iw_handler_def {
   __u16 num_standard ;
   __u16 num_private ;
   __u16 num_private_args ;
   iw_handler const   *standard ;
   iw_handler const   *private ;
   struct iw_priv_args  const  *private_args ;
   struct iw_statistics *(*get_wireless_stats)(struct net_device *dev ) ;
};
#line 396 "include/net/iw_handler.h"
struct iw_spy_data {
   int spy_number ;
   u_char spy_address[8][6] ;
   struct iw_quality spy_stat[8] ;
   struct iw_quality spy_thr_low ;
   struct iw_quality spy_thr_high ;
   u_char spy_thr_under[8] ;
};
#line 419
struct libipw_device;
#line 419
struct libipw_device;
#line 419
struct libipw_device;
#line 421 "include/net/iw_handler.h"
struct iw_public_data {
   struct iw_spy_data *spy_data ;
   struct libipw_device *libipw ;
};
#line 41 "include/net/cfg80211.h"
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_NUM_BANDS = 2
} ;
#line 96 "include/net/cfg80211.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
};
#line 151 "include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
#line 169 "include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
#line 192 "include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
};
#line 530
struct wiphy;
#line 530
struct wiphy;
#line 530
struct wiphy;
#line 533
struct ieee80211_channel;
#line 540 "include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32] ;
   u8 ssid_len ;
};
#line 557 "include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   u8 const   *ie ;
   size_t ie_len ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   bool aborted ;
   struct ieee80211_channel *channels[0] ;
};
#line 580
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
#line 642 "include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5] ;
   int n_akm_suites ;
   u32 akm_suites[2] ;
   bool control_port ;
};
#line 750 "include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 *ssid ;
   u8 *bssid ;
   struct ieee80211_channel *channel ;
   u8 *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   bool channel_fixed ;
   bool privacy ;
};
#line 782 "include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   u8 *bssid ;
   u8 *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 *ie ;
   size_t ie_len ;
   bool privacy ;
   struct cfg80211_crypto_settings crypto ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
};
#line 1115 "include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6] ;
   u16 interface_modes ;
   bool custom_regulatory ;
   bool strict_regulatory ;
   bool disable_beacon_hints ;
   bool netnsok ;
   bool ps_default ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u16 max_scan_ie_len ;
   int n_cipher_suites ;
   u32 const   *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   void const   *privid ;
   struct ieee80211_supported_band *bands[2] ;
   int (*reg_notifier)(struct wiphy *wiphy , struct regulatory_request *request ) ;
   struct ieee80211_regdomain  const  *regd ;
   struct device dev ;
   struct dentry *debugfsdir ;
   struct net *_net ;
   char priv[0]  __attribute__((__aligned__(32))) ;
};
#line 1293
struct cfg80211_conn;
#line 1293
struct cfg80211_conn;
#line 1293
struct cfg80211_conn;
#line 1294
struct cfg80211_internal_bss;
#line 1294
struct cfg80211_internal_bss;
#line 1294
struct cfg80211_internal_bss;
#line 1295
struct cfg80211_cached_keys;
#line 1295
struct cfg80211_cached_keys;
#line 1295
struct cfg80211_cached_keys;
#line 1318
enum __anonenum_sme_state_284 {
    CFG80211_SME_IDLE = 0,
    CFG80211_SME_CONNECTING = 1,
    CFG80211_SME_CONNECTED = 2
} ;
#line 1318 "include/net/cfg80211.h"
struct __anonstruct_wext_285 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 *ie ;
   size_t ie_len ;
   u8 bssid[6] ;
   u8 prev_bssid[6] ;
   u8 ssid[32] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool ps ;
   bool prev_bssid_valid ;
   int ps_timeout ;
};
#line 1318 "include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   struct mutex mtx ;
   struct work_struct cleanup_work ;
   u8 ssid[32] ;
   u8 ssid_len ;
   enum __anonenum_sme_state_284 sme_state ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *authtry_bsses[4] ;
   struct cfg80211_internal_bss *auth_bsses[4] ;
   struct cfg80211_internal_bss *current_bss ;
   struct __anonstruct_wext_285 wext ;
};
#line 111 "include/net/mac80211.h"
struct ieee80211_tx_queue_params {
   u16 txop ;
   u16 cw_min ;
   u16 cw_max ;
   u8 aifs ;
};
#line 125 "include/net/mac80211.h"
struct ieee80211_tx_queue_stats {
   unsigned int len ;
   unsigned int limit ;
   unsigned int count ;
};
#line 131 "include/net/mac80211.h"
struct ieee80211_low_level_stats {
   unsigned int dot11ACKFailureCount ;
   unsigned int dot11RTSFailureCount ;
   unsigned int dot11FCSErrorCount ;
   unsigned int dot11RTSSuccessCount ;
};
#line 199 "include/net/mac80211.h"
struct ieee80211_bss_conf {
   u8 const   *bssid ;
   bool assoc ;
   u16 aid ;
   bool use_cts_prot ;
   bool use_short_preamble ;
   bool use_short_slot ;
   bool enable_beacon ;
   u8 dtim_period ;
   u16 beacon_int ;
   u16 assoc_capability ;
   u64 timestamp ;
   u32 basic_rates ;
   u16 ht_operation_mode ;
};
#line 399
struct ieee80211_vif;
#line 399
struct ieee80211_vif;
#line 399
struct ieee80211_key_conf;
#line 399
struct ieee80211_key_conf;
#line 399
struct ieee80211_sta;
#line 399
struct ieee80211_sta;
#line 633 "include/net/mac80211.h"
struct ieee80211_conf {
   u32 flags ;
   int power_level ;
   int dynamic_ps_timeout ;
   int max_sleep_period ;
   u16 listen_interval ;
   u8 long_frame_max_tx_count ;
   u8 short_frame_max_tx_count ;
   struct ieee80211_channel *channel ;
   enum nl80211_channel_type channel_type ;
};
#line 658 "include/net/mac80211.h"
struct ieee80211_vif {
   enum nl80211_iftype type ;
   struct ieee80211_bss_conf bss_conf ;
   u8 drv_priv[0]  __attribute__((__aligned__(sizeof(void *)))) ;
};
#line 694 "include/net/mac80211.h"
struct ieee80211_if_init_conf {
   enum nl80211_iftype type ;
   struct ieee80211_vif *vif ;
   void *mac_addr ;
};
#line 707
enum ieee80211_key_alg {
    ALG_WEP = 0,
    ALG_TKIP = 1,
    ALG_CCMP = 2,
    ALG_AES_CMAC = 3
} ;
#line 763 "include/net/mac80211.h"
struct ieee80211_key_conf {
   enum ieee80211_key_alg alg ;
   u8 icv_len ;
   u8 iv_len ;
   u8 hw_key_idx ;
   u8 flags ;
   s8 keyidx ;
   u8 keylen ;
   u8 key[0] ;
};
#line 783
enum set_key_cmd {
    SET_KEY = 0,
    DISABLE_KEY = 1
} ;
#line 804 "include/net/mac80211.h"
struct ieee80211_sta {
   u32 supp_rates[2] ;
   u8 addr[6] ;
   u16 aid ;
   struct ieee80211_sta_ht_cap ht_cap ;
   u8 drv_priv[0]  __attribute__((__aligned__(sizeof(void *)))) ;
};
#line 826
enum sta_notify_cmd {
    STA_NOTIFY_ADD = 0,
    STA_NOTIFY_REMOVE = 1,
    STA_NOTIFY_SLEEP = 2,
    STA_NOTIFY_AWAKE = 3
} ;
#line 975 "include/net/mac80211.h"
struct ieee80211_hw {
   struct ieee80211_conf conf ;
   struct wiphy *wiphy ;
   char const   *rate_control_algorithm ;
   void *priv ;
   u32 flags ;
   unsigned int extra_tx_headroom ;
   int channel_change_time ;
   int vif_data_size ;
   int sta_data_size ;
   u16 queues ;
   u16 max_listen_interval ;
   s8 max_signal ;
   u8 max_rates ;
   u8 max_rate_tries ;
};
#line 1298
enum ieee80211_ampdu_mlme_action {
    IEEE80211_AMPDU_RX_START = 0,
    IEEE80211_AMPDU_RX_STOP = 1,
    IEEE80211_AMPDU_TX_START = 2,
    IEEE80211_AMPDU_TX_STOP = 3,
    IEEE80211_AMPDU_TX_OPERATIONAL = 4
} ;
#line 1467 "include/net/mac80211.h"
struct ieee80211_ops {
   int (*tx)(struct ieee80211_hw *hw , struct sk_buff *skb ) ;
   int (*start)(struct ieee80211_hw *hw ) ;
   void (*stop)(struct ieee80211_hw *hw ) ;
   int (*add_interface)(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) ;
   void (*remove_interface)(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) ;
   int (*config)(struct ieee80211_hw *hw , u32 changed ) ;
   void (*bss_info_changed)(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                            struct ieee80211_bss_conf *info , u32 changed ) ;
   u64 (*prepare_multicast)(struct ieee80211_hw *hw , int mc_count , struct dev_addr_list *mc_list ) ;
   void (*configure_filter)(struct ieee80211_hw *hw , unsigned int changed_flags ,
                            unsigned int *total_flags , u64 multicast ) ;
   int (*set_tim)(struct ieee80211_hw *hw , struct ieee80211_sta *sta , bool set ) ;
   int (*set_key)(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                  struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) ;
   void (*update_tkip_key)(struct ieee80211_hw *hw , struct ieee80211_key_conf *conf ,
                           u8 const   *address , u32 iv32 , u16 *phase1key ) ;
   int (*hw_scan)(struct ieee80211_hw *hw , struct cfg80211_scan_request *req ) ;
   void (*sw_scan_start)(struct ieee80211_hw *hw ) ;
   void (*sw_scan_complete)(struct ieee80211_hw *hw ) ;
   int (*get_stats)(struct ieee80211_hw *hw , struct ieee80211_low_level_stats *stats ) ;
   void (*get_tkip_seq)(struct ieee80211_hw *hw , u8 hw_key_idx , u32 *iv32 , u16 *iv16 ) ;
   int (*set_rts_threshold)(struct ieee80211_hw *hw , u32 value ) ;
   void (*sta_notify)(struct ieee80211_hw *hw , struct ieee80211_vif *vif , enum sta_notify_cmd  ,
                      struct ieee80211_sta *sta ) ;
   int (*conf_tx)(struct ieee80211_hw *hw , u16 queue , struct ieee80211_tx_queue_params  const  *params ) ;
   int (*get_tx_stats)(struct ieee80211_hw *hw , struct ieee80211_tx_queue_stats *stats ) ;
   u64 (*get_tsf)(struct ieee80211_hw *hw ) ;
   void (*set_tsf)(struct ieee80211_hw *hw , u64 tsf ) ;
   void (*reset_tsf)(struct ieee80211_hw *hw ) ;
   int (*tx_last_beacon)(struct ieee80211_hw *hw ) ;
   int (*ampdu_action)(struct ieee80211_hw *hw , enum ieee80211_ampdu_mlme_action action ,
                       struct ieee80211_sta *sta , u16 tid , u16 *ssn ) ;
   void (*rfkill_poll)(struct ieee80211_hw *hw ) ;
   int (*testmode_cmd)(struct ieee80211_hw *hw , void *data , int len ) ;
};
#line 109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct boot_attr {
   u32 radio_type ;
   u8 mac_clock ;
   u8 arm_clock ;
   int firmware_debug ;
   u32 minor ;
   u32 major ;
   u32 bugfix ;
};
#line 119
enum wl12xx_state {
    WL12XX_STATE_OFF = 0,
    WL12XX_STATE_ON = 1,
    WL12XX_STATE_PLT = 2
} ;
#line 133 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_partition {
   u32 size ;
   u32 start ;
};
#line 138 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_partition_set {
   struct wl12xx_partition mem ;
   struct wl12xx_partition reg ;
};
#line 143
struct wl12xx;
#line 143
struct wl12xx;
#line 143
struct wl12xx;
#line 146
enum wl12xx_acx_int_reg;
#line 146
enum wl12xx_acx_int_reg;
#line 146 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_chip {
   u32 id ;
   char const   *fw_filename ;
   char const   *nvs_filename ;
   char fw_ver[21] ;
   unsigned int power_on_sleep ;
   int intr_cmd_complete ;
   int intr_init_complete ;
   int (*op_upload_fw)(struct wl12xx *wl ) ;
   int (*op_upload_nvs)(struct wl12xx *wl ) ;
   int (*op_boot)(struct wl12xx *wl ) ;
   void (*op_set_ecpu_ctrl)(struct wl12xx *wl , u32 flag ) ;
   void (*op_target_enable_interrupts)(struct wl12xx *wl ) ;
   int (*op_hw_init)(struct wl12xx *wl ) ;
   int (*op_plt_init)(struct wl12xx *wl ) ;
   struct wl12xx_partition_set *p_table ;
   enum wl12xx_acx_int_reg *acx_reg_table ;
};
#line 170
struct acx_statistics;
#line 170
struct acx_statistics;
#line 170 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_stats {
   struct acx_statistics *fw_stats ;
   unsigned long fw_stats_update ;
   unsigned int retry_count ;
   unsigned int excessive_retries ;
};
#line 178 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_debugfs {
   struct dentry *rootdir ;
   struct dentry *fw_statistics ;
   struct dentry *tx_internal_desc_overflow ;
   struct dentry *rx_out_of_mem ;
   struct dentry *rx_hdr_overflow ;
   struct dentry *rx_hw_stuck ;
   struct dentry *rx_dropped ;
   struct dentry *rx_fcs_err ;
   struct dentry *rx_xfr_hint_trig ;
   struct dentry *rx_path_reset ;
   struct dentry *rx_reset_counter ;
   struct dentry *dma_rx_requested ;
   struct dentry *dma_rx_errors ;
   struct dentry *dma_tx_requested ;
   struct dentry *dma_tx_errors ;
   struct dentry *isr_cmd_cmplt ;
   struct dentry *isr_fiqs ;
   struct dentry *isr_rx_headers ;
   struct dentry *isr_rx_mem_overflow ;
   struct dentry *isr_rx_rdys ;
   struct dentry *isr_irqs ;
   struct dentry *isr_tx_procs ;
   struct dentry *isr_decrypt_done ;
   struct dentry *isr_dma0_done ;
   struct dentry *isr_dma1_done ;
   struct dentry *isr_tx_exch_complete ;
   struct dentry *isr_commands ;
   struct dentry *isr_rx_procs ;
   struct dentry *isr_hw_pm_mode_changes ;
   struct dentry *isr_host_acknowledges ;
   struct dentry *isr_pci_pm ;
   struct dentry *isr_wakeups ;
   struct dentry *isr_low_rssi ;
   struct dentry *wep_addr_key_count ;
   struct dentry *wep_default_key_count ;
   struct dentry *wep_key_not_found ;
   struct dentry *wep_decrypt_fail ;
   struct dentry *wep_packets ;
   struct dentry *wep_interrupt ;
   struct dentry *pwr_ps_enter ;
   struct dentry *pwr_elp_enter ;
   struct dentry *pwr_missing_bcns ;
   struct dentry *pwr_wake_on_host ;
   struct dentry *pwr_wake_on_timer_exp ;
   struct dentry *pwr_tx_with_ps ;
   struct dentry *pwr_tx_without_ps ;
   struct dentry *pwr_rcvd_beacons ;
   struct dentry *pwr_power_save_off ;
   struct dentry *pwr_enable_ps ;
   struct dentry *pwr_disable_ps ;
   struct dentry *pwr_fix_tsf_ps ;
   struct dentry *pwr_rcvd_awake_beacons ;
   struct dentry *mic_rx_pkts ;
   struct dentry *mic_calc_failure ;
   struct dentry *aes_encrypt_fail ;
   struct dentry *aes_decrypt_fail ;
   struct dentry *aes_encrypt_packets ;
   struct dentry *aes_decrypt_packets ;
   struct dentry *aes_encrypt_interrupt ;
   struct dentry *aes_decrypt_interrupt ;
   struct dentry *event_heart_beat ;
   struct dentry *event_calibration ;
   struct dentry *event_rx_mismatch ;
   struct dentry *event_rx_mem_empty ;
   struct dentry *event_rx_pool ;
   struct dentry *event_oom_late ;
   struct dentry *event_phy_transmit_error ;
   struct dentry *event_tx_stuck ;
   struct dentry *ps_pspoll_timeouts ;
   struct dentry *ps_upsd_timeouts ;
   struct dentry *ps_upsd_max_sptime ;
   struct dentry *ps_upsd_max_apturn ;
   struct dentry *ps_pspoll_max_apturn ;
   struct dentry *ps_pspoll_utilization ;
   struct dentry *ps_upsd_utilization ;
   struct dentry *rxpipe_rx_prep_beacon_drop ;
   struct dentry *rxpipe_descr_host_int_trig_rx_data ;
   struct dentry *rxpipe_beacon_buffer_thres_host_int_trig_rx_data ;
   struct dentry *rxpipe_missed_beacon_host_int_trig_rx_data ;
   struct dentry *rxpipe_tx_xfr_host_int_trig_rx_data ;
   struct dentry *tx_queue_len ;
   struct dentry *retry_count ;
   struct dentry *excessive_retries ;
};
#line 279
struct acx_data_path_params_resp;
#line 279
struct acx_data_path_params_resp;
#line 279 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx {
   struct ieee80211_hw *hw ;
   bool mac80211_registered ;
   struct spi_device *spi ;
   void (*set_power)(bool enable ) ;
   int irq ;
   enum wl12xx_state state ;
   struct mutex mutex ;
   int physical_mem_addr ;
   int physical_reg_addr ;
   int virtual_mem_addr ;
   int virtual_reg_addr ;
   struct wl12xx_chip chip ;
   int cmd_box_addr ;
   int event_box_addr ;
   struct boot_attr boot_attr ;
   u8 *fw ;
   size_t fw_len ;
   u8 *nvs ;
   size_t nvs_len ;
   u8 bssid[6] ;
   u8 mac_addr[6] ;
   u8 bss_type ;
   u8 listen_int ;
   int channel ;
   void *target_mem_map ;
   struct acx_data_path_params_resp *data_path ;
   u32 data_in_count ;
   struct sk_buff_head tx_queue ;
   bool tx_queue_stopped ;
   struct work_struct tx_work ;
   struct work_struct filter_work ;
   struct sk_buff *tx_frames[16] ;
   u32 next_tx_complete ;
   u32 rx_counter ;
   u32 rx_handled ;
   u32 rx_current_buffer ;
   u32 rx_last_id ;
   u32 intr_mask ;
   struct work_struct irq_work ;
   u32 event_mask ;
   u32 mbox_ptr[2] ;
   bool scanning ;
   u16 aid ;
   u32 default_key ;
   unsigned int tx_mgmt_frm_rate ;
   unsigned int tx_mgmt_frm_mod ;
   unsigned int rx_config ;
   unsigned int rx_filter ;
   bool elp ;
   bool psm ;
   bool psm_requested ;
   int power_level ;
   struct wl12xx_stats stats ;
   struct wl12xx_debugfs debugfs ;
};
#line 61 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct ieee80211_header {
   __le16 frame_ctl ;
   __le16 duration_id ;
   u8 da[6] ;
   u8 sa[6] ;
   u8 bssid[6] ;
   __le16 seq_ctl ;
   u8 payload[0] ;
} __attribute__((__packed__)) ;
#line 71 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ie_header {
   u8 id ;
   u8 len ;
} __attribute__((__packed__)) ;
#line 78 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ie_ssid {
   struct wl12xx_ie_header header ;
   char ssid[32] ;
} __attribute__((__packed__)) ;
#line 83 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ie_rates {
   struct wl12xx_ie_header header ;
   u8 rates[32] ;
} __attribute__((__packed__)) ;
#line 120 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_null_data_template {
   struct ieee80211_header header ;
} __attribute__((__packed__)) ;
#line 124 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ps_poll_template {
   u16 fc ;
   u16 aid ;
   u8 bssid[6] ;
   u8 ta[6] ;
} __attribute__((__packed__)) ;
#line 136 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_probe_req_template {
   struct ieee80211_header header ;
   struct wl12xx_ie_ssid ssid ;
   struct wl12xx_ie_rates rates ;
   struct wl12xx_ie_rates ext_rates ;
} __attribute__((__packed__)) ;
#line 167 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/reg.h"
enum wl12xx_acx_int_reg {
    ACX_REG_INTERRUPT_TRIG = 0,
    ACX_REG_INTERRUPT_TRIG_H = 1,
    ACX_REG_INTERRUPT_MASK = 2,
    ACX_REG_HINT_MASK_SET = 3,
    ACX_REG_HINT_MASK_CLR = 4,
    ACX_REG_INTERRUPT_NO_CLEAR = 5,
    ACX_REG_INTERRUPT_CLEAR = 6,
    ACX_REG_INTERRUPT_ACK = 7,
    ACX_REG_SLV_SOFT_RESET = 8,
    ACX_REG_EE_START = 9,
    ACX_REG_ECPU_CONTROL = 10,
    ACX_REG_TABLE_LEN = 11
} ;
#line 31 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_header {
   u16 id ;
   u16 len ;
};
#line 178 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_data_path_params_resp {
   struct acx_header header ;
   u16 rx_packet_ring_chunk_size ;
   u16 tx_packet_ring_chunk_size ;
   u8 rx_packet_ring_chunk_num ;
   u8 tx_packet_ring_chunk_num ;
   u8 pad[2] ;
   u32 rx_packet_ring_addr ;
   u32 tx_packet_ring_addr ;
   u32 rx_control_addr ;
   u32 tx_control_addr ;
   u32 tx_complete_addr ;
} __attribute__((__packed__)) ;
#line 350
enum acx_slot_type {
    SLOT_TIME_LONG = 0,
    SLOT_TIME_SHORT = 1,
    DEFAULT_SLOT_TIME = 1,
    MAX_SLOT_TIMES = 255
} ;
#line 790 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_set_key {
   u8 addr[6] ;
   u16 key_action ;
   u16 reserved_1 ;
   u8 key_size ;
   u8 key_type ;
   u8 ssid_profile ;
   u8 id ;
   u8 reserved_2[6] ;
   u8 key[32] ;
   u16 ac_seq_num16[4] ;
   u32 ac_seq_num32[4] ;
} __attribute__((__packed__)) ;
#line 843
enum acx_ps_mode {
    STATION_ACTIVE_MODE = 0,
    STATION_POWER_SAVE_MODE = 1
} ;
#line 888
enum acx_preamble_type {
    ACX_PREAMBLE_LONG = 0,
    ACX_PREAMBLE_SHORT = 1
} ;
#line 903
enum acx_ctsprotect_type {
    CTSPROTECT_DISABLE = 0,
    CTSPROTECT_ENABLE = 1
} ;
#line 914 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_tx_statistics {
   u32 internal_desc_overflow ;
} __attribute__((__packed__)) ;
#line 918 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_rx_statistics {
   u32 out_of_mem ;
   u32 hdr_overflow ;
   u32 hw_stuck ;
   u32 dropped ;
   u32 fcs_err ;
   u32 xfr_hint_trig ;
   u32 path_reset ;
   u32 reset_counter ;
} __attribute__((__packed__)) ;
#line 929 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_dma_statistics {
   u32 rx_requested ;
   u32 rx_errors ;
   u32 tx_requested ;
   u32 tx_errors ;
} __attribute__((__packed__)) ;
#line 936 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_isr_statistics {
   u32 cmd_cmplt ;
   u32 fiqs ;
   u32 rx_headers ;
   u32 rx_completes ;
   u32 rx_mem_overflow ;
   u32 rx_rdys ;
   u32 irqs ;
   u32 tx_procs ;
   u32 decrypt_done ;
   u32 dma0_done ;
   u32 dma1_done ;
   u32 tx_exch_complete ;
   u32 commands ;
   u32 rx_procs ;
   u32 hw_pm_mode_changes ;
   u32 host_acknowledges ;
   u32 pci_pm ;
   u32 wakeups ;
   u32 low_rssi ;
} __attribute__((__packed__)) ;
#line 995 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_wep_statistics {
   u32 addr_key_count ;
   u32 default_key_count ;
   u32 reserved ;
   u32 key_not_found ;
   u32 decrypt_fail ;
   u32 packets ;
   u32 interrupt ;
} __attribute__((__packed__)) ;
#line 1019 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_pwr_statistics {
   u32 ps_enter ;
   u32 elp_enter ;
   u32 missing_bcns ;
   u32 wake_on_host ;
   u32 wake_on_timer_exp ;
   u32 tx_with_ps ;
   u32 tx_without_ps ;
   u32 rcvd_beacons ;
   u32 power_save_off ;
   u16 enable_ps ;
   u16 disable_ps ;
   u32 fix_tsf_ps ;
   u32 cont_miss_bcns_spread[10] ;
   u32 rcvd_awake_beacons ;
} __attribute__((__packed__)) ;
#line 1077 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_mic_statistics {
   u32 rx_pkts ;
   u32 calc_failure ;
} __attribute__((__packed__)) ;
#line 1082 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_aes_statistics {
   u32 encrypt_fail ;
   u32 decrypt_fail ;
   u32 encrypt_packets ;
   u32 decrypt_packets ;
   u32 encrypt_interrupt ;
   u32 decrypt_interrupt ;
} __attribute__((__packed__)) ;
#line 1091 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_event_statistics {
   u32 heart_beat ;
   u32 calibration ;
   u32 rx_mismatch ;
   u32 rx_mem_empty ;
   u32 rx_pool ;
   u32 oom_late ;
   u32 phy_transmit_error ;
   u32 tx_stuck ;
} __attribute__((__packed__)) ;
#line 1102 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_ps_statistics {
   u32 pspoll_timeouts ;
   u32 upsd_timeouts ;
   u32 upsd_max_sptime ;
   u32 upsd_max_apturn ;
   u32 pspoll_max_apturn ;
   u32 pspoll_utilization ;
   u32 upsd_utilization ;
} __attribute__((__packed__)) ;
#line 1112 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_rxpipe_statistics {
   u32 rx_prep_beacon_drop ;
   u32 descr_host_int_trig_rx_data ;
   u32 beacon_buffer_thres_host_int_trig_rx_data ;
   u32 missed_beacon_host_int_trig_rx_data ;
   u32 tx_xfr_host_int_trig_rx_data ;
} __attribute__((__packed__)) ;
#line 1120 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_statistics {
   struct acx_header header ;
   struct acx_tx_statistics tx ;
   struct acx_rx_statistics rx ;
   struct acx_dma_statistics dma ;
   struct acx_isr_statistics isr ;
   struct acx_wep_statistics wep ;
   struct acx_pwr_statistics pwr ;
   struct acx_aes_statistics aes ;
   struct acx_mic_statistics mic ;
   struct acx_event_statistics event ;
   struct acx_ps_statistics ps ;
   struct acx_rxpipe_statistics rxpipe ;
} __attribute__((__packed__)) ;
#line 103 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct wl12xx_command {
   u16 id ;
   u16 status ;
   u8 parameters[572] ;
};
#line 164 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct basic_scan_parameters {
   u32 rx_config_options ;
   u32 rx_filter_options ;
   u16 scan_options ;
   u8 num_channels ;
   u8 num_probe_requests ;
   u16 tx_rate ;
   u8 tid_trigger ;
   u8 ssid_len ;
   u32 ssid[8] ;
} __attribute__((__packed__)) ;
#line 193 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct basic_scan_channel_parameters {
   u32 min_duration ;
   u32 max_duration ;
   u32 bssid_lsb ;
   u16 bssid_msb ;
   u8 early_termination ;
   u8 tx_power_att ;
   u8 channel ;
   u8 pad[3] ;
} __attribute__((__packed__)) ;
#line 213 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct cmd_scan {
   struct basic_scan_parameters params ;
   struct basic_scan_channel_parameters channels[16] ;
} __attribute__((__packed__)) ;
#line 81 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/tx.h"
struct tx_control {
   unsigned int rate_policy : 3 ;
   unsigned int ack_policy : 1 ;
   unsigned int packet_type : 2 ;
   unsigned int qos : 1 ;
   unsigned int tx_complete : 1 ;
   unsigned int xfer_pad : 1 ;
   unsigned int reserved : 7 ;
} __attribute__((__packed__)) ;
#line 113 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/tx.h"
struct tx_double_buffer_desc {
   u16 length ;
   u16 rate ;
   u32 expiry_time ;
   u8 xmit_queue ;
   u8 id ;
   struct tx_control control ;
   u16 frag_threshold ;
   u8 num_mem_blocks ;
   u8 reserved ;
} __attribute__((__packed__)) ;
#line 1109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
struct __anonstruct_310 {
   int  : 0 ;
};
#line 1109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
struct __anonstruct_311 {
   int  : 0 ;
};
#line 1 "<compiler builtins>"
long __builtin_expect(long  , long  ) ;
#line 63 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   *file , int line ) ;
#line 241 "include/linux/kernel.h"
extern int ( __attribute__((__regparm__(0))) printk)(char const   *fmt  , ...)  __attribute__((__cold__)) ;
#line 32 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/string_32.h"
__inline static void *( __attribute__((__always_inline__)) __memcpy)(void *to , void const   *from ,
                                                                     size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
#line 35
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
#line 44
  return (to);
}
}
#line 51 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/string_32.h"
__inline static void *( __attribute__((__always_inline__)) __constant_memcpy)(void *to ,
                                                                              void const   *from ,
                                                                              size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  short *__cil_tmp16 ;
  short *__cil_tmp17 ;
  int *__cil_tmp18 ;
  int *__cil_tmp19 ;
  short *__cil_tmp20 ;
  short *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  int *__cil_tmp26 ;
  int *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  int *__cil_tmp32 ;
  int *__cil_tmp33 ;
  short *__cil_tmp34 ;
  short *__cil_tmp35 ;
  short *__cil_tmp36 ;
  short *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  int *__cil_tmp40 ;
  int *__cil_tmp41 ;
  int *__cil_tmp42 ;
  int *__cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  int __cil_tmp49 ;

  {
#line 55
  if (! n) {
#line 56
    return (to);
  } else {

  }
  {
#line 59
  __cil_tmp7 = (int )n;
#line 59
  if (__cil_tmp7 == 1) {
    goto switch_0_1;
  } else {
    {
#line 62
    __cil_tmp8 = (int )n;
#line 62
    if (__cil_tmp8 == 2) {
      goto switch_0_2;
    } else {
      {
#line 65
      __cil_tmp9 = (int )n;
#line 65
      if (__cil_tmp9 == 4) {
        goto switch_0_4;
      } else {
        {
#line 68
        __cil_tmp10 = (int )n;
#line 68
        if (__cil_tmp10 == 3) {
          goto switch_0_3;
        } else {
          {
#line 72
          __cil_tmp11 = (int )n;
#line 72
          if (__cil_tmp11 == 5) {
            goto switch_0_5;
          } else {
            {
#line 76
            __cil_tmp12 = (int )n;
#line 76
            if (__cil_tmp12 == 6) {
              goto switch_0_6;
            } else {
              {
#line 80
              __cil_tmp13 = (int )n;
#line 80
              if (__cil_tmp13 == 8) {
                goto switch_0_8;
              } else {
#line 58
                if (0) {
                  switch_0_1: 
#line 60
                  __cil_tmp14 = (char *)to;
#line 60
                  __cil_tmp15 = (char *)from;
#line 60
                  *__cil_tmp14 = *__cil_tmp15;
#line 61
                  return (to);
                  switch_0_2: 
#line 63
                  __cil_tmp16 = (short *)to;
#line 63
                  __cil_tmp17 = (short *)from;
#line 63
                  *__cil_tmp16 = *__cil_tmp17;
#line 64
                  return (to);
                  switch_0_4: 
#line 66
                  __cil_tmp18 = (int *)to;
#line 66
                  __cil_tmp19 = (int *)from;
#line 66
                  *__cil_tmp18 = *__cil_tmp19;
#line 67
                  return (to);
                  switch_0_3: 
#line 69
                  __cil_tmp20 = (short *)to;
#line 69
                  __cil_tmp21 = (short *)from;
#line 69
                  *__cil_tmp20 = *__cil_tmp21;
#line 70
                  __cil_tmp22 = (char *)to;
#line 70
                  __cil_tmp23 = __cil_tmp22 + 2;
#line 70
                  __cil_tmp24 = (char *)from;
#line 70
                  __cil_tmp25 = __cil_tmp24 + 2;
#line 70
                  *__cil_tmp23 = *__cil_tmp25;
#line 71
                  return (to);
                  switch_0_5: 
#line 73
                  __cil_tmp26 = (int *)to;
#line 73
                  __cil_tmp27 = (int *)from;
#line 73
                  *__cil_tmp26 = *__cil_tmp27;
#line 74
                  __cil_tmp28 = (char *)to;
#line 74
                  __cil_tmp29 = __cil_tmp28 + 4;
#line 74
                  __cil_tmp30 = (char *)from;
#line 74
                  __cil_tmp31 = __cil_tmp30 + 4;
#line 74
                  *__cil_tmp29 = *__cil_tmp31;
#line 75
                  return (to);
                  switch_0_6: 
#line 77
                  __cil_tmp32 = (int *)to;
#line 77
                  __cil_tmp33 = (int *)from;
#line 77
                  *__cil_tmp32 = *__cil_tmp33;
#line 78
                  __cil_tmp34 = (short *)to;
#line 78
                  __cil_tmp35 = __cil_tmp34 + 2;
#line 78
                  __cil_tmp36 = (short *)from;
#line 78
                  __cil_tmp37 = __cil_tmp36 + 2;
#line 78
                  *__cil_tmp35 = *__cil_tmp37;
#line 79
                  return (to);
                  switch_0_8: 
#line 81
                  __cil_tmp38 = (int *)to;
#line 81
                  __cil_tmp39 = (int *)from;
#line 81
                  *__cil_tmp38 = *__cil_tmp39;
#line 82
                  __cil_tmp40 = (int *)to;
#line 82
                  __cil_tmp41 = __cil_tmp40 + 1;
#line 82
                  __cil_tmp42 = (int *)from;
#line 82
                  __cil_tmp43 = __cil_tmp42 + 1;
#line 82
                  *__cil_tmp41 = *__cil_tmp43;
#line 83
                  return (to);
                } else {

                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
#line 86
  esi = (long )from;
#line 87
  edi = (long )to;
#line 88
  if (n >= 20U) {
#line 91
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n / 4U),
                         "1" (edi), "2" (esi): "memory");
  } else {
#line 98
    if (n >= 16U) {
#line 99
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
#line 103
    if (n >= 12U) {
#line 104
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
#line 108
    if (n >= 8U) {
#line 109
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
#line 113
    if (n >= 4U) {
#line 114
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
  }
  {
#line 121
  __cil_tmp44 = n % 4U;
#line 121
  __cil_tmp45 = (int )__cil_tmp44;
#line 121
  if (__cil_tmp45 == 0) {
    goto switch_1_0;
  } else {
    {
#line 123
    __cil_tmp46 = n % 4U;
#line 123
    __cil_tmp47 = (int )__cil_tmp46;
#line 123
    if (__cil_tmp47 == 1) {
      goto switch_1_1;
    } else {
      {
#line 129
      __cil_tmp48 = n % 4U;
#line 129
      __cil_tmp49 = (int )__cil_tmp48;
#line 129
      if (__cil_tmp49 == 2) {
        goto switch_1_2;
      } else {
        goto switch_1_default;
#line 119
        if (0) {
          switch_1_0: 
#line 122
          return (to);
          switch_1_1: 
#line 124
          __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
#line 128
          return (to);
          switch_1_2: 
#line 130
          __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
#line 134
          return (to);
          switch_1_default: 
#line 136
          __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi),
                               "1" (esi): "memory");
#line 140
          return (to);
        } else {

        }
      }
      }
    }
    }
  }
  }
}
}
#line 251 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/string_32.h"
__inline static void *( __attribute__((__always_inline__)) __constant_c_and_count_memset)(void *s ,
                                                                                          unsigned long pattern ,
                                                                                          size_t count ) 
{ int d0 ;
  int d1 ;
  unsigned long eax ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned short *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned short *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  int __cil_tmp27 ;

  {
  {
#line 256
  __cil_tmp7 = (int )count;
#line 256
  if (__cil_tmp7 == 0) {
    goto switch_2_0;
  } else {
    {
#line 258
    __cil_tmp8 = (int )count;
#line 258
    if (__cil_tmp8 == 1) {
      goto switch_2_1;
    } else {
      {
#line 261
      __cil_tmp9 = (int )count;
#line 261
      if (__cil_tmp9 == 2) {
        goto switch_2_2;
      } else {
        {
#line 264
        __cil_tmp10 = (int )count;
#line 264
        if (__cil_tmp10 == 3) {
          goto switch_2_3;
        } else {
          {
#line 268
          __cil_tmp11 = (int )count;
#line 268
          if (__cil_tmp11 == 4) {
            goto switch_2_4;
          } else {
#line 255
            if (0) {
              switch_2_0: 
#line 257
              return (s);
              switch_2_1: 
#line 259
              __cil_tmp12 = (unsigned char *)s;
#line 259
              __cil_tmp13 = pattern & 255UL;
#line 259
              *__cil_tmp12 = (unsigned char )__cil_tmp13;
#line 260
              return (s);
              switch_2_2: 
#line 262
              __cil_tmp14 = (unsigned short *)s;
#line 262
              __cil_tmp15 = pattern & 65535UL;
#line 262
              *__cil_tmp14 = (unsigned short )__cil_tmp15;
#line 263
              return (s);
              switch_2_3: 
#line 265
              __cil_tmp16 = (unsigned short *)s;
#line 265
              __cil_tmp17 = pattern & 65535UL;
#line 265
              *__cil_tmp16 = (unsigned short )__cil_tmp17;
#line 266
              __cil_tmp18 = (unsigned char *)s;
#line 266
              __cil_tmp19 = __cil_tmp18 + 2;
#line 266
              __cil_tmp20 = pattern & 255UL;
#line 266
              *__cil_tmp19 = (unsigned char )__cil_tmp20;
#line 267
              return (s);
              switch_2_4: 
#line 269
              __cil_tmp21 = (unsigned long *)s;
#line 269
              *__cil_tmp21 = pattern;
#line 270
              return (s);
            } else {

            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
#line 286
  eax = pattern;
  {
#line 290
  __cil_tmp22 = count % 4U;
#line 290
  __cil_tmp23 = (int )__cil_tmp22;
#line 290
  if (__cil_tmp23 == 0) {
    goto switch_3_0;
  } else {
    {
#line 293
    __cil_tmp24 = count % 4U;
#line 293
    __cil_tmp25 = (int )__cil_tmp24;
#line 293
    if (__cil_tmp25 == 1) {
      goto switch_3_1;
    } else {
      {
#line 296
      __cil_tmp26 = count % 4U;
#line 296
      __cil_tmp27 = (int )__cil_tmp26;
#line 296
      if (__cil_tmp27 == 2) {
        goto switch_3_2;
      } else {
        goto switch_3_default;
#line 289
        if (0) {
          switch_3_0: 
#line 291
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
#line 292
          return (s);
          switch_3_1: 
#line 294
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
#line 295
          return (s);
          switch_3_2: 
#line 297
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
#line 298
          return (s);
          switch_3_default: 
#line 300
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax),
                               "0" (count / 4U), "1" ((long )s): "memory");
#line 301
          return (s);
        } else {

        }
      }
      }
    }
    }
  }
  }
}
}
#line 101 "include/linux/string.h"
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
#line 28 "include/linux/list.h"
__inline static void ( __attribute__((__always_inline__)) INIT_LIST_HEAD)(struct list_head *list ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;

  {
#line 30
  *((struct list_head **)list) = list;
#line 31
  __cil_tmp2 = (unsigned int )list;
#line 31
  __cil_tmp3 = __cil_tmp2 + 4;
#line 31
  *((struct list_head **)__cil_tmp3) = list;
#line 32
  return;
}
}
#line 178 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/thread_info.h"
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
#line 94 "include/linux/spinlock.h"
extern void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 107 "include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
#line 136
void mutex_lock(struct mutex *lock ) ;
#line 137
int mutex_lock_interruptible(struct mutex *lock ) ;
#line 138
int mutex_lock_killable(struct mutex *lock ) ;
#line 151
int mutex_trylock(struct mutex *lock ) ;
#line 152
void mutex_unlock(struct mutex *lock ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int msecs ) ;
#line 212 "include/linux/workqueue.h"
extern int schedule_work(struct work_struct *work ) ;
#line 226
extern int cancel_work_sync(struct work_struct *work ) ;
#line 138 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 218 "include/linux/slub_def.h"
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 241 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___1 ;

  {
  {
#line 262
  tmp___1 = __kmalloc(size, flags);
  }
#line 262
  return (tmp___1);
}
}
#line 313 "include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 315
  __cil_tmp4 = flags | 32768U;
#line 315
  tmp = kmalloc(size, __cil_tmp4);
  }
#line 315
  return (tmp);
}
}
#line 68 "include/linux/module.h"
int init_module(void) ;
#line 69
void cleanup_module(void) ;
#line 88
extern struct module __this_module ;
#line 409 "include/linux/irq.h"
extern int set_irq_type(unsigned int irq , unsigned int type ) ;
#line 111 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                irqreturn_t (*thread_fn)(int  , void * ) , unsigned long flags ,
                                char const   *name , void *dev ) ;
#line 116 "include/linux/interrupt.h"
__inline static int ( __attribute__((__always_inline__)) request_irq)(unsigned int irq ,
                                                                      irqreturn_t (*handler)(int  ,
                                                                                             void * ) ,
                                                                      unsigned long flags ,
                                                                      char const   *name ,
                                                                      void *dev ) 
{ int tmp ;
  void *__cil_tmp7 ;
  irqreturn_t (*__cil_tmp8)(int  , void * ) ;

  {
  {
#line 120
  __cil_tmp7 = (void *)0;
#line 120
  __cil_tmp8 = (irqreturn_t (*)(int  , void * ))__cil_tmp7;
#line 120
  tmp = request_threaded_irq(irq, handler, __cil_tmp8, flags, name, dev);
  }
#line 120
  return (tmp);
}
}
#line 147
extern void free_irq(unsigned int  , void * ) ;
#line 186
extern void disable_irq(unsigned int irq ) ;
#line 37 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  **fw , char const   *name , struct device *device ) ;
#line 44
extern void release_firmware(struct firmware  const  *fw ) ;
#line 145 "include/linux/device.h"
extern void driver_unregister(struct device_driver *drv ) ;
#line 494
extern void *dev_get_drvdata(struct device  const  *dev ) ;
#line 495
extern void dev_set_drvdata(struct device *dev , void *data ) ;
#line 29 "include/linux/spi/spi.h"
extern struct bus_type spi_bus_type ;
#line 189
extern int spi_register_driver(struct spi_driver *sdrv ) ;
#line 196 "include/linux/spi/spi.h"
__inline static void ( __attribute__((__always_inline__)) spi_unregister_driver)(struct spi_driver *sdrv ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  struct device_driver *__cil_tmp4 ;

  {
#line 198
  if (sdrv) {
    {
#line 199
    __cil_tmp2 = (unsigned int )sdrv;
#line 199
    __cil_tmp3 = __cil_tmp2 + 24;
#line 199
    __cil_tmp4 = (struct device_driver *)__cil_tmp3;
#line 199
    driver_unregister(__cil_tmp4);
    }
  } else {

  }
#line 200
  return;
}
}
#line 542
extern int spi_setup(struct spi_device *spi ) ;
#line 53 "include/linux/random.h"
extern void get_random_bytes(void *buf , int nbytes ) ;
#line 441 "include/linux/skbuff.h"
extern void consume_skb(struct sk_buff *skb ) ;
#line 795 "include/linux/skbuff.h"
__inline static __u32 ( __attribute__((__always_inline__)) skb_queue_len)(struct sk_buff_head  const  *list_ ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  __u32 __cil_tmp4 ;

  {
  {
#line 797
  __cil_tmp2 = (unsigned int )list_;
#line 797
  __cil_tmp3 = __cil_tmp2 + 8;
#line 797
  __cil_tmp4 = *((__u32 const   *)__cil_tmp3);
#line 797
  return ((unsigned int )__cil_tmp4);
  }
}
}
#line 810 "include/linux/skbuff.h"
__inline static void ( __attribute__((__always_inline__)) __skb_queue_head_init)(struct sk_buff_head *list ) 
{ struct sk_buff *tmp ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
#line 812
  tmp = (struct sk_buff *)list;
#line 812
  *((struct sk_buff **)list) = tmp;
#line 812
  __cil_tmp3 = (unsigned int )list;
#line 812
  __cil_tmp4 = __cil_tmp3 + 4;
#line 812
  *((struct sk_buff **)__cil_tmp4) = tmp;
#line 813
  __cil_tmp5 = (unsigned int )list;
#line 813
  __cil_tmp6 = __cil_tmp5 + 8;
#line 813
  *((__u32 *)__cil_tmp6) = 0U;
#line 814
  return;
}
}
#line 826 "include/linux/skbuff.h"
static struct lock_class_key __key___2  ;
#line 824 "include/linux/skbuff.h"
__inline static void ( __attribute__((__always_inline__)) skb_queue_head_init)(struct sk_buff_head *list ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  spinlock_t *__cil_tmp4 ;

  {
  {
#line 826
  while (1) {
    while_0_continue: /* CIL Label */ ;
    {
#line 826
    __cil_tmp2 = (unsigned int )list;
#line 826
    __cil_tmp3 = __cil_tmp2 + 12;
#line 826
    __cil_tmp4 = (spinlock_t *)__cil_tmp3;
#line 826
    __spin_lock_init(__cil_tmp4, "&list->lock", & __key___2);
    }
    goto while_10_break;
  }
  while_0_break: /* CIL Label */ ;
  }
  while_10_break: 
  {
#line 827
  __skb_queue_head_init(list);
  }
#line 828
  return;
}
}
#line 986
extern void skb_queue_tail(struct sk_buff_head *list , struct sk_buff *newsk ) ;
#line 60 "include/linux/etherdevice.h"
__inline static int ( __attribute__((__always_inline__)) is_zero_ether_addr)(u8 const   *addr ) 
{ u8 const   *__cil_tmp2 ;
  u8 __cil_tmp3 ;
  int __cil_tmp4 ;
  u8 const   *__cil_tmp5 ;
  u8 __cil_tmp6 ;
  int __cil_tmp7 ;
  u8 const   *__cil_tmp8 ;
  u8 __cil_tmp9 ;
  int __cil_tmp10 ;
  u8 const   *__cil_tmp11 ;
  u8 __cil_tmp12 ;
  int __cil_tmp13 ;
  u8 const   *__cil_tmp14 ;
  u8 __cil_tmp15 ;
  int __cil_tmp16 ;
  u8 const   *__cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
  {
#line 62
  __cil_tmp2 = addr + 5;
#line 62
  __cil_tmp3 = *__cil_tmp2;
#line 62
  __cil_tmp4 = (int const   )__cil_tmp3;
#line 62
  __cil_tmp5 = addr + 4;
#line 62
  __cil_tmp6 = *__cil_tmp5;
#line 62
  __cil_tmp7 = (int const   )__cil_tmp6;
#line 62
  __cil_tmp8 = addr + 3;
#line 62
  __cil_tmp9 = *__cil_tmp8;
#line 62
  __cil_tmp10 = (int const   )__cil_tmp9;
#line 62
  __cil_tmp11 = addr + 2;
#line 62
  __cil_tmp12 = *__cil_tmp11;
#line 62
  __cil_tmp13 = (int const   )__cil_tmp12;
#line 62
  __cil_tmp14 = addr + 1;
#line 62
  __cil_tmp15 = *__cil_tmp14;
#line 62
  __cil_tmp16 = (int const   )__cil_tmp15;
#line 62
  __cil_tmp17 = addr + 0;
#line 62
  __cil_tmp18 = *__cil_tmp17;
#line 62
  __cil_tmp19 = (int const   )__cil_tmp18;
#line 62
  __cil_tmp20 = __cil_tmp19 | __cil_tmp16;
#line 62
  __cil_tmp21 = __cil_tmp20 | __cil_tmp13;
#line 62
  __cil_tmp22 = __cil_tmp21 | __cil_tmp10;
#line 62
  __cil_tmp23 = __cil_tmp22 | __cil_tmp7;
#line 62
  __cil_tmp24 = __cil_tmp23 | __cil_tmp4;
#line 62
  return (! __cil_tmp24);
  }
}
}
#line 94 "include/linux/etherdevice.h"
__inline static int ( __attribute__((__always_inline__)) is_broadcast_ether_addr)(u8 const   *addr ) 
{ u8 const   *__cil_tmp2 ;
  u8 __cil_tmp3 ;
  int __cil_tmp4 ;
  u8 const   *__cil_tmp5 ;
  u8 __cil_tmp6 ;
  int __cil_tmp7 ;
  u8 const   *__cil_tmp8 ;
  u8 __cil_tmp9 ;
  int __cil_tmp10 ;
  u8 const   *__cil_tmp11 ;
  u8 __cil_tmp12 ;
  int __cil_tmp13 ;
  u8 const   *__cil_tmp14 ;
  u8 __cil_tmp15 ;
  int __cil_tmp16 ;
  u8 const   *__cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
  {
#line 96
  __cil_tmp2 = addr + 5;
#line 96
  __cil_tmp3 = *__cil_tmp2;
#line 96
  __cil_tmp4 = (int const   )__cil_tmp3;
#line 96
  __cil_tmp5 = addr + 4;
#line 96
  __cil_tmp6 = *__cil_tmp5;
#line 96
  __cil_tmp7 = (int const   )__cil_tmp6;
#line 96
  __cil_tmp8 = addr + 3;
#line 96
  __cil_tmp9 = *__cil_tmp8;
#line 96
  __cil_tmp10 = (int const   )__cil_tmp9;
#line 96
  __cil_tmp11 = addr + 2;
#line 96
  __cil_tmp12 = *__cil_tmp11;
#line 96
  __cil_tmp13 = (int const   )__cil_tmp12;
#line 96
  __cil_tmp14 = addr + 1;
#line 96
  __cil_tmp15 = *__cil_tmp14;
#line 96
  __cil_tmp16 = (int const   )__cil_tmp15;
#line 96
  __cil_tmp17 = addr + 0;
#line 96
  __cil_tmp18 = *__cil_tmp17;
#line 96
  __cil_tmp19 = (int const   )__cil_tmp18;
#line 96
  __cil_tmp20 = __cil_tmp19 & __cil_tmp16;
#line 96
  __cil_tmp21 = __cil_tmp20 & __cil_tmp13;
#line 96
  __cil_tmp22 = __cil_tmp21 & __cil_tmp10;
#line 96
  __cil_tmp23 = __cil_tmp22 & __cil_tmp7;
#line 96
  __cil_tmp24 = __cil_tmp23 & __cil_tmp4;
#line 96
  return (__cil_tmp24 == 255);
  }
}
}
#line 1226 "include/net/cfg80211.h"
__inline static void ( __attribute__((__always_inline__)) set_wiphy_dev)(struct wiphy *wiphy ,
                                                                         struct device *dev ) 
{ unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 1228
  __cil_tmp3 = (unsigned int )wiphy;
#line 1228
  __cil_tmp4 = __cil_tmp3 + 96;
#line 1228
  *((struct device **)__cil_tmp4) = dev;
#line 1229
  return;
}
}
#line 1388
extern int ieee80211_frequency_to_channel(int freq ) ;
#line 1011 "include/net/mac80211.h"
__inline static void ( __attribute__((__always_inline__)) SET_IEEE80211_DEV)(struct ieee80211_hw *hw ,
                                                                             struct device *dev ) 
{ unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  struct wiphy *__cil_tmp5 ;

  {
  {
#line 1013
  __cil_tmp3 = (unsigned int )hw;
#line 1013
  __cil_tmp4 = __cil_tmp3 + 56;
#line 1013
  __cil_tmp5 = *((struct wiphy **)__cil_tmp4);
#line 1013
  set_wiphy_dev(__cil_tmp5, dev);
  }
#line 1014
  return;
}
}
#line 1022 "include/net/mac80211.h"
__inline static void ( __attribute__((__always_inline__)) SET_IEEE80211_PERM_ADDR)(struct ieee80211_hw *hw ,
                                                                                   u8 *addr ) 
{ unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  struct wiphy *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  u8 *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void const   *__cil_tmp12 ;

  {
  {
#line 1024
  __cil_tmp3 = 0 * 1U;
#line 1024
  __cil_tmp4 = 0 + __cil_tmp3;
#line 1024
  __cil_tmp5 = (unsigned int )hw;
#line 1024
  __cil_tmp6 = __cil_tmp5 + 56;
#line 1024
  __cil_tmp7 = *((struct wiphy **)__cil_tmp6);
#line 1024
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 1024
  __cil_tmp9 = __cil_tmp8 + __cil_tmp4;
#line 1024
  __cil_tmp10 = (u8 *)__cil_tmp9;
#line 1024
  __cil_tmp11 = (void *)__cil_tmp10;
#line 1024
  __cil_tmp12 = (void const   *)addr;
#line 1024
  __constant_memcpy(__cil_tmp11, __cil_tmp12, 6U);
  }
#line 1025
  return;
}
}
#line 1535
extern struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len , struct ieee80211_ops  const  *ops ) ;
#line 1547
extern int ieee80211_register_hw(struct ieee80211_hw *hw ) ;
#line 1639
extern void ieee80211_unregister_hw(struct ieee80211_hw *hw ) ;
#line 1650
extern void ieee80211_free_hw(struct ieee80211_hw *hw ) ;
#line 1744
extern struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) ;
#line 1905
extern void ieee80211_stop_queues(struct ieee80211_hw *hw ) ;
#line 1925
extern void ieee80211_scan_completed(struct ieee80211_hw *hw , bool aborted ) ;
#line 387 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
int wl12xx_plt_start(struct wl12xx *wl ) ;
#line 388
int wl12xx_plt_stop(struct wl12xx *wl ) ;
#line 1215 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
extern int wl12xx_acx_station_id(struct wl12xx *wl ) ;
#line 1220
extern int wl12xx_acx_tx_power(struct wl12xx *wl , int power ) ;
#line 1228
extern int wl12xx_acx_slot(struct wl12xx *wl , enum acx_slot_type slot_time ) ;
#line 1231
extern int wl12xx_acx_rts_threshold(struct wl12xx *wl , u16 rts_threshold ) ;
#line 1238
extern int wl12xx_acx_aid(struct wl12xx *wl , u16 aid ) ;
#line 1240
extern int wl12xx_acx_set_preamble(struct wl12xx *wl , enum acx_preamble_type preamble ) ;
#line 1241
extern int wl12xx_acx_cts_protect(struct wl12xx *wl , enum acx_ctsprotect_type ctsprotect ) ;
#line 37 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl1251.h"
extern void wl1251_setup(struct wl12xx *wl ) ;
#line 30 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
extern int wl12xx_cmd_send(struct wl12xx *wl , u16 type , void *buf , size_t buf_len ) ;
#line 38
extern int wl12xx_cmd_join(struct wl12xx *wl , u8 bss_type , u8 dtim_interval , u16 beacon_interval ,
                           u8 wait ) ;
#line 42
extern int wl12xx_cmd_template_set(struct wl12xx *wl , u16 cmd_id , void *buf , size_t buf_len ) ;
#line 75 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/spi.h"
extern void wl12xx_spi_read(struct wl12xx *wl , int addr , void *buf , size_t len ) ;
#line 76
extern void wl12xx_spi_write(struct wl12xx *wl , int addr , void *buf , size_t len ) ;
#line 79
extern void wl12xx_spi_mem_read(struct wl12xx *wl , int addr , void *buf , size_t len ) ;
#line 85
extern u32 wl12xx_reg_read32(struct wl12xx *wl , int addr ) ;
#line 89
extern void wl12xx_spi_reset(struct wl12xx *wl ) ;
#line 90
extern void wl12xx_spi_init(struct wl12xx *wl ) ;
#line 91
extern void wl12xx_set_partition(struct wl12xx *wl , u32 part_start , u32 part_size ,
                                 u32 reg_start , u32 reg_size ) ;
#line 95 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/spi.h"
__inline static u32 ( __attribute__((__always_inline__)) wl12xx_read32)(struct wl12xx *wl ,
                                                                        int addr ) 
{ u32 response ;
  void *__cil_tmp4 ;
  u32 *__cil_tmp5 ;

  {
  {
#line 99
  __cil_tmp4 = (void *)(& response);
#line 99
  wl12xx_spi_read(wl, addr, __cil_tmp4, 4U);
  }
  {
#line 101
  __cil_tmp5 = & response;
#line 101
  return (*__cil_tmp5);
  }
}
}
#line 104 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/spi.h"
__inline static void ( __attribute__((__always_inline__)) wl12xx_write32)(struct wl12xx *wl ,
                                                                          int addr ,
                                                                          u32 val ) 
{ void *__cil_tmp4 ;

  {
  {
#line 106
  __cil_tmp4 = (void *)(& val);
#line 106
  wl12xx_spi_write(wl, addr, __cil_tmp4, 4U);
  }
#line 107
  return;
}
}
#line 211 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/tx.h"
extern void wl12xx_tx_work(struct work_struct *work ) ;
#line 213
extern void wl12xx_tx_flush(struct wl12xx *wl ) ;
#line 31 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/ps.h"
extern int wl12xx_ps_set_mode(struct wl12xx *wl , enum acx_ps_mode mode ) ;
#line 29 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/debugfs.h"
extern int wl12xx_debugfs_init(struct wl12xx *wl ) ;
#line 30
extern void wl12xx_debugfs_exit(struct wl12xx *wl ) ;
#line 31
extern void wl12xx_debugfs_reset(struct wl12xx *wl ) ;
#line 47 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_disable_interrupts(struct wl12xx *wl ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp2 = (unsigned int )wl;
#line 49
  __cil_tmp3 = __cil_tmp2 + 16;
#line 49
  __cil_tmp4 = *((int *)__cil_tmp3);
#line 49
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 49
  disable_irq(__cil_tmp5);
  }
#line 50
  return;
}
}
#line 52 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_power_off(struct wl12xx *wl ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  void (*__cil_tmp4)(bool enable ) ;

  {
  {
#line 54
  __cil_tmp2 = (unsigned int )wl;
#line 54
  __cil_tmp3 = __cil_tmp2 + 12;
#line 54
  __cil_tmp4 = *((void (**)(bool enable ))__cil_tmp3);
#line 54
  (*__cil_tmp4)((_Bool)0);
  }
#line 55
  return;
}
}
#line 57 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_power_on(struct wl12xx *wl ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  void (*__cil_tmp4)(bool enable ) ;

  {
  {
#line 59
  __cil_tmp2 = (unsigned int )wl;
#line 59
  __cil_tmp3 = __cil_tmp2 + 12;
#line 59
  __cil_tmp4 = *((void (**)(bool enable ))__cil_tmp3);
#line 59
  (*__cil_tmp4)((_Bool)1);
  }
#line 60
  return;
}
}
#line 62 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static irqreturn_t wl12xx_irq(int irq , void *cookie ) 
{ struct wl12xx *wl ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  struct work_struct *__cil_tmp6 ;

  {
  {
#line 66
  while (1) {
    while_1_continue: /* CIL Label */ ;

    goto while_11_break;
  }
  while_1_break: /* CIL Label */ ;
  }
  while_11_break: 
  {
#line 68
  wl = (struct wl12xx *)cookie;
#line 70
  __cil_tmp4 = (unsigned int )wl;
#line 70
  __cil_tmp5 = __cil_tmp4 + 416;
#line 70
  __cil_tmp6 = (struct work_struct *)__cil_tmp5;
#line 70
  schedule_work(__cil_tmp6);
  }
#line 72
  return ((enum irqreturn )1);
}
}
#line 75 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_fetch_firmware(struct wl12xx *wl ) 
{ struct firmware  const  *fw ;
  int ret ;
  void *tmp ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  char const   *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  struct spi_device *__cil_tmp11 ;
  struct device *__cil_tmp12 ;
  struct firmware  const  **__cil_tmp13 ;
  struct firmware  const  *__cil_tmp14 ;
  size_t __cil_tmp15 ;
  struct firmware  const  **__cil_tmp16 ;
  struct firmware  const  *__cil_tmp17 ;
  size_t __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  struct firmware  const  **__cil_tmp21 ;
  struct firmware  const  *__cil_tmp22 ;
  size_t __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  size_t __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  u8 *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  u8 *__cil_tmp34 ;
  void *__cil_tmp35 ;
  struct firmware  const  **__cil_tmp36 ;
  struct firmware  const  *__cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  u8 const   *__cil_tmp40 ;
  void const   *__cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  size_t __cil_tmp44 ;
  struct firmware  const  **__cil_tmp45 ;
  struct firmware  const  *__cil_tmp46 ;

  {
  {
#line 80
  __cil_tmp5 = 100 + 4;
#line 80
  __cil_tmp6 = (unsigned int )wl;
#line 80
  __cil_tmp7 = __cil_tmp6 + __cil_tmp5;
#line 80
  __cil_tmp8 = *((char const   **)__cil_tmp7);
#line 80
  __cil_tmp9 = (unsigned int )wl;
#line 80
  __cil_tmp10 = __cil_tmp9 + 8;
#line 80
  __cil_tmp11 = *((struct spi_device **)__cil_tmp10);
#line 80
  __cil_tmp12 = (struct device *)__cil_tmp11;
#line 80
  ret = request_firmware(& fw, __cil_tmp8, __cil_tmp12);
  }
#line 82
  if (ret < 0) {
    {
#line 83
    printk("<3>wl12xx: ERROR could not get firmware: %d\n", ret);
    }
#line 84
    return (ret);
  } else {

  }
  {
#line 87
  __cil_tmp13 = & fw;
#line 87
  __cil_tmp14 = *__cil_tmp13;
#line 87
  __cil_tmp15 = *((size_t const   *)__cil_tmp14);
#line 87
  if (__cil_tmp15 % 4U) {
    {
#line 88
    __cil_tmp16 = & fw;
#line 88
    __cil_tmp17 = *__cil_tmp16;
#line 88
    __cil_tmp18 = *((size_t const   *)__cil_tmp17);
#line 88
    printk("<3>wl12xx: ERROR firmware size is not multiple of 32 bits: %zu\n", __cil_tmp18);
#line 90
    ret = -84;
    }
    goto out;
  } else {

  }
  }
  {
#line 94
  __cil_tmp19 = (unsigned int )wl;
#line 94
  __cil_tmp20 = __cil_tmp19 + 220;
#line 94
  __cil_tmp21 = & fw;
#line 94
  __cil_tmp22 = *__cil_tmp21;
#line 94
  __cil_tmp23 = *((size_t const   *)__cil_tmp22);
#line 94
  *((size_t *)__cil_tmp20) = (unsigned int )__cil_tmp23;
#line 95
  __cil_tmp24 = (unsigned int )wl;
#line 95
  __cil_tmp25 = __cil_tmp24 + 220;
#line 95
  __cil_tmp26 = *((size_t *)__cil_tmp25);
#line 95
  tmp = kmalloc(__cil_tmp26, 208U);
#line 95
  __cil_tmp27 = (unsigned int )wl;
#line 95
  __cil_tmp28 = __cil_tmp27 + 216;
#line 95
  *((u8 **)__cil_tmp28) = (u8 *)tmp;
  }
  {
#line 97
  __cil_tmp29 = (unsigned int )wl;
#line 97
  __cil_tmp30 = __cil_tmp29 + 216;
#line 97
  __cil_tmp31 = *((u8 **)__cil_tmp30);
#line 97
  if (! __cil_tmp31) {
    {
#line 98
    printk("<3>wl12xx: ERROR could not allocate memory for the firmware\n");
#line 99
    ret = -12;
    }
    goto out;
  } else {

  }
  }
  {
#line 103
  __cil_tmp32 = (unsigned int )wl;
#line 103
  __cil_tmp33 = __cil_tmp32 + 216;
#line 103
  __cil_tmp34 = *((u8 **)__cil_tmp33);
#line 103
  __cil_tmp35 = (void *)__cil_tmp34;
#line 103
  __cil_tmp36 = & fw;
#line 103
  __cil_tmp37 = *__cil_tmp36;
#line 103
  __cil_tmp38 = (unsigned int )__cil_tmp37;
#line 103
  __cil_tmp39 = __cil_tmp38 + 4;
#line 103
  __cil_tmp40 = *((u8 const   * const  *)__cil_tmp39);
#line 103
  __cil_tmp41 = (void const   *)__cil_tmp40;
#line 103
  __cil_tmp42 = (unsigned int )wl;
#line 103
  __cil_tmp43 = __cil_tmp42 + 220;
#line 103
  __cil_tmp44 = *((size_t *)__cil_tmp43);
#line 103
  __memcpy(__cil_tmp35, __cil_tmp41, __cil_tmp44);
#line 105
  ret = 0;
  }
  out: 
  {
#line 108
  __cil_tmp45 = & fw;
#line 108
  __cil_tmp46 = *__cil_tmp45;
#line 108
  release_firmware(__cil_tmp46);
  }
#line 110
  return (ret);
}
}
#line 113 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_fetch_nvs(struct wl12xx *wl ) 
{ struct firmware  const  *fw ;
  int ret ;
  void *tmp ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  char const   *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  struct spi_device *__cil_tmp11 ;
  struct device *__cil_tmp12 ;
  struct firmware  const  **__cil_tmp13 ;
  struct firmware  const  *__cil_tmp14 ;
  size_t __cil_tmp15 ;
  struct firmware  const  **__cil_tmp16 ;
  struct firmware  const  *__cil_tmp17 ;
  size_t __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  struct firmware  const  **__cil_tmp21 ;
  struct firmware  const  *__cil_tmp22 ;
  size_t __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  size_t __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  u8 *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  u8 *__cil_tmp34 ;
  void *__cil_tmp35 ;
  struct firmware  const  **__cil_tmp36 ;
  struct firmware  const  *__cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  u8 const   *__cil_tmp40 ;
  void const   *__cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  size_t __cil_tmp44 ;
  struct firmware  const  **__cil_tmp45 ;
  struct firmware  const  *__cil_tmp46 ;

  {
  {
#line 118
  __cil_tmp5 = 100 + 8;
#line 118
  __cil_tmp6 = (unsigned int )wl;
#line 118
  __cil_tmp7 = __cil_tmp6 + __cil_tmp5;
#line 118
  __cil_tmp8 = *((char const   **)__cil_tmp7);
#line 118
  __cil_tmp9 = (unsigned int )wl;
#line 118
  __cil_tmp10 = __cil_tmp9 + 8;
#line 118
  __cil_tmp11 = *((struct spi_device **)__cil_tmp10);
#line 118
  __cil_tmp12 = (struct device *)__cil_tmp11;
#line 118
  ret = request_firmware(& fw, __cil_tmp8, __cil_tmp12);
  }
#line 120
  if (ret < 0) {
    {
#line 121
    printk("<3>wl12xx: ERROR could not get nvs file: %d\n", ret);
    }
#line 122
    return (ret);
  } else {

  }
  {
#line 125
  __cil_tmp13 = & fw;
#line 125
  __cil_tmp14 = *__cil_tmp13;
#line 125
  __cil_tmp15 = *((size_t const   *)__cil_tmp14);
#line 125
  if (__cil_tmp15 % 4U) {
    {
#line 126
    __cil_tmp16 = & fw;
#line 126
    __cil_tmp17 = *__cil_tmp16;
#line 126
    __cil_tmp18 = *((size_t const   *)__cil_tmp17);
#line 126
    printk("<3>wl12xx: ERROR nvs size is not multiple of 32 bits: %zu\n", __cil_tmp18);
#line 128
    ret = -84;
    }
    goto out;
  } else {

  }
  }
  {
#line 132
  __cil_tmp19 = (unsigned int )wl;
#line 132
  __cil_tmp20 = __cil_tmp19 + 228;
#line 132
  __cil_tmp21 = & fw;
#line 132
  __cil_tmp22 = *__cil_tmp21;
#line 132
  __cil_tmp23 = *((size_t const   *)__cil_tmp22);
#line 132
  *((size_t *)__cil_tmp20) = (unsigned int )__cil_tmp23;
#line 133
  __cil_tmp24 = (unsigned int )wl;
#line 133
  __cil_tmp25 = __cil_tmp24 + 228;
#line 133
  __cil_tmp26 = *((size_t *)__cil_tmp25);
#line 133
  tmp = kmalloc(__cil_tmp26, 208U);
#line 133
  __cil_tmp27 = (unsigned int )wl;
#line 133
  __cil_tmp28 = __cil_tmp27 + 224;
#line 133
  *((u8 **)__cil_tmp28) = (u8 *)tmp;
  }
  {
#line 135
  __cil_tmp29 = (unsigned int )wl;
#line 135
  __cil_tmp30 = __cil_tmp29 + 224;
#line 135
  __cil_tmp31 = *((u8 **)__cil_tmp30);
#line 135
  if (! __cil_tmp31) {
    {
#line 136
    printk("<3>wl12xx: ERROR could not allocate memory for the nvs file\n");
#line 137
    ret = -12;
    }
    goto out;
  } else {

  }
  }
  {
#line 141
  __cil_tmp32 = (unsigned int )wl;
#line 141
  __cil_tmp33 = __cil_tmp32 + 224;
#line 141
  __cil_tmp34 = *((u8 **)__cil_tmp33);
#line 141
  __cil_tmp35 = (void *)__cil_tmp34;
#line 141
  __cil_tmp36 = & fw;
#line 141
  __cil_tmp37 = *__cil_tmp36;
#line 141
  __cil_tmp38 = (unsigned int )__cil_tmp37;
#line 141
  __cil_tmp39 = __cil_tmp38 + 4;
#line 141
  __cil_tmp40 = *((u8 const   * const  *)__cil_tmp39);
#line 141
  __cil_tmp41 = (void const   *)__cil_tmp40;
#line 141
  __cil_tmp42 = (unsigned int )wl;
#line 141
  __cil_tmp43 = __cil_tmp42 + 228;
#line 141
  __cil_tmp44 = *((size_t *)__cil_tmp43);
#line 141
  __memcpy(__cil_tmp35, __cil_tmp41, __cil_tmp44);
#line 143
  ret = 0;
  }
  out: 
  {
#line 146
  __cil_tmp45 = & fw;
#line 146
  __cil_tmp46 = *__cil_tmp45;
#line 146
  release_firmware(__cil_tmp46);
  }
#line 148
  return (ret);
}
}
#line 151 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_fw_wakeup(struct wl12xx *wl ) 
{ u32 elp_reg ;
  unsigned int __cil_tmp3 ;

  {
  {
#line 155
  elp_reg = 1U;
#line 156
  wl12xx_write32(wl, 131068, elp_reg);
#line 157
  elp_reg = wl12xx_read32(wl, 131068);
  }
  {
#line 159
  __cil_tmp3 = elp_reg & 2U;
#line 159
  if (! __cil_tmp3) {
    {
#line 160
    printk("<4>wl12xx: WARNING WLAN not ready\n");
#line 161
    elp_reg = 5U;
#line 162
    wl12xx_write32(wl, 131068, elp_reg);
    }
  } else {

  }
  }
#line 164
  return;
}
}
#line 166 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_chip_wakeup(struct wl12xx *wl ) 
{ int ret ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  u32 __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  u32 __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  u32 __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  u32 __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  u32 __cil_tmp27 ;
  void *__cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  u8 *__cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  u8 *__cil_tmp38 ;
  unsigned int __cil_tmp39 ;

  {
  {
#line 168
  ret = 0;
#line 170
  wl12xx_power_on(wl);
#line 171
  __cil_tmp3 = 100 + 36;
#line 171
  __cil_tmp4 = (unsigned int )wl;
#line 171
  __cil_tmp5 = __cil_tmp4 + __cil_tmp3;
#line 171
  __cil_tmp6 = *((unsigned int *)__cil_tmp5);
#line 171
  msleep(__cil_tmp6);
#line 172
  wl12xx_spi_reset(wl);
#line 173
  wl12xx_spi_init(wl);
#line 177
  wl12xx_set_partition(wl, 0U, 0U, 3145728U, 34816U);
#line 184
  wl12xx_fw_wakeup(wl);
#line 189
  __cil_tmp7 = (unsigned int )wl;
#line 189
  __cil_tmp8 = __cil_tmp7 + 100;
#line 189
  *((u32 *)__cil_tmp8) = wl12xx_reg_read32(wl, 3167860);
  }
  {
#line 194
  __cil_tmp9 = (unsigned int )wl;
#line 194
  __cil_tmp10 = __cil_tmp9 + 100;
#line 194
  __cil_tmp11 = *((u32 *)__cil_tmp10);
#line 194
  __cil_tmp12 = (int )__cil_tmp11;
#line 194
  if (__cil_tmp12 == 117637377) {
    goto switch_12_117637377;
  } else {
    {
#line 201
    __cil_tmp13 = (unsigned int )wl;
#line 201
    __cil_tmp14 = __cil_tmp13 + 100;
#line 201
    __cil_tmp15 = *((u32 *)__cil_tmp14);
#line 201
    __cil_tmp16 = (int )__cil_tmp15;
#line 201
    if (__cil_tmp16 == 67305729) {
      goto switch_12_67305729;
    } else {
      {
#line 202
      __cil_tmp17 = (unsigned int )wl;
#line 202
      __cil_tmp18 = __cil_tmp17 + 100;
#line 202
      __cil_tmp19 = *((u32 *)__cil_tmp18);
#line 202
      __cil_tmp20 = (int )__cil_tmp19;
#line 202
      if (__cil_tmp20 == 117506305) {
        goto switch_12_67305729;
      } else {
        {
#line 203
        __cil_tmp21 = (unsigned int )wl;
#line 203
        __cil_tmp22 = __cil_tmp21 + 100;
#line 203
        __cil_tmp23 = *((u32 *)__cil_tmp22);
#line 203
        __cil_tmp24 = (int )__cil_tmp23;
#line 203
        if (__cil_tmp24 == 117571841) {
          goto switch_12_67305729;
        } else {
          goto switch_12_67305729;
#line 193
          if (0) {
            switch_12_117637377: 
            {
#line 195
            while (1) {
              while_2_continue: /* CIL Label */ ;

              goto while_13_break;
            }
            while_2_break: /* CIL Label */ ;
            }
            while_13_break: 
            {
#line 198
            wl1251_setup(wl);
            }
            goto switch_12_break;
            switch_12_67305729: 
            {
#line 205
            __cil_tmp25 = (unsigned int )wl;
#line 205
            __cil_tmp26 = __cil_tmp25 + 100;
#line 205
            __cil_tmp27 = *((u32 *)__cil_tmp26);
#line 205
            printk("<3>wl12xx: ERROR unsupported chip id: 0x%x\n", __cil_tmp27);
#line 206
            ret = -19;
            }
            goto out;
          } else {
            switch_12_break: ;
          }
        }
        }
      }
      }
    }
    }
  }
  }
  {
#line 210
  __cil_tmp28 = (void *)0;
#line 210
  __cil_tmp29 = (unsigned int )__cil_tmp28;
#line 210
  __cil_tmp30 = (unsigned int )wl;
#line 210
  __cil_tmp31 = __cil_tmp30 + 216;
#line 210
  __cil_tmp32 = *((u8 **)__cil_tmp31);
#line 210
  __cil_tmp33 = (unsigned int )__cil_tmp32;
#line 210
  if (__cil_tmp33 == __cil_tmp29) {
    {
#line 211
    ret = wl12xx_fetch_firmware(wl);
    }
#line 212
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
  }
  {
#line 217
  __cil_tmp34 = (void *)0;
#line 217
  __cil_tmp35 = (unsigned int )__cil_tmp34;
#line 217
  __cil_tmp36 = (unsigned int )wl;
#line 217
  __cil_tmp37 = __cil_tmp36 + 224;
#line 217
  __cil_tmp38 = *((u8 **)__cil_tmp37);
#line 217
  __cil_tmp39 = (unsigned int )__cil_tmp38;
#line 217
  if (__cil_tmp39 == __cil_tmp35) {
    {
#line 218
    ret = wl12xx_fetch_nvs(wl);
    }
#line 219
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
  }
  out: 
#line 224
  return (ret);
}
}
#line 227 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_filter_work(struct work_struct *work ) 
{ struct wl12xx *wl ;
  struct work_struct  const  *__mptr ;
  int ret ;
  struct wl12xx *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  struct work_struct *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  enum wl12xx_state __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  u8 __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  struct mutex *__cil_tmp24 ;

  {
  {
#line 230
  __mptr = (struct work_struct  const  *)work;
#line 230
  __cil_tmp5 = (struct wl12xx *)0;
#line 230
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 230
  __cil_tmp7 = __cil_tmp6 + 312;
#line 230
  __cil_tmp8 = (struct work_struct *)__cil_tmp7;
#line 230
  __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 230
  __cil_tmp10 = (char *)__mptr;
#line 230
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
#line 230
  wl = (struct wl12xx *)__cil_tmp11;
#line 233
  __cil_tmp12 = (unsigned int )wl;
#line 233
  __cil_tmp13 = __cil_tmp12 + 52;
#line 233
  __cil_tmp14 = (struct mutex *)__cil_tmp13;
#line 233
  mutex_lock(__cil_tmp14);
  }
  {
#line 235
  __cil_tmp15 = (unsigned int )wl;
#line 235
  __cil_tmp16 = __cil_tmp15 + 20;
#line 235
  __cil_tmp17 = *((enum wl12xx_state *)__cil_tmp16);
#line 235
  __cil_tmp18 = (unsigned int )__cil_tmp17;
#line 235
  if (__cil_tmp18 == 0U) {
    goto out;
  } else {

  }
  }
  {
#line 238
  __cil_tmp19 = (unsigned int )wl;
#line 238
  __cil_tmp20 = __cil_tmp19 + 244;
#line 238
  __cil_tmp21 = *((u8 *)__cil_tmp20);
#line 238
  ret = wl12xx_cmd_join(wl, __cil_tmp21, (unsigned char)1, (unsigned short)100, (unsigned char)0);
  }
#line 239
  if (ret < 0) {
    goto out;
  } else {

  }
  out: 
  {
#line 243
  __cil_tmp22 = (unsigned int )wl;
#line 243
  __cil_tmp23 = __cil_tmp22 + 52;
#line 243
  __cil_tmp24 = (struct mutex *)__cil_tmp23;
#line 243
  mutex_unlock(__cil_tmp24);
  }
#line 244
  return;
}
}
#line 246 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
int wl12xx_plt_start(struct wl12xx *wl ) 
{ int ret ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  enum wl12xx_state __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  enum wl12xx_state __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int (*__cil_tmp15)(struct wl12xx *wl ) ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int (*__cil_tmp25)(struct wl12xx *wl ) ;

  {
  {
#line 250
  printk("<6>wl12xx: power up\n");
  }
  {
#line 252
  __cil_tmp3 = (unsigned int )wl;
#line 252
  __cil_tmp4 = __cil_tmp3 + 20;
#line 252
  __cil_tmp5 = *((enum wl12xx_state *)__cil_tmp4);
#line 252
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 252
  if (__cil_tmp6 != 0U) {
    {
#line 253
    __cil_tmp7 = (unsigned int )wl;
#line 253
    __cil_tmp8 = __cil_tmp7 + 20;
#line 253
    __cil_tmp9 = *((enum wl12xx_state *)__cil_tmp8);
#line 253
    printk("<3>wl12xx: ERROR cannot go into PLT state because not in off state: %d\n",
           __cil_tmp9);
    }
#line 255
    return (-16);
  } else {

  }
  }
  {
#line 258
  __cil_tmp10 = (unsigned int )wl;
#line 258
  __cil_tmp11 = __cil_tmp10 + 20;
#line 258
  *((enum wl12xx_state *)__cil_tmp11) = (enum wl12xx_state )2;
#line 260
  ret = wl12xx_chip_wakeup(wl);
  }
#line 261
  if (ret < 0) {
#line 262
    return (ret);
  } else {

  }
  {
#line 264
  __cil_tmp12 = 100 + 56;
#line 264
  __cil_tmp13 = (unsigned int )wl;
#line 264
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 264
  __cil_tmp15 = *((int (**)(struct wl12xx *wl ))__cil_tmp14);
#line 264
  ret = (*__cil_tmp15)(wl);
  }
#line 265
  if (ret < 0) {
#line 266
    return (ret);
  } else {

  }
  {
#line 268
  __cil_tmp16 = 0 * 1U;
#line 268
  __cil_tmp17 = 12 + __cil_tmp16;
#line 268
  __cil_tmp18 = 100 + __cil_tmp17;
#line 268
  __cil_tmp19 = (unsigned int )wl;
#line 268
  __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
#line 268
  __cil_tmp21 = (char *)__cil_tmp20;
#line 268
  printk("<6>wl12xx: firmware booted in PLT mode (%s)\n", __cil_tmp21);
#line 270
  __cil_tmp22 = 100 + 72;
#line 270
  __cil_tmp23 = (unsigned int )wl;
#line 270
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 270
  __cil_tmp25 = *((int (**)(struct wl12xx *wl ))__cil_tmp24);
#line 270
  ret = (*__cil_tmp25)(wl);
  }
#line 271
  if (ret < 0) {
#line 272
    return (ret);
  } else {

  }
#line 274
  return (0);
}
}
#line 277 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
int wl12xx_plt_stop(struct wl12xx *wl ) 
{ unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  enum wl12xx_state __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  enum wl12xx_state __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;

  {
  {
#line 279
  printk("<6>wl12xx: power down\n");
  }
  {
#line 281
  __cil_tmp2 = (unsigned int )wl;
#line 281
  __cil_tmp3 = __cil_tmp2 + 20;
#line 281
  __cil_tmp4 = *((enum wl12xx_state *)__cil_tmp3);
#line 281
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 281
  if (__cil_tmp5 != 2U) {
    {
#line 282
    __cil_tmp6 = (unsigned int )wl;
#line 282
    __cil_tmp7 = __cil_tmp6 + 20;
#line 282
    __cil_tmp8 = *((enum wl12xx_state *)__cil_tmp7);
#line 282
    printk("<3>wl12xx: ERROR cannot power down because not in PLT state: %d\n", __cil_tmp8);
    }
#line 284
    return (-16);
  } else {

  }
  }
  {
#line 287
  wl12xx_disable_interrupts(wl);
#line 288
  wl12xx_power_off(wl);
#line 290
  __cil_tmp9 = (unsigned int )wl;
#line 290
  __cil_tmp10 = __cil_tmp9 + 20;
#line 290
  *((enum wl12xx_state *)__cil_tmp10) = (enum wl12xx_state )0;
  }
#line 292
  return (0);
}
}
#line 296 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_tx(struct ieee80211_hw *hw , struct sk_buff *skb ) 
{ struct wl12xx *wl ;
  __u32 tmp ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  void *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  struct sk_buff_head *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  struct work_struct *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  struct sk_buff_head *__cil_tmp16 ;
  struct sk_buff_head  const  *__cil_tmp17 ;
  struct ieee80211_hw *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  {
#line 298
  __cil_tmp5 = (unsigned int )hw;
#line 298
  __cil_tmp6 = __cil_tmp5 + 64;
#line 298
  __cil_tmp7 = *((void **)__cil_tmp6);
#line 298
  wl = (struct wl12xx *)__cil_tmp7;
#line 300
  __cil_tmp8 = (unsigned int )wl;
#line 300
  __cil_tmp9 = __cil_tmp8 + 264;
#line 300
  __cil_tmp10 = (struct sk_buff_head *)__cil_tmp9;
#line 300
  skb_queue_tail(__cil_tmp10, skb);
#line 302
  __cil_tmp11 = (unsigned int )wl;
#line 302
  __cil_tmp12 = __cil_tmp11 + 296;
#line 302
  __cil_tmp13 = (struct work_struct *)__cil_tmp12;
#line 302
  schedule_work(__cil_tmp13);
#line 308
  __cil_tmp14 = (unsigned int )wl;
#line 308
  __cil_tmp15 = __cil_tmp14 + 264;
#line 308
  __cil_tmp16 = (struct sk_buff_head *)__cil_tmp15;
#line 308
  __cil_tmp17 = (struct sk_buff_head  const  *)__cil_tmp16;
#line 308
  tmp = skb_queue_len(__cil_tmp17);
  }
#line 308
  if (tmp >= 20U) {
    {
#line 309
    __cil_tmp18 = *((struct ieee80211_hw **)wl);
#line 309
    ieee80211_stop_queues(__cil_tmp18);
#line 316
    __cil_tmp19 = (unsigned int )wl;
#line 316
    __cil_tmp20 = __cil_tmp19 + 292;
#line 316
    *((bool *)__cil_tmp20) = (_Bool)1;
    }
  } else {

  }
#line 319
  return (0);
}
}
#line 322 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_start(struct ieee80211_hw *hw ) 
{ struct wl12xx *wl ;
  int ret ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  void *__cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  enum wl12xx_state __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  enum wl12xx_state __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int (*__cil_tmp20)(struct wl12xx *wl ) ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int (*__cil_tmp24)(struct wl12xx *wl ) ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  struct mutex *__cil_tmp35 ;

  {
#line 324
  __cil_tmp4 = (unsigned int )hw;
#line 324
  __cil_tmp5 = __cil_tmp4 + 64;
#line 324
  __cil_tmp6 = *((void **)__cil_tmp5);
#line 324
  wl = (struct wl12xx *)__cil_tmp6;
#line 325
  ret = 0;
  {
#line 327
  while (1) {
    while_3_continue: /* CIL Label */ ;

    goto while_14_break;
  }
  while_3_break: /* CIL Label */ ;
  }
  while_14_break: 
  {
#line 329
  __cil_tmp7 = (unsigned int )wl;
#line 329
  __cil_tmp8 = __cil_tmp7 + 52;
#line 329
  __cil_tmp9 = (struct mutex *)__cil_tmp8;
#line 329
  mutex_lock(__cil_tmp9);
  }
  {
#line 331
  __cil_tmp10 = (unsigned int )wl;
#line 331
  __cil_tmp11 = __cil_tmp10 + 20;
#line 331
  __cil_tmp12 = *((enum wl12xx_state *)__cil_tmp11);
#line 331
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 331
  if (__cil_tmp13 != 0U) {
    {
#line 332
    __cil_tmp14 = (unsigned int )wl;
#line 332
    __cil_tmp15 = __cil_tmp14 + 20;
#line 332
    __cil_tmp16 = *((enum wl12xx_state *)__cil_tmp15);
#line 332
    printk("<3>wl12xx: ERROR cannot start because not in off state: %d\n", __cil_tmp16);
#line 334
    ret = -16;
    }
    goto out;
  } else {

  }
  }
  {
#line 338
  ret = wl12xx_chip_wakeup(wl);
  }
#line 339
  if (ret < 0) {
#line 340
    return (ret);
  } else {

  }
  {
#line 342
  __cil_tmp17 = 100 + 56;
#line 342
  __cil_tmp18 = (unsigned int )wl;
#line 342
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 342
  __cil_tmp20 = *((int (**)(struct wl12xx *wl ))__cil_tmp19);
#line 342
  ret = (*__cil_tmp20)(wl);
  }
#line 343
  if (ret < 0) {
    goto out;
  } else {

  }
  {
#line 346
  __cil_tmp21 = 100 + 68;
#line 346
  __cil_tmp22 = (unsigned int )wl;
#line 346
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 346
  __cil_tmp24 = *((int (**)(struct wl12xx *wl ))__cil_tmp23);
#line 346
  ret = (*__cil_tmp24)(wl);
  }
#line 347
  if (ret < 0) {
    goto out;
  } else {

  }
  {
#line 350
  ret = wl12xx_acx_station_id(wl);
  }
#line 351
  if (ret < 0) {
    goto out;
  } else {

  }
  {
#line 354
  __cil_tmp25 = (unsigned int )wl;
#line 354
  __cil_tmp26 = __cil_tmp25 + 20;
#line 354
  *((enum wl12xx_state *)__cil_tmp26) = (enum wl12xx_state )1;
#line 356
  __cil_tmp27 = 0 * 1U;
#line 356
  __cil_tmp28 = 12 + __cil_tmp27;
#line 356
  __cil_tmp29 = 100 + __cil_tmp28;
#line 356
  __cil_tmp30 = (unsigned int )wl;
#line 356
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 356
  __cil_tmp32 = (char *)__cil_tmp31;
#line 356
  printk("<7>wl12xx: firmware booted (%s)\n", __cil_tmp32);
  }
  out: 
#line 359
  if (ret < 0) {
    {
#line 360
    wl12xx_power_off(wl);
    }
  } else {

  }
  {
#line 362
  __cil_tmp33 = (unsigned int )wl;
#line 362
  __cil_tmp34 = __cil_tmp33 + 52;
#line 362
  __cil_tmp35 = (struct mutex *)__cil_tmp34;
#line 362
  mutex_unlock(__cil_tmp35);
  }
#line 364
  return (ret);
}
}
#line 367 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_stop(struct ieee80211_hw *hw ) 
{ struct wl12xx *wl ;
  int __ret_warn_on ;
  long tmp ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  void *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  struct mutex *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  enum wl12xx_state __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  struct mutex *__cil_tmp29 ;
  struct ieee80211_hw *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  struct mutex *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  struct mutex *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  struct work_struct *__cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  struct work_struct *__cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  struct work_struct *__cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  struct mutex *__cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  u8 *__cil_tmp57 ;
  void *__cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  unsigned int __cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  unsigned int __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  unsigned int __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned int __cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  unsigned int __cil_tmp77 ;
  unsigned int __cil_tmp78 ;
  unsigned int __cil_tmp79 ;
  unsigned int __cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned int __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  struct mutex *__cil_tmp85 ;

  {
  {
#line 369
  __cil_tmp5 = (unsigned int )hw;
#line 369
  __cil_tmp6 = __cil_tmp5 + 64;
#line 369
  __cil_tmp7 = *((void **)__cil_tmp6);
#line 369
  wl = (struct wl12xx *)__cil_tmp7;
#line 371
  printk("<7>wl12xx: down\n");
  }
  {
#line 373
  while (1) {
    while_4_continue: /* CIL Label */ ;

    goto while_15_break;
  }
  while_4_break: /* CIL Label */ ;
  }
  while_15_break: 
  {
#line 375
  __cil_tmp8 = (unsigned int )wl;
#line 375
  __cil_tmp9 = __cil_tmp8 + 52;
#line 375
  __cil_tmp10 = (struct mutex *)__cil_tmp9;
#line 375
  mutex_lock(__cil_tmp10);
#line 377
  __cil_tmp11 = (unsigned int )wl;
#line 377
  __cil_tmp12 = __cil_tmp11 + 20;
#line 377
  __cil_tmp13 = *((enum wl12xx_state *)__cil_tmp12);
#line 377
  __cil_tmp14 = (unsigned int )__cil_tmp13;
#line 377
  __cil_tmp15 = __cil_tmp14 != 1U;
#line 377
  __cil_tmp16 = ! __cil_tmp15;
#line 377
  __ret_warn_on = ! __cil_tmp16;
#line 377
  __cil_tmp17 = ! __ret_warn_on;
#line 377
  __cil_tmp18 = ! __cil_tmp17;
#line 377
  __cil_tmp19 = (long )__cil_tmp18;
#line 377
  tmp = __builtin_expect(__cil_tmp19, 0L);
  }
#line 377
  if (tmp) {
    {
#line 377
    __cil_tmp20 = (int const   )377;
#line 377
    __cil_tmp21 = (int )__cil_tmp20;
#line 377
    warn_slowpath_null("/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c",
                       __cil_tmp21);
    }
  } else {

  }
  {
#line 377
  __cil_tmp22 = ! __ret_warn_on;
#line 377
  __cil_tmp23 = ! __cil_tmp22;
#line 377
  __cil_tmp24 = (long )__cil_tmp23;
#line 377
  __builtin_expect(__cil_tmp24, 0L);
  }
  {
#line 379
  __cil_tmp25 = (unsigned int )wl;
#line 379
  __cil_tmp26 = __cil_tmp25 + 444;
#line 379
  if (*((bool *)__cil_tmp26)) {
    {
#line 380
    __cil_tmp27 = (unsigned int )wl;
#line 380
    __cil_tmp28 = __cil_tmp27 + 52;
#line 380
    __cil_tmp29 = (struct mutex *)__cil_tmp28;
#line 380
    mutex_unlock(__cil_tmp29);
#line 381
    __cil_tmp30 = *((struct ieee80211_hw **)wl);
#line 381
    ieee80211_scan_completed(__cil_tmp30, (_Bool)1);
#line 382
    __cil_tmp31 = (unsigned int )wl;
#line 382
    __cil_tmp32 = __cil_tmp31 + 52;
#line 382
    __cil_tmp33 = (struct mutex *)__cil_tmp32;
#line 382
    mutex_lock(__cil_tmp33);
#line 383
    __cil_tmp34 = (unsigned int )wl;
#line 383
    __cil_tmp35 = __cil_tmp34 + 444;
#line 383
    *((bool *)__cil_tmp35) = (_Bool)0;
    }
  } else {

  }
  }
  {
#line 386
  __cil_tmp36 = (unsigned int )wl;
#line 386
  __cil_tmp37 = __cil_tmp36 + 20;
#line 386
  *((enum wl12xx_state *)__cil_tmp37) = (enum wl12xx_state )0;
#line 388
  wl12xx_disable_interrupts(wl);
#line 390
  __cil_tmp38 = (unsigned int )wl;
#line 390
  __cil_tmp39 = __cil_tmp38 + 52;
#line 390
  __cil_tmp40 = (struct mutex *)__cil_tmp39;
#line 390
  mutex_unlock(__cil_tmp40);
#line 392
  __cil_tmp41 = (unsigned int )wl;
#line 392
  __cil_tmp42 = __cil_tmp41 + 416;
#line 392
  __cil_tmp43 = (struct work_struct *)__cil_tmp42;
#line 392
  cancel_work_sync(__cil_tmp43);
#line 393
  __cil_tmp44 = (unsigned int )wl;
#line 393
  __cil_tmp45 = __cil_tmp44 + 296;
#line 393
  __cil_tmp46 = (struct work_struct *)__cil_tmp45;
#line 393
  cancel_work_sync(__cil_tmp46);
#line 394
  __cil_tmp47 = (unsigned int )wl;
#line 394
  __cil_tmp48 = __cil_tmp47 + 312;
#line 394
  __cil_tmp49 = (struct work_struct *)__cil_tmp48;
#line 394
  cancel_work_sync(__cil_tmp49);
#line 396
  __cil_tmp50 = (unsigned int )wl;
#line 396
  __cil_tmp51 = __cil_tmp50 + 52;
#line 396
  __cil_tmp52 = (struct mutex *)__cil_tmp51;
#line 396
  mutex_lock(__cil_tmp52);
#line 399
  wl12xx_tx_flush(wl);
#line 401
  wl12xx_power_off(wl);
#line 403
  __cil_tmp53 = 0 * 1U;
#line 403
  __cil_tmp54 = 232 + __cil_tmp53;
#line 403
  __cil_tmp55 = (unsigned int )wl;
#line 403
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
#line 403
  __cil_tmp57 = (u8 *)__cil_tmp56;
#line 403
  __cil_tmp58 = (void *)__cil_tmp57;
#line 403
  __constant_c_and_count_memset(__cil_tmp58, 0UL, 6U);
#line 404
  __cil_tmp59 = (unsigned int )wl;
#line 404
  __cil_tmp60 = __cil_tmp59 + 245;
#line 404
  *((u8 *)__cil_tmp60) = (unsigned char)1;
#line 405
  __cil_tmp61 = (unsigned int )wl;
#line 405
  __cil_tmp62 = __cil_tmp61 + 244;
#line 405
  *((u8 *)__cil_tmp62) = (unsigned char)255;
#line 407
  __cil_tmp63 = (unsigned int )wl;
#line 407
  __cil_tmp64 = __cil_tmp63 + 260;
#line 407
  *((u32 *)__cil_tmp64) = 0U;
#line 408
  __cil_tmp65 = (unsigned int )wl;
#line 408
  __cil_tmp66 = __cil_tmp65 + 396;
#line 408
  *((u32 *)__cil_tmp66) = 0U;
#line 409
  __cil_tmp67 = (unsigned int )wl;
#line 409
  __cil_tmp68 = __cil_tmp67 + 400;
#line 409
  *((u32 *)__cil_tmp68) = 0U;
#line 410
  __cil_tmp69 = (unsigned int )wl;
#line 410
  __cil_tmp70 = __cil_tmp69 + 404;
#line 410
  *((u32 *)__cil_tmp70) = 0U;
#line 411
  __cil_tmp71 = (unsigned int )wl;
#line 411
  __cil_tmp72 = __cil_tmp71 + 408;
#line 411
  *((u32 *)__cil_tmp72) = 0U;
#line 412
  __cil_tmp73 = (unsigned int )wl;
#line 412
  __cil_tmp74 = __cil_tmp73 + 392;
#line 412
  *((u32 *)__cil_tmp74) = 0U;
#line 413
  __cil_tmp75 = (unsigned int )wl;
#line 413
  __cil_tmp76 = __cil_tmp75 + 468;
#line 413
  *((bool *)__cil_tmp76) = (_Bool)0;
#line 414
  __cil_tmp77 = (unsigned int )wl;
#line 414
  __cil_tmp78 = __cil_tmp77 + 469;
#line 414
  *((bool *)__cil_tmp78) = (_Bool)0;
#line 415
  __cil_tmp79 = (unsigned int )wl;
#line 415
  __cil_tmp80 = __cil_tmp79 + 292;
#line 415
  *((bool *)__cil_tmp80) = (_Bool)0;
#line 416
  __cil_tmp81 = (unsigned int )wl;
#line 416
  __cil_tmp82 = __cil_tmp81 + 472;
#line 416
  *((int *)__cil_tmp82) = 20;
#line 418
  wl12xx_debugfs_reset(wl);
#line 420
  __cil_tmp83 = (unsigned int )wl;
#line 420
  __cil_tmp84 = __cil_tmp83 + 52;
#line 420
  __cil_tmp85 = (struct mutex *)__cil_tmp84;
#line 420
  mutex_unlock(__cil_tmp85);
  }
#line 421
  return;
}
}
#line 423 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_add_interface(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) 
{ struct wl12xx *wl ;
  int ret ;
  int tmp___0 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  enum nl80211_iftype __cil_tmp12 ;
  int __cil_tmp13 ;
  enum nl80211_iftype __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  u8 *__cil_tmp24 ;
  void const   *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  void *__cil_tmp28 ;
  void const   *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  u8 *__cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  void *__cil_tmp38 ;
  void const   *__cil_tmp39 ;
  struct ieee80211_hw *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  u8 *__cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  struct mutex *__cil_tmp48 ;

  {
#line 426
  __cil_tmp6 = (unsigned int )hw;
#line 426
  __cil_tmp7 = __cil_tmp6 + 64;
#line 426
  __cil_tmp8 = *((void **)__cil_tmp7);
#line 426
  wl = (struct wl12xx *)__cil_tmp8;
#line 428
  ret = 0;
  {
#line 430
  while (1) {
    while_5_continue: /* CIL Label */ ;

    goto while_16_break;
  }
  while_5_break: /* CIL Label */ ;
  }
  while_16_break: 
  {
#line 433
  __cil_tmp9 = (unsigned int )wl;
#line 433
  __cil_tmp10 = __cil_tmp9 + 52;
#line 433
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
#line 433
  mutex_lock(__cil_tmp11);
  }
  {
#line 436
  __cil_tmp12 = *((enum nl80211_iftype *)conf);
#line 436
  __cil_tmp13 = (int )__cil_tmp12;
#line 436
  if (__cil_tmp13 == 2) {
    goto switch_17_2;
  } else {
    {
#line 439
    __cil_tmp14 = *((enum nl80211_iftype *)conf);
#line 439
    __cil_tmp15 = (int )__cil_tmp14;
#line 439
    if (__cil_tmp15 == 1) {
      goto switch_17_1;
    } else {
      goto switch_17_default;
#line 435
      if (0) {
        switch_17_2: 
#line 437
        __cil_tmp16 = (unsigned int )wl;
#line 437
        __cil_tmp17 = __cil_tmp16 + 244;
#line 437
        *((u8 *)__cil_tmp17) = (unsigned char)2;
        goto switch_17_break;
        switch_17_1: 
#line 440
        __cil_tmp18 = (unsigned int )wl;
#line 440
        __cil_tmp19 = __cil_tmp18 + 244;
#line 440
        *((u8 *)__cil_tmp19) = (unsigned char)0;
        goto switch_17_break;
        switch_17_default: 
#line 443
        ret = -95;
        goto out;
      } else {
        switch_17_break: ;
      }
    }
    }
  }
  }
  {
#line 447
  __cil_tmp20 = 0 * 1U;
#line 447
  __cil_tmp21 = 238 + __cil_tmp20;
#line 447
  __cil_tmp22 = (unsigned int )wl;
#line 447
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 447
  __cil_tmp24 = (u8 *)__cil_tmp23;
#line 447
  __cil_tmp25 = (void const   *)__cil_tmp24;
#line 447
  __cil_tmp26 = (unsigned int )conf;
#line 447
  __cil_tmp27 = __cil_tmp26 + 36;
#line 447
  __cil_tmp28 = *((void **)__cil_tmp27);
#line 447
  __cil_tmp29 = (void const   *)__cil_tmp28;
#line 447
  tmp___0 = __builtin_memcmp(__cil_tmp25, __cil_tmp29, 6U);
  }
#line 447
  if (tmp___0) {
    {
#line 448
    __cil_tmp30 = 0 * 1U;
#line 448
    __cil_tmp31 = 238 + __cil_tmp30;
#line 448
    __cil_tmp32 = (unsigned int )wl;
#line 448
    __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
#line 448
    __cil_tmp34 = (u8 *)__cil_tmp33;
#line 448
    __cil_tmp35 = (void *)__cil_tmp34;
#line 448
    __cil_tmp36 = (unsigned int )conf;
#line 448
    __cil_tmp37 = __cil_tmp36 + 36;
#line 448
    __cil_tmp38 = *((void **)__cil_tmp37);
#line 448
    __cil_tmp39 = (void const   *)__cil_tmp38;
#line 448
    __constant_memcpy(__cil_tmp35, __cil_tmp39, 6U);
#line 449
    __cil_tmp40 = *((struct ieee80211_hw **)wl);
#line 449
    __cil_tmp41 = 0 * 1U;
#line 449
    __cil_tmp42 = 238 + __cil_tmp41;
#line 449
    __cil_tmp43 = (unsigned int )wl;
#line 449
    __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
#line 449
    __cil_tmp45 = (u8 *)__cil_tmp44;
#line 449
    SET_IEEE80211_PERM_ADDR(__cil_tmp40, __cil_tmp45);
#line 450
    ret = wl12xx_acx_station_id(wl);
    }
#line 451
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
  out: 
  {
#line 456
  __cil_tmp46 = (unsigned int )wl;
#line 456
  __cil_tmp47 = __cil_tmp46 + 52;
#line 456
  __cil_tmp48 = (struct mutex *)__cil_tmp47;
#line 456
  mutex_unlock(__cil_tmp48);
  }
#line 457
  return (ret);
}
}
#line 460 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_remove_interface(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) 
{ 

  {
  {
#line 463
  while (1) {
    while_6_continue: /* CIL Label */ ;

    goto while_18_break;
  }
  while_6_break: /* CIL Label */ ;
  }
  while_18_break: ;
#line 464
  return;
}
}
#line 466 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_null_data(struct wl12xx *wl ) 
{ struct wl12xx_null_data_template template ;
  int tmp ;
  int tmp___0 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  u8 *__cil_tmp9 ;
  u8 const   *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  u8 *__cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  u8 *__cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  u8 *__cil_tmp27 ;
  void *__cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  u8 *__cil_tmp33 ;
  void const   *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  u8 *__cil_tmp39 ;
  void *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  u8 *__cil_tmp45 ;
  void const   *__cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  u8 *__cil_tmp51 ;
  void *__cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  u8 *__cil_tmp57 ;
  void const   *__cil_tmp58 ;
  struct wl12xx_null_data_template *__cil_tmp59 ;
  void *__cil_tmp60 ;

  {
  {
#line 470
  __cil_tmp5 = 0 * 1U;
#line 470
  __cil_tmp6 = 232 + __cil_tmp5;
#line 470
  __cil_tmp7 = (unsigned int )wl;
#line 470
  __cil_tmp8 = __cil_tmp7 + __cil_tmp6;
#line 470
  __cil_tmp9 = (u8 *)__cil_tmp8;
#line 470
  __cil_tmp10 = (u8 const   *)__cil_tmp9;
#line 470
  tmp = is_zero_ether_addr(__cil_tmp10);
  }
#line 470
  if (tmp) {
    {
#line 474
    __cil_tmp11 = 0 * 1U;
#line 474
    __cil_tmp12 = 4 + __cil_tmp11;
#line 474
    __cil_tmp13 = 0 + __cil_tmp12;
#line 474
    __cil_tmp14 = (unsigned int )(& template) + __cil_tmp13;
#line 474
    __cil_tmp15 = (u8 *)__cil_tmp14;
#line 474
    __cil_tmp16 = (void *)__cil_tmp15;
#line 474
    __constant_c_and_count_memset(__cil_tmp16, 4294967295UL, 6U);
#line 475
    __cil_tmp17 = 0 * 1U;
#line 475
    __cil_tmp18 = 16 + __cil_tmp17;
#line 475
    __cil_tmp19 = 0 + __cil_tmp18;
#line 475
    __cil_tmp20 = (unsigned int )(& template) + __cil_tmp19;
#line 475
    __cil_tmp21 = (u8 *)__cil_tmp20;
#line 475
    __cil_tmp22 = (void *)__cil_tmp21;
#line 475
    __constant_c_and_count_memset(__cil_tmp22, 4294967295UL, 6U);
    }
  } else {
    {
#line 471
    __cil_tmp23 = 0 * 1U;
#line 471
    __cil_tmp24 = 4 + __cil_tmp23;
#line 471
    __cil_tmp25 = 0 + __cil_tmp24;
#line 471
    __cil_tmp26 = (unsigned int )(& template) + __cil_tmp25;
#line 471
    __cil_tmp27 = (u8 *)__cil_tmp26;
#line 471
    __cil_tmp28 = (void *)__cil_tmp27;
#line 471
    __cil_tmp29 = 0 * 1U;
#line 471
    __cil_tmp30 = 232 + __cil_tmp29;
#line 471
    __cil_tmp31 = (unsigned int )wl;
#line 471
    __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
#line 471
    __cil_tmp33 = (u8 *)__cil_tmp32;
#line 471
    __cil_tmp34 = (void const   *)__cil_tmp33;
#line 471
    __constant_memcpy(__cil_tmp28, __cil_tmp34, 6U);
#line 472
    __cil_tmp35 = 0 * 1U;
#line 472
    __cil_tmp36 = 16 + __cil_tmp35;
#line 472
    __cil_tmp37 = 0 + __cil_tmp36;
#line 472
    __cil_tmp38 = (unsigned int )(& template) + __cil_tmp37;
#line 472
    __cil_tmp39 = (u8 *)__cil_tmp38;
#line 472
    __cil_tmp40 = (void *)__cil_tmp39;
#line 472
    __cil_tmp41 = 0 * 1U;
#line 472
    __cil_tmp42 = 232 + __cil_tmp41;
#line 472
    __cil_tmp43 = (unsigned int )wl;
#line 472
    __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
#line 472
    __cil_tmp45 = (u8 *)__cil_tmp44;
#line 472
    __cil_tmp46 = (void const   *)__cil_tmp45;
#line 472
    __constant_memcpy(__cil_tmp40, __cil_tmp46, 6U);
    }
  }
  {
#line 478
  __cil_tmp47 = 0 * 1U;
#line 478
  __cil_tmp48 = 10 + __cil_tmp47;
#line 478
  __cil_tmp49 = 0 + __cil_tmp48;
#line 478
  __cil_tmp50 = (unsigned int )(& template) + __cil_tmp49;
#line 478
  __cil_tmp51 = (u8 *)__cil_tmp50;
#line 478
  __cil_tmp52 = (void *)__cil_tmp51;
#line 478
  __cil_tmp53 = 0 * 1U;
#line 478
  __cil_tmp54 = 238 + __cil_tmp53;
#line 478
  __cil_tmp55 = (unsigned int )wl;
#line 478
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
#line 478
  __cil_tmp57 = (u8 *)__cil_tmp56;
#line 478
  __cil_tmp58 = (void const   *)__cil_tmp57;
#line 478
  __constant_memcpy(__cil_tmp52, __cil_tmp58, 6U);
#line 479
  __cil_tmp59 = & template;
#line 479
  *((__le16 *)__cil_tmp59) = (unsigned short)72;
#line 482
  __cil_tmp60 = (void *)(& template);
#line 482
  tmp___0 = wl12xx_cmd_template_set(wl, (unsigned short)21, __cil_tmp60, 24U);
  }
#line 482
  return (tmp___0);
}
}
#line 487 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_ps_poll(struct wl12xx *wl , u16 aid ) 
{ struct wl12xx_ps_poll_template template ;
  int tmp ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  u8 *__cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  u8 *__cil_tmp14 ;
  void const   *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  u8 *__cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  u8 *__cil_tmp25 ;
  void const   *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  struct wl12xx_ps_poll_template *__cil_tmp28 ;
  void *__cil_tmp29 ;

  {
  {
#line 491
  __cil_tmp5 = 0 * 1U;
#line 491
  __cil_tmp6 = 4 + __cil_tmp5;
#line 491
  __cil_tmp7 = (unsigned int )(& template) + __cil_tmp6;
#line 491
  __cil_tmp8 = (u8 *)__cil_tmp7;
#line 491
  __cil_tmp9 = (void *)__cil_tmp8;
#line 491
  __cil_tmp10 = 0 * 1U;
#line 491
  __cil_tmp11 = 232 + __cil_tmp10;
#line 491
  __cil_tmp12 = (unsigned int )wl;
#line 491
  __cil_tmp13 = __cil_tmp12 + __cil_tmp11;
#line 491
  __cil_tmp14 = (u8 *)__cil_tmp13;
#line 491
  __cil_tmp15 = (void const   *)__cil_tmp14;
#line 491
  __constant_memcpy(__cil_tmp9, __cil_tmp15, 6U);
#line 492
  __cil_tmp16 = 0 * 1U;
#line 492
  __cil_tmp17 = 10 + __cil_tmp16;
#line 492
  __cil_tmp18 = (unsigned int )(& template) + __cil_tmp17;
#line 492
  __cil_tmp19 = (u8 *)__cil_tmp18;
#line 492
  __cil_tmp20 = (void *)__cil_tmp19;
#line 492
  __cil_tmp21 = 0 * 1U;
#line 492
  __cil_tmp22 = 238 + __cil_tmp21;
#line 492
  __cil_tmp23 = (unsigned int )wl;
#line 492
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 492
  __cil_tmp25 = (u8 *)__cil_tmp24;
#line 492
  __cil_tmp26 = (void const   *)__cil_tmp25;
#line 492
  __constant_memcpy(__cil_tmp20, __cil_tmp26, 6U);
#line 493
  __cil_tmp27 = (unsigned int )(& template) + 2;
#line 493
  *((u16 *)__cil_tmp27) = aid;
#line 494
  __cil_tmp28 = & template;
#line 494
  *((u16 *)__cil_tmp28) = (unsigned short)164;
#line 496
  __cil_tmp29 = (void *)(& template);
#line 496
  tmp = wl12xx_cmd_template_set(wl, (unsigned short)30, __cil_tmp29, 16U);
  }
#line 496
  return (tmp);
}
}
#line 501 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_config(struct ieee80211_hw *hw , u32 changed ) 
{ struct wl12xx *wl ;
  struct ieee80211_conf *conf ;
  int channel ;
  int ret ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  struct ieee80211_channel *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  u16 __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  struct mutex *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  u8 __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  u32 __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  bool __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  enum acx_ps_mode __cil_tmp34 ;
  u32 __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  enum acx_ps_mode __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  struct mutex *__cil_tmp59 ;

  {
  {
#line 503
  __cil_tmp7 = (unsigned int )hw;
#line 503
  __cil_tmp8 = __cil_tmp7 + 64;
#line 503
  __cil_tmp9 = *((void **)__cil_tmp8);
#line 503
  wl = (struct wl12xx *)__cil_tmp9;
#line 504
  conf = (struct ieee80211_conf *)hw;
#line 505
  ret = 0;
#line 507
  __cil_tmp10 = (unsigned int )conf;
#line 507
  __cil_tmp11 = __cil_tmp10 + 20;
#line 507
  __cil_tmp12 = *((struct ieee80211_channel **)__cil_tmp11);
#line 507
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 507
  __cil_tmp14 = __cil_tmp13 + 32;
#line 507
  __cil_tmp15 = *((u16 *)__cil_tmp14);
#line 507
  __cil_tmp16 = (int )__cil_tmp15;
#line 507
  channel = ieee80211_frequency_to_channel(__cil_tmp16);
  }
  {
#line 509
  while (1) {
    while_7_continue: /* CIL Label */ ;

    goto while_19_break;
  }
  while_7_break: /* CIL Label */ ;
  }
  while_19_break: 
  {
#line 514
  __cil_tmp17 = (unsigned int )wl;
#line 514
  __cil_tmp18 = __cil_tmp17 + 52;
#line 514
  __cil_tmp19 = (struct mutex *)__cil_tmp18;
#line 514
  mutex_lock(__cil_tmp19);
  }
  {
#line 516
  __cil_tmp20 = (unsigned int )wl;
#line 516
  __cil_tmp21 = __cil_tmp20 + 248;
#line 516
  __cil_tmp22 = *((int *)__cil_tmp21);
#line 516
  if (channel != __cil_tmp22) {
    {
#line 518
    __cil_tmp23 = (unsigned int )wl;
#line 518
    __cil_tmp24 = __cil_tmp23 + 244;
#line 518
    __cil_tmp25 = *((u8 *)__cil_tmp24);
#line 518
    ret = wl12xx_cmd_join(wl, __cil_tmp25, (unsigned char)1, (unsigned short)100,
                          (unsigned char)0);
    }
#line 519
    if (ret < 0) {
      goto out;
    } else {

    }
#line 522
    __cil_tmp26 = (unsigned int )wl;
#line 522
    __cil_tmp27 = __cil_tmp26 + 248;
#line 522
    *((int *)__cil_tmp27) = channel;
  } else {

  }
  }
  {
#line 525
  ret = wl12xx_build_null_data(wl);
  }
#line 526
  if (ret < 0) {
    goto out;
  } else {

  }
  {
#line 529
  __cil_tmp28 = *((u32 *)conf);
#line 529
  if (__cil_tmp28 & 2U) {
    {
#line 529
    __cil_tmp29 = (unsigned int )wl;
#line 529
    __cil_tmp30 = __cil_tmp29 + 470;
#line 529
    __cil_tmp31 = *((bool *)__cil_tmp30);
#line 529
    if (! __cil_tmp31) {
      {
#line 530
      printk("<7>wl12xx: psm enabled\n");
#line 532
      __cil_tmp32 = (unsigned int )wl;
#line 532
      __cil_tmp33 = __cil_tmp32 + 470;
#line 532
      *((bool *)__cil_tmp33) = (_Bool)1;
#line 539
      __cil_tmp34 = (enum acx_ps_mode )1;
#line 539
      ret = wl12xx_ps_set_mode(wl, __cil_tmp34);
      }
    } else {
      goto _L;
    }
    }
  } else {
    _L: 
    {
#line 540
    __cil_tmp35 = *((u32 *)conf);
#line 540
    __cil_tmp36 = __cil_tmp35 & 2U;
#line 540
    if (! __cil_tmp36) {
      {
#line 540
      __cil_tmp37 = (unsigned int )wl;
#line 540
      __cil_tmp38 = __cil_tmp37 + 470;
#line 540
      if (*((bool *)__cil_tmp38)) {
        {
#line 542
        printk("<7>wl12xx: psm disabled\n");
#line 544
        __cil_tmp39 = (unsigned int )wl;
#line 544
        __cil_tmp40 = __cil_tmp39 + 470;
#line 544
        *((bool *)__cil_tmp40) = (_Bool)0;
        }
        {
#line 546
        __cil_tmp41 = (unsigned int )wl;
#line 546
        __cil_tmp42 = __cil_tmp41 + 469;
#line 546
        if (*((bool *)__cil_tmp42)) {
          {
#line 547
          __cil_tmp43 = (enum acx_ps_mode )0;
#line 547
          ret = wl12xx_ps_set_mode(wl, __cil_tmp43);
          }
        } else {

        }
        }
      } else {

      }
      }
    } else {

    }
    }
  }
  }
  {
#line 550
  __cil_tmp44 = (unsigned int )wl;
#line 550
  __cil_tmp45 = __cil_tmp44 + 472;
#line 550
  __cil_tmp46 = *((int *)__cil_tmp45);
#line 550
  __cil_tmp47 = (unsigned int )conf;
#line 550
  __cil_tmp48 = __cil_tmp47 + 4;
#line 550
  __cil_tmp49 = *((int *)__cil_tmp48);
#line 550
  if (__cil_tmp49 != __cil_tmp46) {
    {
#line 551
    __cil_tmp50 = (unsigned int )conf;
#line 551
    __cil_tmp51 = __cil_tmp50 + 4;
#line 551
    __cil_tmp52 = *((int *)__cil_tmp51);
#line 551
    ret = wl12xx_acx_tx_power(wl, __cil_tmp52);
    }
#line 552
    if (ret < 0) {
      goto out;
    } else {

    }
#line 555
    __cil_tmp53 = (unsigned int )wl;
#line 555
    __cil_tmp54 = __cil_tmp53 + 472;
#line 555
    __cil_tmp55 = (unsigned int )conf;
#line 555
    __cil_tmp56 = __cil_tmp55 + 4;
#line 555
    *((int *)__cil_tmp54) = *((int *)__cil_tmp56);
  } else {

  }
  }
  out: 
  {
#line 559
  __cil_tmp57 = (unsigned int )wl;
#line 559
  __cil_tmp58 = __cil_tmp57 + 52;
#line 559
  __cil_tmp59 = (struct mutex *)__cil_tmp58;
#line 559
  mutex_unlock(__cil_tmp59);
  }
#line 560
  return (ret);
}
}
#line 570 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_configure_filter(struct ieee80211_hw *hw , unsigned int changed ,
                                       unsigned int *total , int mc_count , struct dev_addr_list *mc_list ) 
{ struct wl12xx *wl ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  unsigned int __cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  unsigned int __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned int __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned int __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned int __cil_tmp77 ;
  unsigned int __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned int __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned int __cil_tmp90 ;
  unsigned int __cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned int __cil_tmp95 ;
  unsigned int __cil_tmp96 ;
  unsigned int __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned int __cil_tmp100 ;
  unsigned int __cil_tmp101 ;
  unsigned int __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;

  {
#line 576
  __cil_tmp7 = (unsigned int )hw;
#line 576
  __cil_tmp8 = __cil_tmp7 + 64;
#line 576
  __cil_tmp9 = *((void **)__cil_tmp8);
#line 576
  wl = (struct wl12xx *)__cil_tmp9;
  {
#line 578
  while (1) {
    while_8_continue: /* CIL Label */ ;

    goto while_20_break;
  }
  while_8_break: /* CIL Label */ ;
  }
  while_20_break: 
#line 580
  __cil_tmp10 = *total;
#line 580
  *total = __cil_tmp10 & 119U;
#line 581
  changed = changed & 119U;
#line 583
  if (changed == 0U) {
#line 585
    return;
  } else {

  }
#line 589
  __cil_tmp11 = (unsigned int )wl;
#line 589
  __cil_tmp12 = __cil_tmp11 + 460;
#line 589
  __cil_tmp13 = 1UL << 5;
#line 589
  __cil_tmp14 = 1UL << 4;
#line 589
  __cil_tmp15 = __cil_tmp14 | __cil_tmp13;
#line 589
  *((unsigned int *)__cil_tmp12) = (unsigned int )__cil_tmp15;
#line 590
  __cil_tmp16 = (unsigned int )wl;
#line 590
  __cil_tmp17 = __cil_tmp16 + 464;
#line 590
  __cil_tmp18 = 1UL << 11;
#line 590
  __cil_tmp19 = 1UL << 10;
#line 590
  __cil_tmp20 = 1UL << 9;
#line 590
  __cil_tmp21 = 1UL << 7;
#line 590
  __cil_tmp22 = 1UL << 6;
#line 590
  __cil_tmp23 = 1UL << 4;
#line 590
  __cil_tmp24 = 1UL << 2;
#line 590
  __cil_tmp25 = __cil_tmp24 | __cil_tmp23;
#line 590
  __cil_tmp26 = __cil_tmp25 | __cil_tmp22;
#line 590
  __cil_tmp27 = __cil_tmp26 | __cil_tmp21;
#line 590
  __cil_tmp28 = __cil_tmp27 | __cil_tmp20;
#line 590
  __cil_tmp29 = __cil_tmp28 | __cil_tmp19;
#line 590
  __cil_tmp30 = __cil_tmp29 | __cil_tmp18;
#line 590
  *((unsigned int *)__cil_tmp17) = (unsigned int )__cil_tmp30;
  {
#line 592
  __cil_tmp31 = *total;
#line 592
  if (__cil_tmp31 & 1U) {
#line 593
    __cil_tmp32 = (unsigned int )wl;
#line 593
    __cil_tmp33 = __cil_tmp32 + 460;
#line 593
    __cil_tmp34 = 1UL << 5;
#line 593
    __cil_tmp35 = (unsigned int )wl;
#line 593
    __cil_tmp36 = __cil_tmp35 + 460;
#line 593
    __cil_tmp37 = *((unsigned int *)__cil_tmp36);
#line 593
    __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 593
    __cil_tmp39 = __cil_tmp38 | __cil_tmp34;
#line 593
    *((unsigned int *)__cil_tmp33) = (unsigned int )__cil_tmp39;
#line 594
    __cil_tmp40 = (unsigned int )wl;
#line 594
    __cil_tmp41 = __cil_tmp40 + 460;
#line 594
    __cil_tmp42 = 1UL << 3;
#line 594
    __cil_tmp43 = (unsigned int )wl;
#line 594
    __cil_tmp44 = __cil_tmp43 + 460;
#line 594
    __cil_tmp45 = *((unsigned int *)__cil_tmp44);
#line 594
    __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 594
    __cil_tmp47 = __cil_tmp46 | __cil_tmp42;
#line 594
    *((unsigned int *)__cil_tmp41) = (unsigned int )__cil_tmp47;
  } else {

  }
  }
  {
#line 596
  __cil_tmp48 = *total;
#line 596
  if (__cil_tmp48 & 2U) {
#line 601
    __cil_tmp49 = (unsigned int )wl;
#line 601
    __cil_tmp50 = __cil_tmp49 + 460;
#line 601
    __cil_tmp51 = 1UL << 6;
#line 601
    __cil_tmp52 = ~ __cil_tmp51;
#line 601
    __cil_tmp53 = (unsigned int )wl;
#line 601
    __cil_tmp54 = __cil_tmp53 + 460;
#line 601
    __cil_tmp55 = *((unsigned int *)__cil_tmp54);
#line 601
    __cil_tmp56 = (unsigned long )__cil_tmp55;
#line 601
    __cil_tmp57 = __cil_tmp56 & __cil_tmp52;
#line 601
    *((unsigned int *)__cil_tmp50) = (unsigned int )__cil_tmp57;
  } else {

  }
  }
  {
#line 602
  __cil_tmp58 = *total;
#line 602
  if (__cil_tmp58 & 4U) {
#line 603
    __cil_tmp59 = (unsigned int )wl;
#line 603
    __cil_tmp60 = __cil_tmp59 + 464;
#line 603
    __cil_tmp61 = 1UL << 5;
#line 603
    __cil_tmp62 = (unsigned int )wl;
#line 603
    __cil_tmp63 = __cil_tmp62 + 464;
#line 603
    __cil_tmp64 = *((unsigned int *)__cil_tmp63);
#line 603
    __cil_tmp65 = (unsigned long )__cil_tmp64;
#line 603
    __cil_tmp66 = __cil_tmp65 | __cil_tmp61;
#line 603
    *((unsigned int *)__cil_tmp60) = (unsigned int )__cil_tmp66;
  } else {

  }
  }
  {
#line 604
  __cil_tmp67 = *total;
#line 604
  if (__cil_tmp67 & 16U) {
#line 605
    __cil_tmp68 = (unsigned int )wl;
#line 605
    __cil_tmp69 = __cil_tmp68 + 460;
#line 605
    __cil_tmp70 = 1UL << 5;
#line 605
    __cil_tmp71 = ~ __cil_tmp70;
#line 605
    __cil_tmp72 = (unsigned int )wl;
#line 605
    __cil_tmp73 = __cil_tmp72 + 460;
#line 605
    __cil_tmp74 = *((unsigned int *)__cil_tmp73);
#line 605
    __cil_tmp75 = (unsigned long )__cil_tmp74;
#line 605
    __cil_tmp76 = __cil_tmp75 & __cil_tmp71;
#line 605
    *((unsigned int *)__cil_tmp69) = (unsigned int )__cil_tmp76;
#line 606
    __cil_tmp77 = (unsigned int )wl;
#line 606
    __cil_tmp78 = __cil_tmp77 + 460;
#line 606
    __cil_tmp79 = 1UL << 10;
#line 606
    __cil_tmp80 = ~ __cil_tmp79;
#line 606
    __cil_tmp81 = (unsigned int )wl;
#line 606
    __cil_tmp82 = __cil_tmp81 + 460;
#line 606
    __cil_tmp83 = *((unsigned int *)__cil_tmp82);
#line 606
    __cil_tmp84 = (unsigned long )__cil_tmp83;
#line 606
    __cil_tmp85 = __cil_tmp84 & __cil_tmp80;
#line 606
    *((unsigned int *)__cil_tmp78) = (unsigned int )__cil_tmp85;
  } else {

  }
  }
  {
#line 608
  __cil_tmp86 = *total;
#line 608
  if (__cil_tmp86 & 32U) {
#line 609
    __cil_tmp87 = (unsigned int )wl;
#line 609
    __cil_tmp88 = __cil_tmp87 + 464;
#line 609
    __cil_tmp89 = 1UL << 7;
#line 609
    __cil_tmp90 = (unsigned int )wl;
#line 609
    __cil_tmp91 = __cil_tmp90 + 464;
#line 609
    __cil_tmp92 = *((unsigned int *)__cil_tmp91);
#line 609
    __cil_tmp93 = (unsigned long )__cil_tmp92;
#line 609
    __cil_tmp94 = __cil_tmp93 | __cil_tmp89;
#line 609
    *((unsigned int *)__cil_tmp88) = (unsigned int )__cil_tmp94;
  } else {

  }
  }
  {
#line 610
  __cil_tmp95 = *total;
#line 610
  if (__cil_tmp95 & 64U) {
#line 611
    __cil_tmp96 = (unsigned int )wl;
#line 611
    __cil_tmp97 = __cil_tmp96 + 464;
#line 611
    __cil_tmp98 = 1UL << 5;
#line 611
    __cil_tmp99 = ~ __cil_tmp98;
#line 611
    __cil_tmp100 = (unsigned int )wl;
#line 611
    __cil_tmp101 = __cil_tmp100 + 464;
#line 611
    __cil_tmp102 = *((unsigned int *)__cil_tmp101);
#line 611
    __cil_tmp103 = (unsigned long )__cil_tmp102;
#line 611
    __cil_tmp104 = __cil_tmp103 & __cil_tmp99;
#line 611
    *((unsigned int *)__cil_tmp97) = (unsigned int )__cil_tmp104;
  } else {

  }
  }
#line 619
  return;
}
}
#line 622 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_set_key_type(struct wl12xx *wl , struct acx_set_key *key , enum set_key_cmd cmd ,
                               struct ieee80211_key_conf *mac80211_key , u8 const   *addr ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  enum ieee80211_key_alg __cil_tmp9 ;
  int __cil_tmp10 ;
  enum ieee80211_key_alg __cil_tmp11 ;
  int __cil_tmp12 ;
  enum ieee80211_key_alg __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  s8 __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  s8 __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  u8 __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  enum ieee80211_key_alg __cil_tmp44 ;

  {
  {
#line 628
  __cil_tmp9 = *((enum ieee80211_key_alg *)mac80211_key);
#line 628
  __cil_tmp10 = (int )__cil_tmp9;
#line 628
  if (__cil_tmp10 == 0) {
    goto switch_21_0;
  } else {
    {
#line 636
    __cil_tmp11 = *((enum ieee80211_key_alg *)mac80211_key);
#line 636
    __cil_tmp12 = (int )__cil_tmp11;
#line 636
    if (__cil_tmp12 == 1) {
      goto switch_21_1;
    } else {
      {
#line 644
      __cil_tmp13 = *((enum ieee80211_key_alg *)mac80211_key);
#line 644
      __cil_tmp14 = (int )__cil_tmp13;
#line 644
      if (__cil_tmp14 == 2) {
        goto switch_21_2;
      } else {
        goto switch_21_default;
#line 627
        if (0) {
          switch_21_0: 
          {
#line 629
          tmp = is_broadcast_ether_addr(addr);
          }
#line 629
          if (tmp) {
#line 630
            __cil_tmp15 = (unsigned int )key;
#line 630
            __cil_tmp16 = __cil_tmp15 + 11;
#line 630
            *((u8 *)__cil_tmp16) = (unsigned char)0;
          } else {
#line 632
            __cil_tmp17 = (unsigned int )key;
#line 632
            __cil_tmp18 = __cil_tmp17 + 11;
#line 632
            *((u8 *)__cil_tmp18) = (unsigned char)1;
          }
#line 634
          __cil_tmp19 = (unsigned int )mac80211_key;
#line 634
          __cil_tmp20 = __cil_tmp19 + 34;
#line 634
          __cil_tmp21 = (unsigned int )mac80211_key;
#line 634
          __cil_tmp22 = __cil_tmp21 + 36;
#line 634
          __cil_tmp23 = *((s8 *)__cil_tmp22);
#line 634
          *((u8 *)__cil_tmp20) = (unsigned char )__cil_tmp23;
          goto switch_21_break;
          switch_21_1: 
          {
#line 637
          tmp___0 = is_broadcast_ether_addr(addr);
          }
#line 637
          if (tmp___0) {
#line 638
            __cil_tmp24 = (unsigned int )key;
#line 638
            __cil_tmp25 = __cil_tmp24 + 11;
#line 638
            *((u8 *)__cil_tmp25) = (unsigned char)10;
          } else {
#line 640
            __cil_tmp26 = (unsigned int )key;
#line 640
            __cil_tmp27 = __cil_tmp26 + 11;
#line 640
            *((u8 *)__cil_tmp27) = (unsigned char)11;
          }
#line 642
          __cil_tmp28 = (unsigned int )mac80211_key;
#line 642
          __cil_tmp29 = __cil_tmp28 + 34;
#line 642
          __cil_tmp30 = (unsigned int )mac80211_key;
#line 642
          __cil_tmp31 = __cil_tmp30 + 36;
#line 642
          __cil_tmp32 = *((s8 *)__cil_tmp31);
#line 642
          *((u8 *)__cil_tmp29) = (unsigned char )__cil_tmp32;
          goto switch_21_break;
          switch_21_2: 
          {
#line 645
          tmp___1 = is_broadcast_ether_addr(addr);
          }
#line 645
          if (tmp___1) {
#line 646
            __cil_tmp33 = (unsigned int )key;
#line 646
            __cil_tmp34 = __cil_tmp33 + 11;
#line 646
            *((u8 *)__cil_tmp34) = (unsigned char)4;
          } else {
#line 648
            __cil_tmp35 = (unsigned int )key;
#line 648
            __cil_tmp36 = __cil_tmp35 + 11;
#line 648
            *((u8 *)__cil_tmp36) = (unsigned char)5;
          }
#line 649
          __cil_tmp37 = (unsigned int )mac80211_key;
#line 649
          __cil_tmp38 = __cil_tmp37 + 35;
#line 649
          __cil_tmp39 = (unsigned int )mac80211_key;
#line 649
          __cil_tmp40 = __cil_tmp39 + 35;
#line 649
          __cil_tmp41 = *((u8 *)__cil_tmp40);
#line 649
          __cil_tmp42 = (int )__cil_tmp41;
#line 649
          __cil_tmp43 = __cil_tmp42 | 2;
#line 649
          *((u8 *)__cil_tmp38) = (unsigned char )__cil_tmp43;
          goto switch_21_break;
          switch_21_default: 
          {
#line 652
          __cil_tmp44 = *((enum ieee80211_key_alg *)mac80211_key);
#line 652
          printk("<3>wl12xx: ERROR Unknown key algo 0x%x\n", __cil_tmp44);
          }
#line 653
          return (-95);
        } else {
          switch_21_break: ;
        }
      }
      }
    }
    }
  }
  }
#line 656
  return (0);
}
}
#line 669
static int wl12xx_op_set_key(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                             struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) ;
#line 669 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static u8 const   bcast_addr[6]  = {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255};
#line 659 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_set_key(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                             struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) 
{ struct wl12xx *wl ;
  struct acx_set_key wl_key ;
  u8 const   *addr ;
  int ret ;
  int tmp___2 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  u8 *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  struct mutex *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  u8 __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  u8 *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void const   *__cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  u8 __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  u8 *__cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  u8 *__cil_tmp50 ;
  void const   *__cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  u8 *__cil_tmp55 ;
  u8 *__cil_tmp56 ;
  void *__cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  u8 *__cil_tmp62 ;
  u8 *__cil_tmp63 ;
  void const   *__cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  u8 *__cil_tmp68 ;
  u8 *__cil_tmp69 ;
  void *__cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  unsigned int __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned int __cil_tmp74 ;
  u8 *__cil_tmp75 ;
  u8 *__cil_tmp76 ;
  void const   *__cil_tmp77 ;
  unsigned int __cil_tmp78 ;
  u8 __cil_tmp79 ;
  int __cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned int __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  u8 *__cil_tmp84 ;
  void *__cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  unsigned int __cil_tmp89 ;
  u8 *__cil_tmp90 ;
  void const   *__cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  unsigned int __cil_tmp94 ;
  u8 *__cil_tmp95 ;
  u8 *__cil_tmp96 ;
  void *__cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  unsigned int __cil_tmp99 ;
  unsigned int __cil_tmp100 ;
  unsigned int __cil_tmp101 ;
  u8 *__cil_tmp102 ;
  u8 *__cil_tmp103 ;
  void const   *__cil_tmp104 ;
  unsigned int __cil_tmp105 ;
  unsigned int __cil_tmp106 ;
  unsigned int __cil_tmp107 ;
  u8 *__cil_tmp108 ;
  u8 *__cil_tmp109 ;
  void *__cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  unsigned int __cil_tmp114 ;
  u8 *__cil_tmp115 ;
  u8 *__cil_tmp116 ;
  void const   *__cil_tmp117 ;
  unsigned int __cil_tmp118 ;
  unsigned int __cil_tmp119 ;
  unsigned int __cil_tmp120 ;
  u8 *__cil_tmp121 ;
  void *__cil_tmp122 ;
  unsigned int __cil_tmp123 ;
  unsigned int __cil_tmp124 ;
  unsigned int __cil_tmp125 ;
  unsigned int __cil_tmp126 ;
  u8 *__cil_tmp127 ;
  void const   *__cil_tmp128 ;
  unsigned int __cil_tmp129 ;
  unsigned int __cil_tmp130 ;
  u8 __cil_tmp131 ;
  unsigned int __cil_tmp132 ;
  unsigned int __cil_tmp133 ;
  unsigned int __cil_tmp134 ;
  unsigned int __cil_tmp135 ;
  unsigned int __cil_tmp136 ;
  unsigned int __cil_tmp137 ;
  unsigned int __cil_tmp138 ;
  s8 __cil_tmp139 ;
  unsigned int __cil_tmp140 ;
  void *__cil_tmp141 ;
  unsigned int __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  struct mutex *__cil_tmp144 ;

  {
#line 664
  __cil_tmp11 = (unsigned int )hw;
#line 664
  __cil_tmp12 = __cil_tmp11 + 64;
#line 664
  __cil_tmp13 = *((void **)__cil_tmp12);
#line 664
  wl = (struct wl12xx *)__cil_tmp13;
  {
#line 672
  while (1) {
    while_9_continue: /* CIL Label */ ;

    goto while_22_break;
  }
  while_9_break: /* CIL Label */ ;
  }
  while_22_break: 
  {
#line 674
  __cil_tmp14 = (void *)(& wl_key);
#line 674
  __constant_c_and_count_memset(__cil_tmp14, 0UL, 76U);
  }
#line 676
  if (sta) {
#line 676
    __cil_tmp15 = 0 * 1U;
#line 676
    __cil_tmp16 = 8 + __cil_tmp15;
#line 676
    __cil_tmp17 = (unsigned int )sta;
#line 676
    __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
#line 676
    __cil_tmp19 = (u8 *)__cil_tmp18;
#line 676
    addr = (u8 const   *)__cil_tmp19;
  } else {
#line 676
    __cil_tmp20 = 0 * 1U;
#line 676
    __cil_tmp21 = (unsigned int )(bcast_addr) + __cil_tmp20;
#line 676
    addr = (u8 const   *)__cil_tmp21;
  }
  {
#line 678
  while (1) {
    while_10_continue: /* CIL Label */ ;

    goto while_23_break;
  }
  while_10_break: /* CIL Label */ ;
  }
  while_23_break: ;
  {
#line 679
  while (1) {
    while_11_continue: /* CIL Label */ ;

    goto while_24_break;
  }
  while_11_break: /* CIL Label */ ;
  }
  while_24_break: ;
  {
#line 680
  while (1) {
    while_12_continue: /* CIL Label */ ;

    goto while_25_break;
  }
  while_12_break: /* CIL Label */ ;
  }
  while_25_break: ;
  {
#line 682
  while (1) {
    while_13_continue: /* CIL Label */ ;

    goto while_26_break;
  }
  while_13_break: /* CIL Label */ ;
  }
  while_26_break: 
  {
#line 684
  __cil_tmp22 = (unsigned int )wl;
#line 684
  __cil_tmp23 = __cil_tmp22 + 52;
#line 684
  __cil_tmp24 = (struct mutex *)__cil_tmp23;
#line 684
  mutex_lock(__cil_tmp24);
  }
  {
#line 687
  __cil_tmp25 = (int )cmd;
#line 687
  if (__cil_tmp25 == 0) {
    goto switch_27_0;
  } else {
    {
#line 690
    __cil_tmp26 = (int )cmd;
#line 690
    if (__cil_tmp26 == 1) {
      goto switch_27_1;
    } else {
      goto switch_27_default;
#line 686
      if (0) {
        switch_27_0: 
#line 688
        __cil_tmp27 = (unsigned int )(& wl_key) + 6;
#line 688
        *((u16 *)__cil_tmp27) = (unsigned short)1;
        goto switch_27_break;
        switch_27_1: 
#line 691
        __cil_tmp28 = (unsigned int )(& wl_key) + 6;
#line 691
        *((u16 *)__cil_tmp28) = (unsigned short)2;
        goto switch_27_break;
        switch_27_default: 
        {
#line 694
        printk("<3>wl12xx: ERROR Unsupported key cmd 0x%x\n", cmd);
        }
        goto switch_27_break;
      } else {
        switch_27_break: ;
      }
    }
    }
  }
  }
  {
#line 698
  ret = wl12xx_set_key_type(wl, & wl_key, cmd, key, addr);
  }
#line 699
  if (ret < 0) {
    {
#line 700
    printk("<3>wl12xx: ERROR Set KEY type failed\n");
    }
    goto out;
  } else {

  }
  {
#line 704
  __cil_tmp29 = (unsigned int )(& wl_key) + 11;
#line 704
  __cil_tmp30 = *((u8 *)__cil_tmp29);
#line 704
  __cil_tmp31 = (int )__cil_tmp30;
#line 704
  if (__cil_tmp31 != 0) {
    {
#line 705
    __cil_tmp32 = 0 * 1U;
#line 705
    __cil_tmp33 = 0 + __cil_tmp32;
#line 705
    __cil_tmp34 = (unsigned int )(& wl_key) + __cil_tmp33;
#line 705
    __cil_tmp35 = (u8 *)__cil_tmp34;
#line 705
    __cil_tmp36 = (void *)__cil_tmp35;
#line 705
    __cil_tmp37 = (void const   *)addr;
#line 705
    __constant_memcpy(__cil_tmp36, __cil_tmp37, 6U);
    }
  } else {

  }
  }
  {
#line 707
  __cil_tmp38 = (unsigned int )(& wl_key) + 11;
#line 707
  __cil_tmp39 = *((u8 *)__cil_tmp38);
#line 707
  __cil_tmp40 = (int )__cil_tmp39;
#line 707
  if (__cil_tmp40 == 10) {
    {
#line 715
    __cil_tmp41 = 0 * 1U;
#line 715
    __cil_tmp42 = 20 + __cil_tmp41;
#line 715
    __cil_tmp43 = (unsigned int )(& wl_key) + __cil_tmp42;
#line 715
    __cil_tmp44 = (u8 *)__cil_tmp43;
#line 715
    __cil_tmp45 = (void *)__cil_tmp44;
#line 715
    __cil_tmp46 = 0 * 1U;
#line 715
    __cil_tmp47 = 38 + __cil_tmp46;
#line 715
    __cil_tmp48 = (unsigned int )key;
#line 715
    __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
#line 715
    __cil_tmp50 = (u8 *)__cil_tmp49;
#line 715
    __cil_tmp51 = (void const   *)__cil_tmp50;
#line 715
    __constant_memcpy(__cil_tmp45, __cil_tmp51, 16U);
#line 716
    __cil_tmp52 = 0 * 1U;
#line 716
    __cil_tmp53 = 20 + __cil_tmp52;
#line 716
    __cil_tmp54 = (unsigned int )(& wl_key) + __cil_tmp53;
#line 716
    __cil_tmp55 = (u8 *)__cil_tmp54;
#line 716
    __cil_tmp56 = __cil_tmp55 + 16;
#line 716
    __cil_tmp57 = (void *)__cil_tmp56;
#line 716
    __cil_tmp58 = 0 * 1U;
#line 716
    __cil_tmp59 = 38 + __cil_tmp58;
#line 716
    __cil_tmp60 = (unsigned int )key;
#line 716
    __cil_tmp61 = __cil_tmp60 + __cil_tmp59;
#line 716
    __cil_tmp62 = (u8 *)__cil_tmp61;
#line 716
    __cil_tmp63 = __cil_tmp62 + 24;
#line 716
    __cil_tmp64 = (void const   *)__cil_tmp63;
#line 716
    __constant_memcpy(__cil_tmp57, __cil_tmp64, 8U);
#line 717
    __cil_tmp65 = 0 * 1U;
#line 717
    __cil_tmp66 = 20 + __cil_tmp65;
#line 717
    __cil_tmp67 = (unsigned int )(& wl_key) + __cil_tmp66;
#line 717
    __cil_tmp68 = (u8 *)__cil_tmp67;
#line 717
    __cil_tmp69 = __cil_tmp68 + 24;
#line 717
    __cil_tmp70 = (void *)__cil_tmp69;
#line 717
    __cil_tmp71 = 0 * 1U;
#line 717
    __cil_tmp72 = 38 + __cil_tmp71;
#line 717
    __cil_tmp73 = (unsigned int )key;
#line 717
    __cil_tmp74 = __cil_tmp73 + __cil_tmp72;
#line 717
    __cil_tmp75 = (u8 *)__cil_tmp74;
#line 717
    __cil_tmp76 = __cil_tmp75 + 16;
#line 717
    __cil_tmp77 = (void const   *)__cil_tmp76;
#line 717
    __constant_memcpy(__cil_tmp70, __cil_tmp77, 8U);
    }
  } else {
    {
#line 707
    __cil_tmp78 = (unsigned int )(& wl_key) + 11;
#line 707
    __cil_tmp79 = *((u8 *)__cil_tmp78);
#line 707
    __cil_tmp80 = (int )__cil_tmp79;
#line 707
    if (__cil_tmp80 == 11) {
      {
#line 715
      __cil_tmp81 = 0 * 1U;
#line 715
      __cil_tmp82 = 20 + __cil_tmp81;
#line 715
      __cil_tmp83 = (unsigned int )(& wl_key) + __cil_tmp82;
#line 715
      __cil_tmp84 = (u8 *)__cil_tmp83;
#line 715
      __cil_tmp85 = (void *)__cil_tmp84;
#line 715
      __cil_tmp86 = 0 * 1U;
#line 715
      __cil_tmp87 = 38 + __cil_tmp86;
#line 715
      __cil_tmp88 = (unsigned int )key;
#line 715
      __cil_tmp89 = __cil_tmp88 + __cil_tmp87;
#line 715
      __cil_tmp90 = (u8 *)__cil_tmp89;
#line 715
      __cil_tmp91 = (void const   *)__cil_tmp90;
#line 715
      __constant_memcpy(__cil_tmp85, __cil_tmp91, 16U);
#line 716
      __cil_tmp92 = 0 * 1U;
#line 716
      __cil_tmp93 = 20 + __cil_tmp92;
#line 716
      __cil_tmp94 = (unsigned int )(& wl_key) + __cil_tmp93;
#line 716
      __cil_tmp95 = (u8 *)__cil_tmp94;
#line 716
      __cil_tmp96 = __cil_tmp95 + 16;
#line 716
      __cil_tmp97 = (void *)__cil_tmp96;
#line 716
      __cil_tmp98 = 0 * 1U;
#line 716
      __cil_tmp99 = 38 + __cil_tmp98;
#line 716
      __cil_tmp100 = (unsigned int )key;
#line 716
      __cil_tmp101 = __cil_tmp100 + __cil_tmp99;
#line 716
      __cil_tmp102 = (u8 *)__cil_tmp101;
#line 716
      __cil_tmp103 = __cil_tmp102 + 24;
#line 716
      __cil_tmp104 = (void const   *)__cil_tmp103;
#line 716
      __constant_memcpy(__cil_tmp97, __cil_tmp104, 8U);
#line 717
      __cil_tmp105 = 0 * 1U;
#line 717
      __cil_tmp106 = 20 + __cil_tmp105;
#line 717
      __cil_tmp107 = (unsigned int )(& wl_key) + __cil_tmp106;
#line 717
      __cil_tmp108 = (u8 *)__cil_tmp107;
#line 717
      __cil_tmp109 = __cil_tmp108 + 24;
#line 717
      __cil_tmp110 = (void *)__cil_tmp109;
#line 717
      __cil_tmp111 = 0 * 1U;
#line 717
      __cil_tmp112 = 38 + __cil_tmp111;
#line 717
      __cil_tmp113 = (unsigned int )key;
#line 717
      __cil_tmp114 = __cil_tmp113 + __cil_tmp112;
#line 717
      __cil_tmp115 = (u8 *)__cil_tmp114;
#line 717
      __cil_tmp116 = __cil_tmp115 + 16;
#line 717
      __cil_tmp117 = (void const   *)__cil_tmp116;
#line 717
      __constant_memcpy(__cil_tmp110, __cil_tmp117, 8U);
      }
    } else {
      {
#line 720
      __cil_tmp118 = 0 * 1U;
#line 720
      __cil_tmp119 = 20 + __cil_tmp118;
#line 720
      __cil_tmp120 = (unsigned int )(& wl_key) + __cil_tmp119;
#line 720
      __cil_tmp121 = (u8 *)__cil_tmp120;
#line 720
      __cil_tmp122 = (void *)__cil_tmp121;
#line 720
      __cil_tmp123 = 0 * 1U;
#line 720
      __cil_tmp124 = 38 + __cil_tmp123;
#line 720
      __cil_tmp125 = (unsigned int )key;
#line 720
      __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
#line 720
      __cil_tmp127 = (u8 *)__cil_tmp126;
#line 720
      __cil_tmp128 = (void const   *)__cil_tmp127;
#line 720
      __cil_tmp129 = (unsigned int )key;
#line 720
      __cil_tmp130 = __cil_tmp129 + 37;
#line 720
      __cil_tmp131 = *((u8 *)__cil_tmp130);
#line 720
      __cil_tmp132 = (unsigned int )__cil_tmp131;
#line 720
      __memcpy(__cil_tmp122, __cil_tmp128, __cil_tmp132);
      }
    }
    }
  }
  }
#line 722
  __cil_tmp133 = (unsigned int )(& wl_key) + 10;
#line 722
  __cil_tmp134 = (unsigned int )key;
#line 722
  __cil_tmp135 = __cil_tmp134 + 37;
#line 722
  *((u8 *)__cil_tmp133) = *((u8 *)__cil_tmp135);
#line 724
  __cil_tmp136 = (unsigned int )(& wl_key) + 13;
#line 724
  __cil_tmp137 = (unsigned int )key;
#line 724
  __cil_tmp138 = __cil_tmp137 + 36;
#line 724
  __cil_tmp139 = *((s8 *)__cil_tmp138);
#line 724
  *((u8 *)__cil_tmp136) = (unsigned char )__cil_tmp139;
#line 725
  __cil_tmp140 = (unsigned int )(& wl_key) + 12;
#line 725
  *((u8 *)__cil_tmp140) = (unsigned char)0;
  {
#line 727
  while (1) {
    while_14_continue: /* CIL Label */ ;

    goto while_28_break;
  }
  while_14_break: /* CIL Label */ ;
  }
  while_28_break: 
  {
#line 729
  __cil_tmp141 = (void *)(& wl_key);
#line 729
  tmp___2 = wl12xx_cmd_send(wl, (unsigned short)12, __cil_tmp141, 76U);
  }
#line 729
  if (tmp___2 < 0) {
    {
#line 730
    printk("<3>wl12xx: ERROR Set KEY failed\n");
#line 731
    ret = -95;
    }
    goto out;
  } else {

  }
  out: 
  {
#line 736
  __cil_tmp142 = (unsigned int )wl;
#line 736
  __cil_tmp143 = __cil_tmp142 + 52;
#line 736
  __cil_tmp144 = (struct mutex *)__cil_tmp143;
#line 736
  mutex_unlock(__cil_tmp144);
  }
#line 737
  return (ret);
}
}
#line 740 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_basic_rates(char *rates ) 
{ u8 index ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 742
  index = (unsigned char)0;
#line 744
  tmp = index;
#line 744
  __cil_tmp7 = (int )index;
#line 744
  __cil_tmp8 = __cil_tmp7 + 1;
#line 744
  index = (unsigned char )__cil_tmp8;
#line 744
  __cil_tmp9 = (int )tmp;
#line 744
  __cil_tmp10 = rates + __cil_tmp9;
#line 744
  *__cil_tmp10 = (char)130;
#line 745
  tmp___0 = index;
#line 745
  __cil_tmp11 = (int )index;
#line 745
  __cil_tmp12 = __cil_tmp11 + 1;
#line 745
  index = (unsigned char )__cil_tmp12;
#line 745
  __cil_tmp13 = (int )tmp___0;
#line 745
  __cil_tmp14 = rates + __cil_tmp13;
#line 745
  *__cil_tmp14 = (char)132;
#line 746
  tmp___1 = index;
#line 746
  __cil_tmp15 = (int )index;
#line 746
  __cil_tmp16 = __cil_tmp15 + 1;
#line 746
  index = (unsigned char )__cil_tmp16;
#line 746
  __cil_tmp17 = (int )tmp___1;
#line 746
  __cil_tmp18 = rates + __cil_tmp17;
#line 746
  *__cil_tmp18 = (char)139;
#line 747
  tmp___2 = index;
#line 747
  __cil_tmp19 = (int )index;
#line 747
  __cil_tmp20 = __cil_tmp19 + 1;
#line 747
  index = (unsigned char )__cil_tmp20;
#line 747
  __cil_tmp21 = (int )tmp___2;
#line 747
  __cil_tmp22 = rates + __cil_tmp21;
#line 747
  *__cil_tmp22 = (char)150;
#line 749
  return ((int )index);
}
}
#line 752 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_extended_rates(char *rates ) 
{ u8 index ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  char *__cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  char *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 754
  index = (unsigned char)0;
#line 756
  tmp = index;
#line 756
  __cil_tmp11 = (int )index;
#line 756
  __cil_tmp12 = __cil_tmp11 + 1;
#line 756
  index = (unsigned char )__cil_tmp12;
#line 756
  __cil_tmp13 = (int )tmp;
#line 756
  __cil_tmp14 = rates + __cil_tmp13;
#line 756
  *__cil_tmp14 = (char)12;
#line 757
  tmp___0 = index;
#line 757
  __cil_tmp15 = (int )index;
#line 757
  __cil_tmp16 = __cil_tmp15 + 1;
#line 757
  index = (unsigned char )__cil_tmp16;
#line 757
  __cil_tmp17 = (int )tmp___0;
#line 757
  __cil_tmp18 = rates + __cil_tmp17;
#line 757
  *__cil_tmp18 = (char)18;
#line 758
  tmp___1 = index;
#line 758
  __cil_tmp19 = (int )index;
#line 758
  __cil_tmp20 = __cil_tmp19 + 1;
#line 758
  index = (unsigned char )__cil_tmp20;
#line 758
  __cil_tmp21 = (int )tmp___1;
#line 758
  __cil_tmp22 = rates + __cil_tmp21;
#line 758
  *__cil_tmp22 = (char)24;
#line 759
  tmp___2 = index;
#line 759
  __cil_tmp23 = (int )index;
#line 759
  __cil_tmp24 = __cil_tmp23 + 1;
#line 759
  index = (unsigned char )__cil_tmp24;
#line 759
  __cil_tmp25 = (int )tmp___2;
#line 759
  __cil_tmp26 = rates + __cil_tmp25;
#line 759
  *__cil_tmp26 = (char)36;
#line 760
  tmp___3 = index;
#line 760
  __cil_tmp27 = (int )index;
#line 760
  __cil_tmp28 = __cil_tmp27 + 1;
#line 760
  index = (unsigned char )__cil_tmp28;
#line 760
  __cil_tmp29 = (int )tmp___3;
#line 760
  __cil_tmp30 = rates + __cil_tmp29;
#line 760
  *__cil_tmp30 = (char)48;
#line 761
  tmp___4 = index;
#line 761
  __cil_tmp31 = (int )index;
#line 761
  __cil_tmp32 = __cil_tmp31 + 1;
#line 761
  index = (unsigned char )__cil_tmp32;
#line 761
  __cil_tmp33 = (int )tmp___4;
#line 761
  __cil_tmp34 = rates + __cil_tmp33;
#line 761
  *__cil_tmp34 = (char)72;
#line 762
  tmp___5 = index;
#line 762
  __cil_tmp35 = (int )index;
#line 762
  __cil_tmp36 = __cil_tmp35 + 1;
#line 762
  index = (unsigned char )__cil_tmp36;
#line 762
  __cil_tmp37 = (int )tmp___5;
#line 762
  __cil_tmp38 = rates + __cil_tmp37;
#line 762
  *__cil_tmp38 = (char)96;
#line 763
  tmp___6 = index;
#line 763
  __cil_tmp39 = (int )index;
#line 763
  __cil_tmp40 = __cil_tmp39 + 1;
#line 763
  index = (unsigned char )__cil_tmp40;
#line 763
  __cil_tmp41 = (int )tmp___6;
#line 763
  __cil_tmp42 = rates + __cil_tmp41;
#line 763
  *__cil_tmp42 = (char)108;
#line 765
  return ((int )index);
}
}
#line 769 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_probe_req(struct wl12xx *wl , u8 *ssid , size_t ssid_len ) 
{ struct wl12xx_probe_req_template template ;
  struct wl12xx_ie_rates *rates ;
  char *ptr ;
  u16 size ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  u8 *__cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  u8 *__cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  u8 *__cil_tmp27 ;
  void *__cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  u8 *__cil_tmp33 ;
  void const   *__cil_tmp34 ;
  struct wl12xx_probe_req_template *__cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  char *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void const   *__cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  u8 *__cil_tmp55 ;
  char *__cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  u8 __cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  unsigned int __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  u8 __cil_tmp71 ;
  unsigned int __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned int __cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  unsigned int __cil_tmp77 ;
  u8 *__cil_tmp78 ;
  char *__cil_tmp79 ;
  unsigned int __cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned int __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned int __cil_tmp85 ;
  u8 __cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  unsigned int __cil_tmp89 ;
  unsigned int __cil_tmp90 ;
  void *__cil_tmp91 ;
  unsigned int __cil_tmp92 ;

  {
  {
#line 776
  ptr = (char *)(& template);
#line 777
  size = (unsigned short )24U;
#line 779
  __cil_tmp11 = 0 * 1U;
#line 779
  __cil_tmp12 = 4 + __cil_tmp11;
#line 779
  __cil_tmp13 = 0 + __cil_tmp12;
#line 779
  __cil_tmp14 = (unsigned int )(& template) + __cil_tmp13;
#line 779
  __cil_tmp15 = (u8 *)__cil_tmp14;
#line 779
  __cil_tmp16 = (void *)__cil_tmp15;
#line 779
  __constant_c_and_count_memset(__cil_tmp16, 4294967295UL, 6U);
#line 780
  __cil_tmp17 = 0 * 1U;
#line 780
  __cil_tmp18 = 16 + __cil_tmp17;
#line 780
  __cil_tmp19 = 0 + __cil_tmp18;
#line 780
  __cil_tmp20 = (unsigned int )(& template) + __cil_tmp19;
#line 780
  __cil_tmp21 = (u8 *)__cil_tmp20;
#line 780
  __cil_tmp22 = (void *)__cil_tmp21;
#line 780
  __constant_c_and_count_memset(__cil_tmp22, 4294967295UL, 6U);
#line 781
  __cil_tmp23 = 0 * 1U;
#line 781
  __cil_tmp24 = 10 + __cil_tmp23;
#line 781
  __cil_tmp25 = 0 + __cil_tmp24;
#line 781
  __cil_tmp26 = (unsigned int )(& template) + __cil_tmp25;
#line 781
  __cil_tmp27 = (u8 *)__cil_tmp26;
#line 781
  __cil_tmp28 = (void *)__cil_tmp27;
#line 781
  __cil_tmp29 = 0 * 1U;
#line 781
  __cil_tmp30 = 238 + __cil_tmp29;
#line 781
  __cil_tmp31 = (unsigned int )wl;
#line 781
  __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
#line 781
  __cil_tmp33 = (u8 *)__cil_tmp32;
#line 781
  __cil_tmp34 = (void const   *)__cil_tmp33;
#line 781
  __constant_memcpy(__cil_tmp28, __cil_tmp34, 6U);
#line 782
  __cil_tmp35 = & template;
#line 782
  *((__le16 *)__cil_tmp35) = (unsigned short)64;
#line 786
  __cil_tmp36 = (unsigned int )(& template) + 24;
#line 786
  *((u8 *)__cil_tmp36) = (unsigned char)0;
#line 787
  __cil_tmp37 = 0 + 1;
#line 787
  __cil_tmp38 = 24 + __cil_tmp37;
#line 787
  __cil_tmp39 = (unsigned int )(& template) + __cil_tmp38;
#line 787
  *((u8 *)__cil_tmp39) = (unsigned char )ssid_len;
  }
#line 788
  if (ssid_len) {
#line 788
    if (ssid) {
      {
#line 789
      __cil_tmp40 = 0 * 1U;
#line 789
      __cil_tmp41 = 2 + __cil_tmp40;
#line 789
      __cil_tmp42 = 24 + __cil_tmp41;
#line 789
      __cil_tmp43 = (unsigned int )(& template) + __cil_tmp42;
#line 789
      __cil_tmp44 = (char *)__cil_tmp43;
#line 789
      __cil_tmp45 = (void *)__cil_tmp44;
#line 789
      __cil_tmp46 = (void const   *)ssid;
#line 789
      __memcpy(__cil_tmp45, __cil_tmp46, ssid_len);
      }
    } else {

    }
  } else {

  }
  {
#line 790
  __cil_tmp47 = 2U + ssid_len;
#line 790
  __cil_tmp48 = (unsigned int )size;
#line 790
  __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
#line 790
  size = (unsigned short )__cil_tmp49;
#line 791
  __cil_tmp50 = (int )size;
#line 791
  ptr = ptr + __cil_tmp50;
#line 794
  rates = (struct wl12xx_ie_rates *)ptr;
#line 795
  *((u8 *)rates) = (unsigned char)1;
#line 796
  __cil_tmp51 = 0 * 1U;
#line 796
  __cil_tmp52 = 2 + __cil_tmp51;
#line 796
  __cil_tmp53 = (unsigned int )rates;
#line 796
  __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
#line 796
  __cil_tmp55 = (u8 *)__cil_tmp54;
#line 796
  __cil_tmp56 = (char *)__cil_tmp55;
#line 796
  tmp = wl12xx_build_basic_rates(__cil_tmp56);
#line 796
  __cil_tmp57 = 0 + 1;
#line 796
  __cil_tmp58 = (unsigned int )rates;
#line 796
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
#line 796
  *((u8 *)__cil_tmp59) = (unsigned char )tmp;
#line 797
  __cil_tmp60 = 0 + 1;
#line 797
  __cil_tmp61 = (unsigned int )rates;
#line 797
  __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
#line 797
  __cil_tmp63 = *((u8 *)__cil_tmp62);
#line 797
  __cil_tmp64 = (unsigned int )__cil_tmp63;
#line 797
  __cil_tmp65 = 2U + __cil_tmp64;
#line 797
  __cil_tmp66 = (unsigned int )size;
#line 797
  __cil_tmp67 = __cil_tmp66 + __cil_tmp65;
#line 797
  size = (unsigned short )__cil_tmp67;
#line 798
  __cil_tmp68 = 0 + 1;
#line 798
  __cil_tmp69 = (unsigned int )rates;
#line 798
  __cil_tmp70 = __cil_tmp69 + __cil_tmp68;
#line 798
  __cil_tmp71 = *((u8 *)__cil_tmp70);
#line 798
  __cil_tmp72 = (unsigned int )__cil_tmp71;
#line 798
  __cil_tmp73 = 2U + __cil_tmp72;
#line 798
  ptr = ptr + __cil_tmp73;
#line 801
  rates = (struct wl12xx_ie_rates *)ptr;
#line 802
  *((u8 *)rates) = (unsigned char)50;
#line 803
  __cil_tmp74 = 0 * 1U;
#line 803
  __cil_tmp75 = 2 + __cil_tmp74;
#line 803
  __cil_tmp76 = (unsigned int )rates;
#line 803
  __cil_tmp77 = __cil_tmp76 + __cil_tmp75;
#line 803
  __cil_tmp78 = (u8 *)__cil_tmp77;
#line 803
  __cil_tmp79 = (char *)__cil_tmp78;
#line 803
  tmp___0 = wl12xx_build_extended_rates(__cil_tmp79);
#line 803
  __cil_tmp80 = 0 + 1;
#line 803
  __cil_tmp81 = (unsigned int )rates;
#line 803
  __cil_tmp82 = __cil_tmp81 + __cil_tmp80;
#line 803
  *((u8 *)__cil_tmp82) = (unsigned char )tmp___0;
#line 804
  __cil_tmp83 = 0 + 1;
#line 804
  __cil_tmp84 = (unsigned int )rates;
#line 804
  __cil_tmp85 = __cil_tmp84 + __cil_tmp83;
#line 804
  __cil_tmp86 = *((u8 *)__cil_tmp85);
#line 804
  __cil_tmp87 = (unsigned int )__cil_tmp86;
#line 804
  __cil_tmp88 = 2U + __cil_tmp87;
#line 804
  __cil_tmp89 = (unsigned int )size;
#line 804
  __cil_tmp90 = __cil_tmp89 + __cil_tmp88;
#line 804
  size = (unsigned short )__cil_tmp90;
  }
  {
#line 806
  while (1) {
    while_15_continue: /* CIL Label */ ;

    goto while_29_break;
  }
  while_15_break: /* CIL Label */ ;
  }
  while_29_break: 
  {
#line 808
  __cil_tmp91 = (void *)(& template);
#line 808
  __cil_tmp92 = (unsigned int )size;
#line 808
  tmp___2 = wl12xx_cmd_template_set(wl, (unsigned short)22, __cil_tmp91, __cil_tmp92);
  }
#line 808
  return (tmp___2);
}
}
#line 812 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_hw_scan(struct wl12xx *wl , u8 *ssid , size_t len , u8 active_scan ,
                          u8 high_prio , u8 num_channels , u8 probe_requests ) 
{ int i ;
  int ret ;
  u32 split_scan ;
  u16 scan_options ;
  struct cmd_scan *params ;
  struct wl12xx_command *cmd_answer ;
  void *tmp ;
  u32 *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  int __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  u32 *__cil_tmp63 ;
  void *__cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  unsigned int __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  u16 *__cil_tmp70 ;
  void *__cil_tmp71 ;
  unsigned int __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned int __cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  unsigned int __cil_tmp77 ;
  unsigned int __cil_tmp78 ;
  unsigned int __cil_tmp79 ;
  unsigned int __cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned int __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned int __cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  int __cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  unsigned int __cil_tmp89 ;
  unsigned int __cil_tmp90 ;
  unsigned int __cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  unsigned int __cil_tmp94 ;
  u8 *__cil_tmp95 ;
  void *__cil_tmp96 ;
  unsigned int __cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  unsigned int __cil_tmp99 ;
  unsigned int __cil_tmp100 ;
  struct basic_scan_channel_parameters *__cil_tmp101 ;
  void *__cil_tmp102 ;
  unsigned int __cil_tmp103 ;
  unsigned int __cil_tmp104 ;
  unsigned int __cil_tmp105 ;
  unsigned int __cil_tmp106 ;
  unsigned int __cil_tmp107 ;
  unsigned int __cil_tmp108 ;
  unsigned int __cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  u32 *__cil_tmp111 ;
  void *__cil_tmp112 ;
  void const   *__cil_tmp113 ;
  unsigned int __cil_tmp114 ;
  unsigned int __cil_tmp115 ;
  unsigned int __cil_tmp116 ;
  unsigned int __cil_tmp117 ;
  unsigned int __cil_tmp118 ;
  unsigned int __cil_tmp119 ;
  unsigned int __cil_tmp120 ;
  unsigned int __cil_tmp121 ;
  u32 *__cil_tmp122 ;
  void *__cil_tmp123 ;
  unsigned int __cil_tmp124 ;
  unsigned int __cil_tmp125 ;
  unsigned int __cil_tmp126 ;
  unsigned int __cil_tmp127 ;
  unsigned int __cil_tmp128 ;
  unsigned int __cil_tmp129 ;
  unsigned int __cil_tmp130 ;
  unsigned int __cil_tmp131 ;
  u32 *__cil_tmp132 ;
  void *__cil_tmp133 ;
  void *__cil_tmp134 ;
  unsigned int __cil_tmp135 ;
  unsigned int __cil_tmp136 ;
  void *__cil_tmp137 ;
  unsigned int __cil_tmp138 ;
  unsigned int __cil_tmp139 ;
  int __cil_tmp140 ;
  void *__cil_tmp141 ;
  unsigned int __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  u16 __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned int __cil_tmp146 ;
  unsigned int __cil_tmp147 ;
  u16 __cil_tmp148 ;
  unsigned int __cil_tmp149 ;
  unsigned int __cil_tmp150 ;
  void const   *__cil_tmp151 ;

  {
#line 817
  __cil_tmp15 = & split_scan;
#line 817
  *__cil_tmp15 = 0U;
#line 818
  scan_options = (unsigned short)0;
  {
#line 822
  __cil_tmp16 = (unsigned int )wl;
#line 822
  __cil_tmp17 = __cil_tmp16 + 444;
#line 822
  if (*((bool *)__cil_tmp17)) {
#line 823
    return (-22);
  } else {

  }
  }
  {
#line 825
  tmp = kzalloc(368U, 208U);
#line 825
  params = (struct cmd_scan *)tmp;
  }
#line 826
  if (! params) {
#line 827
    return (-12);
  } else {

  }
#line 829
  __cil_tmp18 = 1UL << 3;
#line 829
  *((u32 *)params) = (unsigned int )__cil_tmp18;
#line 830
  __cil_tmp19 = 0 + 4;
#line 830
  __cil_tmp20 = (unsigned int )params;
#line 830
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
#line 830
  __cil_tmp22 = 1UL << 9;
#line 830
  __cil_tmp23 = 1UL << 4;
#line 830
  __cil_tmp24 = 1UL << 2;
#line 830
  __cil_tmp25 = __cil_tmp24 | __cil_tmp23;
#line 830
  __cil_tmp26 = __cil_tmp25 | __cil_tmp22;
#line 830
  *((u32 *)__cil_tmp21) = (unsigned int )__cil_tmp26;
#line 834
  if (! active_scan) {
#line 835
    __cil_tmp27 = (unsigned long )scan_options;
#line 835
    __cil_tmp28 = __cil_tmp27 | 1UL;
#line 835
    scan_options = (unsigned short )__cil_tmp28;
  } else {

  }
#line 836
  if (high_prio) {
#line 837
    __cil_tmp29 = 1UL << 3;
#line 837
    __cil_tmp30 = (unsigned long )scan_options;
#line 837
    __cil_tmp31 = __cil_tmp30 | __cil_tmp29;
#line 837
    scan_options = (unsigned short )__cil_tmp31;
  } else {

  }
#line 838
  __cil_tmp32 = 0 + 8;
#line 838
  __cil_tmp33 = (unsigned int )params;
#line 838
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 838
  *((u16 *)__cil_tmp34) = scan_options;
#line 840
  __cil_tmp35 = 0 + 10;
#line 840
  __cil_tmp36 = (unsigned int )params;
#line 840
  __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
#line 840
  *((u8 *)__cil_tmp37) = num_channels;
#line 841
  __cil_tmp38 = 0 + 11;
#line 841
  __cil_tmp39 = (unsigned int )params;
#line 841
  __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
#line 841
  *((u8 *)__cil_tmp40) = probe_requests;
#line 842
  __cil_tmp41 = 0 + 12;
#line 842
  __cil_tmp42 = (unsigned int )params;
#line 842
  __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
#line 842
  __cil_tmp44 = 1 << 1;
#line 842
  *((u16 *)__cil_tmp43) = (unsigned short )__cil_tmp44;
#line 843
  __cil_tmp45 = 0 + 14;
#line 843
  __cil_tmp46 = (unsigned int )params;
#line 843
  __cil_tmp47 = __cil_tmp46 + __cil_tmp45;
#line 843
  *((u8 *)__cil_tmp47) = (unsigned char)0;
#line 845
  i = 0;
  {
#line 845
  while (1) {
    while_16_continue: /* CIL Label */ ;

    {
#line 845
    __cil_tmp48 = (int )num_channels;
#line 845
    if (i < __cil_tmp48) {

    } else {
      goto while_30_break;
    }
    }
    {
#line 846
    __cil_tmp49 = i * 20U;
#line 846
    __cil_tmp50 = 48 + __cil_tmp49;
#line 846
    __cil_tmp51 = (unsigned int )params;
#line 846
    __cil_tmp52 = __cil_tmp51 + __cil_tmp50;
#line 846
    *((u32 *)__cil_tmp52) = 30000U;
#line 847
    __cil_tmp53 = i * 20U;
#line 847
    __cil_tmp54 = __cil_tmp53 + 4;
#line 847
    __cil_tmp55 = 48 + __cil_tmp54;
#line 847
    __cil_tmp56 = (unsigned int )params;
#line 847
    __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
#line 847
    *((u32 *)__cil_tmp57) = 60000U;
#line 848
    __cil_tmp58 = i * 20U;
#line 848
    __cil_tmp59 = __cil_tmp58 + 8;
#line 848
    __cil_tmp60 = 48 + __cil_tmp59;
#line 848
    __cil_tmp61 = (unsigned int )params;
#line 848
    __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
#line 848
    __cil_tmp63 = (u32 *)__cil_tmp62;
#line 848
    __cil_tmp64 = (void *)__cil_tmp63;
#line 848
    __constant_c_and_count_memset(__cil_tmp64, 4294967295UL, 4U);
#line 849
    __cil_tmp65 = i * 20U;
#line 849
    __cil_tmp66 = __cil_tmp65 + 12;
#line 849
    __cil_tmp67 = 48 + __cil_tmp66;
#line 849
    __cil_tmp68 = (unsigned int )params;
#line 849
    __cil_tmp69 = __cil_tmp68 + __cil_tmp67;
#line 849
    __cil_tmp70 = (u16 *)__cil_tmp69;
#line 849
    __cil_tmp71 = (void *)__cil_tmp70;
#line 849
    __constant_c_and_count_memset(__cil_tmp71, 4294967295UL, 2U);
#line 850
    __cil_tmp72 = i * 20U;
#line 850
    __cil_tmp73 = __cil_tmp72 + 14;
#line 850
    __cil_tmp74 = 48 + __cil_tmp73;
#line 850
    __cil_tmp75 = (unsigned int )params;
#line 850
    __cil_tmp76 = __cil_tmp75 + __cil_tmp74;
#line 850
    *((u8 *)__cil_tmp76) = (unsigned char)0;
#line 851
    __cil_tmp77 = i * 20U;
#line 851
    __cil_tmp78 = __cil_tmp77 + 15;
#line 851
    __cil_tmp79 = 48 + __cil_tmp78;
#line 851
    __cil_tmp80 = (unsigned int )params;
#line 851
    __cil_tmp81 = __cil_tmp80 + __cil_tmp79;
#line 851
    *((u8 *)__cil_tmp81) = (unsigned char)0;
#line 852
    __cil_tmp82 = i * 20U;
#line 852
    __cil_tmp83 = __cil_tmp82 + 16;
#line 852
    __cil_tmp84 = 48 + __cil_tmp83;
#line 852
    __cil_tmp85 = (unsigned int )params;
#line 852
    __cil_tmp86 = __cil_tmp85 + __cil_tmp84;
#line 852
    __cil_tmp87 = i + 1;
#line 852
    *((u8 *)__cil_tmp86) = (unsigned char )__cil_tmp87;
#line 853
    __cil_tmp88 = 0 * 1U;
#line 853
    __cil_tmp89 = 17 + __cil_tmp88;
#line 853
    __cil_tmp90 = i * 20U;
#line 853
    __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
#line 853
    __cil_tmp92 = 48 + __cil_tmp91;
#line 853
    __cil_tmp93 = (unsigned int )params;
#line 853
    __cil_tmp94 = __cil_tmp93 + __cil_tmp92;
#line 853
    __cil_tmp95 = (u8 *)__cil_tmp94;
#line 853
    __cil_tmp96 = (void *)__cil_tmp95;
#line 853
    __constant_c_and_count_memset(__cil_tmp96, 0UL, 3U);
#line 845
    i = i + 1;
    }
  }
  while_16_break: /* CIL Label */ ;
  }
  while_30_break: 
#line 856
  i = (int )num_channels;
  {
#line 856
  while (1) {
    while_17_continue: /* CIL Label */ ;

#line 856
    if (i < 16) {

    } else {
      goto while_31_break;
    }
    {
#line 857
    __cil_tmp97 = i * 20U;
#line 857
    __cil_tmp98 = 48 + __cil_tmp97;
#line 857
    __cil_tmp99 = (unsigned int )params;
#line 857
    __cil_tmp100 = __cil_tmp99 + __cil_tmp98;
#line 857
    __cil_tmp101 = (struct basic_scan_channel_parameters *)__cil_tmp100;
#line 857
    __cil_tmp102 = (void *)__cil_tmp101;
#line 857
    __constant_c_and_count_memset(__cil_tmp102, 0UL, 20U);
#line 856
    i = i + 1;
    }
  }
  while_17_break: /* CIL Label */ ;
  }
  while_31_break: ;
#line 860
  if (len) {
#line 860
    if (ssid) {
      {
#line 861
      __cil_tmp103 = 0 + 15;
#line 861
      __cil_tmp104 = (unsigned int )params;
#line 861
      __cil_tmp105 = __cil_tmp104 + __cil_tmp103;
#line 861
      *((u8 *)__cil_tmp105) = (unsigned char )len;
#line 862
      __cil_tmp106 = 0 * 4U;
#line 862
      __cil_tmp107 = 16 + __cil_tmp106;
#line 862
      __cil_tmp108 = 0 + __cil_tmp107;
#line 862
      __cil_tmp109 = (unsigned int )params;
#line 862
      __cil_tmp110 = __cil_tmp109 + __cil_tmp108;
#line 862
      __cil_tmp111 = (u32 *)__cil_tmp110;
#line 862
      __cil_tmp112 = (void *)__cil_tmp111;
#line 862
      __cil_tmp113 = (void const   *)ssid;
#line 862
      __memcpy(__cil_tmp112, __cil_tmp113, len);
      }
    } else {
      {
#line 864
      __cil_tmp114 = 0 + 15;
#line 864
      __cil_tmp115 = (unsigned int )params;
#line 864
      __cil_tmp116 = __cil_tmp115 + __cil_tmp114;
#line 864
      *((u8 *)__cil_tmp116) = (unsigned char)0;
#line 865
      __cil_tmp117 = 0 * 4U;
#line 865
      __cil_tmp118 = 16 + __cil_tmp117;
#line 865
      __cil_tmp119 = 0 + __cil_tmp118;
#line 865
      __cil_tmp120 = (unsigned int )params;
#line 865
      __cil_tmp121 = __cil_tmp120 + __cil_tmp119;
#line 865
      __cil_tmp122 = (u32 *)__cil_tmp121;
#line 865
      __cil_tmp123 = (void *)__cil_tmp122;
#line 865
      __constant_c_and_count_memset(__cil_tmp123, 0UL, 32U);
      }
    }
  } else {
    {
#line 864
    __cil_tmp124 = 0 + 15;
#line 864
    __cil_tmp125 = (unsigned int )params;
#line 864
    __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
#line 864
    *((u8 *)__cil_tmp126) = (unsigned char)0;
#line 865
    __cil_tmp127 = 0 * 4U;
#line 865
    __cil_tmp128 = 16 + __cil_tmp127;
#line 865
    __cil_tmp129 = 0 + __cil_tmp128;
#line 865
    __cil_tmp130 = (unsigned int )params;
#line 865
    __cil_tmp131 = __cil_tmp130 + __cil_tmp129;
#line 865
    __cil_tmp132 = (u32 *)__cil_tmp131;
#line 865
    __cil_tmp133 = (void *)__cil_tmp132;
#line 865
    __constant_c_and_count_memset(__cil_tmp133, 0UL, 32U);
    }
  }
  {
#line 868
  ret = wl12xx_build_probe_req(wl, ssid, len);
  }
#line 869
  if (ret < 0) {
    {
#line 870
    printk("<3>wl12xx: ERROR PROBE request template failed\n");
    }
    goto out;
  } else {

  }
  {
#line 874
  __cil_tmp134 = (void *)(& split_scan);
#line 874
  ret = wl12xx_cmd_send(wl, (unsigned short)47, __cil_tmp134, 4U);
  }
#line 876
  if (ret < 0) {
    {
#line 877
    printk("<3>wl12xx: ERROR Split SCAN failed\n");
    }
    goto out;
  } else {

  }
  {
#line 881
  while (1) {
    while_18_continue: /* CIL Label */ ;

    goto while_32_break;
  }
  while_18_break: /* CIL Label */ ;
  }
  while_32_break: 
  {
#line 883
  __cil_tmp135 = (unsigned int )wl;
#line 883
  __cil_tmp136 = __cil_tmp135 + 444;
#line 883
  *((bool *)__cil_tmp136) = (_Bool)1;
#line 885
  __cil_tmp137 = (void *)params;
#line 885
  ret = wl12xx_cmd_send(wl, (unsigned short)8, __cil_tmp137, 368U);
  }
#line 886
  if (ret < 0) {
    {
#line 887
    printk("<3>wl12xx: ERROR SCAN failed\n");
    }
  } else {

  }
  {
#line 889
  __cil_tmp138 = (unsigned int )wl;
#line 889
  __cil_tmp139 = __cil_tmp138 + 184;
#line 889
  __cil_tmp140 = *((int *)__cil_tmp139);
#line 889
  __cil_tmp141 = (void *)params;
#line 889
  wl12xx_spi_mem_read(wl, __cil_tmp140, __cil_tmp141, 368U);
#line 891
  cmd_answer = (struct wl12xx_command *)params;
  }
  {
#line 892
  __cil_tmp142 = (unsigned int )cmd_answer;
#line 892
  __cil_tmp143 = __cil_tmp142 + 2;
#line 892
  __cil_tmp144 = *((u16 *)__cil_tmp143);
#line 892
  __cil_tmp145 = (int )__cil_tmp144;
#line 892
  if (__cil_tmp145 != 1) {
    {
#line 893
    __cil_tmp146 = (unsigned int )cmd_answer;
#line 893
    __cil_tmp147 = __cil_tmp146 + 2;
#line 893
    __cil_tmp148 = *((u16 *)__cil_tmp147);
#line 893
    printk("<3>wl12xx: ERROR TEST command answer error: %d\n", __cil_tmp148);
#line 895
    __cil_tmp149 = (unsigned int )wl;
#line 895
    __cil_tmp150 = __cil_tmp149 + 444;
#line 895
    *((bool *)__cil_tmp150) = (_Bool)0;
#line 896
    ret = -5;
    }
    goto out;
  } else {

  }
  }
  out: 
  {
#line 901
  __cil_tmp151 = (void const   *)params;
#line 901
  kfree(__cil_tmp151);
  }
#line 902
  return (ret);
}
}
#line 906 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_hw_scan(struct ieee80211_hw *hw , struct cfg80211_scan_request *req ) 
{ struct wl12xx *wl ;
  int ret ;
  u8 *ssid ;
  size_t ssid_len ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  struct cfg80211_ssid *__cil_tmp15 ;
  struct cfg80211_ssid *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  struct cfg80211_ssid *__cil_tmp19 ;
  struct cfg80211_ssid *__cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  u8 __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  struct mutex *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  void *__cil_tmp29 ;
  struct wl12xx *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  struct mutex *__cil_tmp33 ;

  {
#line 909
  __cil_tmp7 = (unsigned int )hw;
#line 909
  __cil_tmp8 = __cil_tmp7 + 64;
#line 909
  __cil_tmp9 = *((void **)__cil_tmp8);
#line 909
  wl = (struct wl12xx *)__cil_tmp9;
#line 911
  __cil_tmp10 = (void *)0;
#line 911
  ssid = (u8 *)__cil_tmp10;
#line 912
  ssid_len = 0U;
  {
#line 914
  while (1) {
    while_19_continue: /* CIL Label */ ;

    goto while_33_break;
  }
  while_19_break: /* CIL Label */ ;
  }
  while_33_break: ;
  {
#line 916
  __cil_tmp11 = (unsigned int )req;
#line 916
  __cil_tmp12 = __cil_tmp11 + 4;
#line 916
  if (*((int *)__cil_tmp12)) {
#line 917
    __cil_tmp13 = 0 * 1U;
#line 917
    __cil_tmp14 = 0 + __cil_tmp13;
#line 917
    __cil_tmp15 = *((struct cfg80211_ssid **)req);
#line 917
    __cil_tmp16 = __cil_tmp15 + 0;
#line 917
    __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 917
    __cil_tmp18 = __cil_tmp17 + __cil_tmp14;
#line 917
    ssid = (u8 *)__cil_tmp18;
#line 918
    __cil_tmp19 = *((struct cfg80211_ssid **)req);
#line 918
    __cil_tmp20 = __cil_tmp19 + 0;
#line 918
    __cil_tmp21 = (unsigned int )__cil_tmp20;
#line 918
    __cil_tmp22 = __cil_tmp21 + 32;
#line 918
    __cil_tmp23 = *((u8 *)__cil_tmp22);
#line 918
    ssid_len = (unsigned int )__cil_tmp23;
  } else {

  }
  }
  {
#line 921
  __cil_tmp24 = (unsigned int )wl;
#line 921
  __cil_tmp25 = __cil_tmp24 + 52;
#line 921
  __cil_tmp26 = (struct mutex *)__cil_tmp25;
#line 921
  mutex_lock(__cil_tmp26);
#line 922
  __cil_tmp27 = (unsigned int )hw;
#line 922
  __cil_tmp28 = __cil_tmp27 + 64;
#line 922
  __cil_tmp29 = *((void **)__cil_tmp28);
#line 922
  __cil_tmp30 = (struct wl12xx *)__cil_tmp29;
#line 922
  ret = wl12xx_hw_scan(__cil_tmp30, ssid, ssid_len, (unsigned char)1, (unsigned char)0,
                       (unsigned char)13, (unsigned char)3);
#line 923
  __cil_tmp31 = (unsigned int )wl;
#line 923
  __cil_tmp32 = __cil_tmp31 + 52;
#line 923
  __cil_tmp33 = (struct mutex *)__cil_tmp32;
#line 923
  mutex_unlock(__cil_tmp33);
  }
#line 925
  return (ret);
}
}
#line 928 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_set_rts_threshold(struct ieee80211_hw *hw , u32 value ) 
{ struct wl12xx *wl ;
  int ret ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  void *__cil_tmp7 ;
  unsigned short __cil_tmp8 ;

  {
  {
#line 930
  __cil_tmp5 = (unsigned int )hw;
#line 930
  __cil_tmp6 = __cil_tmp5 + 64;
#line 930
  __cil_tmp7 = *((void **)__cil_tmp6);
#line 930
  wl = (struct wl12xx *)__cil_tmp7;
#line 933
  __cil_tmp8 = (unsigned short )value;
#line 933
  ret = wl12xx_acx_rts_threshold(wl, __cil_tmp8);
  }
#line 935
  if (ret < 0) {
    {
#line 936
    printk("<4>wl12xx: WARNING wl12xx_op_set_rts_threshold failed: %d\n", ret);
    }
  } else {

  }
#line 938
  return (ret);
}
}
#line 941 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_bss_info_changed(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       struct ieee80211_bss_conf *bss_conf , u32 changed ) 
{ enum acx_ps_mode mode ;
  struct wl12xx *wl ;
  struct sk_buff *beacon ;
  int ret ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  u16 __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  u16 __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  bool __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  enum acx_slot_type __cil_tmp34 ;
  enum acx_slot_type __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  enum acx_preamble_type __cil_tmp38 ;
  enum acx_preamble_type __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  enum acx_ctsprotect_type __cil_tmp42 ;
  enum acx_ctsprotect_type __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  u8 *__cil_tmp48 ;
  void *__cil_tmp49 ;
  u8 const   *__cil_tmp50 ;
  void const   *__cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  u8 __cil_tmp54 ;
  int __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  u8 __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned char *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned int __cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  unsigned char *__cil_tmp68 ;
  void *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  unsigned int __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned int __cil_tmp74 ;
  u8 __cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  unsigned int __cil_tmp77 ;
  struct mutex *__cil_tmp78 ;

  {
#line 947
  __cil_tmp9 = (unsigned int )hw;
#line 947
  __cil_tmp10 = __cil_tmp9 + 64;
#line 947
  __cil_tmp11 = *((void **)__cil_tmp10);
#line 947
  wl = (struct wl12xx *)__cil_tmp11;
  {
#line 951
  while (1) {
    while_20_continue: /* CIL Label */ ;

    goto while_34_break;
  }
  while_20_break: /* CIL Label */ ;
  }
  while_34_break: 
  {
#line 953
  __cil_tmp12 = (unsigned int )wl;
#line 953
  __cil_tmp13 = __cil_tmp12 + 52;
#line 953
  __cil_tmp14 = (struct mutex *)__cil_tmp13;
#line 953
  mutex_lock(__cil_tmp14);
  }
#line 955
  if (changed & 1U) {
    {
#line 956
    __cil_tmp15 = (unsigned int )bss_conf;
#line 956
    __cil_tmp16 = __cil_tmp15 + 4;
#line 956
    if (*((bool *)__cil_tmp16)) {
      {
#line 957
      __cil_tmp17 = (unsigned int )wl;
#line 957
      __cil_tmp18 = __cil_tmp17 + 446;
#line 957
      __cil_tmp19 = (unsigned int )bss_conf;
#line 957
      __cil_tmp20 = __cil_tmp19 + 6;
#line 957
      *((u16 *)__cil_tmp18) = *((u16 *)__cil_tmp20);
#line 959
      __cil_tmp21 = (unsigned int )wl;
#line 959
      __cil_tmp22 = __cil_tmp21 + 446;
#line 959
      __cil_tmp23 = *((u16 *)__cil_tmp22);
#line 959
      ret = wl12xx_build_ps_poll(wl, __cil_tmp23);
      }
#line 960
      if (ret < 0) {
        goto out;
      } else {

      }
      {
#line 963
      __cil_tmp24 = (unsigned int )wl;
#line 963
      __cil_tmp25 = __cil_tmp24 + 446;
#line 963
      __cil_tmp26 = *((u16 *)__cil_tmp25);
#line 963
      ret = wl12xx_acx_aid(wl, __cil_tmp26);
      }
#line 964
      if (ret < 0) {
        goto out;
      } else {

      }
      {
#line 968
      __cil_tmp27 = (unsigned int )wl;
#line 968
      __cil_tmp28 = __cil_tmp27 + 470;
#line 968
      if (*((bool *)__cil_tmp28)) {
        {
#line 968
        __cil_tmp29 = (unsigned int )wl;
#line 968
        __cil_tmp30 = __cil_tmp29 + 469;
#line 968
        __cil_tmp31 = *((bool *)__cil_tmp30);
#line 968
        if (! __cil_tmp31) {
          {
#line 969
          mode = (enum acx_ps_mode )1;
#line 970
          ret = wl12xx_ps_set_mode(wl, mode);
          }
#line 971
          if (ret < 0) {
            goto out;
          } else {

          }
        } else {

        }
        }
      } else {

      }
      }
    } else {

    }
    }
  } else {

  }
#line 976
  if (changed & 8U) {
    {
#line 977
    __cil_tmp32 = (unsigned int )bss_conf;
#line 977
    __cil_tmp33 = __cil_tmp32 + 10;
#line 977
    if (*((bool *)__cil_tmp33)) {
      {
#line 978
      __cil_tmp34 = (enum acx_slot_type )1;
#line 978
      ret = wl12xx_acx_slot(wl, __cil_tmp34);
      }
    } else {
      {
#line 980
      __cil_tmp35 = (enum acx_slot_type )0;
#line 980
      ret = wl12xx_acx_slot(wl, __cil_tmp35);
      }
    }
    }
#line 981
    if (ret < 0) {
      {
#line 982
      printk("<4>wl12xx: WARNING Set slot time failed %d\n", ret);
      }
      goto out;
    } else {

    }
  } else {

  }
#line 987
  if (changed & 4U) {
    {
#line 988
    __cil_tmp36 = (unsigned int )bss_conf;
#line 988
    __cil_tmp37 = __cil_tmp36 + 9;
#line 988
    if (*((bool *)__cil_tmp37)) {
      {
#line 989
      __cil_tmp38 = (enum acx_preamble_type )1;
#line 989
      wl12xx_acx_set_preamble(wl, __cil_tmp38);
      }
    } else {
      {
#line 991
      __cil_tmp39 = (enum acx_preamble_type )0;
#line 991
      wl12xx_acx_set_preamble(wl, __cil_tmp39);
      }
    }
    }
  } else {

  }
#line 994
  if (changed & 2U) {
    {
#line 995
    __cil_tmp40 = (unsigned int )bss_conf;
#line 995
    __cil_tmp41 = __cil_tmp40 + 8;
#line 995
    if (*((bool *)__cil_tmp41)) {
      {
#line 996
      __cil_tmp42 = (enum acx_ctsprotect_type )1;
#line 996
      ret = wl12xx_acx_cts_protect(wl, __cil_tmp42);
      }
    } else {
      {
#line 998
      __cil_tmp43 = (enum acx_ctsprotect_type )0;
#line 998
      ret = wl12xx_acx_cts_protect(wl, __cil_tmp43);
      }
    }
    }
#line 999
    if (ret < 0) {
      {
#line 1000
      printk("<4>wl12xx: WARNING Set ctsprotect failed %d\n", ret);
      }
      goto out;
    } else {

    }
  } else {

  }
#line 1005
  if (changed & 128U) {
    {
#line 1006
    __cil_tmp44 = 0 * 1U;
#line 1006
    __cil_tmp45 = 232 + __cil_tmp44;
#line 1006
    __cil_tmp46 = (unsigned int )wl;
#line 1006
    __cil_tmp47 = __cil_tmp46 + __cil_tmp45;
#line 1006
    __cil_tmp48 = (u8 *)__cil_tmp47;
#line 1006
    __cil_tmp49 = (void *)__cil_tmp48;
#line 1006
    __cil_tmp50 = *((u8 const   **)bss_conf);
#line 1006
    __cil_tmp51 = (void const   *)__cil_tmp50;
#line 1006
    __constant_memcpy(__cil_tmp49, __cil_tmp51, 6U);
#line 1008
    ret = wl12xx_build_null_data(wl);
    }
#line 1009
    if (ret < 0) {
      goto out;
    } else {

    }
    {
#line 1012
    __cil_tmp52 = (unsigned int )wl;
#line 1012
    __cil_tmp53 = __cil_tmp52 + 244;
#line 1012
    __cil_tmp54 = *((u8 *)__cil_tmp53);
#line 1012
    __cil_tmp55 = (int )__cil_tmp54;
#line 1012
    if (__cil_tmp55 != 0) {
      {
#line 1013
      __cil_tmp56 = (unsigned int )wl;
#line 1013
      __cil_tmp57 = __cil_tmp56 + 244;
#line 1013
      __cil_tmp58 = *((u8 *)__cil_tmp57);
#line 1013
      ret = wl12xx_cmd_join(wl, __cil_tmp58, (unsigned char)5, (unsigned short)100,
                            (unsigned char)1);
      }
#line 1014
      if (ret < 0) {
        goto out;
      } else {

      }
    } else {

    }
    }
  } else {

  }
#line 1019
  if (changed & 256U) {
    {
#line 1020
    beacon = ieee80211_beacon_get(hw, vif);
#line 1021
    __cil_tmp59 = (unsigned int )beacon;
#line 1021
    __cil_tmp60 = __cil_tmp59 + 172;
#line 1021
    __cil_tmp61 = *((unsigned char **)__cil_tmp60);
#line 1021
    __cil_tmp62 = (void *)__cil_tmp61;
#line 1021
    __cil_tmp63 = (unsigned int )beacon;
#line 1021
    __cil_tmp64 = __cil_tmp63 + 80;
#line 1021
    __cil_tmp65 = *((unsigned int *)__cil_tmp64);
#line 1021
    ret = wl12xx_cmd_template_set(wl, (unsigned short)19, __cil_tmp62, __cil_tmp65);
    }
#line 1024
    if (ret < 0) {
      {
#line 1025
      consume_skb(beacon);
      }
      goto out;
    } else {

    }
    {
#line 1029
    __cil_tmp66 = (unsigned int )beacon;
#line 1029
    __cil_tmp67 = __cil_tmp66 + 172;
#line 1029
    __cil_tmp68 = *((unsigned char **)__cil_tmp67);
#line 1029
    __cil_tmp69 = (void *)__cil_tmp68;
#line 1029
    __cil_tmp70 = (unsigned int )beacon;
#line 1029
    __cil_tmp71 = __cil_tmp70 + 80;
#line 1029
    __cil_tmp72 = *((unsigned int *)__cil_tmp71);
#line 1029
    ret = wl12xx_cmd_template_set(wl, (unsigned short)20, __cil_tmp69, __cil_tmp72);
#line 1032
    consume_skb(beacon);
    }
#line 1034
    if (ret < 0) {
      goto out;
    } else {

    }
    {
#line 1037
    __cil_tmp73 = (unsigned int )wl;
#line 1037
    __cil_tmp74 = __cil_tmp73 + 244;
#line 1037
    __cil_tmp75 = *((u8 *)__cil_tmp74);
#line 1037
    ret = wl12xx_cmd_join(wl, __cil_tmp75, (unsigned char)1, (unsigned short)100,
                          (unsigned char)0);
    }
#line 1039
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
  out: 
  {
#line 1044
  __cil_tmp76 = (unsigned int )wl;
#line 1044
  __cil_tmp77 = __cil_tmp76 + 52;
#line 1044
  __cil_tmp78 = (struct mutex *)__cil_tmp77;
#line 1044
  mutex_unlock(__cil_tmp78);
  }
#line 1045
  return;
}
}
#line 1049 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_rate wl12xx_rates[12]  = 
#line 1049
  {      {0U, (unsigned short)10, (unsigned short)1, (unsigned short)1}, 
        {1U, (unsigned short)20, (unsigned short)2, (unsigned short)2}, 
        {1U, (unsigned short)55, (unsigned short)4, (unsigned short)4}, 
        {1U, (unsigned short)110, (unsigned short)32, (unsigned short)32}, 
        {0U, (unsigned short)60, (unsigned short)8, (unsigned short)8}, 
        {0U, (unsigned short)90, (unsigned short)16, (unsigned short)16}, 
        {0U, (unsigned short)120, (unsigned short)64, (unsigned short)64}, 
        {0U, (unsigned short)180, (unsigned short)128, (unsigned short)128}, 
        {0U, (unsigned short)240, (unsigned short)512, (unsigned short)512}, 
        {0U, (unsigned short)360, (unsigned short)1024, (unsigned short)1024}, 
        {0U, (unsigned short)480, (unsigned short)2048, (unsigned short)2048}, 
        {0U, (unsigned short)540, (unsigned short)4096, (unsigned short)4096}};
#line 1092 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_channel wl12xx_channels[13]  = 
#line 1092
  {      {(enum ieee80211_band )0, (unsigned short)2412, (unsigned short)1, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2417, (unsigned short)2, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2422, (unsigned short)3, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2427, (unsigned short)4, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2432, (unsigned short)5, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2437, (unsigned short)6, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2442, (unsigned short)7, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2447, (unsigned short)8, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2452, (unsigned short)9, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2457, (unsigned short)10, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2462, (unsigned short)11, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2467, (unsigned short)12, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}, 
        {(enum ieee80211_band )0, (unsigned short)2472, (unsigned short)13, 0U, 0, 0,
      (_Bool)0, 0U, 0, 0}};
#line 1109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_supported_band wl12xx_band_2ghz  =    {wl12xx_channels, wl12xx_rates, (enum ieee80211_band )0, (int )(sizeof(wl12xx_channels) / sizeof(wl12xx_channels[0]) + sizeof(struct __anonstruct_310 )),
    (int )(sizeof(wl12xx_rates) / sizeof(wl12xx_rates[0]) + sizeof(struct __anonstruct_311 )),
    {(unsigned short)0, (_Bool)0, (unsigned char)0, (unsigned char)0, {{(unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0},
                                                                       (unsigned short)0,
                                                                       (unsigned char)0,
                                                                       {(unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0}}}};
#line 1116 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_ops  const  wl12xx_ops  = 
#line 1116
     {& wl12xx_op_tx, & wl12xx_op_start, & wl12xx_op_stop, & wl12xx_op_add_interface,
    & wl12xx_op_remove_interface, & wl12xx_op_config, & wl12xx_op_bss_info_changed,
    (u64 (*)(struct ieee80211_hw *hw , int mc_count , struct dev_addr_list *mc_list ))0,
    (void (*)(struct ieee80211_hw *hw , unsigned int changed_flags , unsigned int *total_flags ,
              u64 multicast ))(& wl12xx_op_configure_filter), (int (*)(struct ieee80211_hw *hw ,
                                                                       struct ieee80211_sta *sta ,
                                                                       bool set ))0,
    & wl12xx_op_set_key, (void (*)(struct ieee80211_hw *hw , struct ieee80211_key_conf *conf ,
                                   u8 const   *address , u32 iv32 , u16 *phase1key ))0,
    & wl12xx_op_hw_scan, (void (*)(struct ieee80211_hw *hw ))0, (void (*)(struct ieee80211_hw *hw ))0,
    (int (*)(struct ieee80211_hw *hw , struct ieee80211_low_level_stats *stats ))0,
    (void (*)(struct ieee80211_hw *hw , u8 hw_key_idx , u32 *iv32 , u16 *iv16 ))0,
    & wl12xx_op_set_rts_threshold, (void (*)(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                             enum sta_notify_cmd  , struct ieee80211_sta *sta ))0,
    (int (*)(struct ieee80211_hw *hw , u16 queue , struct ieee80211_tx_queue_params  const  *params ))0,
    (int (*)(struct ieee80211_hw *hw , struct ieee80211_tx_queue_stats *stats ))0,
    (u64 (*)(struct ieee80211_hw *hw ))0, (void (*)(struct ieee80211_hw *hw , u64 tsf ))0,
    (void (*)(struct ieee80211_hw *hw ))0, (int (*)(struct ieee80211_hw *hw ))0, (int (*)(struct ieee80211_hw *hw ,
                                                                                          enum ieee80211_ampdu_mlme_action action ,
                                                                                          struct ieee80211_sta *sta ,
                                                                                          u16 tid ,
                                                                                          u16 *ssn ))0,
    (void (*)(struct ieee80211_hw *hw ))0, (int (*)(struct ieee80211_hw *hw , void *data ,
                                                    int len ))0};
#line 1130 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_register_hw(struct wl12xx *wl ) 
{ int ret ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  struct ieee80211_hw *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  u8 *__cil_tmp10 ;
  struct ieee80211_hw *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
  {
#line 1134
  __cil_tmp3 = (unsigned int )wl;
#line 1134
  __cil_tmp4 = __cil_tmp3 + 4;
#line 1134
  if (*((bool *)__cil_tmp4)) {
#line 1135
    return (0);
  } else {

  }
  }
  {
#line 1137
  __cil_tmp5 = *((struct ieee80211_hw **)wl);
#line 1137
  __cil_tmp6 = 0 * 1U;
#line 1137
  __cil_tmp7 = 238 + __cil_tmp6;
#line 1137
  __cil_tmp8 = (unsigned int )wl;
#line 1137
  __cil_tmp9 = __cil_tmp8 + __cil_tmp7;
#line 1137
  __cil_tmp10 = (u8 *)__cil_tmp9;
#line 1137
  SET_IEEE80211_PERM_ADDR(__cil_tmp5, __cil_tmp10);
#line 1139
  __cil_tmp11 = *((struct ieee80211_hw **)wl);
#line 1139
  ret = ieee80211_register_hw(__cil_tmp11);
  }
#line 1140
  if (ret < 0) {
    {
#line 1141
    printk("<3>wl12xx: ERROR unable to register mac80211 hw: %d\n", ret);
    }
#line 1142
    return (ret);
  } else {

  }
  {
#line 1145
  __cil_tmp12 = (unsigned int )wl;
#line 1145
  __cil_tmp13 = __cil_tmp12 + 4;
#line 1145
  *((bool *)__cil_tmp13) = (_Bool)1;
#line 1147
  printk("<6>wl12xx: loaded\n");
  }
#line 1149
  return (0);
}
}
#line 1152 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_init_ieee80211(struct wl12xx *wl ) 
{ struct ieee80211_hw *__cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  struct ieee80211_hw *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  struct ieee80211_hw *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  struct ieee80211_hw *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  struct wiphy *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct ieee80211_hw *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  struct wiphy *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  struct ieee80211_hw *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  struct wiphy *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  struct ieee80211_hw *__cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  struct spi_device *__cil_tmp35 ;
  struct device *__cil_tmp36 ;

  {
  {
#line 1155
  __cil_tmp2 = *((struct ieee80211_hw **)wl);
#line 1155
  __cil_tmp3 = (unsigned int )__cil_tmp2;
#line 1155
  __cil_tmp4 = __cil_tmp3 + 72;
#line 1155
  *((unsigned int *)__cil_tmp4) = 16U + 4U;
#line 1160
  __cil_tmp5 = *((struct ieee80211_hw **)wl);
#line 1160
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 1160
  __cil_tmp7 = __cil_tmp6 + 76;
#line 1160
  *((int *)__cil_tmp7) = 10000;
#line 1162
  __cil_tmp8 = *((struct ieee80211_hw **)wl);
#line 1162
  __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 1162
  __cil_tmp10 = __cil_tmp9 + 68;
#line 1162
  *((u32 *)__cil_tmp10) = 192U;
#line 1165
  __cil_tmp11 = *((struct ieee80211_hw **)wl);
#line 1165
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 1165
  __cil_tmp13 = __cil_tmp12 + 56;
#line 1165
  __cil_tmp14 = *((struct wiphy **)__cil_tmp13);
#line 1165
  __cil_tmp15 = (unsigned int )__cil_tmp14;
#line 1165
  __cil_tmp16 = __cil_tmp15 + 6;
#line 1165
  __cil_tmp17 = 1UL << 2;
#line 1165
  *((u16 *)__cil_tmp16) = (unsigned short )__cil_tmp17;
#line 1166
  __cil_tmp18 = *((struct ieee80211_hw **)wl);
#line 1166
  __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 1166
  __cil_tmp20 = __cil_tmp19 + 56;
#line 1166
  __cil_tmp21 = *((struct wiphy **)__cil_tmp20);
#line 1166
  __cil_tmp22 = (unsigned int )__cil_tmp21;
#line 1166
  __cil_tmp23 = __cil_tmp22 + 52;
#line 1166
  *((u8 *)__cil_tmp23) = (unsigned char)1;
#line 1167
  __cil_tmp24 = 0 * 4U;
#line 1167
  __cil_tmp25 = 80 + __cil_tmp24;
#line 1167
  __cil_tmp26 = *((struct ieee80211_hw **)wl);
#line 1167
  __cil_tmp27 = (unsigned int )__cil_tmp26;
#line 1167
  __cil_tmp28 = __cil_tmp27 + 56;
#line 1167
  __cil_tmp29 = *((struct wiphy **)__cil_tmp28);
#line 1167
  __cil_tmp30 = (unsigned int )__cil_tmp29;
#line 1167
  __cil_tmp31 = __cil_tmp30 + __cil_tmp25;
#line 1167
  *((struct ieee80211_supported_band **)__cil_tmp31) = & wl12xx_band_2ghz;
#line 1169
  __cil_tmp32 = *((struct ieee80211_hw **)wl);
#line 1169
  __cil_tmp33 = (unsigned int )wl;
#line 1169
  __cil_tmp34 = __cil_tmp33 + 8;
#line 1169
  __cil_tmp35 = *((struct spi_device **)__cil_tmp34);
#line 1169
  __cil_tmp36 = (struct device *)__cil_tmp35;
#line 1169
  SET_IEEE80211_DEV(__cil_tmp32, __cil_tmp36);
  }
#line 1171
  return (0);
}
}
#line 1181
static int __attribute__((__cold__))  wl12xx_probe(struct spi_device *spi )  __attribute__((__section__(".devinit.text"))) ;
#line 1181 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static u8 const   nokia_oui[3]  = {      (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )223};
#line 1241 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct lock_class_key __key___3  ;
#line 1175
static int __attribute__((__cold__))  wl12xx_probe(struct spi_device *spi )  __attribute__((__section__(".devinit.text"))) ;
#line 1175 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  wl12xx_probe(struct spi_device *spi ) 
{ struct wl12xx_platform_data *pdata ;
  struct ieee80211_hw *hw ;
  struct wl12xx *wl ;
  int ret ;
  int i ;
  atomic_long_t __constr_expr_0 ;
  atomic_long_t __constr_expr_1 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  struct device *__cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  struct sk_buff_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned int __cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned int __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned int __cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  unsigned int __cil_tmp89 ;
  unsigned int __cil_tmp90 ;
  unsigned int __cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  unsigned int __cil_tmp94 ;
  unsigned int __cil_tmp95 ;
  unsigned int __cil_tmp96 ;
  void *__cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  unsigned int __cil_tmp99 ;
  unsigned int __cil_tmp100 ;
  unsigned int __cil_tmp101 ;
  unsigned int __cil_tmp102 ;
  unsigned int __cil_tmp103 ;
  u8 *__cil_tmp104 ;
  void *__cil_tmp105 ;
  unsigned int __cil_tmp106 ;
  unsigned int __cil_tmp107 ;
  u8 const   *__cil_tmp108 ;
  void const   *__cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  u8 *__cil_tmp114 ;
  u8 *__cil_tmp115 ;
  void *__cil_tmp116 ;
  unsigned int __cil_tmp117 ;
  unsigned int __cil_tmp118 ;
  unsigned int __cil_tmp119 ;
  unsigned int __cil_tmp120 ;
  struct mutex *__cil_tmp121 ;
  unsigned int __cil_tmp122 ;
  unsigned int __cil_tmp123 ;
  unsigned int __cil_tmp124 ;
  unsigned int __cil_tmp125 ;
  unsigned int __cil_tmp126 ;
  unsigned int __cil_tmp127 ;
  unsigned int __cil_tmp128 ;
  unsigned int __cil_tmp129 ;
  unsigned int __cil_tmp130 ;
  unsigned int __cil_tmp131 ;
  void (*__cil_tmp132)(bool enable ) ;
  unsigned int __cil_tmp133 ;
  unsigned int __cil_tmp134 ;
  unsigned int __cil_tmp135 ;
  unsigned int __cil_tmp136 ;
  unsigned int __cil_tmp137 ;
  unsigned int __cil_tmp138 ;
  int __cil_tmp139 ;
  unsigned int __cil_tmp140 ;
  unsigned int __cil_tmp141 ;
  int __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  void *__cil_tmp144 ;
  unsigned int __cil_tmp145 ;
  unsigned int __cil_tmp146 ;
  int __cil_tmp147 ;
  unsigned int __cil_tmp148 ;
  unsigned int __cil_tmp149 ;
  unsigned int __cil_tmp150 ;
  int __cil_tmp151 ;
  unsigned int __cil_tmp152 ;
  unsigned int __cil_tmp153 ;
  unsigned int __cil_tmp154 ;
  int __cil_tmp155 ;
  unsigned int __cil_tmp156 ;
  void *__cil_tmp157 ;
  int volatile   __constr_expr_0_counter158 ;
  int volatile   __constr_expr_1_counter159 ;

  {
#line 1183
  __cil_tmp9 = 0 + 88;
#line 1183
  __cil_tmp10 = (unsigned int )spi;
#line 1183
  __cil_tmp11 = __cil_tmp10 + __cil_tmp9;
#line 1183
  __cil_tmp12 = *((void **)__cil_tmp11);
#line 1183
  pdata = (struct wl12xx_platform_data *)__cil_tmp12;
#line 1184
  if (! pdata) {
    {
#line 1185
    printk("<3>wl12xx: ERROR no platform data\n");
    }
#line 1186
    return ((int __attribute__((__cold__))  )-19);
  } else {

  }
  {
#line 1189
  hw = ieee80211_alloc_hw(824U, & wl12xx_ops);
  }
#line 1190
  if (! hw) {
    {
#line 1191
    printk("<3>wl12xx: ERROR could not alloc ieee80211_hw\n");
    }
#line 1192
    return ((int __attribute__((__cold__))  )-12);
  } else {

  }
  {
#line 1195
  __cil_tmp13 = (unsigned int )hw;
#line 1195
  __cil_tmp14 = __cil_tmp13 + 64;
#line 1195
  __cil_tmp15 = *((void **)__cil_tmp14);
#line 1195
  wl = (struct wl12xx *)__cil_tmp15;
#line 1196
  __cil_tmp16 = (void *)wl;
#line 1196
  __constant_c_and_count_memset(__cil_tmp16, 0UL, 824U);
#line 1198
  *((struct ieee80211_hw **)wl) = hw;
#line 1199
  __cil_tmp17 = (struct device *)spi;
#line 1199
  __cil_tmp18 = (void *)wl;
#line 1199
  dev_set_drvdata(__cil_tmp17, __cil_tmp18);
#line 1200
  __cil_tmp19 = (unsigned int )wl;
#line 1200
  __cil_tmp20 = __cil_tmp19 + 8;
#line 1200
  *((struct spi_device **)__cil_tmp20) = spi;
#line 1202
  __cil_tmp21 = (unsigned int )wl;
#line 1202
  __cil_tmp22 = __cil_tmp21 + 260;
#line 1202
  *((u32 *)__cil_tmp22) = 0U;
#line 1204
  __cil_tmp23 = (unsigned int )wl;
#line 1204
  __cil_tmp24 = __cil_tmp23 + 264;
#line 1204
  __cil_tmp25 = (struct sk_buff_head *)__cil_tmp24;
#line 1204
  skb_queue_head_init(__cil_tmp25);
  }
  {
#line 1206
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
#line 1206
    __constr_expr_0_counter158 = (int volatile   )0;
#line 1206
    __cil_tmp26 = (unsigned int )wl;
#line 1206
    __cil_tmp27 = __cil_tmp26 + 296;
#line 1206
    ((atomic_long_t *)__cil_tmp27)->counter = __constr_expr_0_counter158;
#line 1206
    __cil_tmp28 = 296 + 4;
#line 1206
    __cil_tmp29 = (unsigned int )wl;
#line 1206
    __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 1206
    __cil_tmp31 = (struct list_head *)__cil_tmp30;
#line 1206
    INIT_LIST_HEAD(__cil_tmp31);
    }
    {
#line 1206
    while (1) {
      while_22_continue: /* CIL Label */ ;
#line 1206
      __cil_tmp32 = 296 + 12;
#line 1206
      __cil_tmp33 = (unsigned int )wl;
#line 1206
      __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 1206
      *((void (**)(struct work_struct *work ))__cil_tmp34) = & wl12xx_tx_work;
      goto while_36_break;
    }
    while_22_break: /* CIL Label */ ;
    }
    while_36_break: ;
    goto while_35_break;
  }
  while_21_break: /* CIL Label */ ;
  }
  while_35_break: ;
  {
#line 1207
  while (1) {
    while_23_continue: /* CIL Label */ ;
    {
#line 1207
    __constr_expr_1_counter159 = (int volatile   )0;
#line 1207
    __cil_tmp35 = (unsigned int )wl;
#line 1207
    __cil_tmp36 = __cil_tmp35 + 312;
#line 1207
    ((atomic_long_t *)__cil_tmp36)->counter = __constr_expr_1_counter159;
#line 1207
    __cil_tmp37 = 312 + 4;
#line 1207
    __cil_tmp38 = (unsigned int )wl;
#line 1207
    __cil_tmp39 = __cil_tmp38 + __cil_tmp37;
#line 1207
    __cil_tmp40 = (struct list_head *)__cil_tmp39;
#line 1207
    INIT_LIST_HEAD(__cil_tmp40);
    }
    {
#line 1207
    while (1) {
      while_24_continue: /* CIL Label */ ;
#line 1207
      __cil_tmp41 = 312 + 12;
#line 1207
      __cil_tmp42 = (unsigned int )wl;
#line 1207
      __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
#line 1207
      *((void (**)(struct work_struct *work ))__cil_tmp43) = & wl12xx_filter_work;
      goto while_38_break;
    }
    while_24_break: /* CIL Label */ ;
    }
    while_38_break: ;
    goto while_37_break;
  }
  while_23_break: /* CIL Label */ ;
  }
  while_37_break: 
#line 1208
  __cil_tmp44 = (unsigned int )wl;
#line 1208
  __cil_tmp45 = __cil_tmp44 + 248;
#line 1208
  *((int *)__cil_tmp45) = 1;
#line 1209
  __cil_tmp46 = (unsigned int )wl;
#line 1209
  __cil_tmp47 = __cil_tmp46 + 444;
#line 1209
  *((bool *)__cil_tmp47) = (_Bool)0;
#line 1210
  __cil_tmp48 = (unsigned int )wl;
#line 1210
  __cil_tmp49 = __cil_tmp48 + 448;
#line 1210
  *((u32 *)__cil_tmp49) = 0U;
#line 1211
  __cil_tmp50 = (unsigned int )wl;
#line 1211
  __cil_tmp51 = __cil_tmp50 + 245;
#line 1211
  *((u8 *)__cil_tmp51) = (unsigned char)1;
#line 1212
  __cil_tmp52 = (unsigned int )wl;
#line 1212
  __cil_tmp53 = __cil_tmp52 + 396;
#line 1212
  *((u32 *)__cil_tmp53) = 0U;
#line 1213
  __cil_tmp54 = (unsigned int )wl;
#line 1213
  __cil_tmp55 = __cil_tmp54 + 400;
#line 1213
  *((u32 *)__cil_tmp55) = 0U;
#line 1214
  __cil_tmp56 = (unsigned int )wl;
#line 1214
  __cil_tmp57 = __cil_tmp56 + 404;
#line 1214
  *((u32 *)__cil_tmp57) = 0U;
#line 1215
  __cil_tmp58 = (unsigned int )wl;
#line 1215
  __cil_tmp59 = __cil_tmp58 + 408;
#line 1215
  *((u32 *)__cil_tmp59) = 0U;
#line 1216
  __cil_tmp60 = (unsigned int )wl;
#line 1216
  __cil_tmp61 = __cil_tmp60 + 460;
#line 1216
  __cil_tmp62 = 1UL << 5;
#line 1216
  __cil_tmp63 = 1UL << 4;
#line 1216
  __cil_tmp64 = __cil_tmp63 | __cil_tmp62;
#line 1216
  *((unsigned int *)__cil_tmp61) = (unsigned int )__cil_tmp64;
#line 1217
  __cil_tmp65 = (unsigned int )wl;
#line 1217
  __cil_tmp66 = __cil_tmp65 + 464;
#line 1217
  __cil_tmp67 = 1UL << 11;
#line 1217
  __cil_tmp68 = 1UL << 10;
#line 1217
  __cil_tmp69 = 1UL << 9;
#line 1217
  __cil_tmp70 = 1UL << 7;
#line 1217
  __cil_tmp71 = 1UL << 6;
#line 1217
  __cil_tmp72 = 1UL << 4;
#line 1217
  __cil_tmp73 = 1UL << 2;
#line 1217
  __cil_tmp74 = __cil_tmp73 | __cil_tmp72;
#line 1217
  __cil_tmp75 = __cil_tmp74 | __cil_tmp71;
#line 1217
  __cil_tmp76 = __cil_tmp75 | __cil_tmp70;
#line 1217
  __cil_tmp77 = __cil_tmp76 | __cil_tmp69;
#line 1217
  __cil_tmp78 = __cil_tmp77 | __cil_tmp68;
#line 1217
  __cil_tmp79 = __cil_tmp78 | __cil_tmp67;
#line 1217
  *((unsigned int *)__cil_tmp66) = (unsigned int )__cil_tmp79;
#line 1218
  __cil_tmp80 = (unsigned int )wl;
#line 1218
  __cil_tmp81 = __cil_tmp80 + 468;
#line 1218
  *((bool *)__cil_tmp81) = (_Bool)0;
#line 1219
  __cil_tmp82 = (unsigned int )wl;
#line 1219
  __cil_tmp83 = __cil_tmp82 + 469;
#line 1219
  *((bool *)__cil_tmp83) = (_Bool)0;
#line 1220
  __cil_tmp84 = (unsigned int )wl;
#line 1220
  __cil_tmp85 = __cil_tmp84 + 470;
#line 1220
  *((bool *)__cil_tmp85) = (_Bool)0;
#line 1221
  __cil_tmp86 = (unsigned int )wl;
#line 1221
  __cil_tmp87 = __cil_tmp86 + 292;
#line 1221
  *((bool *)__cil_tmp87) = (_Bool)0;
#line 1222
  __cil_tmp88 = (unsigned int )wl;
#line 1222
  __cil_tmp89 = __cil_tmp88 + 472;
#line 1222
  *((int *)__cil_tmp89) = 20;
#line 1226
  __cil_tmp90 = 100 + 36;
#line 1226
  __cil_tmp91 = (unsigned int )wl;
#line 1226
  __cil_tmp92 = __cil_tmp91 + __cil_tmp90;
#line 1226
  *((unsigned int *)__cil_tmp92) = 200U;
#line 1228
  i = 0;
  {
#line 1228
  while (1) {
    while_25_continue: /* CIL Label */ ;

#line 1228
    if (i < 16) {

    } else {
      goto while_39_break;
    }
#line 1229
    __cil_tmp93 = i * 4U;
#line 1229
    __cil_tmp94 = 328 + __cil_tmp93;
#line 1229
    __cil_tmp95 = (unsigned int )wl;
#line 1229
    __cil_tmp96 = __cil_tmp95 + __cil_tmp94;
#line 1229
    __cil_tmp97 = (void *)0;
#line 1229
    *((struct sk_buff **)__cil_tmp96) = (struct sk_buff *)__cil_tmp97;
#line 1228
    i = i + 1;
  }
  while_25_break: /* CIL Label */ ;
  }
  while_39_break: 
  {
#line 1231
  __cil_tmp98 = (unsigned int )wl;
#line 1231
  __cil_tmp99 = __cil_tmp98 + 392;
#line 1231
  *((u32 *)__cil_tmp99) = 0U;
#line 1237
  __cil_tmp100 = 0 * 1U;
#line 1237
  __cil_tmp101 = 238 + __cil_tmp100;
#line 1237
  __cil_tmp102 = (unsigned int )wl;
#line 1237
  __cil_tmp103 = __cil_tmp102 + __cil_tmp101;
#line 1237
  __cil_tmp104 = (u8 *)__cil_tmp103;
#line 1237
  __cil_tmp105 = (void *)__cil_tmp104;
#line 1237
  __cil_tmp106 = 0 * 1U;
#line 1237
  __cil_tmp107 = (unsigned int )(nokia_oui) + __cil_tmp106;
#line 1237
  __cil_tmp108 = (u8 const   *)__cil_tmp107;
#line 1237
  __cil_tmp109 = (void const   *)__cil_tmp108;
#line 1237
  __constant_memcpy(__cil_tmp105, __cil_tmp109, 3U);
#line 1238
  __cil_tmp110 = 0 * 1U;
#line 1238
  __cil_tmp111 = 238 + __cil_tmp110;
#line 1238
  __cil_tmp112 = (unsigned int )wl;
#line 1238
  __cil_tmp113 = __cil_tmp112 + __cil_tmp111;
#line 1238
  __cil_tmp114 = (u8 *)__cil_tmp113;
#line 1238
  __cil_tmp115 = __cil_tmp114 + 3;
#line 1238
  __cil_tmp116 = (void *)__cil_tmp115;
#line 1238
  get_random_bytes(__cil_tmp116, 3);
#line 1240
  __cil_tmp117 = (unsigned int )wl;
#line 1240
  __cil_tmp118 = __cil_tmp117 + 20;
#line 1240
  *((enum wl12xx_state *)__cil_tmp118) = (enum wl12xx_state )0;
  }
  {
#line 1241
  while (1) {
    while_26_continue: /* CIL Label */ ;
    {
#line 1241
    __cil_tmp119 = (unsigned int )wl;
#line 1241
    __cil_tmp120 = __cil_tmp119 + 52;
#line 1241
    __cil_tmp121 = (struct mutex *)__cil_tmp120;
#line 1241
    __mutex_init(__cil_tmp121, "&wl->mutex", & __key___3);
    }
    goto while_40_break;
  }
  while_26_break: /* CIL Label */ ;
  }
  while_40_break: 
  {
#line 1243
  __cil_tmp122 = (unsigned int )wl;
#line 1243
  __cil_tmp123 = __cil_tmp122 + 452;
#line 1243
  *((unsigned int *)__cil_tmp123) = 20U;
#line 1244
  __cil_tmp124 = (unsigned int )wl;
#line 1244
  __cil_tmp125 = __cil_tmp124 + 456;
#line 1244
  *((unsigned int *)__cil_tmp125) = 0U;
#line 1248
  __cil_tmp126 = (unsigned int )spi;
#line 1248
  __cil_tmp127 = __cil_tmp126 + 410;
#line 1248
  *((u8 *)__cil_tmp127) = (unsigned char)32;
#line 1250
  ret = spi_setup(spi);
  }
#line 1251
  if (ret < 0) {
    {
#line 1252
    printk("<3>wl12xx: ERROR spi_setup failed\n");
    }
    goto out_free;
  } else {

  }
#line 1256
  __cil_tmp128 = (unsigned int )wl;
#line 1256
  __cil_tmp129 = __cil_tmp128 + 12;
#line 1256
  *((void (**)(bool enable ))__cil_tmp129) = *((void (**)(bool enable ))pdata);
  {
#line 1257
  __cil_tmp130 = (unsigned int )wl;
#line 1257
  __cil_tmp131 = __cil_tmp130 + 12;
#line 1257
  __cil_tmp132 = *((void (**)(bool enable ))__cil_tmp131);
#line 1257
  if (! __cil_tmp132) {
    {
#line 1258
    printk("<3>wl12xx: ERROR set power function missing in platform data\n");
    }
#line 1259
    return ((int __attribute__((__cold__))  )-19);
  } else {

  }
  }
#line 1262
  __cil_tmp133 = (unsigned int )wl;
#line 1262
  __cil_tmp134 = __cil_tmp133 + 16;
#line 1262
  __cil_tmp135 = (unsigned int )spi;
#line 1262
  __cil_tmp136 = __cil_tmp135 + 412;
#line 1262
  *((int *)__cil_tmp134) = *((int *)__cil_tmp136);
  {
#line 1263
  __cil_tmp137 = (unsigned int )wl;
#line 1263
  __cil_tmp138 = __cil_tmp137 + 16;
#line 1263
  __cil_tmp139 = *((int *)__cil_tmp138);
#line 1263
  if (__cil_tmp139 < 0) {
    {
#line 1264
    printk("<3>wl12xx: ERROR irq missing in platform data\n");
    }
#line 1265
    return ((int __attribute__((__cold__))  )-19);
  } else {

  }
  }
  {
#line 1268
  __cil_tmp140 = (unsigned int )wl;
#line 1268
  __cil_tmp141 = __cil_tmp140 + 16;
#line 1268
  __cil_tmp142 = *((int *)__cil_tmp141);
#line 1268
  __cil_tmp143 = (unsigned int )__cil_tmp142;
#line 1268
  __cil_tmp144 = (void *)wl;
#line 1268
  ret = request_irq(__cil_tmp143, & wl12xx_irq, 0UL, "wl12xx", __cil_tmp144);
  }
#line 1269
  if (ret < 0) {
    {
#line 1270
    printk("<3>wl12xx: ERROR request_irq() failed: %d\n", ret);
    }
    goto out_free;
  } else {

  }
  {
#line 1274
  __cil_tmp145 = (unsigned int )wl;
#line 1274
  __cil_tmp146 = __cil_tmp145 + 16;
#line 1274
  __cil_tmp147 = *((int *)__cil_tmp146);
#line 1274
  __cil_tmp148 = (unsigned int )__cil_tmp147;
#line 1274
  set_irq_type(__cil_tmp148, 1U);
#line 1276
  __cil_tmp149 = (unsigned int )wl;
#line 1276
  __cil_tmp150 = __cil_tmp149 + 16;
#line 1276
  __cil_tmp151 = *((int *)__cil_tmp150);
#line 1276
  __cil_tmp152 = (unsigned int )__cil_tmp151;
#line 1276
  disable_irq(__cil_tmp152);
#line 1278
  ret = wl12xx_init_ieee80211(wl);
  }
#line 1279
  if (ret) {
    goto out_irq;
  } else {

  }
  {
#line 1282
  ret = wl12xx_register_hw(wl);
  }
#line 1283
  if (ret) {
    goto out_irq;
  } else {

  }
  {
#line 1286
  wl12xx_debugfs_init(wl);
#line 1288
  printk("<6>wl12xx: initialized\n");
  }
#line 1290
  return ((int __attribute__((__cold__))  )0);
  out_irq: 
  {
#line 1293
  __cil_tmp153 = (unsigned int )wl;
#line 1293
  __cil_tmp154 = __cil_tmp153 + 16;
#line 1293
  __cil_tmp155 = *((int *)__cil_tmp154);
#line 1293
  __cil_tmp156 = (unsigned int )__cil_tmp155;
#line 1293
  __cil_tmp157 = (void *)wl;
#line 1293
  free_irq(__cil_tmp156, __cil_tmp157);
  }
  out_free: 
  {
#line 1296
  ieee80211_free_hw(hw);
  }
#line 1298
  return ((int __attribute__((__cold__))  )ret);
}
}
#line 1301
static int __attribute__((__cold__))  wl12xx_remove(struct spi_device *spi )  __attribute__((__section__(".devexit.text"))) ;
#line 1301
static int __attribute__((__cold__))  wl12xx_remove(struct spi_device *spi )  __attribute__((__section__(".devexit.text"))) ;
#line 1301 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  wl12xx_remove(struct spi_device *spi ) 
{ struct wl12xx *wl ;
  void *tmp ;
  struct device *__cil_tmp4 ;
  struct device  const  *__cil_tmp5 ;
  struct ieee80211_hw *__cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void const   *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  struct acx_data_path_params_resp *__cil_tmp18 ;
  void const   *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  u8 *__cil_tmp22 ;
  void const   *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  u8 *__cil_tmp29 ;
  void const   *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  void *__cil_tmp33 ;
  struct ieee80211_hw *__cil_tmp34 ;

  {
  {
#line 1303
  __cil_tmp4 = (struct device *)spi;
#line 1303
  __cil_tmp5 = (struct device  const  *)__cil_tmp4;
#line 1303
  tmp = dev_get_drvdata(__cil_tmp5);
#line 1303
  wl = (struct wl12xx *)tmp;
#line 1305
  __cil_tmp6 = *((struct ieee80211_hw **)wl);
#line 1305
  ieee80211_unregister_hw(__cil_tmp6);
#line 1307
  wl12xx_debugfs_exit(wl);
#line 1309
  __cil_tmp7 = (unsigned int )wl;
#line 1309
  __cil_tmp8 = __cil_tmp7 + 16;
#line 1309
  __cil_tmp9 = *((int *)__cil_tmp8);
#line 1309
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 1309
  __cil_tmp11 = (void *)wl;
#line 1309
  free_irq(__cil_tmp10, __cil_tmp11);
#line 1310
  __cil_tmp12 = (unsigned int )wl;
#line 1310
  __cil_tmp13 = __cil_tmp12 + 252;
#line 1310
  __cil_tmp14 = *((void **)__cil_tmp13);
#line 1310
  __cil_tmp15 = (void const   *)__cil_tmp14;
#line 1310
  kfree(__cil_tmp15);
#line 1311
  __cil_tmp16 = (unsigned int )wl;
#line 1311
  __cil_tmp17 = __cil_tmp16 + 256;
#line 1311
  __cil_tmp18 = *((struct acx_data_path_params_resp **)__cil_tmp17);
#line 1311
  __cil_tmp19 = (void const   *)__cil_tmp18;
#line 1311
  kfree(__cil_tmp19);
#line 1312
  __cil_tmp20 = (unsigned int )wl;
#line 1312
  __cil_tmp21 = __cil_tmp20 + 216;
#line 1312
  __cil_tmp22 = *((u8 **)__cil_tmp21);
#line 1312
  __cil_tmp23 = (void const   *)__cil_tmp22;
#line 1312
  kfree(__cil_tmp23);
#line 1313
  __cil_tmp24 = (unsigned int )wl;
#line 1313
  __cil_tmp25 = __cil_tmp24 + 216;
#line 1313
  __cil_tmp26 = (void *)0;
#line 1313
  *((u8 **)__cil_tmp25) = (u8 *)__cil_tmp26;
#line 1314
  __cil_tmp27 = (unsigned int )wl;
#line 1314
  __cil_tmp28 = __cil_tmp27 + 224;
#line 1314
  __cil_tmp29 = *((u8 **)__cil_tmp28);
#line 1314
  __cil_tmp30 = (void const   *)__cil_tmp29;
#line 1314
  kfree(__cil_tmp30);
#line 1315
  __cil_tmp31 = (unsigned int )wl;
#line 1315
  __cil_tmp32 = __cil_tmp31 + 224;
#line 1315
  __cil_tmp33 = (void *)0;
#line 1315
  *((u8 **)__cil_tmp32) = (u8 *)__cil_tmp33;
#line 1316
  __cil_tmp34 = *((struct ieee80211_hw **)wl);
#line 1316
  ieee80211_free_hw(__cil_tmp34);
  }
#line 1318
  return ((int __attribute__((__cold__))  )0);
}
}
#line 1322 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct spi_driver wl12xx_spi_driver  =    {(struct spi_device_id  const  *)0, (int (*)(struct spi_device *spi ))(& wl12xx_probe),
    (int (*)(struct spi_device *spi ))(& wl12xx_remove), (void (*)(struct spi_device *spi ))0,
    (int (*)(struct spi_device *spi , pm_message_t mesg ))0, (int (*)(struct spi_device *spi ))0,
    {"wl12xx", & spi_bus_type, & __this_module, (char const   *)0, (_Bool)0, (int (*)(struct device *dev ))0,
     (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0, (int (*)(struct device *dev ,
                                                                                 pm_message_t state ))0,
     (int (*)(struct device *dev ))0, (struct attribute_group  const  **)0, (struct dev_pm_ops  const  *)0,
     (struct driver_private *)0}};
#line 1333
static int __attribute__((__cold__))  wl12xx_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1333
static int __attribute__((__cold__))  wl12xx_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1333 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  wl12xx_init(void) 
{ int ret ;

  {
  {
#line 1337
  ret = spi_register_driver(& wl12xx_spi_driver);
  }
#line 1338
  if (ret < 0) {
    {
#line 1339
    printk("<3>wl12xx: ERROR failed to register spi driver: %d\n", ret);
    }
    goto out;
  } else {

  }
  out: 
#line 1344
  return ((int __attribute__((__cold__))  )ret);
}
}
#line 1347
static void __attribute__((__cold__))  wl12xx_exit(void)  __attribute__((__section__(".exit.text"))) ;
#line 1347
static void __attribute__((__cold__))  wl12xx_exit(void)  __attribute__((__section__(".exit.text"))) ;
#line 1347 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void __attribute__((__cold__))  wl12xx_exit(void) 
{ 

  {
  {
#line 1349
  spi_unregister_driver(& wl12xx_spi_driver);
#line 1351
  printk("<6>wl12xx: unloaded\n");
  }
#line 1352
  return;
}
}
#line 1354 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
int init_module(void) 
{ int __attribute__((__cold__))  tmp ;

  {
  {
#line 1354
  tmp = wl12xx_init();
  }
#line 1354
  return ((int )tmp);
}
}
#line 1355 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
void cleanup_module(void) 
{ 

  {
  {
#line 1355
  wl12xx_exit();
  }
#line 1355
  return;
}
}
#line 1357 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static char const   __mod_license1357[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
#line 1357
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
#line 1358 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static char const   __mod_author1359[84]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
#line 1358
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'K', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'V',      (char const   )'a',      (char const   )'l', 
        (char const   )'o',      (char const   )' ',      (char const   )'<',      (char const   )'K', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'e', 
        (char const   )'.',      (char const   )'V',      (char const   )'a',      (char const   )'l', 
        (char const   )'o',      (char const   )'@',      (char const   )'n',      (char const   )'o', 
        (char const   )'k',      (char const   )'i',      (char const   )'a',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'>', 
        (char const   )',',      (char const   )' ',      (char const   )'L',      (char const   )'u', 
        (char const   )'c',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )'o',      (char const   )' ',      (char const   )'C',      (char const   )'o', 
        (char const   )'e',      (char const   )'l',      (char const   )'h',      (char const   )'o', 
        (char const   )' ',      (char const   )'<',      (char const   )'l',      (char const   )'u', 
        (char const   )'c',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )'o',      (char const   )'.',      (char const   )'c',      (char const   )'o', 
        (char const   )'e',      (char const   )'l',      (char const   )'h',      (char const   )'o', 
        (char const   )'@',      (char const   )'n',      (char const   )'o',      (char const   )'k', 
        (char const   )'i',      (char const   )'a',      (char const   )'.',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'>',      (char const   )'\000'};
#line 1370
void check_final_state(void) ;
#line 1371
extern void check_return_value(int res ) ;
#line 1372
extern int IN_INTERRUPT ;
#line 1501 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  rtmp0  __attribute__((__section__(".devinit.text")))  ;
#line 1373 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
void main(void) 
{ struct ieee80211_hw *var0 ;
  struct sk_buff *var1 ;
  struct ieee80211_hw *var2 ;
  struct ieee80211_hw *var3 ;
  struct ieee80211_hw *var4 ;
  struct ieee80211_if_init_conf *var5 ;
  struct ieee80211_hw *var6 ;
  struct ieee80211_if_init_conf *var7 ;
  struct ieee80211_hw *var8 ;
  u32 var9 ;
  struct ieee80211_hw *var10 ;
  unsigned int var11 ;
  unsigned int *var12 ;
  int var13 ;
  struct dev_addr_list *var14 ;
  struct ieee80211_hw *var15 ;
  enum set_key_cmd var16 ;
  struct ieee80211_vif *var17 ;
  struct ieee80211_sta *var18 ;
  struct ieee80211_key_conf *var19 ;
  struct ieee80211_hw *var20 ;
  struct cfg80211_scan_request *var21 ;
  struct ieee80211_hw *var22 ;
  u32 var23 ;
  struct ieee80211_hw *var24 ;
  struct ieee80211_vif *var25 ;
  struct ieee80211_bss_conf *var26 ;
  u32 var27 ;
  struct spi_device *var28 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  int __attribute__((__cold__))  tmp___22 ;
  int (*__cil_tmp54)(struct ieee80211_hw *hw , struct sk_buff *skb ) ;
  int (*__cil_tmp55)(struct ieee80211_hw *hw ) ;
  void (*__cil_tmp56)(struct ieee80211_hw *hw ) ;
  int (*__cil_tmp57)(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) ;
  void (*__cil_tmp58)(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) ;
  int (*__cil_tmp59)(struct ieee80211_hw *hw , u32 changed ) ;
  void (*__cil_tmp60)(struct ieee80211_hw *hw , unsigned int changed , unsigned int *total ,
                      int mc_count , struct dev_addr_list *mc_list ) ;
  int (*__cil_tmp61)(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                     struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) ;
  int (*__cil_tmp62)(struct ieee80211_hw *hw , struct cfg80211_scan_request *req ) ;
  int (*__cil_tmp63)(struct ieee80211_hw *hw , u32 value ) ;
  void (*__cil_tmp64)(struct ieee80211_hw *hw , struct ieee80211_vif *vif , struct ieee80211_bss_conf *bss_conf ,
                      u32 changed ) ;
  int __attribute__((__cold__))  (*__cil_tmp65)(struct spi_device *spi ) ;
  int __cil_tmp66 ;

  {
  {
#line 1376
  IN_INTERRUPT = 1;
#line 1509
  tmp = kmalloc(1U, 208U);
#line 1509
  var0 = (struct ieee80211_hw *)tmp;
#line 1510
  tmp___0 = kmalloc(1U, 208U);
#line 1510
  var1 = (struct sk_buff *)tmp___0;
#line 1519
  tmp___1 = kmalloc(1U, 208U);
#line 1519
  var2 = (struct ieee80211_hw *)tmp___1;
#line 1528
  tmp___2 = kmalloc(1U, 208U);
#line 1528
  var3 = (struct ieee80211_hw *)tmp___2;
#line 1537
  tmp___3 = kmalloc(1U, 208U);
#line 1537
  var4 = (struct ieee80211_hw *)tmp___3;
#line 1538
  tmp___4 = kmalloc(1U, 208U);
#line 1538
  var5 = (struct ieee80211_if_init_conf *)tmp___4;
#line 1547
  tmp___5 = kmalloc(1U, 208U);
#line 1547
  var6 = (struct ieee80211_hw *)tmp___5;
#line 1548
  tmp___6 = kmalloc(1U, 208U);
#line 1548
  var7 = (struct ieee80211_if_init_conf *)tmp___6;
#line 1557
  tmp___7 = kmalloc(1U, 208U);
#line 1557
  var8 = (struct ieee80211_hw *)tmp___7;
#line 1566
  tmp___8 = kmalloc(1U, 208U);
#line 1566
  var10 = (struct ieee80211_hw *)tmp___8;
#line 1567
  tmp___9 = kmalloc(1U, 208U);
#line 1567
  var12 = (unsigned int *)tmp___9;
#line 1568
  tmp___10 = kmalloc(1U, 208U);
#line 1568
  var14 = (struct dev_addr_list *)tmp___10;
#line 1577
  tmp___11 = kmalloc(1U, 208U);
#line 1577
  var15 = (struct ieee80211_hw *)tmp___11;
#line 1578
  tmp___12 = kmalloc(1U, 208U);
#line 1578
  var17 = (struct ieee80211_vif *)tmp___12;
#line 1579
  tmp___13 = kmalloc(1U, 208U);
#line 1579
  var18 = (struct ieee80211_sta *)tmp___13;
#line 1580
  tmp___14 = kmalloc(1U, 208U);
#line 1580
  var19 = (struct ieee80211_key_conf *)tmp___14;
#line 1589
  tmp___15 = kmalloc(1U, 208U);
#line 1589
  var20 = (struct ieee80211_hw *)tmp___15;
#line 1590
  tmp___16 = kmalloc(1U, 208U);
#line 1590
  var21 = (struct cfg80211_scan_request *)tmp___16;
#line 1599
  tmp___17 = kmalloc(1U, 208U);
#line 1599
  var22 = (struct ieee80211_hw *)tmp___17;
#line 1608
  tmp___18 = kmalloc(1U, 208U);
#line 1608
  var24 = (struct ieee80211_hw *)tmp___18;
#line 1609
  tmp___19 = kmalloc(1U, 208U);
#line 1609
  var25 = (struct ieee80211_vif *)tmp___19;
#line 1610
  tmp___20 = kmalloc(1U, 208U);
#line 1610
  var26 = (struct ieee80211_bss_conf *)tmp___20;
#line 1622
  tmp___21 = kmalloc(1U, 208U);
#line 1622
  var28 = (struct spi_device *)tmp___21;
#line 1637
  tmp___22 = wl12xx_init();
  }
#line 1637
  if (tmp___22) {
#line 1638
    return;
  } else {

  }
  {
#line 1642
  __cil_tmp54 = & wl12xx_op_tx;
#line 1642
  (*__cil_tmp54)(var0, var1);
#line 1651
  __cil_tmp55 = & wl12xx_op_start;
#line 1651
  (*__cil_tmp55)(var2);
#line 1660
  __cil_tmp56 = & wl12xx_op_stop;
#line 1660
  (*__cil_tmp56)(var3);
#line 1669
  __cil_tmp57 = & wl12xx_op_add_interface;
#line 1669
  (*__cil_tmp57)(var4, var5);
#line 1678
  __cil_tmp58 = & wl12xx_op_remove_interface;
#line 1678
  (*__cil_tmp58)(var6, var7);
#line 1687
  __cil_tmp59 = & wl12xx_op_config;
#line 1687
  (*__cil_tmp59)(var8, var9);
#line 1696
  __cil_tmp60 = & wl12xx_op_configure_filter;
#line 1696
  (*__cil_tmp60)(var10, var11, var12, var13, var14);
#line 1705
  __cil_tmp61 = & wl12xx_op_set_key;
#line 1705
  (*__cil_tmp61)(var15, var16, var17, var18, var19);
#line 1714
  __cil_tmp62 = & wl12xx_op_hw_scan;
#line 1714
  (*__cil_tmp62)(var20, var21);
#line 1723
  __cil_tmp63 = & wl12xx_op_set_rts_threshold;
#line 1723
  (*__cil_tmp63)(var22, var23);
#line 1732
  __cil_tmp64 = & wl12xx_op_bss_info_changed;
#line 1732
  (*__cil_tmp64)(var24, var25, var26, var27);
#line 1744
  __cil_tmp65 = & wl12xx_probe;
#line 1744
  rtmp0 = (*__cil_tmp65)(var28);
#line 1745
  __cil_tmp66 = (int )rtmp0;
#line 1745
  check_return_value(__cil_tmp66);
  }
#line 1746
  if (rtmp0) {
#line 1747
    return;
  } else {

  }
  {
#line 1758
  wl12xx_exit();
#line 1762
  check_final_state();
  }
#line 1763
  return;
}
}
#line 5 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/engine-blast-assert.h"
void __blast_assert(void) 
{ 

  {
  ERROR: 
  goto ERROR;
}
}
#line 4 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/engine-blast.h"
extern int __undefined_int(void) ;
#line 5 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int ldv_mutex  =    1;
#line 17 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int mutex_lock_interruptible(struct mutex *lock ) 
{ int tmp ;

  {
#line 19
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 19
    __blast_assert();
    }
  }
#line 20
  if (ldv_mutex == 1) {

  } else {
    {
#line 20
    __blast_assert();
    }
  }
  {
#line 21
  tmp = __undefined_int();
  }
#line 21
  if (tmp) {
#line 22
    ldv_mutex = 2;
#line 23
    return (0);
  } else {
#line 25
    ldv_mutex = 1;
#line 26
    return (-4);
  }
}
}
#line 30 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int mutex_lock_killable(struct mutex *lock ) 
{ int tmp ;

  {
#line 32
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 32
    __blast_assert();
    }
  }
#line 33
  if (ldv_mutex == 1) {

  } else {
    {
#line 33
    __blast_assert();
    }
  }
  {
#line 34
  tmp = __undefined_int();
  }
#line 34
  if (tmp) {
#line 35
    ldv_mutex = 2;
#line 36
    return (0);
  } else {
#line 38
    ldv_mutex = 1;
#line 39
    return (-4);
  }
}
}
#line 43 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void mutex_lock(struct mutex *lock ) 
{ 

  {
#line 44
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 44
    __blast_assert();
    }
  }
#line 45
  if (ldv_mutex == 1) {

  } else {
    {
#line 45
    __blast_assert();
    }
  }
#line 46
  ldv_mutex = 2;
#line 47
  return;
}
}
#line 49 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int mutex_trylock(struct mutex *lock ) 
{ int tmp ;

  {
#line 50
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 50
    __blast_assert();
    }
  }
#line 51
  if (ldv_mutex == 1) {

  } else {
    {
#line 51
    __blast_assert();
    }
  }
  {
#line 52
  tmp = __undefined_int();
  }
#line 52
  if (tmp) {
#line 53
    ldv_mutex = 2;
#line 54
    return (1);
  } else {
#line 56
    ldv_mutex = 1;
#line 57
    return (0);
  }
}
}
#line 61 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void mutex_unlock(struct mutex *lock ) 
{ 

  {
#line 62
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 62
    __blast_assert();
    }
  }
#line 63
  if (ldv_mutex == 2) {

  } else {
    {
#line 63
    __blast_assert();
    }
  }
#line 64
  ldv_mutex = 1;
#line 65
  return;
}
}
#line 67 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void check_final_state(void) 
{ 

  {
#line 68
  if (ldv_mutex == 1) {

  } else {
    {
#line 68
    __blast_assert();
    }
  }
#line 69
  return;
}
}
